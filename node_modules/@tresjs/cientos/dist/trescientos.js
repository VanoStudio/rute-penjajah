/**
 * name: @tresjs/cientos
 * version: v4.3.1
 * (c) 2025
 * description: Collection of useful helpers and fully functional, ready-made abstractions for Tres
 * author: Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)
 */
var Ml = Object.defineProperty;
var Sl = (r, e, t) => e in r ? Ml(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;
var pe = (r, e, t) => Sl(r, typeof e != "symbol" ? e + "" : e, t);
import * as Jn from "three";
import { TextureLoader as ai, DoubleSide as on, WebGLCubeRenderTarget as aa, HalfFloatType as Lt, CubeCamera as la, Group as Zt, Quaternion as je, Euler as vt, AudioListener as ca, Audio as Al, AudioLoader as ua, MathUtils as Ye, ShaderMaterial as bt, UniformsUtils as Dn, Vector2 as ve, Color as be, FrontSide as ss, REVISION as Ts, Vector3 as $, BufferAttribute as ut, TrianglesDrawMode as Pl, TriangleFanDrawMode as oo, TriangleStripDrawMode as ha, CompressedTexture as mi, Texture as es, RGBAFormat as ei, PropertyBinding as rn, InterpolateDiscrete as fa, Matrix4 as Ie, Scene as xs, PlaneGeometry as jt, Uniform as Se, Mesh as de, PerspectiveCamera as kt, WebGLRenderer as Rl, NearestFilter as Kn, NearestMipmapNearestFilter as da, NearestMipmapLinearFilter as pa, LinearFilter as wt, LinearMipmapNearestFilter as ma, LinearMipmapLinearFilter as Eo, ClampToEdgeWrapping as Wt, RepeatWrapping as Ln, MirroredRepeatWrapping as ga, InterpolateLinear as Mo, Plane as bs, Vector4 as at, WebGLRenderTarget as Xt, NoToneMapping as Cl, MeshBasicMaterial as $t, DataTexture as ti, RawShaderMaterial as gi, AdditiveBlending as So, Box2 as va, BufferGeometry as ht, InterleavedBuffer as Ao, InterleavedBufferAttribute as nn, UniformsLib as ni, BoxGeometry as Ht, BackSide as li, Triangle as Il, Object3D as Rt, Raycaster as ya, LineBasicMaterial as ws, CylinderGeometry as Ct, Float32BufferAttribute as gt, Line as ke, OctahedronGeometry as Mn, SphereGeometry as Ol, TorusGeometry as Ds, EventDispatcher as _a, MOUSE as Dt, TOUCH as Vt, Spherical as si, OrthographicCamera as _n, Ray as Dl, Loader as Un, LoaderUtils as qn, FileLoader as kn, MeshPhysicalMaterial as Kt, SpotLight as xa, PointLight as ro, DirectionalLight as wa, InstancedMesh as Ta, InstancedBufferAttribute as Ll, ImageBitmapLoader as kl, PointsMaterial as Nl, Material as vi, MeshStandardMaterial as Es, SkinnedMesh as Po, LineSegments as Bl, LineLoop as Ul, Points as ba, Skeleton as Ea, AnimationClip as Ma, Bone as ao, VectorKeyframeTrack as lo, NumberKeyframeTrack as co, QuaternionKeyframeTrack as uo, Interpolant as Fl, Box3 as _t, Sphere as Ms, ExtrudeGeometry as zl, Curve as Gl, MeshPhongMaterial as yi, MeshLambertMaterial as Hl, EquirectangularReflectionMapping as ho, AmbientLight as jl, Uint16BufferAttribute as Vl, Matrix3 as Cn, ShapePath as pn, DataTextureLoader as Yl, FloatType as qs, DataUtils as Ls, ShapeUtils as Wl, Shape as Xl, Path as _i, InstancedBufferGeometry as $l, InstancedInterleavedBuffer as fo, WireframeGeometry as Zl, Line3 as Kl, AlwaysStencilFunc as ql, ReplaceStencilOp as xi, AnimationMixer as Ql, KeepStencilOp as wi, NotEqualStencilFunc as $o, EqualStencilFunc as Zo, DepthTexture as Sa, EdgesGeometry as Jl, CubeTextureLoader as ec, CubeReflectionMapping as tc, ShapeGeometry as nc, DefaultLoadingManager as ks, VideoTexture as sc, Clock as ic, NoBlending as oc, Camera as rc, TangentSpaceNormalMap as ac, CatmullRomCurve3 as lc, QuadraticBezierCurve3 as cc, MeshDepthMaterial as Ko, ShaderChunk as Ti, UnsignedByteType as uc, UVMapping as hc, IcosahedronGeometry as fc } from "three";
import { defineComponent as ue, watch as J, ref as me, shallowRef as re, withAsyncContext as Tn, onUnmounted as tt, createElementBlock as ce, openBlock as ae, renderSlot as Ne, createElementVNode as ye, unref as F, getCurrentScope as dc, onScopeDispose as pc, onMounted as bn, nextTick as Ro, getCurrentInstance as Aa, isRef as ii, computed as Pe, reactive as ts, watchEffect as et, toValue as ze, isReactive as po, createVNode as ms, mergeProps as $e, toRefs as Le, shallowReactive as Pa, onBeforeUnmount as Co, useSlots as Io, createCommentVNode as an, createBlock as Oo, Fragment as Ra, renderList as Ca, useAttrs as mc, render as gc, triggerRef as vc, toRaw as qo } from "vue";
import { useLogger as xt, useLoader as Nn, useTresContext as xe, useLoop as Ve, normalizeVectorFlexibleParam as Ia, useTres as xn, extend as Oa, useTexture as Bn, normalizeColor as tn } from "@tresjs/core";
function yc(r) {
  const e = _c(r), t = [];
  for (const { startFrame: n, endFrame: s, duration: i } of e)
    if (!(i <= 0))
      if (s < 0 || n === s) {
        for (let o = 0; o < i; o++)
          t.push(n);
        continue;
      } else {
        const o = Math.sign(s - n);
        for (let a = n; a !== s + o; a += o)
          for (let l = 0; l < i; l++)
            t.push(a);
      }
  return t;
}
function _c(r) {
  let e = "START_FRAME_IN";
  const t = [];
  for (const { name: n, value: s, startI: i } of xc(r))
    e === "START_FRAME_IN" ? n === "NUMBER" ? (t.push({
      startFrame: s,
      endFrame: s,
      duration: 1
    }), e = "START_FRAME_OUT") : Sn(
      "number",
      n,
      r,
      i
    ) : e === "START_FRAME_OUT" ? n === "COMMA" ? e = "START_FRAME_IN" : n === "HYPHEN" ? e = "END_FRAME_IN" : n === "OPEN_PAREN" ? e = "DURATION_IN" : Sn(
      '",", "-", "("',
      n,
      r,
      i
    ) : e === "END_FRAME_IN" ? n === "NUMBER" ? (t[t.length - 1].endFrame = s, e = "END_FRAME_OUT") : Sn(
      "number",
      n,
      r,
      i
    ) : e === "END_FRAME_OUT" ? n === "COMMA" ? e = "START_FRAME_IN" : n === "OPEN_PAREN" ? e = "DURATION_IN" : Sn(
      "',' or '('",
      n,
      r,
      i
    ) : e === "DURATION_IN" ? n === "NUMBER" ? (t[t.length - 1].duration = s, e = "DURATION_OUT") : Sn(
      "number",
      n,
      r,
      i
    ) : e === "DURATION_OUT" ? n === "CLOSE_PAREN" ? e = "NEXT_OR_DONE" : Sn('"("', n, r, i) : e === "NEXT_OR_DONE" && (n === "COMMA" ? e = "START_FRAME_IN" : Sn('","', n, r, i));
  return t;
}
function xc(r) {
  const e = [];
  for (let t = 0; t < r.length; t++) {
    const n = r[t];
    if ("0123456789".includes(n))
      e.length && e[e.length - 1].name === "NUMBER" ? (e[e.length - 1].value *= 10, e[e.length - 1].value += Number.parseInt(n)) : e.push({ name: "NUMBER", value: Number.parseInt(n), startI: t });
    else {
      if (n === " ")
        continue;
      n === "," ? e.push({ name: "COMMA", value: -1, startI: t }) : n === "(" ? e.push({ name: "OPEN_PAREN", value: -1, startI: t }) : n === ")" ? e.push({ name: "CLOSE_PAREN", value: -1, startI: t }) : n === "-" ? e.push({ name: "HYPHEN", value: -1, startI: t }) : wc("0123456789,-()", n, r, t);
    }
  }
  return e;
}
function wc(r, e, t, n) {
  xt().logError(
    `Cientos AnimationDefinitionParser: Unexpected character while processing animation definition: expected ${r}, got ${e}.
${t}
${Array.from({ length: n + 1 }).join(" ")}^`
  );
}
function Sn(r, e, t, n) {
  xt().logError(
    `Cientos AnimationDefinitionParser: Syntax error while processing animation definition: expected ${r}, got ${e}.
${t}
${Array.from({ length: n + 1 }).join(" ")}^`
  );
}
const Tc = /\d*$/, bc = /_*\d*$/;
function Ec(r) {
  return r.replace(bc, "");
}
function Mc(r) {
  const e = r.match(Tc);
  return e ? Number.parseInt(e[e.length - 1]) : null;
}
async function Sc(r, e) {
  const t = Nn(
    ai,
    r
  ), n = typeof e != "string" ? new Promise((s) => s(e)) : fetch(e).then((s) => s.json()).catch((s) => xt().logError(`Cientos Atlas - ${s}`));
  return Promise.all([t, n]).then(
    ([s, i]) => {
      const o = Ac(
        i,
        s.image.width,
        s.image.height
      );
      return [s, o];
    }
  );
}
function Ac(r, e, t) {
  const n = typeof r == "number" || Array.isArray(r) ? Ic(r, e, t) : Pc(
    r,
    e,
    t
  );
  return { frames: n, animations: Da(n) };
}
function gs(r, e, t) {
  let n;
  return typeof e == "string" ? n = Dc(r, e) : typeof e == "number" ? n = Qo(
    r,
    e,
    e
  ) : n = Qo(
    r,
    e[0],
    e[1]
  ), t ? n.toReversed() : n;
}
function Do() {
  return {
    name: "null",
    width: 0,
    height: 0,
    offsetX: 0,
    offsetY: 0,
    repeatX: 0,
    repeatY: 0
  };
}
function Pc(r, e, t) {
  return Array.isArray(r.frames) ? Rc(
    r,
    e,
    t
  ) : Cc(
    r,
    e,
    t
  );
}
function Rc(r, e, t) {
  const n = 1 / e, s = 1 / t;
  return r.frames.map((i) => ({
    name: i.filename,
    offsetX: i.frame.x * n,
    offsetY: 1 - (i.frame.y + i.frame.h) * s,
    repeatX: i.frame.w * n,
    repeatY: i.frame.h * s,
    width: i.frame.w,
    height: i.frame.h
  }));
}
function Cc(r, e, t) {
  const n = 1 / e, s = 1 / t;
  return Object.entries(r.frames).map(([i, o]) => ({
    name: i,
    offsetX: o.frame.x * n,
    offsetY: 1 - (o.frame.y + o.frame.h) * s,
    repeatX: o.frame.w * n,
    repeatY: o.frame.h * s,
    width: o.frame.w,
    height: o.frame.h
  }));
}
function Ic(r, e, t, n = "default") {
  const [s, i] = Array.isArray(r) ? r : [r, 1], o = e / s, a = t / i, l = (s * i).toString().length, c = 1 / s, f = 1 / i, u = [];
  let d = 0;
  for (let h = i - 1; h >= 0; h--)
    for (let m = 0; m < s; m++)
      d++, u.push({
        name: n + String(d).padStart(l, "0"),
        offsetX: m * c,
        offsetY: h * f,
        repeatX: c,
        repeatY: f,
        width: o,
        height: a
      });
  return u;
}
function Oc(r, e = {}) {
  const t = Da(r.frames);
  for (const [n, s] of Object.entries(e)) {
    const i = gs(r, n, !1), o = yc(s);
    for (const a of o)
      (a < 0 || i.length <= a) && xt().logError(
        `Cientos Atlas: Attempting to access frame index ${a} in animation ${n}, but it does not exist.`
      );
    t[n] = o.map((a) => i[a]);
  }
  r.animations = t;
}
function Dc(r, e) {
  if (!(e in r.animations)) {
    const t = Object.keys(r.animations).map((n) => `* ${n}
`).join("");
    return xt().logError(
      `Cientos Atlas: getAtlasFramesByAnimationName
The animation name "${e}" does not exist in this atlas.
Available names:
${t}`
    ), [Do()];
  }
  return r.animations[e];
}
function Qo(r, e, t) {
  if (e < 0 || r.frames.length <= e || t < 0 || r.frames.length <= t)
    return xt().logError(
      `Cientos Atlas: getFramesByIndex – [${e}, ${t}] is out of bounds.`
    ), [Do()];
  const n = [], s = Math.sign(t - e);
  if (s === 0)
    return [r.frames[e]];
  for (let i = e; i !== t + s; i += s)
    n.push(r.frames[i]);
  return n;
}
function Da(r) {
  const e = {};
  for (const t of r)
    if (Mc(t.name) !== null) {
      const n = Ec(t.name);
      Object.prototype.hasOwnProperty.call(e, n) ? e[n].push(t) : e[n] = [t];
    }
  for (const t of Object.values(e))
    t.sort((n, s) => n.name.localeCompare(s.name));
  return e;
}
const Lc = ["scale", "position"], kc = ["map", "alphaTest"], Nc = ["scale", "position"], Bc = ["side", "map", "alphaTest", "depthWrite", "depthTest"], Ns = 0.01, Ag = /* @__PURE__ */ ue({
  __name: "component",
  props: {
    image: {},
    atlas: {},
    definitions: {},
    fps: { default: 30 },
    loop: { type: Boolean, default: !0 },
    animation: { default: 0 },
    paused: { type: Boolean, default: !1 },
    reversed: { type: Boolean, default: !1 },
    flipX: { type: Boolean, default: !1 },
    resetOnEnd: { type: Boolean, default: !1 },
    asSprite: { type: Boolean, default: !0 },
    center: { default: () => [0.5, 0.5] },
    alphaTest: { default: 0 },
    depthTest: { type: Boolean, default: !0 },
    depthWrite: { type: Boolean, default: !0 }
  },
  emits: ["frame", "end", "loop"],
  async setup(r, { expose: e, emit: t }) {
    let n, s;
    const i = r, o = t, { invalidate: a } = xe();
    J(i, () => {
      a();
    });
    const l = me(0), c = me(0), f = me(0), u = me(0), d = re();
    e({ instance: d });
    const [h, m] = ([n, s] = Tn(() => Sc(i.image, i.atlas)), n = await n, s(), n);
    h.matrixAutoUpdate = !1;
    let g = gs(m, i.animation, i.reversed), v = 0.5, p = 0.5, b = 1, _ = Do(), M = null, R = 0, w = !1, E = !0;
    Ve().onBeforeRender(({ delta: T }) => {
      for (!i.paused && !w && (b -= T * i.fps); b <= 0; )
        b++, R++, i.loop ? (R >= g.length && o("loop", g[g.length - 1].name), R %= g.length) : R >= g.length && (w = !0, R = i.resetOnEnd ? 0 : g.length - 1, o("end", g[g.length - 1].name));
      g[R] !== _ && (_ = g[R], M = _.name, x()), E && (E = !1, h.offset.x = _.offsetX + (i.flipX ? _.repeatX : 0), h.offset.y = _.offsetY, h.repeat.x = _.repeatX * (i.flipX ? -1 : 1), h.repeat.y = _.repeatY, h.updateMatrix(), f.value = _.width * Ns, u.value = _.height * Ns, l.value = (0.5 - v) * _.width * Ns, c.value = (0.5 - p) * _.height * Ns), M && (o("frame", M), M = null);
    });
    function x() {
      E = !0;
    }
    return J(() => i.animation, (T, y) => {
      JSON.stringify(T) !== JSON.stringify(y) && (g = gs(m, i.animation, i.reversed), R = 0, b = 1, w = !1, x());
    }, { immediate: !0 }), J(() => i.reversed, () => {
      R = (g.length - R - 1) % g.length, g = gs(m, i.animation, i.reversed), w && (R = i.resetOnEnd ? 0 : g.length - 1), x();
    }), J(() => i.paused, () => {
      w = !1;
    }), J(() => i.loop, () => {
      w && i.loop && (w = !1);
    }), J(() => i.resetOnEnd, () => {
      w && (R = i.resetOnEnd ? 0 : g.length - 1, x());
    }), J(() => i.flipX, x), J(() => [i.center], () => {
      [v, p] = Ia(i.center), x();
    }, { immediate: !0 }), J(() => [i.definitions], () => {
      Oc(m, i.definitions), g = gs(m, i.animation, i.reversed), b = 1, R = 0, x();
    }, { immediate: !0 }), tt(() => {
      h.dispose();
    }), (T, y) => (ae(), ce("TresGroup", {
      ref_key: "groupRef",
      ref: d
    }, [
      i.asSprite ? (ae(), ce("TresSprite", {
        key: 0,
        scale: [f.value, u.value, 1],
        position: [l.value, c.value, 0]
      }, [
        ye("TresSpriteMaterial", {
          toneMapped: !1,
          map: F(h),
          transparent: !0,
          alphaTest: i.alphaTest
        }, null, 8, kc)
      ], 8, Lc)) : (ae(), ce("TresMesh", {
        key: 1,
        scale: [f.value, u.value, 1],
        position: [l.value, c.value, 0]
      }, [
        y[0] || (y[0] = ye("TresPlaneGeometry", { args: [1, 1] }, null, -1)),
        ye("TresMeshBasicMaterial", {
          toneMapped: !1,
          side: F(on),
          map: F(h),
          transparent: !0,
          alphaTest: i.alphaTest,
          depthWrite: i.depthWrite,
          depthTest: i.depthTest
        }, null, 8, Bc)
      ], 8, Nc)),
      Ne(T.$slots, "default")
    ], 512));
  }
});
function ci(r) {
  return dc() ? (pc(r), !0) : !1;
}
function ct(r) {
  return typeof r == "function" ? r() : F(r);
}
const Uc = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const Fc = Object.prototype.toString, zc = (r) => Fc.call(r) === "[object Object]", wn = () => {
};
function Lo(r, e) {
  function t(...n) {
    return new Promise((s, i) => {
      Promise.resolve(r(() => e.apply(this, n), { fn: e, thisArg: this, args: n })).then(s).catch(i);
    });
  }
  return t;
}
const Gc = (r) => r();
function Hc(r, e = {}) {
  let t, n, s = wn;
  const i = (a) => {
    clearTimeout(a), s(), s = wn;
  };
  return (a) => {
    const l = ct(r), c = ct(e.maxWait);
    return t && i(t), l <= 0 || c !== void 0 && c <= 0 ? (n && (i(n), n = null), Promise.resolve(a())) : new Promise((f, u) => {
      s = e.rejectOnCancel ? u : f, c && !n && (n = setTimeout(() => {
        t && i(t), n = null, f(a());
      }, c)), t = setTimeout(() => {
        n && i(n), n = null, f(a());
      }, l);
    });
  };
}
function La(...r) {
  let e = 0, t, n = !0, s = wn, i, o, a, l, c;
  !ii(r[0]) && typeof r[0] == "object" ? { delay: o, trailing: a = !0, leading: l = !0, rejectOnCancel: c = !1 } = r[0] : [o, a = !0, l = !0, c = !1] = r;
  const f = () => {
    t && (clearTimeout(t), t = void 0, s(), s = wn);
  };
  return (d) => {
    const h = ct(o), m = Date.now() - e, g = () => i = d();
    return f(), h <= 0 ? (e = Date.now(), g()) : (m > h && (l || !n) ? (e = Date.now(), g()) : a && (i = new Promise((v, p) => {
      s = c ? p : v, t = setTimeout(() => {
        e = Date.now(), n = !0, v(g()), f();
      }, Math.max(0, h - m));
    })), !l && !t && (t = setTimeout(() => n = !0, h)), n = !1, i);
  };
}
function jc(r) {
  return Aa();
}
function Vc(r, e = 200, t = {}) {
  return Lo(
    Hc(e, t),
    r
  );
}
function Yc(r, e = 200, t = !1, n = !0, s = !1) {
  return Lo(
    La(e, t, n, s),
    r
  );
}
function Wc(r, e, t = {}) {
  const {
    eventFilter: n = Gc,
    ...s
  } = t;
  return J(
    r,
    Lo(
      n,
      e
    ),
    s
  );
}
function ko(r, e = !0, t) {
  jc() ? bn(r, t) : e ? r() : Ro(r);
}
function Xc(r, e, t = {}) {
  const {
    throttle: n = 0,
    trailing: s = !0,
    leading: i = !0,
    ...o
  } = t;
  return Wc(
    r,
    e,
    {
      ...o,
      eventFilter: La(n, s, i)
    }
  );
}
const ln = Uc ? window : void 0;
function gn(r) {
  var e;
  const t = ct(r);
  return (e = t == null ? void 0 : t.$el) != null ? e : t;
}
function Xe(...r) {
  let e, t, n, s;
  if (typeof r[0] == "string" || Array.isArray(r[0]) ? ([t, n, s] = r, e = ln) : [e, t, n, s] = r, !e)
    return wn;
  Array.isArray(t) || (t = [t]), Array.isArray(n) || (n = [n]);
  const i = [], o = () => {
    i.forEach((f) => f()), i.length = 0;
  }, a = (f, u, d, h) => (f.addEventListener(u, d, h), () => f.removeEventListener(u, d, h)), l = J(
    () => [gn(e), ct(s)],
    ([f, u]) => {
      if (o(), !f)
        return;
      const d = zc(u) ? { ...u } : u;
      i.push(
        ...t.flatMap((h) => n.map((m) => a(f, h, m, d)))
      );
    },
    { immediate: !0, flush: "post" }
  ), c = () => {
    l(), o();
  };
  return ci(c), c;
}
function $c() {
  const r = me(!1), e = Aa();
  return e && bn(() => {
    r.value = !0;
  }, e), r;
}
function ka(r) {
  const e = $c();
  return Pe(() => (e.value, !!r()));
}
function Zc(r, e = {}) {
  const { window: t = ln } = e, n = ka(() => t && "matchMedia" in t && typeof t.matchMedia == "function");
  let s;
  const i = me(!1), o = (c) => {
    i.value = c.matches;
  }, a = () => {
    s && ("removeEventListener" in s ? s.removeEventListener("change", o) : s.removeListener(o));
  }, l = et(() => {
    n.value && (a(), s = t.matchMedia(ct(r)), "addEventListener" in s ? s.addEventListener("change", o) : s.addListener(o), i.value = s.matches);
  });
  return ci(() => {
    l(), a(), s = void 0;
  }), i;
}
function Kc(r, e, t = {}) {
  const { window: n = ln, ...s } = t;
  let i;
  const o = ka(() => n && "ResizeObserver" in n), a = () => {
    i && (i.disconnect(), i = void 0);
  }, l = Pe(() => {
    const u = ct(r);
    return Array.isArray(u) ? u.map((d) => gn(d)) : [gn(u)];
  }), c = J(
    l,
    (u) => {
      if (a(), o.value && n) {
        i = new ResizeObserver(e);
        for (const d of u)
          d && i.observe(d, s);
      }
    },
    { immediate: !0, flush: "post" }
  ), f = () => {
    a(), c();
  };
  return ci(f), {
    isSupported: o,
    stop: f
  };
}
function qc(r, e = { width: 0, height: 0 }, t = {}) {
  const { window: n = ln, box: s = "content-box" } = t, i = Pe(() => {
    var u, d;
    return (d = (u = gn(r)) == null ? void 0 : u.namespaceURI) == null ? void 0 : d.includes("svg");
  }), o = me(e.width), a = me(e.height), { stop: l } = Kc(
    r,
    ([u]) => {
      const d = s === "border-box" ? u.borderBoxSize : s === "content-box" ? u.contentBoxSize : u.devicePixelContentBoxSize;
      if (n && i.value) {
        const h = gn(r);
        if (h) {
          const m = h.getBoundingClientRect();
          o.value = m.width, a.value = m.height;
        }
      } else if (d) {
        const h = Array.isArray(d) ? d : [d];
        o.value = h.reduce((m, { inlineSize: g }) => m + g, 0), a.value = h.reduce((m, { blockSize: g }) => m + g, 0);
      } else
        o.value = u.contentRect.width, a.value = u.contentRect.height;
    },
    t
  );
  ko(() => {
    const u = gn(r);
    u && (o.value = "offsetWidth" in u ? u.offsetWidth : e.width, a.value = "offsetHeight" in u ? u.offsetHeight : e.height);
  });
  const c = J(
    () => gn(r),
    (u) => {
      o.value = u ? e.width : 0, a.value = u ? e.height : 0;
    }
  );
  function f() {
    l(), c();
  }
  return {
    width: o,
    height: a,
    stop: f
  };
}
const Jo = 1;
function Qc(r, e = {}) {
  const {
    throttle: t = 0,
    idle: n = 200,
    onStop: s = wn,
    onScroll: i = wn,
    offset: o = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    },
    eventListenerOptions: a = {
      capture: !1,
      passive: !0
    },
    behavior: l = "auto",
    window: c = ln,
    onError: f = (E) => {
      console.error(E);
    }
  } = e, u = me(0), d = me(0), h = Pe({
    get() {
      return u.value;
    },
    set(E) {
      g(E, void 0);
    }
  }), m = Pe({
    get() {
      return d.value;
    },
    set(E) {
      g(void 0, E);
    }
  });
  function g(E, x) {
    var T, y, A, C;
    if (!c)
      return;
    const N = ct(r);
    if (!N)
      return;
    (A = N instanceof Document ? c.document.body : N) == null || A.scrollTo({
      top: (T = ct(x)) != null ? T : m.value,
      left: (y = ct(E)) != null ? y : h.value,
      behavior: ct(l)
    });
    const U = ((C = N == null ? void 0 : N.document) == null ? void 0 : C.documentElement) || (N == null ? void 0 : N.documentElement) || N;
    h != null && (u.value = U.scrollLeft), m != null && (d.value = U.scrollTop);
  }
  const v = me(!1), p = ts({
    left: !0,
    right: !1,
    top: !0,
    bottom: !1
  }), b = ts({
    left: !1,
    right: !1,
    top: !1,
    bottom: !1
  }), _ = (E) => {
    v.value && (v.value = !1, b.left = !1, b.right = !1, b.top = !1, b.bottom = !1, s(E));
  }, M = Vc(_, t + n), R = (E) => {
    var x;
    if (!c)
      return;
    const T = ((x = E == null ? void 0 : E.document) == null ? void 0 : x.documentElement) || (E == null ? void 0 : E.documentElement) || gn(E), { display: y, flexDirection: A } = getComputedStyle(T), C = T.scrollLeft;
    b.left = C < u.value, b.right = C > u.value;
    const N = Math.abs(C) <= (o.left || 0), U = Math.abs(C) + T.clientWidth >= T.scrollWidth - (o.right || 0) - Jo;
    y === "flex" && A === "row-reverse" ? (p.left = U, p.right = N) : (p.left = N, p.right = U), u.value = C;
    let Y = T.scrollTop;
    E === c.document && !Y && (Y = c.document.body.scrollTop), b.top = Y < d.value, b.bottom = Y > d.value;
    const V = Math.abs(Y) <= (o.top || 0), ne = Math.abs(Y) + T.clientHeight >= T.scrollHeight - (o.bottom || 0) - Jo;
    y === "flex" && A === "column-reverse" ? (p.top = ne, p.bottom = V) : (p.top = V, p.bottom = ne), d.value = Y;
  }, w = (E) => {
    var x;
    if (!c)
      return;
    const T = (x = E.target.documentElement) != null ? x : E.target;
    R(T), v.value = !0, M(E), i(E);
  };
  return Xe(
    r,
    "scroll",
    t ? Yc(w, t, !0, !1) : w,
    a
  ), ko(() => {
    try {
      const E = ct(r);
      if (!E)
        return;
      R(E);
    } catch (E) {
      f(E);
    }
  }), Xe(
    r,
    "scrollend",
    _,
    a
  ), {
    x: h,
    y: m,
    isScrolling: v,
    arrivedState: p,
    directions: b,
    measure() {
      const E = ct(r);
      c && E && R(E);
    }
  };
}
const Jc = {
  ctrl: "control",
  command: "meta",
  cmd: "meta",
  option: "alt",
  up: "arrowup",
  down: "arrowdown",
  left: "arrowleft",
  right: "arrowright"
};
function eu(r = {}) {
  const {
    reactive: e = !1,
    target: t = ln,
    aliasMap: n = Jc,
    passive: s = !0,
    onEventFired: i = wn
  } = r, o = ts(/* @__PURE__ */ new Set()), a = {
    toJSON() {
      return {};
    },
    current: o
  }, l = e ? ts(a) : a, c = /* @__PURE__ */ new Set(), f = /* @__PURE__ */ new Set();
  function u(g, v) {
    g in l && (e ? l[g] = v : l[g].value = v);
  }
  function d() {
    o.clear();
    for (const g of f)
      u(g, !1);
  }
  function h(g, v) {
    var p, b;
    const _ = (p = g.key) == null ? void 0 : p.toLowerCase(), R = [(b = g.code) == null ? void 0 : b.toLowerCase(), _].filter(Boolean);
    _ && (v ? o.add(_) : o.delete(_));
    for (const w of R)
      f.add(w), u(w, v);
    _ === "meta" && !v ? (c.forEach((w) => {
      o.delete(w), u(w, !1);
    }), c.clear()) : typeof g.getModifierState == "function" && g.getModifierState("Meta") && v && [...o, ...R].forEach((w) => c.add(w));
  }
  Xe(t, "keydown", (g) => (h(g, !0), i(g)), { passive: s }), Xe(t, "keyup", (g) => (h(g, !1), i(g)), { passive: s }), Xe("blur", d, { passive: !0 }), Xe("focus", d, { passive: !0 });
  const m = new Proxy(
    l,
    {
      get(g, v, p) {
        if (typeof v != "string")
          return Reflect.get(g, v, p);
        if (v = v.toLowerCase(), v in n && (v = n[v]), !(v in l))
          if (/[+_-]/.test(v)) {
            const _ = v.split(/[+_-]/g).map((M) => M.trim());
            l[v] = Pe(() => _.every((M) => ct(m[M])));
          } else
            l[v] = me(!1);
        const b = Reflect.get(g, v, p);
        return e ? ct(b) : b;
      }
    }
  );
  return m;
}
const tu = {
  page: (r) => [r.pageX, r.pageY],
  client: (r) => [r.clientX, r.clientY],
  screen: (r) => [r.screenX, r.screenY],
  movement: (r) => r instanceof Touch ? null : [r.movementX, r.movementY]
};
function nu(r = {}) {
  const {
    type: e = "page",
    touch: t = !0,
    resetOnTouchEnds: n = !1,
    initialValue: s = { x: 0, y: 0 },
    window: i = ln,
    target: o = i,
    scroll: a = !0,
    eventFilter: l
  } = r;
  let c = null, f = 0, u = 0;
  const d = me(s.x), h = me(s.y), m = me(null), g = typeof e == "function" ? e : tu[e], v = (E) => {
    const x = g(E);
    c = E, x && ([d.value, h.value] = x, m.value = "mouse"), i && (f = i.scrollX, u = i.scrollY);
  }, p = (E) => {
    if (E.touches.length > 0) {
      const x = g(E.touches[0]);
      x && ([d.value, h.value] = x, m.value = "touch");
    }
  }, b = () => {
    if (!c || !i)
      return;
    const E = g(c);
    c instanceof MouseEvent && E && (d.value = E[0] + i.scrollX - f, h.value = E[1] + i.scrollY - u);
  }, _ = () => {
    d.value = s.x, h.value = s.y;
  }, M = l ? (E) => l(() => v(E), {}) : (E) => v(E), R = l ? (E) => l(() => p(E), {}) : (E) => p(E), w = l ? () => l(() => b(), {}) : () => b();
  if (o) {
    const E = { passive: !0 };
    Xe(o, ["mousemove", "dragover"], M, E), t && e !== "movement" && (Xe(o, ["touchstart", "touchmove"], R, E), n && Xe(o, "touchend", _, E)), a && e === "page" && Xe(i, "scroll", w, { passive: !0 });
  }
  return {
    x: d,
    y: h,
    sourceType: m
  };
}
function su(r = {}) {
  const { window: e = ln, behavior: t = "auto" } = r;
  if (!e)
    return {
      x: me(0),
      y: me(0)
    };
  const n = me(e.scrollX), s = me(e.scrollY), i = Pe({
    get() {
      return n.value;
    },
    set(a) {
      scrollTo({ left: a, behavior: t });
    }
  }), o = Pe({
    get() {
      return s.value;
    },
    set(a) {
      scrollTo({ top: a, behavior: t });
    }
  });
  return Xe(
    e,
    "scroll",
    () => {
      n.value = e.scrollX, s.value = e.scrollY;
    },
    {
      capture: !1,
      passive: !0
    }
  ), { x: i, y: o };
}
function Na(r = {}) {
  const {
    window: e = ln,
    initialWidth: t = Number.POSITIVE_INFINITY,
    initialHeight: n = Number.POSITIVE_INFINITY,
    listenOrientation: s = !0,
    includeScrollbar: i = !0,
    type: o = "inner"
  } = r, a = me(t), l = me(n), c = () => {
    e && (o === "outer" ? (a.value = e.outerWidth, l.value = e.outerHeight) : i ? (a.value = e.innerWidth, l.value = e.innerHeight) : (a.value = e.document.documentElement.clientWidth, l.value = e.document.documentElement.clientHeight));
  };
  if (c(), ko(c), Xe("resize", c, { passive: !0 }), s) {
    const f = Zc("(orientation: portrait)");
    J(f, () => c());
  }
  return { width: a, height: l };
}
function iu(r) {
  let { resolution: e, renderer: t, scene: n, envMap: s, fog: i, near: o, far: a } = r;
  t = t ?? xn().renderer, n = n ?? xn().scene, et(() => {
    e = ze(r.resolution) ?? 255, o = ze(r.near) ?? 0.1, a = ze(r.far) ?? 1e3, s = ze(r.envMap) ?? void 0, i = ze(r.fog) ?? void 0, t = ze(r.renderer) ?? t, n = ze(r.scene) ?? n;
  });
  const c = Pe(() => new aa(ze(e)));
  c.value.texture.type = Lt, ci(() => {
    c.value.dispose();
  });
  const f = Pe(() => new la(ze(o), ze(a), ze(c))), u = () => {
    const d = ze(n), h = d.fog, m = d.background;
    d.background = ze(s) || m, d.fog = ze(i) || h, f.value.update(ze(t), d), d.fog = h, d.background = m;
  };
  return et(u), {
    fbo: c,
    camera: f,
    update: u
  };
}
const ou = ["object"], Pg = /* @__PURE__ */ ue({
  __name: "component",
  props: {
    frames: { default: 1 / 0 },
    resolution: {},
    near: {},
    far: {},
    envMap: {},
    fog: {},
    renderer: {},
    scene: {}
  },
  setup(r, { expose: e }) {
    const t = r, n = re(), { fbo: s, camera: i, update: o } = iu(t);
    let a = 0;
    return Ve().onBeforeRender(() => {
      n.value && (t.frames === 1 / 0 || a < ze(t.frames)) && (n.value.visible = !1, o(), n.value.visible = !0, n.value && n.value.traverse((l) => {
        "material" in l && typeof l.material == "object" && l.material && "envMap" in l.material && (l.material.envMap = s.value.texture);
      }), a++);
    }), e({ instance: n, fbo: s, camera: i, update: o }), (l, c) => (ae(), ce("TresGroup", {
      ref_key: "groupRef",
      ref: n
    }, [
      ye("primitive", { object: F(i) }, null, 8, ou),
      Ne(l.$slots, "default")
    ], 512));
  }
}), Rg = /* @__PURE__ */ ue({
  __name: "Billboard",
  props: {
    autoUpdate: { type: Boolean, default: !0 },
    lockX: { type: Boolean, default: !1 },
    lockY: { type: Boolean, default: !1 },
    lockZ: { type: Boolean, default: !1 }
  },
  setup(r, { expose: e }) {
    const t = r, n = re(new Zt()), s = re(new Zt()), i = new je(), o = new vt();
    function a(l) {
      n.value && (!l && (l = xn().camera.value, !l) || (s.value.rotation.copy(o), n.value.updateMatrix(), n.value.updateWorldMatrix(!1, !1), n.value.getWorldQuaternion(i), l.getWorldQuaternion(s.value.quaternion).premultiply(i.invert()), t.lockX && (s.value.rotation.x = o.x), t.lockY && (s.value.rotation.y = o.y), t.lockZ && (s.value.rotation.z = o.z)));
    }
    return Ve().onBeforeRender(({ camera: l }) => {
      t.autoUpdate && a(l);
    }), e({ instance: n, update: a }), (l, c) => (ae(), ce("TresGroup", {
      ref_key: "outerRef",
      ref: n
    }, [
      ye("TresGroup", {
        ref_key: "innerRef",
        ref: s
      }, [
        Ne(l.$slots, "default")
      ], 512)
    ], 512));
  }
}), Cg = ue({
  name: "GlobalAudio",
  props: [
    "src",
    "loop",
    "volume",
    "playbackRate",
    "playTrigger",
    "stopTrigger"
  ],
  async setup(r, { expose: e, emit: t }) {
    var u;
    const { camera: n, renderer: s } = xe(), i = new ca();
    (u = n.value) == null || u.add(i);
    const o = new Al(i), a = new ua();
    e({ instance: o }), tt(() => {
      o && o.disconnect();
    }), J(() => [r.playbackRate], () => o.setPlaybackRate(r.playbackRate ?? 1), { immediate: !0 }), J(() => [r.volume], () => o.setVolume(r.volume ?? 0.5), { immediate: !0 }), J(() => [r.loop], () => o.setLoop(r.loop ?? !1), { immediate: !0 }), J(() => [r.src], async () => {
      const d = await a.loadAsync(r.src);
      o.setBuffer(d);
    }, { immediate: !0 });
    const c = document.getElementById(r.playTrigger ?? "") || s.value.domElement;
    Xe(c, "click", () => {
      o.isPlaying ? o.pause() : o.play(), t("isPlaying", o.isPlaying);
    });
    const f = document.getElementById(r.stopTrigger ?? "");
    return f && Xe(f, "click", () => {
      o.stop(), t("isPlaying", o.isPlaying);
    }), null;
  }
}), ru = ["color-space", "args", "attach"], Ig = /* @__PURE__ */ ue({
  __name: "GradientTexture",
  props: {
    stops: {},
    colors: {},
    attach: { default: "map" },
    height: { default: 1024 },
    width: { default: 16 },
    type: { default: "linear" },
    innerCircleRadius: { default: 0 },
    outerCircleRadius: { default: "auto" }
  },
  setup(r, { expose: e }) {
    const t = r, n = re(), s = document.createElement("canvas");
    function i(a) {
      const l = a.getContext("2d");
      a.width = t.width, a.height = t.height;
      let c;
      if (t.type === "linear")
        c = l.createLinearGradient(0, 0, 0, t.height);
      else {
        const d = a.width / 2, h = a.height / 2, m = t.outerCircleRadius !== "auto" ? Math.abs(Number(t.outerCircleRadius)) : Math.sqrt(d ** 2 + h ** 2);
        c = l.createRadialGradient(
          d,
          h,
          Math.abs(t.innerCircleRadius),
          d,
          h,
          m
        );
      }
      const f = new Jn.Color();
      let u = t.stops.length;
      for (; u--; )
        c.addColorStop(t.stops[u], f.set(t.colors[u]).getStyle());
      l.save(), l.fillStyle = c, l.fillRect(0, 0, t.width, t.height), l.restore(), n.value && (n.value.needsUpdate = !0);
    }
    const o = xn().renderer;
    return J(() => [t.colors, t.stops, t.height, t.width, t.type, t.innerCircleRadius, t.outerCircleRadius], () => {
      i(s);
    }, { immediate: !0 }), po(t.colors) && J(t.colors, () => i(s)), po(t.stops) && J(t.stops, () => i(s)), e({ instance: n }), (a, l) => (ae(), ce("TresCanvasTexture", {
      ref_key: "textureRef",
      ref: n,
      "color-space": F(o).outputColorSpace,
      args: [F(s)],
      attach: t.attach
    }, null, 8, ru));
  }
});
function No(r, e, t, n) {
  const s = class extends bt {
    constructor(o = {}) {
      const a = Object.entries(r);
      super({
        uniforms: a.reduce((l, [c, f]) => {
          const u = Dn.clone({ [c]: { value: f } });
          return {
            ...l,
            ...u
          };
        }, {}),
        vertexShader: e,
        fragmentShader: t
      });
      pe(this, "key", "");
      a.forEach(
        ([l]) => Object.defineProperty(this, l, {
          get: () => this.uniforms[l].value,
          set: (c) => this.uniforms[l].value = c
        })
      ), Object.assign(this, o);
    }
  };
  return s.key = Ye.generateUUID(), s;
}
const au = No(
  {
    color: /* @__PURE__ */ new be("white"),
    scale: /* @__PURE__ */ new ve(1, 1),
    imageBounds: /* @__PURE__ */ new ve(1, 1),
    resolution: 1024,
    map: null,
    zoom: 1,
    radius: 0,
    grayscale: 0,
    opacity: 1
  },
  /* glsl */
  `
    varying vec2 vUv;
    varying vec2 vPos;
    void main() {
      gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);
      vUv = uv;
      vPos = position.xy;
    }
  `,
  /* glsl */
  `
    // mostly from https://gist.github.com/statico/df64c5d167362ecf7b34fca0b1459a44
    varying vec2 vUv;
    varying vec2 vPos;
    uniform vec2 scale;
    uniform vec2 imageBounds;
    uniform float resolution;
    uniform vec3 color;
    uniform sampler2D map;
    uniform float radius;
    uniform float zoom;
    uniform float grayscale;
    uniform float opacity;
    const vec3 luma = vec3(.299, 0.587, 0.114);
    vec4 toGrayscale(vec4 color, float intensity) {
      return vec4(mix(color.rgb, vec3(dot(color.rgb, luma)), intensity), color.a);
    }
    vec2 aspect(vec2 size) {
      return size / min(size.x, size.y);
    }
    
    const float PI = 3.14159265;
      
    // from https://iquilezles.org/articles/distfunctions
    float udRoundBox( vec2 p, vec2 b, float r ) {
      return length(max(abs(p)-b+r,0.0))-r;
    }
  
    void main() {
      vec2 s = aspect(scale);
      vec2 i = aspect(imageBounds);
      float rs = s.x / s.y;
      float ri = i.x / i.y;
      vec2 new = rs < ri ? vec2(i.x * s.y / i.y, s.y) : vec2(s.x, i.y * s.x / i.x);
      vec2 offset = (rs < ri ? vec2((new.x - s.x) / 2.0, 0.0) : vec2(0.0, (new.y - s.y) / 2.0)) / new;
      vec2 uv = vUv * s / new + offset;
      vec2 zUv = (uv - vec2(0.5, 0.5)) / zoom + vec2(0.5, 0.5);
  
      vec2 res = vec2(scale * resolution);
      vec2 halfRes = 0.5 * res;
      float b = udRoundBox(vUv.xy * res - halfRes, halfRes, resolution * radius);    
        vec3 a = mix(vec3(1.0,0.0,0.0), vec3(0.0,0.0,0.0), smoothstep(0.0, 1.0, b));
      gl_FragColor = toGrayscale(texture2D(map, zUv) * vec4(color, opacity * a), grayscale);
      
      #include <tonemapping_fragment>
      #include <colorspace_fragment>
    }
  `
), lu = /* @__PURE__ */ ue({
  __name: "ImageMaterial",
  setup(r, { expose: e }) {
    Oa({ ImageMaterial: au });
    const t = re();
    return e({ instance: t }), (n, s) => (ae(), ce("TresImageMaterial", {
      ref_key: "materialRef",
      ref: t
    }, null, 512));
  }
}), cu = ["scale"], uu = ["args"], Og = /* @__PURE__ */ ue({
  __name: "component",
  props: {
    segments: { default: 1 },
    scale: { default: 1 },
    color: { default: () => new be("white") },
    zoom: { default: 1 },
    radius: { default: 0 },
    grayscale: { default: 0 },
    toneMapped: { type: Boolean, default: !0 },
    transparent: { type: Boolean, default: !1 },
    opacity: { default: 1 },
    side: { default: ss },
    texture: {},
    url: {}
  },
  setup(r, { expose: e }) {
    const t = r, n = re(), s = re(t.texture ?? null), i = xn().sizes, o = Pe(() => Array.isArray(t.scale) ? [t.scale[0], t.scale[1]] : [t.scale, t.scale]), a = Pe(() => {
      var f, u;
      return [((f = s.value) == null ? void 0 : f.image.width) ?? 0, ((u = s.value) == null ? void 0 : u.image.height) ?? 0];
    }), l = Pe(() => Math.max(i.width.value, i.height.value));
    et(() => {
      t.texture ? s.value = t.texture : Bn([t.url]).then((f) => s.value = f);
    });
    const c = Pe(
      () => Array.isArray(t.scale) ? [...t.scale, 1] : t.scale
    );
    return e({ instance: n }), (f, u) => (ae(), ce("TresMesh", {
      ref_key: "imageRef",
      ref: n,
      scale: c.value
    }, [
      Ne(f.$slots, "default", {}, () => [
        ye("TresPlaneGeometry", {
          args: [1, 1, t.segments, t.segments]
        }, null, 8, uu)
      ]),
      ms(lu, {
        color: t.color,
        map: s.value,
        zoom: t.zoom,
        grayscale: t.grayscale,
        opacity: t.opacity,
        scale: o.value,
        imageBounds: a.value,
        resolution: l.value,
        radius: f.radius,
        toneMapped: f.toneMapped,
        transparent: f.transparent,
        side: f.side
      }, null, 8, ["color", "map", "zoom", "grayscale", "opacity", "scale", "imageBounds", "resolution", "radius", "toneMapped", "transparent", "side"])
    ], 8, cu));
  }
}), Ss = parseInt(Ts.replace(/\D+/g, "")), Bo = Ss >= 125 ? "uv1" : "uv2";
function er(r, e) {
  if (e === Pl)
    return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), r;
  if (e === oo || e === ha) {
    let t = r.getIndex();
    if (t === null) {
      const o = [], a = r.getAttribute("position");
      if (a !== void 0) {
        for (let l = 0; l < a.count; l++)
          o.push(l);
        r.setIndex(o), t = r.getIndex();
      } else
        return console.error(
          "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
        ), r;
    }
    const n = t.count - 2, s = [];
    if (t)
      if (e === oo)
        for (let o = 1; o <= n; o++)
          s.push(t.getX(0)), s.push(t.getX(o)), s.push(t.getX(o + 1));
      else
        for (let o = 0; o < n; o++)
          o % 2 === 0 ? (s.push(t.getX(o)), s.push(t.getX(o + 1)), s.push(t.getX(o + 2))) : (s.push(t.getX(o + 2)), s.push(t.getX(o + 1)), s.push(t.getX(o)));
    s.length / 3 !== n && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const i = r.clone();
    return i.setIndex(s), i.clearGroups(), i;
  } else
    return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), r;
}
function hu(r, e = Math.PI / 3) {
  const t = Math.cos(e), n = (1 + 1e-10) * 100, s = [new $(), new $(), new $()], i = new $(), o = new $(), a = new $(), l = new $();
  function c(g) {
    const v = ~~(g.x * n), p = ~~(g.y * n), b = ~~(g.z * n);
    return `${v},${p},${b}`;
  }
  const f = r.index ? r.toNonIndexed() : r, u = f.attributes.position, d = {};
  for (let g = 0, v = u.count / 3; g < v; g++) {
    const p = 3 * g, b = s[0].fromBufferAttribute(u, p + 0), _ = s[1].fromBufferAttribute(u, p + 1), M = s[2].fromBufferAttribute(u, p + 2);
    i.subVectors(M, _), o.subVectors(b, _);
    const R = new $().crossVectors(i, o).normalize();
    for (let w = 0; w < 3; w++) {
      const E = s[w], x = c(E);
      x in d || (d[x] = []), d[x].push(R);
    }
  }
  const h = new Float32Array(u.count * 3), m = new ut(h, 3, !1);
  for (let g = 0, v = u.count / 3; g < v; g++) {
    const p = 3 * g, b = s[0].fromBufferAttribute(u, p + 0), _ = s[1].fromBufferAttribute(u, p + 1), M = s[2].fromBufferAttribute(u, p + 2);
    i.subVectors(M, _), o.subVectors(b, _), a.crossVectors(i, o).normalize();
    for (let R = 0; R < 3; R++) {
      const w = s[R], E = c(w), x = d[E];
      l.set(0, 0, 0);
      for (let T = 0, y = x.length; T < y; T++) {
        const A = x[T];
        a.dot(A) > t && l.add(A);
      }
      l.normalize(), m.setXYZ(p + R, l.x, l.y, l.z);
    }
  }
  return f.setAttribute("normal", m), f;
}
var fu = Object.defineProperty, du = (r, e, t) => e in r ? fu(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, pu = (r, e, t) => (du(r, e + "", t), t);
async function tr(r) {
  const e = await r.arrayBuffer(), t = btoa(String.fromCharCode(...new Uint8Array(e)));
  return `data:${r.type || ""};base64,${t}`;
}
let Bs, bi, Fn, Us;
function Ei(r, e = 1 / 0, t = null) {
  bi || (bi = new jt(2, 2, 1, 1)), Fn || (Fn = new bt({
    uniforms: { blitTexture: new Se(r) },
    vertexShader: (
      /* glsl */
      `
        varying vec2 vUv;
        void main(){
            vUv = uv;
            gl_Position = vec4(position.xy * 1.0,0.,.999999);
        }
      `
    ),
    fragmentShader: (
      /* glsl */
      `
          uniform sampler2D blitTexture; 
          varying vec2 vUv;

          void main(){ 
              gl_FragColor = vec4(vUv.xy, 0, 1);
              
              #ifdef IS_SRGB
              gl_FragColor = LinearTosRGB( texture2D( blitTexture, vUv) );
              #else
              gl_FragColor = texture2D( blitTexture, vUv);
              #endif
          }
      `
    )
  })), Fn.uniforms.blitTexture.value = r, Fn.defines.IS_SRGB = "colorSpace" in r ? r.colorSpace === "srgb" : r.encoding === 3001, Fn.needsUpdate = !0, Us || (Us = new de(bi, Fn), Us.frustrumCulled = !1);
  const n = new kt(), s = new xs();
  s.add(Us), t || (t = Bs = new Rl({ antialias: !1 })), t.setSize(Math.min(r.image.width, e), Math.min(r.image.height, e)), t.clear(), t.render(s, n);
  const i = new es(t.domElement);
  return i.minFilter = r.minFilter, i.magFilter = r.magFilter, i.wrapS = r.wrapS, i.wrapT = r.wrapT, i.name = r.name, Bs && (Bs.dispose(), Bs = null), i;
}
const nr = {
  POSITION: [
    "byte",
    "byte normalized",
    "unsigned byte",
    "unsigned byte normalized",
    "short",
    "short normalized",
    "unsigned short",
    "unsigned short normalized"
  ],
  NORMAL: ["byte normalized", "short normalized"],
  TANGENT: ["byte normalized", "short normalized"],
  TEXCOORD: ["byte", "byte normalized", "unsigned byte", "short", "short normalized", "unsigned short"]
};
class Uo {
  constructor() {
    this.pluginCallbacks = [], this.register(function(e) {
      return new Eu(e);
    }), this.register(function(e) {
      return new Mu(e);
    }), this.register(function(e) {
      return new Pu(e);
    }), this.register(function(e) {
      return new Ru(e);
    }), this.register(function(e) {
      return new Cu(e);
    }), this.register(function(e) {
      return new Iu(e);
    }), this.register(function(e) {
      return new Su(e);
    }), this.register(function(e) {
      return new Au(e);
    }), this.register(function(e) {
      return new Ou(e);
    }), this.register(function(e) {
      return new Du(e);
    }), this.register(function(e) {
      return new Lu(e);
    });
  }
  register(e) {
    return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
  }
  unregister(e) {
    return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
  }
  /**
   * Parse scenes and generate GLTF output
   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes
   * @param  {Function} onDone  Callback on completed
   * @param  {Function} onError  Callback on errors
   * @param  {Object} options options
   */
  parse(e, t, n, s) {
    const i = new bu(), o = [];
    for (let a = 0, l = this.pluginCallbacks.length; a < l; a++)
      o.push(this.pluginCallbacks[a](i));
    i.setPlugins(o), i.write(e, t, s).catch(n);
  }
  parseAsync(e, t) {
    const n = this;
    return new Promise(function(s, i) {
      n.parse(e, s, i, t);
    });
  }
}
pu(Uo, "Utils", {
  insertKeyframe: function(r, e) {
    const n = r.getValueSize(), s = new r.TimeBufferType(r.times.length + 1), i = new r.ValueBufferType(r.values.length + n), o = r.createInterpolant(new r.ValueBufferType(n));
    let a;
    if (r.times.length === 0) {
      s[0] = e;
      for (let l = 0; l < n; l++)
        i[l] = 0;
      a = 0;
    } else if (e < r.times[0]) {
      if (Math.abs(r.times[0] - e) < 1e-3)
        return 0;
      s[0] = e, s.set(r.times, 1), i.set(o.evaluate(e), 0), i.set(r.values, n), a = 0;
    } else if (e > r.times[r.times.length - 1]) {
      if (Math.abs(r.times[r.times.length - 1] - e) < 1e-3)
        return r.times.length - 1;
      s[s.length - 1] = e, s.set(r.times, 0), i.set(r.values, 0), i.set(o.evaluate(e), r.values.length), a = s.length - 1;
    } else
      for (let l = 0; l < r.times.length; l++) {
        if (Math.abs(r.times[l] - e) < 1e-3)
          return l;
        if (r.times[l] < e && r.times[l + 1] > e) {
          s.set(r.times.slice(0, l + 1), 0), s[l + 1] = e, s.set(r.times.slice(l + 1), l + 2), i.set(r.values.slice(0, (l + 1) * n), 0), i.set(o.evaluate(e), (l + 1) * n), i.set(r.values.slice((l + 1) * n), (l + 2) * n), a = l + 1;
          break;
        }
      }
    return r.times = s, r.values = i, a;
  },
  mergeMorphTargetTracks: function(r, e) {
    const t = [], n = {}, s = r.tracks;
    for (let i = 0; i < s.length; ++i) {
      let o = s[i];
      const a = rn.parseTrackName(o.name), l = rn.findNode(e, a.nodeName);
      if (a.propertyName !== "morphTargetInfluences" || a.propertyIndex === void 0) {
        t.push(o);
        continue;
      }
      if (o.createInterpolant !== o.InterpolantFactoryMethodDiscrete && o.createInterpolant !== o.InterpolantFactoryMethodLinear) {
        if (o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)
          throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
        console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."), o = o.clone(), o.setInterpolation(Mo);
      }
      const c = l.morphTargetInfluences.length, f = l.morphTargetDictionary[a.propertyIndex];
      if (f === void 0)
        throw new Error("THREE.GLTFExporter: Morph target name not found: " + a.propertyIndex);
      let u;
      if (n[l.uuid] === void 0) {
        u = o.clone();
        const h = new u.ValueBufferType(c * u.times.length);
        for (let m = 0; m < u.times.length; m++)
          h[m * c + f] = u.values[m];
        u.name = (a.nodeName || "") + ".morphTargetInfluences", u.values = h, n[l.uuid] = u, t.push(u);
        continue;
      }
      const d = o.createInterpolant(new o.ValueBufferType(1));
      u = n[l.uuid];
      for (let h = 0; h < u.times.length; h++)
        u.values[h * c + f] = d.evaluate(u.times[h]);
      for (let h = 0; h < o.times.length; h++) {
        const m = this.insertKeyframe(u, o.times[h]);
        u.values[m * c + f] = o.values[h];
      }
    }
    return r.tracks = t, r;
  }
});
const De = {
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  BYTE: 5120,
  UNSIGNED_BYTE: 5121,
  SHORT: 5122,
  UNSIGNED_SHORT: 5123,
  INT: 5124,
  UNSIGNED_INT: 5125,
  FLOAT: 5126,
  ARRAY_BUFFER: 34962,
  ELEMENT_ARRAY_BUFFER: 34963,
  NEAREST: 9728,
  LINEAR: 9729,
  NEAREST_MIPMAP_NEAREST: 9984,
  LINEAR_MIPMAP_NEAREST: 9985,
  NEAREST_MIPMAP_LINEAR: 9986,
  LINEAR_MIPMAP_LINEAR: 9987,
  CLAMP_TO_EDGE: 33071,
  MIRRORED_REPEAT: 33648,
  REPEAT: 10497
}, Mi = "KHR_mesh_quantization", Tt = {};
Tt[Kn] = De.NEAREST;
Tt[da] = De.NEAREST_MIPMAP_NEAREST;
Tt[pa] = De.NEAREST_MIPMAP_LINEAR;
Tt[wt] = De.LINEAR;
Tt[ma] = De.LINEAR_MIPMAP_NEAREST;
Tt[Eo] = De.LINEAR_MIPMAP_LINEAR;
Tt[Wt] = De.CLAMP_TO_EDGE;
Tt[Ln] = De.REPEAT;
Tt[ga] = De.MIRRORED_REPEAT;
const sr = {
  scale: "scale",
  position: "translation",
  quaternion: "rotation",
  morphTargetInfluences: "weights"
}, mu = new be(), ir = 12, gu = 1179937895, vu = 2, or = 8, yu = 1313821514, _u = 5130562;
function vs(r, e) {
  return r.length === e.length && r.every(function(t, n) {
    return t === e[n];
  });
}
function xu(r) {
  return new TextEncoder().encode(r).buffer;
}
function wu(r) {
  return vs(r.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
}
function Tu(r, e, t) {
  const n = {
    min: new Array(r.itemSize).fill(Number.POSITIVE_INFINITY),
    max: new Array(r.itemSize).fill(Number.NEGATIVE_INFINITY)
  };
  for (let s = e; s < e + t; s++)
    for (let i = 0; i < r.itemSize; i++) {
      let o;
      r.itemSize > 4 ? o = r.array[s * r.itemSize + i] : (i === 0 ? o = r.getX(s) : i === 1 ? o = r.getY(s) : i === 2 ? o = r.getZ(s) : i === 3 && (o = r.getW(s)), r.normalized === !0 && (o = Ye.normalize(o, r.array))), n.min[i] = Math.min(n.min[i], o), n.max[i] = Math.max(n.max[i], o);
    }
  return n;
}
function Ba(r) {
  return Math.ceil(r / 4) * 4;
}
function Si(r, e = 0) {
  const t = Ba(r.byteLength);
  if (t !== r.byteLength) {
    const n = new Uint8Array(t);
    if (n.set(new Uint8Array(r)), e !== 0)
      for (let s = r.byteLength; s < t; s++)
        n[s] = e;
    return n.buffer;
  }
  return r;
}
function rr() {
  return typeof document > "u" && typeof OffscreenCanvas < "u" ? new OffscreenCanvas(1, 1) : document.createElement("canvas");
}
function ar(r, e) {
  if (r.toBlob !== void 0)
    return new Promise((n) => r.toBlob(n, e));
  let t;
  return e === "image/jpeg" ? t = 0.92 : e === "image/webp" && (t = 0.8), r.convertToBlob({
    type: e,
    quality: t
  });
}
class bu {
  constructor() {
    this.plugins = [], this.options = {}, this.pending = [], this.buffers = [], this.byteOffset = 0, this.buffers = [], this.nodeMap = /* @__PURE__ */ new Map(), this.skins = [], this.extensionsUsed = {}, this.extensionsRequired = {}, this.uids = /* @__PURE__ */ new Map(), this.uid = 0, this.json = {
      asset: {
        version: "2.0",
        generator: "THREE.GLTFExporter"
      }
    }, this.cache = {
      meshes: /* @__PURE__ */ new Map(),
      attributes: /* @__PURE__ */ new Map(),
      attributesNormalized: /* @__PURE__ */ new Map(),
      materials: /* @__PURE__ */ new Map(),
      textures: /* @__PURE__ */ new Map(),
      images: /* @__PURE__ */ new Map()
    };
  }
  setPlugins(e) {
    this.plugins = e;
  }
  /**
   * Parse scenes and generate GLTF output
   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes
   * @param  {Function} onDone  Callback on completed
   * @param  {Object} options options
   */
  async write(e, t, n = {}) {
    this.options = Object.assign(
      {
        // default options
        binary: !1,
        trs: !1,
        onlyVisible: !0,
        maxTextureSize: 1 / 0,
        animations: [],
        includeCustomExtensions: !1
      },
      n
    ), this.options.animations.length > 0 && (this.options.trs = !0), this.processInput(e), await Promise.all(this.pending);
    const s = this, i = s.buffers, o = s.json;
    n = s.options;
    const a = s.extensionsUsed, l = s.extensionsRequired, c = new Blob(i, { type: "application/octet-stream" }), f = Object.keys(a), u = Object.keys(l);
    f.length > 0 && (o.extensionsUsed = f), u.length > 0 && (o.extensionsRequired = u), o.buffers && o.buffers.length > 0 && (o.buffers[0].byteLength = c.size), n.binary === !0 ? c.arrayBuffer().then((d) => {
      const h = Si(d), m = new DataView(new ArrayBuffer(or));
      m.setUint32(0, h.byteLength, !0), m.setUint32(4, _u, !0);
      const g = Si(xu(JSON.stringify(o)), 32), v = new DataView(new ArrayBuffer(or));
      v.setUint32(0, g.byteLength, !0), v.setUint32(4, yu, !0);
      const p = new ArrayBuffer(ir), b = new DataView(p);
      b.setUint32(0, gu, !0), b.setUint32(4, vu, !0);
      const _ = ir + v.byteLength + g.byteLength + m.byteLength + h.byteLength;
      b.setUint32(8, _, !0), new Blob([p, v, g, m, h], {
        type: "application/octet-stream"
      }).arrayBuffer().then(t);
    }) : o.buffers && o.buffers.length > 0 ? tr(c).then((d) => {
      o.buffers[0].uri = d, t(o);
    }) : t(o);
  }
  /**
   * Serializes a userData.
   *
   * @param {THREE.Object3D|THREE.Material} object
   * @param {Object} objectDef
   */
  serializeUserData(e, t) {
    if (Object.keys(e.userData).length === 0)
      return;
    const n = this.options, s = this.extensionsUsed;
    try {
      const i = JSON.parse(JSON.stringify(e.userData));
      if (n.includeCustomExtensions && i.gltfExtensions) {
        t.extensions === void 0 && (t.extensions = {});
        for (const o in i.gltfExtensions)
          t.extensions[o] = i.gltfExtensions[o], s[o] = !0;
        delete i.gltfExtensions;
      }
      Object.keys(i).length > 0 && (t.extras = i);
    } catch (i) {
      console.warn(
        "THREE.GLTFExporter: userData of '" + e.name + "' won't be serialized because of JSON.stringify error - " + i.message
      );
    }
  }
  /**
   * Returns ids for buffer attributes.
   * @param  {Object} object
   * @return {Integer}
   */
  getUID(e, t = !1) {
    if (this.uids.has(e) === !1) {
      const s = /* @__PURE__ */ new Map();
      s.set(!0, this.uid++), s.set(!1, this.uid++), this.uids.set(e, s);
    }
    return this.uids.get(e).get(t);
  }
  /**
   * Checks if normal attribute values are normalized.
   *
   * @param {BufferAttribute} normal
   * @returns {Boolean}
   */
  isNormalizedNormalAttribute(e) {
    if (this.cache.attributesNormalized.has(e))
      return !1;
    const n = new $();
    for (let s = 0, i = e.count; s < i; s++)
      if (Math.abs(n.fromBufferAttribute(e, s).length() - 1) > 5e-4)
        return !1;
    return !0;
  }
  /**
   * Creates normalized normal buffer attribute.
   *
   * @param {BufferAttribute} normal
   * @returns {BufferAttribute}
   *
   */
  createNormalizedNormalAttribute(e) {
    const t = this.cache;
    if (t.attributesNormalized.has(e))
      return t.attributesNormalized.get(e);
    const n = e.clone(), s = new $();
    for (let i = 0, o = n.count; i < o; i++)
      s.fromBufferAttribute(n, i), s.x === 0 && s.y === 0 && s.z === 0 ? s.setX(1) : s.normalize(), n.setXYZ(i, s.x, s.y, s.z);
    return t.attributesNormalized.set(e, n), n;
  }
  /**
   * Applies a texture transform, if present, to the map definition. Requires
   * the KHR_texture_transform extension.
   *
   * @param {Object} mapDef
   * @param {THREE.Texture} texture
   */
  applyTextureTransform(e, t) {
    let n = !1;
    const s = {};
    (t.offset.x !== 0 || t.offset.y !== 0) && (s.offset = t.offset.toArray(), n = !0), t.rotation !== 0 && (s.rotation = t.rotation, n = !0), (t.repeat.x !== 1 || t.repeat.y !== 1) && (s.scale = t.repeat.toArray(), n = !0), n && (e.extensions = e.extensions || {}, e.extensions.KHR_texture_transform = s, this.extensionsUsed.KHR_texture_transform = !0);
  }
  buildMetalRoughTexture(e, t) {
    if (e === t)
      return e;
    function n(h) {
      return ("colorSpace" in h ? h.colorSpace === "srgb" : h.encoding === 3001) ? function(g) {
        return g < 0.04045 ? g * 0.0773993808 : Math.pow(g * 0.9478672986 + 0.0521327014, 2.4);
      } : function(g) {
        return g;
      };
    }
    console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures."), e instanceof mi && (e = Ei(e)), t instanceof mi && (t = Ei(t));
    const s = e ? e.image : null, i = t ? t.image : null, o = Math.max(s ? s.width : 0, i ? i.width : 0), a = Math.max(s ? s.height : 0, i ? i.height : 0), l = rr();
    l.width = o, l.height = a;
    const c = l.getContext("2d");
    c.fillStyle = "#00ffff", c.fillRect(0, 0, o, a);
    const f = c.getImageData(0, 0, o, a);
    if (s) {
      c.drawImage(s, 0, 0, o, a);
      const h = n(e), m = c.getImageData(0, 0, o, a).data;
      for (let g = 2; g < m.length; g += 4)
        f.data[g] = h(m[g] / 256) * 256;
    }
    if (i) {
      c.drawImage(i, 0, 0, o, a);
      const h = n(t), m = c.getImageData(0, 0, o, a).data;
      for (let g = 1; g < m.length; g += 4)
        f.data[g] = h(m[g] / 256) * 256;
    }
    c.putImageData(f, 0, 0);
    const d = (e || t).clone();
    return d.source = new es(l).source, "colorSpace" in d ? d.colorSpace = "" : d.encoding = 3e3, d.channel = (e || t).channel, e && t && e.channel !== t.channel && console.warn("THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match."), d;
  }
  /**
   * Process a buffer to append to the default one.
   * @param  {ArrayBuffer} buffer
   * @return {Integer}
   */
  processBuffer(e) {
    const t = this.json, n = this.buffers;
    return t.buffers || (t.buffers = [{ byteLength: 0 }]), n.push(e), 0;
  }
  /**
   * Process and generate a BufferView
   * @param  {BufferAttribute} attribute
   * @param  {number} componentType
   * @param  {number} start
   * @param  {number} count
   * @param  {number} target (Optional) Target usage of the BufferView
   * @return {Object}
   */
  processBufferView(e, t, n, s, i) {
    const o = this.json;
    o.bufferViews || (o.bufferViews = []);
    let a;
    switch (t) {
      case De.BYTE:
      case De.UNSIGNED_BYTE:
        a = 1;
        break;
      case De.SHORT:
      case De.UNSIGNED_SHORT:
        a = 2;
        break;
      default:
        a = 4;
    }
    const l = Ba(s * e.itemSize * a), c = new DataView(new ArrayBuffer(l));
    let f = 0;
    for (let h = n; h < n + s; h++)
      for (let m = 0; m < e.itemSize; m++) {
        let g;
        e.itemSize > 4 ? g = e.array[h * e.itemSize + m] : (m === 0 ? g = e.getX(h) : m === 1 ? g = e.getY(h) : m === 2 ? g = e.getZ(h) : m === 3 && (g = e.getW(h)), e.normalized === !0 && (g = Ye.normalize(g, e.array))), t === De.FLOAT ? c.setFloat32(f, g, !0) : t === De.INT ? c.setInt32(f, g, !0) : t === De.UNSIGNED_INT ? c.setUint32(f, g, !0) : t === De.SHORT ? c.setInt16(f, g, !0) : t === De.UNSIGNED_SHORT ? c.setUint16(f, g, !0) : t === De.BYTE ? c.setInt8(f, g) : t === De.UNSIGNED_BYTE && c.setUint8(f, g), f += a;
      }
    const u = {
      buffer: this.processBuffer(c.buffer),
      byteOffset: this.byteOffset,
      byteLength: l
    };
    return i !== void 0 && (u.target = i), i === De.ARRAY_BUFFER && (u.byteStride = e.itemSize * a), this.byteOffset += l, o.bufferViews.push(u), {
      id: o.bufferViews.length - 1,
      byteLength: 0
    };
  }
  /**
   * Process and generate a BufferView from an image Blob.
   * @param {Blob} blob
   * @return {Promise<Integer>}
   */
  processBufferViewImage(e) {
    const t = this, n = t.json;
    return n.bufferViews || (n.bufferViews = []), e.arrayBuffer().then((s) => {
      const i = Si(s), o = {
        buffer: t.processBuffer(i),
        byteOffset: t.byteOffset,
        byteLength: i.byteLength
      };
      return t.byteOffset += i.byteLength, n.bufferViews.push(o) - 1;
    });
  }
  /**
   * Process attribute to generate an accessor
   * @param  {BufferAttribute} attribute Attribute to process
   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range
   * @param  {Integer} start (Optional)
   * @param  {Integer} count (Optional)
   * @return {Integer|null} Index of the processed accessor on the "accessors" array
   */
  processAccessor(e, t, n, s) {
    const i = this.json, o = {
      1: "SCALAR",
      2: "VEC2",
      3: "VEC3",
      4: "VEC4",
      9: "MAT3",
      16: "MAT4"
    };
    let a;
    if (e.array.constructor === Float32Array)
      a = De.FLOAT;
    else if (e.array.constructor === Int32Array)
      a = De.INT;
    else if (e.array.constructor === Uint32Array)
      a = De.UNSIGNED_INT;
    else if (e.array.constructor === Int16Array)
      a = De.SHORT;
    else if (e.array.constructor === Uint16Array)
      a = De.UNSIGNED_SHORT;
    else if (e.array.constructor === Int8Array)
      a = De.BYTE;
    else if (e.array.constructor === Uint8Array)
      a = De.UNSIGNED_BYTE;
    else
      throw new Error(
        "THREE.GLTFExporter: Unsupported bufferAttribute component type: " + e.array.constructor.name
      );
    if (n === void 0 && (n = 0), s === void 0 && (s = e.count), s === 0)
      return null;
    const l = Tu(e, n, s);
    let c;
    t !== void 0 && (c = e === t.index ? De.ELEMENT_ARRAY_BUFFER : De.ARRAY_BUFFER);
    const f = this.processBufferView(e, a, n, s, c), u = {
      bufferView: f.id,
      byteOffset: f.byteOffset,
      componentType: a,
      count: s,
      max: l.max,
      min: l.min,
      type: o[e.itemSize]
    };
    return e.normalized === !0 && (u.normalized = !0), i.accessors || (i.accessors = []), i.accessors.push(u) - 1;
  }
  /**
   * Process image
   * @param  {Image} image to process
   * @param  {Integer} format of the image (RGBAFormat)
   * @param  {Boolean} flipY before writing out the image
   * @param  {String} mimeType export format
   * @return {Integer}     Index of the processed texture in the "images" array
   */
  processImage(e, t, n, s = "image/png") {
    if (e !== null) {
      const i = this, o = i.cache, a = i.json, l = i.options, c = i.pending;
      o.images.has(e) || o.images.set(e, {});
      const f = o.images.get(e), u = s + ":flipY/" + n.toString();
      if (f[u] !== void 0)
        return f[u];
      a.images || (a.images = []);
      const d = { mimeType: s }, h = rr();
      h.width = Math.min(e.width, l.maxTextureSize), h.height = Math.min(e.height, l.maxTextureSize);
      const m = h.getContext("2d");
      if (n === !0 && (m.translate(0, h.height), m.scale(1, -1)), e.data !== void 0) {
        t !== ei && console.error("GLTFExporter: Only RGBAFormat is supported.", t), (e.width > l.maxTextureSize || e.height > l.maxTextureSize) && console.warn("GLTFExporter: Image size is bigger than maxTextureSize", e);
        const v = new Uint8ClampedArray(e.height * e.width * 4);
        for (let p = 0; p < v.length; p += 4)
          v[p + 0] = e.data[p + 0], v[p + 1] = e.data[p + 1], v[p + 2] = e.data[p + 2], v[p + 3] = e.data[p + 3];
        m.putImageData(new ImageData(v, e.width, e.height), 0, 0);
      } else
        m.drawImage(e, 0, 0, h.width, h.height);
      l.binary === !0 ? c.push(
        ar(h, s).then((v) => i.processBufferViewImage(v)).then((v) => {
          d.bufferView = v;
        })
      ) : h.toDataURL !== void 0 ? d.uri = h.toDataURL(s) : c.push(
        ar(h, s).then(tr).then((v) => {
          d.uri = v;
        })
      );
      const g = a.images.push(d) - 1;
      return f[u] = g, g;
    } else
      throw new Error("THREE.GLTFExporter: No valid image data found. Unable to process texture.");
  }
  /**
   * Process sampler
   * @param  {Texture} map Texture to process
   * @return {Integer}     Index of the processed texture in the "samplers" array
   */
  processSampler(e) {
    const t = this.json;
    t.samplers || (t.samplers = []);
    const n = {
      magFilter: Tt[e.magFilter],
      minFilter: Tt[e.minFilter],
      wrapS: Tt[e.wrapS],
      wrapT: Tt[e.wrapT]
    };
    return t.samplers.push(n) - 1;
  }
  /**
   * Process texture
   * @param  {Texture} map Map to process
   * @return {Integer} Index of the processed texture in the "textures" array
   */
  processTexture(e) {
    const n = this.options, s = this.cache, i = this.json;
    if (s.textures.has(e))
      return s.textures.get(e);
    i.textures || (i.textures = []), e instanceof mi && (e = Ei(e, n.maxTextureSize));
    let o = e.userData.mimeType;
    o === "image/webp" && (o = "image/png");
    const a = {
      sampler: this.processSampler(e),
      source: this.processImage(e.image, e.format, e.flipY, o)
    };
    e.name && (a.name = e.name), this._invokeAll(function(c) {
      c.writeTexture && c.writeTexture(e, a);
    });
    const l = i.textures.push(a) - 1;
    return s.textures.set(e, l), l;
  }
  /**
   * Process material
   * @param  {THREE.Material} material Material to process
   * @return {Integer|null} Index of the processed material in the "materials" array
   */
  processMaterial(e) {
    const t = this.cache, n = this.json;
    if (t.materials.has(e))
      return t.materials.get(e);
    if (e.isShaderMaterial)
      return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."), null;
    n.materials || (n.materials = []);
    const s = { pbrMetallicRoughness: {} };
    e.isMeshStandardMaterial !== !0 && e.isMeshBasicMaterial !== !0 && console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");
    const i = e.color.toArray().concat([e.opacity]);
    if (vs(i, [1, 1, 1, 1]) || (s.pbrMetallicRoughness.baseColorFactor = i), e.isMeshStandardMaterial ? (s.pbrMetallicRoughness.metallicFactor = e.metalness, s.pbrMetallicRoughness.roughnessFactor = e.roughness) : (s.pbrMetallicRoughness.metallicFactor = 0.5, s.pbrMetallicRoughness.roughnessFactor = 0.5), e.metalnessMap || e.roughnessMap) {
      const a = this.buildMetalRoughTexture(e.metalnessMap, e.roughnessMap), l = {
        index: this.processTexture(a),
        channel: a.channel
      };
      this.applyTextureTransform(l, a), s.pbrMetallicRoughness.metallicRoughnessTexture = l;
    }
    if (e.map) {
      const a = {
        index: this.processTexture(e.map),
        texCoord: e.map.channel
      };
      this.applyTextureTransform(a, e.map), s.pbrMetallicRoughness.baseColorTexture = a;
    }
    if (e.emissive) {
      const a = e.emissive;
      if (Math.max(a.r, a.g, a.b) > 0 && (s.emissiveFactor = e.emissive.toArray()), e.emissiveMap) {
        const c = {
          index: this.processTexture(e.emissiveMap),
          texCoord: e.emissiveMap.channel
        };
        this.applyTextureTransform(c, e.emissiveMap), s.emissiveTexture = c;
      }
    }
    if (e.normalMap) {
      const a = {
        index: this.processTexture(e.normalMap),
        texCoord: e.normalMap.channel
      };
      e.normalScale && e.normalScale.x !== 1 && (a.scale = e.normalScale.x), this.applyTextureTransform(a, e.normalMap), s.normalTexture = a;
    }
    if (e.aoMap) {
      const a = {
        index: this.processTexture(e.aoMap),
        texCoord: e.aoMap.channel
      };
      e.aoMapIntensity !== 1 && (a.strength = e.aoMapIntensity), this.applyTextureTransform(a, e.aoMap), s.occlusionTexture = a;
    }
    e.transparent ? s.alphaMode = "BLEND" : e.alphaTest > 0 && (s.alphaMode = "MASK", s.alphaCutoff = e.alphaTest), e.side === on && (s.doubleSided = !0), e.name !== "" && (s.name = e.name), this.serializeUserData(e, s), this._invokeAll(function(a) {
      a.writeMaterial && a.writeMaterial(e, s);
    });
    const o = n.materials.push(s) - 1;
    return t.materials.set(e, o), o;
  }
  /**
   * Process mesh
   * @param  {THREE.Mesh} mesh Mesh to process
   * @return {Integer|null} Index of the processed mesh in the "meshes" array
   */
  processMesh(e) {
    const t = this.cache, n = this.json, s = [e.geometry.uuid];
    if (Array.isArray(e.material))
      for (let _ = 0, M = e.material.length; _ < M; _++)
        s.push(e.material[_].uuid);
    else
      s.push(e.material.uuid);
    const i = s.join(":");
    if (t.meshes.has(i))
      return t.meshes.get(i);
    const o = e.geometry;
    let a;
    e.isLineSegments ? a = De.LINES : e.isLineLoop ? a = De.LINE_LOOP : e.isLine ? a = De.LINE_STRIP : e.isPoints ? a = De.POINTS : a = e.material.wireframe ? De.LINES : De.TRIANGLES;
    const l = {}, c = {}, f = [], u = [], d = {
      ...Ss >= 152 ? {
        uv: "TEXCOORD_0",
        uv1: "TEXCOORD_1",
        uv2: "TEXCOORD_2",
        uv3: "TEXCOORD_3"
      } : {
        uv: "TEXCOORD_0",
        uv2: "TEXCOORD_1"
      },
      color: "COLOR_0",
      skinWeight: "WEIGHTS_0",
      skinIndex: "JOINTS_0"
    }, h = o.getAttribute("normal");
    h !== void 0 && !this.isNormalizedNormalAttribute(h) && (console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."), o.setAttribute("normal", this.createNormalizedNormalAttribute(h)));
    let m = null;
    for (let _ in o.attributes) {
      if (_.slice(0, 5) === "morph")
        continue;
      const M = o.attributes[_];
      if (_ = d[_] || _.toUpperCase(), /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(_) || (_ = "_" + _), t.attributes.has(this.getUID(M))) {
        c[_] = t.attributes.get(this.getUID(M));
        continue;
      }
      m = null;
      const w = M.array;
      _ === "JOINTS_0" && !(w instanceof Uint16Array) && !(w instanceof Uint8Array) && (console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'), m = new ut(new Uint16Array(w), M.itemSize, M.normalized));
      const E = this.processAccessor(m || M, o);
      E !== null && (_.startsWith("_") || this.detectMeshQuantization(_, M), c[_] = E, t.attributes.set(this.getUID(M), E));
    }
    if (h !== void 0 && o.setAttribute("normal", h), Object.keys(c).length === 0)
      return null;
    if (e.morphTargetInfluences !== void 0 && e.morphTargetInfluences.length > 0) {
      const _ = [], M = [], R = {};
      if (e.morphTargetDictionary !== void 0)
        for (const w in e.morphTargetDictionary)
          R[e.morphTargetDictionary[w]] = w;
      for (let w = 0; w < e.morphTargetInfluences.length; ++w) {
        const E = {};
        let x = !1;
        for (const T in o.morphAttributes) {
          if (T !== "position" && T !== "normal") {
            x || (console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."), x = !0);
            continue;
          }
          const y = o.morphAttributes[T][w], A = T.toUpperCase(), C = o.attributes[T];
          if (t.attributes.has(this.getUID(y, !0))) {
            E[A] = t.attributes.get(this.getUID(y, !0));
            continue;
          }
          const N = y.clone();
          if (!o.morphTargetsRelative)
            for (let U = 0, Y = y.count; U < Y; U++)
              for (let V = 0; V < y.itemSize; V++)
                V === 0 && N.setX(U, y.getX(U) - C.getX(U)), V === 1 && N.setY(U, y.getY(U) - C.getY(U)), V === 2 && N.setZ(U, y.getZ(U) - C.getZ(U)), V === 3 && N.setW(U, y.getW(U) - C.getW(U));
          E[A] = this.processAccessor(N, o), t.attributes.set(this.getUID(C, !0), E[A]);
        }
        u.push(E), _.push(e.morphTargetInfluences[w]), e.morphTargetDictionary !== void 0 && M.push(R[w]);
      }
      l.weights = _, M.length > 0 && (l.extras = {}, l.extras.targetNames = M);
    }
    const g = Array.isArray(e.material);
    if (g && o.groups.length === 0)
      return null;
    const v = g ? e.material : [e.material], p = g ? o.groups : [{ materialIndex: 0, start: void 0, count: void 0 }];
    for (let _ = 0, M = p.length; _ < M; _++) {
      const R = {
        mode: a,
        attributes: c
      };
      if (this.serializeUserData(o, R), u.length > 0 && (R.targets = u), o.index !== null) {
        let E = this.getUID(o.index);
        (p[_].start !== void 0 || p[_].count !== void 0) && (E += ":" + p[_].start + ":" + p[_].count), t.attributes.has(E) ? R.indices = t.attributes.get(E) : (R.indices = this.processAccessor(o.index, o, p[_].start, p[_].count), t.attributes.set(E, R.indices)), R.indices === null && delete R.indices;
      }
      const w = this.processMaterial(v[p[_].materialIndex]);
      w !== null && (R.material = w), f.push(R);
    }
    l.primitives = f, n.meshes || (n.meshes = []), this._invokeAll(function(_) {
      _.writeMesh && _.writeMesh(e, l);
    });
    const b = n.meshes.push(l) - 1;
    return t.meshes.set(i, b), b;
  }
  /**
   * If a vertex attribute with a
   * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)
   * is used, it is checked whether it is a valid data type according to the
   * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)
   * extension.
   * In this case the extension is automatically added to the list of used extensions.
   *
   * @param {string} attributeName
   * @param {THREE.BufferAttribute} attribute
   */
  detectMeshQuantization(e, t) {
    if (this.extensionsUsed[Mi])
      return;
    let n;
    switch (t.array.constructor) {
      case Int8Array:
        n = "byte";
        break;
      case Uint8Array:
        n = "unsigned byte";
        break;
      case Int16Array:
        n = "short";
        break;
      case Uint16Array:
        n = "unsigned short";
        break;
      default:
        return;
    }
    t.normalized && (n += " normalized");
    const s = e.split("_", 1)[0];
    nr[s] && nr[s].includes(n) && (this.extensionsUsed[Mi] = !0, this.extensionsRequired[Mi] = !0);
  }
  /**
   * Process camera
   * @param  {THREE.Camera} camera Camera to process
   * @return {Integer}      Index of the processed mesh in the "camera" array
   */
  processCamera(e) {
    const t = this.json;
    t.cameras || (t.cameras = []);
    const n = e.isOrthographicCamera, s = {
      type: n ? "orthographic" : "perspective"
    };
    return n ? s.orthographic = {
      xmag: e.right * 2,
      ymag: e.top * 2,
      zfar: e.far <= 0 ? 1e-3 : e.far,
      znear: e.near < 0 ? 0 : e.near
    } : s.perspective = {
      aspectRatio: e.aspect,
      yfov: Ye.degToRad(e.fov),
      zfar: e.far <= 0 ? 1e-3 : e.far,
      znear: e.near < 0 ? 0 : e.near
    }, e.name !== "" && (s.name = e.type), t.cameras.push(s) - 1;
  }
  /**
   * Creates glTF animation entry from AnimationClip object.
   *
   * Status:
   * - Only properties listed in PATH_PROPERTIES may be animated.
   *
   * @param {THREE.AnimationClip} clip
   * @param {THREE.Object3D} root
   * @return {number|null}
   */
  processAnimation(e, t) {
    const n = this.json, s = this.nodeMap;
    n.animations || (n.animations = []), e = Uo.Utils.mergeMorphTargetTracks(e.clone(), t);
    const i = e.tracks, o = [], a = [];
    for (let l = 0; l < i.length; ++l) {
      const c = i[l], f = rn.parseTrackName(c.name);
      let u = rn.findNode(t, f.nodeName);
      const d = sr[f.propertyName];
      if (f.objectName === "bones" && (u.isSkinnedMesh === !0 ? u = u.skeleton.getBoneByName(f.objectIndex) : u = void 0), !u || !d)
        return console.warn('THREE.GLTFExporter: Could not export animation track "%s".', c.name), null;
      const h = 1;
      let m = c.values.length / c.times.length;
      d === sr.morphTargetInfluences && (m /= u.morphTargetInfluences.length);
      let g;
      c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === !0 ? (g = "CUBICSPLINE", m /= 3) : c.getInterpolation() === fa ? g = "STEP" : g = "LINEAR", a.push({
        input: this.processAccessor(new ut(c.times, h)),
        output: this.processAccessor(new ut(c.values, m)),
        interpolation: g
      }), o.push({
        sampler: a.length - 1,
        target: {
          node: s.get(u),
          path: d
        }
      });
    }
    return n.animations.push({
      name: e.name || "clip_" + n.animations.length,
      samplers: a,
      channels: o
    }), n.animations.length - 1;
  }
  /**
   * @param {THREE.Object3D} object
   * @return {number|null}
   */
  processSkin(e) {
    const t = this.json, n = this.nodeMap, s = t.nodes[n.get(e)], i = e.skeleton;
    if (i === void 0)
      return null;
    const o = e.skeleton.bones[0];
    if (o === void 0)
      return null;
    const a = [], l = new Float32Array(i.bones.length * 16), c = new Ie();
    for (let u = 0; u < i.bones.length; ++u)
      a.push(n.get(i.bones[u])), c.copy(i.boneInverses[u]), c.multiply(e.bindMatrix).toArray(l, u * 16);
    return t.skins === void 0 && (t.skins = []), t.skins.push({
      inverseBindMatrices: this.processAccessor(new ut(l, 16)),
      joints: a,
      skeleton: n.get(o)
    }), s.skin = t.skins.length - 1;
  }
  /**
   * Process Object3D node
   * @param  {THREE.Object3D} node Object3D to processNode
   * @return {Integer} Index of the node in the nodes list
   */
  processNode(e) {
    const t = this.json, n = this.options, s = this.nodeMap;
    t.nodes || (t.nodes = []);
    const i = {};
    if (n.trs) {
      const a = e.quaternion.toArray(), l = e.position.toArray(), c = e.scale.toArray();
      vs(a, [0, 0, 0, 1]) || (i.rotation = a), vs(l, [0, 0, 0]) || (i.translation = l), vs(c, [1, 1, 1]) || (i.scale = c);
    } else
      e.matrixAutoUpdate && e.updateMatrix(), wu(e.matrix) === !1 && (i.matrix = e.matrix.elements);
    if (e.name !== "" && (i.name = String(e.name)), this.serializeUserData(e, i), e.isMesh || e.isLine || e.isPoints) {
      const a = this.processMesh(e);
      a !== null && (i.mesh = a);
    } else e.isCamera && (i.camera = this.processCamera(e));
    if (e.isSkinnedMesh && this.skins.push(e), e.children.length > 0) {
      const a = [];
      for (let l = 0, c = e.children.length; l < c; l++) {
        const f = e.children[l];
        if (f.visible || n.onlyVisible === !1) {
          const u = this.processNode(f);
          u !== null && a.push(u);
        }
      }
      a.length > 0 && (i.children = a);
    }
    this._invokeAll(function(a) {
      a.writeNode && a.writeNode(e, i);
    });
    const o = t.nodes.push(i) - 1;
    return s.set(e, o), o;
  }
  /**
   * Process Scene
   * @param  {Scene} node Scene to process
   */
  processScene(e) {
    const t = this.json, n = this.options;
    t.scenes || (t.scenes = [], t.scene = 0);
    const s = {};
    e.name !== "" && (s.name = e.name), t.scenes.push(s);
    const i = [];
    for (let o = 0, a = e.children.length; o < a; o++) {
      const l = e.children[o];
      if (l.visible || n.onlyVisible === !1) {
        const c = this.processNode(l);
        c !== null && i.push(c);
      }
    }
    i.length > 0 && (s.nodes = i), this.serializeUserData(e, s);
  }
  /**
   * Creates a Scene to hold a list of objects and parse it
   * @param  {Array} objects List of objects to process
   */
  processObjects(e) {
    const t = new xs();
    t.name = "AuxScene";
    for (let n = 0; n < e.length; n++)
      t.children.push(e[n]);
    this.processScene(t);
  }
  /**
   * @param {THREE.Object3D|Array<THREE.Object3D>} input
   */
  processInput(e) {
    const t = this.options;
    e = e instanceof Array ? e : [e], this._invokeAll(function(s) {
      s.beforeParse && s.beforeParse(e);
    });
    const n = [];
    for (let s = 0; s < e.length; s++)
      e[s] instanceof xs ? this.processScene(e[s]) : n.push(e[s]);
    n.length > 0 && this.processObjects(n);
    for (let s = 0; s < this.skins.length; ++s)
      this.processSkin(this.skins[s]);
    for (let s = 0; s < t.animations.length; ++s)
      this.processAnimation(t.animations[s], e[0]);
    this._invokeAll(function(s) {
      s.afterParse && s.afterParse(e);
    });
  }
  _invokeAll(e) {
    for (let t = 0, n = this.plugins.length; t < n; t++)
      e(this.plugins[t]);
  }
}
class Eu {
  constructor(e) {
    this.writer = e, this.name = "KHR_lights_punctual";
  }
  writeNode(e, t) {
    if (!e.isLight)
      return;
    if (!e.isDirectionalLight && !e.isPointLight && !e.isSpotLight) {
      console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", e);
      return;
    }
    const n = this.writer, s = n.json, i = n.extensionsUsed, o = {};
    e.name && (o.name = e.name), o.color = e.color.toArray(), o.intensity = e.intensity, e.isDirectionalLight ? o.type = "directional" : e.isPointLight ? (o.type = "point", e.distance > 0 && (o.range = e.distance)) : e.isSpotLight && (o.type = "spot", e.distance > 0 && (o.range = e.distance), o.spot = {}, o.spot.innerConeAngle = (e.penumbra - 1) * e.angle * -1, o.spot.outerConeAngle = e.angle), e.decay !== void 0 && e.decay !== 2 && console.warn(
      "THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."
    ), e.target && (e.target.parent !== e || e.target.position.x !== 0 || e.target.position.y !== 0 || e.target.position.z !== -1) && console.warn(
      "THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."
    ), i[this.name] || (s.extensions = s.extensions || {}, s.extensions[this.name] = { lights: [] }, i[this.name] = !0);
    const a = s.extensions[this.name].lights;
    a.push(o), t.extensions = t.extensions || {}, t.extensions[this.name] = { light: a.length - 1 };
  }
}
let Mu = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_unlit";
  }
  writeMaterial(e, t) {
    if (!e.isMeshBasicMaterial)
      return;
    const s = this.writer.extensionsUsed;
    t.extensions = t.extensions || {}, t.extensions[this.name] = {}, s[this.name] = !0, t.pbrMetallicRoughness.metallicFactor = 0, t.pbrMetallicRoughness.roughnessFactor = 0.9;
  }
}, Su = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_clearcoat";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.clearcoat === 0)
      return;
    const n = this.writer, s = n.extensionsUsed, i = {};
    if (i.clearcoatFactor = e.clearcoat, e.clearcoatMap) {
      const o = {
        index: n.processTexture(e.clearcoatMap),
        texCoord: e.clearcoatMap.channel
      };
      n.applyTextureTransform(o, e.clearcoatMap), i.clearcoatTexture = o;
    }
    if (i.clearcoatRoughnessFactor = e.clearcoatRoughness, e.clearcoatRoughnessMap) {
      const o = {
        index: n.processTexture(e.clearcoatRoughnessMap),
        texCoord: e.clearcoatRoughnessMap.channel
      };
      n.applyTextureTransform(o, e.clearcoatRoughnessMap), i.clearcoatRoughnessTexture = o;
    }
    if (e.clearcoatNormalMap) {
      const o = {
        index: n.processTexture(e.clearcoatNormalMap),
        texCoord: e.clearcoatNormalMap.channel
      };
      n.applyTextureTransform(o, e.clearcoatNormalMap), i.clearcoatNormalTexture = o;
    }
    t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
  }
}, Au = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_iridescence";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.iridescence === 0)
      return;
    const n = this.writer, s = n.extensionsUsed, i = {};
    if (i.iridescenceFactor = e.iridescence, e.iridescenceMap) {
      const o = {
        index: n.processTexture(e.iridescenceMap),
        texCoord: e.iridescenceMap.channel
      };
      n.applyTextureTransform(o, e.iridescenceMap), i.iridescenceTexture = o;
    }
    if (i.iridescenceIor = e.iridescenceIOR, i.iridescenceThicknessMinimum = e.iridescenceThicknessRange[0], i.iridescenceThicknessMaximum = e.iridescenceThicknessRange[1], e.iridescenceThicknessMap) {
      const o = {
        index: n.processTexture(e.iridescenceThicknessMap),
        texCoord: e.iridescenceThicknessMap.channel
      };
      n.applyTextureTransform(o, e.iridescenceThicknessMap), i.iridescenceThicknessTexture = o;
    }
    t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
  }
}, Pu = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_transmission";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.transmission === 0)
      return;
    const n = this.writer, s = n.extensionsUsed, i = {};
    if (i.transmissionFactor = e.transmission, e.transmissionMap) {
      const o = {
        index: n.processTexture(e.transmissionMap),
        texCoord: e.transmissionMap.channel
      };
      n.applyTextureTransform(o, e.transmissionMap), i.transmissionTexture = o;
    }
    t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
  }
}, Ru = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_volume";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.transmission === 0)
      return;
    const n = this.writer, s = n.extensionsUsed, i = {};
    if (i.thicknessFactor = e.thickness, e.thicknessMap) {
      const o = {
        index: n.processTexture(e.thicknessMap),
        texCoord: e.thicknessMap.channel
      };
      n.applyTextureTransform(o, e.thicknessMap), i.thicknessTexture = o;
    }
    i.attenuationDistance = e.attenuationDistance, i.attenuationColor = e.attenuationColor.toArray(), t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
  }
}, Cu = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_ior";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.ior === 1.5)
      return;
    const s = this.writer.extensionsUsed, i = {};
    i.ior = e.ior, t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
  }
}, Iu = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_specular";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.specularIntensity === 1 && e.specularColor.equals(mu) && !e.specularIntensityMap && !e.specularColorTexture)
      return;
    const n = this.writer, s = n.extensionsUsed, i = {};
    if (e.specularIntensityMap) {
      const o = {
        index: n.processTexture(e.specularIntensityMap),
        texCoord: e.specularIntensityMap.channel
      };
      n.applyTextureTransform(o, e.specularIntensityMap), i.specularTexture = o;
    }
    if (e.specularColorMap) {
      const o = {
        index: n.processTexture(e.specularColorMap),
        texCoord: e.specularColorMap.channel
      };
      n.applyTextureTransform(o, e.specularColorMap), i.specularColorTexture = o;
    }
    i.specularFactor = e.specularIntensity, i.specularColorFactor = e.specularColor.toArray(), t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
  }
}, Ou = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_sheen";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.sheen == 0)
      return;
    const n = this.writer, s = n.extensionsUsed, i = {};
    if (e.sheenRoughnessMap) {
      const o = {
        index: n.processTexture(e.sheenRoughnessMap),
        texCoord: e.sheenRoughnessMap.channel
      };
      n.applyTextureTransform(o, e.sheenRoughnessMap), i.sheenRoughnessTexture = o;
    }
    if (e.sheenColorMap) {
      const o = {
        index: n.processTexture(e.sheenColorMap),
        texCoord: e.sheenColorMap.channel
      };
      n.applyTextureTransform(o, e.sheenColorMap), i.sheenColorTexture = o;
    }
    i.sheenRoughnessFactor = e.sheenRoughness, i.sheenColorFactor = e.sheenColor.toArray(), t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
  }
}, Du = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_anisotropy";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.anisotropy == 0)
      return;
    const n = this.writer, s = n.extensionsUsed, i = {};
    if (e.anisotropyMap) {
      const o = { index: n.processTexture(e.anisotropyMap) };
      n.applyTextureTransform(o, e.anisotropyMap), i.anisotropyTexture = o;
    }
    i.anisotropyStrength = e.anisotropy, i.anisotropyRotation = e.anisotropyRotation, t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
  }
}, Lu = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_emissive_strength";
  }
  writeMaterial(e, t) {
    if (!e.isMeshStandardMaterial || e.emissiveIntensity === 1)
      return;
    const s = this.writer.extensionsUsed, i = {};
    i.emissiveStrength = e.emissiveIntensity, t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
  }
};
var Pt = Uint8Array, vn = Uint16Array, mo = Uint32Array, Ua = new Pt([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), Fa = new Pt([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), ku = new Pt([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), za = function(r, e) {
  for (var t = new vn(31), n = 0; n < 31; ++n)
    t[n] = e += 1 << r[n - 1];
  for (var s = new mo(t[30]), n = 1; n < 30; ++n)
    for (var i = t[n]; i < t[n + 1]; ++i)
      s[i] = i - t[n] << 5 | n;
  return [t, s];
}, Ga = za(Ua, 2), Ha = Ga[0], Nu = Ga[1];
Ha[28] = 258, Nu[258] = 28;
var Bu = za(Fa, 0), Uu = Bu[0], go = new vn(32768);
for (var Ze = 0; Ze < 32768; ++Ze) {
  var fn = (Ze & 43690) >>> 1 | (Ze & 21845) << 1;
  fn = (fn & 52428) >>> 2 | (fn & 13107) << 2, fn = (fn & 61680) >>> 4 | (fn & 3855) << 4, go[Ze] = ((fn & 65280) >>> 8 | (fn & 255) << 8) >>> 1;
}
var ys = function(r, e, t) {
  for (var n = r.length, s = 0, i = new vn(e); s < n; ++s)
    ++i[r[s] - 1];
  var o = new vn(e);
  for (s = 0; s < e; ++s)
    o[s] = o[s - 1] + i[s - 1] << 1;
  var a;
  if (t) {
    a = new vn(1 << e);
    var l = 15 - e;
    for (s = 0; s < n; ++s)
      if (r[s])
        for (var c = s << 4 | r[s], f = e - r[s], u = o[r[s] - 1]++ << f, d = u | (1 << f) - 1; u <= d; ++u)
          a[go[u] >>> l] = c;
  } else
    for (a = new vn(n), s = 0; s < n; ++s)
      r[s] && (a[s] = go[o[r[s] - 1]++] >>> 15 - r[s]);
  return a;
}, As = new Pt(288);
for (var Ze = 0; Ze < 144; ++Ze)
  As[Ze] = 8;
for (var Ze = 144; Ze < 256; ++Ze)
  As[Ze] = 9;
for (var Ze = 256; Ze < 280; ++Ze)
  As[Ze] = 7;
for (var Ze = 280; Ze < 288; ++Ze)
  As[Ze] = 8;
var ja = new Pt(32);
for (var Ze = 0; Ze < 32; ++Ze)
  ja[Ze] = 5;
var Fu = /* @__PURE__ */ ys(As, 9, 1), zu = /* @__PURE__ */ ys(ja, 5, 1), Ai = function(r) {
  for (var e = r[0], t = 1; t < r.length; ++t)
    r[t] > e && (e = r[t]);
  return e;
}, It = function(r, e, t) {
  var n = e / 8 | 0;
  return (r[n] | r[n + 1] << 8) >> (e & 7) & t;
}, Pi = function(r, e) {
  var t = e / 8 | 0;
  return (r[t] | r[t + 1] << 8 | r[t + 2] << 16) >> (e & 7);
}, Gu = function(r) {
  return (r / 8 | 0) + (r & 7 && 1);
}, Hu = function(r, e, t) {
  (t == null || t > r.length) && (t = r.length);
  var n = new (r instanceof vn ? vn : r instanceof mo ? mo : Pt)(t - e);
  return n.set(r.subarray(e, t)), n;
}, ju = function(r, e, t) {
  var n = r.length;
  if (!n || t && !t.l && n < 5)
    return e || new Pt(0);
  var s = !e || t, i = !t || t.i;
  t || (t = {}), e || (e = new Pt(n * 3));
  var o = function(D) {
    var O = e.length;
    if (D > O) {
      var z = new Pt(Math.max(O * 2, D));
      z.set(e), e = z;
    }
  }, a = t.f || 0, l = t.p || 0, c = t.b || 0, f = t.l, u = t.d, d = t.m, h = t.n, m = n * 8;
  do {
    if (!f) {
      t.f = a = It(r, l, 1);
      var g = It(r, l + 1, 3);
      if (l += 3, g)
        if (g == 1)
          f = Fu, u = zu, d = 9, h = 5;
        else if (g == 2) {
          var _ = It(r, l, 31) + 257, M = It(r, l + 10, 15) + 4, R = _ + It(r, l + 5, 31) + 1;
          l += 14;
          for (var w = new Pt(R), E = new Pt(19), x = 0; x < M; ++x)
            E[ku[x]] = It(r, l + x * 3, 7);
          l += M * 3;
          for (var T = Ai(E), y = (1 << T) - 1, A = ys(E, T, 1), x = 0; x < R; ) {
            var C = A[It(r, l, y)];
            l += C & 15;
            var v = C >>> 4;
            if (v < 16)
              w[x++] = v;
            else {
              var N = 0, U = 0;
              for (v == 16 ? (U = 3 + It(r, l, 3), l += 2, N = w[x - 1]) : v == 17 ? (U = 3 + It(r, l, 7), l += 3) : v == 18 && (U = 11 + It(r, l, 127), l += 7); U--; )
                w[x++] = N;
            }
          }
          var Y = w.subarray(0, _), V = w.subarray(_);
          d = Ai(Y), h = Ai(V), f = ys(Y, d, 1), u = ys(V, h, 1);
        } else
          throw "invalid block type";
      else {
        var v = Gu(l) + 4, p = r[v - 4] | r[v - 3] << 8, b = v + p;
        if (b > n) {
          if (i)
            throw "unexpected EOF";
          break;
        }
        s && o(c + p), e.set(r.subarray(v, b), c), t.b = c += p, t.p = l = b * 8;
        continue;
      }
      if (l > m) {
        if (i)
          throw "unexpected EOF";
        break;
      }
    }
    s && o(c + 131072);
    for (var ne = (1 << d) - 1, Z = (1 << h) - 1, ee = l; ; ee = l) {
      var N = f[Pi(r, l) & ne], te = N >>> 4;
      if (l += N & 15, l > m) {
        if (i)
          throw "unexpected EOF";
        break;
      }
      if (!N)
        throw "invalid length/literal";
      if (te < 256)
        e[c++] = te;
      else if (te == 256) {
        ee = l, f = null;
        break;
      } else {
        var fe = te - 254;
        if (te > 264) {
          var x = te - 257, he = Ua[x];
          fe = It(r, l, (1 << he) - 1) + Ha[x], l += he;
        }
        var we = u[Pi(r, l) & Z], I = we >>> 4;
        if (!we)
          throw "invalid distance";
        l += we & 15;
        var V = Uu[I];
        if (I > 3) {
          var he = Fa[I];
          V += Pi(r, l) & (1 << he) - 1, l += he;
        }
        if (l > m) {
          if (i)
            throw "unexpected EOF";
          break;
        }
        s && o(c + 131072);
        for (var B = c + fe; c < B; c += 4)
          e[c] = e[c - V], e[c + 1] = e[c + 1 - V], e[c + 2] = e[c + 2 - V], e[c + 3] = e[c + 3 - V];
        c = B;
      }
    }
    t.l = f, t.p = ee, t.b = c, f && (a = 1, t.m = d, t.d = u, t.n = h);
  } while (!a);
  return c == e.length ? e : Hu(e, 0, c);
}, Vu = /* @__PURE__ */ new Pt(0), Yu = function(r) {
  if ((r[0] & 15) != 8 || r[0] >>> 4 > 7 || (r[0] << 8 | r[1]) % 31)
    throw "invalid zlib data";
  if (r[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function Wu(r, e) {
  return ju((Yu(r), r.subarray(2, -4)), e);
}
var Xu = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), $u = 0;
try {
  Xu.decode(Vu, { stream: !0 }), $u = 1;
} catch {
}
var Zu = Object.defineProperty, Ku = (r, e, t) => e in r ? Zu(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, qu = (r, e, t) => (Ku(r, e + "", t), t);
const Va = class extends de {
  constructor(r, e = {}) {
    super(r), this.isReflector = !0, this.type = "Reflector", this.camera = new kt();
    const t = this, n = e.color !== void 0 ? new be(e.color) : new be(8355711), s = e.textureWidth || 512, i = e.textureHeight || 512, o = e.clipBias || 0, a = e.shader || Va.ReflectorShader, l = e.multisample !== void 0 ? e.multisample : 4, c = new bs(), f = new $(), u = new $(), d = new $(), h = new Ie(), m = new $(0, 0, -1), g = new at(), v = new $(), p = new $(), b = new at(), _ = new Ie(), M = this.camera, R = new Xt(s, i, {
      samples: l,
      type: Lt
    }), w = new bt({
      uniforms: Dn.clone(a.uniforms),
      fragmentShader: a.fragmentShader,
      vertexShader: a.vertexShader
    });
    w.uniforms.tDiffuse.value = R.texture, w.uniforms.color.value = n, w.uniforms.textureMatrix.value = _, this.material = w, this.onBeforeRender = function(E, x, T) {
      if (u.setFromMatrixPosition(t.matrixWorld), d.setFromMatrixPosition(T.matrixWorld), h.extractRotation(t.matrixWorld), f.set(0, 0, 1), f.applyMatrix4(h), v.subVectors(u, d), v.dot(f) > 0)
        return;
      v.reflect(f).negate(), v.add(u), h.extractRotation(T.matrixWorld), m.set(0, 0, -1), m.applyMatrix4(h), m.add(d), p.subVectors(u, m), p.reflect(f).negate(), p.add(u), M.position.copy(v), M.up.set(0, 1, 0), M.up.applyMatrix4(h), M.up.reflect(f), M.lookAt(p), M.far = T.far, M.updateMatrixWorld(), M.projectionMatrix.copy(T.projectionMatrix), _.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), _.multiply(M.projectionMatrix), _.multiply(M.matrixWorldInverse), _.multiply(t.matrixWorld), c.setFromNormalAndCoplanarPoint(f, u), c.applyMatrix4(M.matrixWorldInverse), g.set(c.normal.x, c.normal.y, c.normal.z, c.constant);
      const y = M.projectionMatrix;
      b.x = (Math.sign(g.x) + y.elements[8]) / y.elements[0], b.y = (Math.sign(g.y) + y.elements[9]) / y.elements[5], b.z = -1, b.w = (1 + y.elements[10]) / y.elements[14], g.multiplyScalar(2 / g.dot(b)), y.elements[2] = g.x, y.elements[6] = g.y, y.elements[10] = g.z + 1 - o, y.elements[14] = g.w, t.visible = !1;
      const A = E.getRenderTarget(), C = E.xr.enabled, N = E.shadowMap.autoUpdate, U = E.toneMapping;
      let Y = !1;
      "outputColorSpace" in E ? Y = E.outputColorSpace === "srgb" : Y = E.outputEncoding === 3001, E.xr.enabled = !1, E.shadowMap.autoUpdate = !1, "outputColorSpace" in E ? E.outputColorSpace = "srgb-linear" : E.outputEncoding = 3e3, E.toneMapping = Cl, E.setRenderTarget(R), E.state.buffers.depth.setMask(!0), E.autoClear === !1 && E.clear(), E.render(x, M), E.xr.enabled = C, E.shadowMap.autoUpdate = N, E.toneMapping = U, "outputColorSpace" in E ? E.outputColorSpace = Y ? "srgb" : "srgb-linear" : E.outputEncoding = Y ? 3001 : 3e3, E.setRenderTarget(A);
      const V = T.viewport;
      V !== void 0 && E.state.viewport(V), t.visible = !0;
    }, this.getRenderTarget = function() {
      return R;
    }, this.dispose = function() {
      R.dispose(), t.material.dispose();
    };
  }
};
let vo = Va;
qu(vo, "ReflectorShader", {
  uniforms: {
    color: {
      value: null
    },
    tDiffuse: {
      value: null
    },
    textureMatrix: {
      value: null
    }
  },
  vertexShader: (
    /* glsl */
    `
		uniform mat4 textureMatrix;
		varying vec4 vUv;

		#include <common>
		#include <logdepthbuf_pars_vertex>

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			#include <logdepthbuf_vertex>

		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 color;
		uniform sampler2D tDiffuse;
		varying vec4 vUv;

		#include <logdepthbuf_pars_fragment>

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			#include <logdepthbuf_fragment>

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

			#include <tonemapping_fragment>
			#include <${Ss >= 154 ? "colorspace_fragment" : "encodings_fragment"}>

		}`
  )
});
var Qu = Object.defineProperty, Ju = (r, e, t) => e in r ? Qu(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Ya = (r, e, t) => (Ju(r, typeof e != "symbol" ? e + "" : e, t), t);
const ui = new ht(), eh = new Float32Array([-1, -1, 0, 0, 0, 1, -1, 0, 1, 0, 1, 1, 0, 1, 1, -1, 1, 0, 0, 1]), Wa = new Ao(eh, 5);
ui.setIndex([0, 1, 2, 0, 2, 3]);
ui.setAttribute("position", new nn(Wa, 3, 0, !1));
ui.setAttribute("uv", new nn(Wa, 2, 3, !1));
const yo = class extends de {
  constructor() {
    super(yo.Geometry, new $t({ opacity: 0, transparent: !0 })), this.isLensflare = !0, this.type = "Lensflare", this.frustumCulled = !1, this.renderOrder = 1 / 0;
    const r = new $(), e = new $(), t = new ti(new Uint8Array(16 * 16 * 3), 16, 16, ei);
    t.minFilter = Kn, t.magFilter = Kn, t.wrapS = Wt, t.wrapT = Wt;
    const n = new ti(new Uint8Array(16 * 16 * 3), 16, 16, ei);
    n.minFilter = Kn, n.magFilter = Kn, n.wrapS = Wt, n.wrapT = Wt;
    const s = yo.Geometry, i = new gi({
      uniforms: {
        scale: { value: null },
        screenPosition: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				precision highp float;

				uniform vec3 screenPosition;
				uniform vec2 scale;

				attribute vec3 position;

				void main() {

					gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );

				}`
      ),
      fragmentShader: (
        /* glsl */
        `

				precision highp float;

				void main() {

					gl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );

				}`
      ),
      depthTest: !0,
      depthWrite: !1,
      transparent: !1
    }), o = new gi({
      uniforms: {
        map: { value: t },
        scale: { value: null },
        screenPosition: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				precision highp float;

				uniform vec3 screenPosition;
				uniform vec2 scale;

				attribute vec3 position;
				attribute vec2 uv;

				varying vec2 vUV;

				void main() {

					vUV = uv;

					gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );

				}`
      ),
      fragmentShader: (
        /* glsl */
        `

				precision highp float;

				uniform sampler2D map;

				varying vec2 vUV;

				void main() {

					gl_FragColor = texture2D( map, vUV );

				}`
      ),
      depthTest: !1,
      depthWrite: !1,
      transparent: !1
    }), a = new de(s, i), l = [], c = $a.Shader, f = new gi({
      uniforms: {
        map: { value: null },
        occlusionMap: { value: n },
        color: { value: new be(16777215) },
        scale: { value: new ve() },
        screenPosition: { value: new $() }
      },
      vertexShader: c.vertexShader,
      fragmentShader: c.fragmentShader,
      blending: So,
      transparent: !0,
      depthWrite: !1
    }), u = new de(s, f);
    this.addElement = function(v) {
      l.push(v);
    };
    const d = new ve(), h = new ve(), m = new va(), g = new at();
    this.onBeforeRender = function(v, p, b) {
      v.getCurrentViewport(g);
      const _ = g.w / g.z, M = g.z / 2, R = g.w / 2;
      let w = 16 / g.w;
      if (d.set(w * _, w), m.min.set(g.x, g.y), m.max.set(g.x + (g.z - 16), g.y + (g.w - 16)), e.setFromMatrixPosition(this.matrixWorld), e.applyMatrix4(b.matrixWorldInverse), !(e.z > 0) && (r.copy(e).applyMatrix4(b.projectionMatrix), h.x = g.x + r.x * M + M - 8, h.y = g.y + r.y * R + R - 8, m.containsPoint(h))) {
        v.copyFramebufferToTexture(h, t);
        let E = i.uniforms;
        E.scale.value = d, E.screenPosition.value = r, v.renderBufferDirect(b, null, s, i, a, null), v.copyFramebufferToTexture(h, n), E = o.uniforms, E.scale.value = d, E.screenPosition.value = r, v.renderBufferDirect(b, null, s, o, a, null);
        const x = -r.x * 2, T = -r.y * 2;
        for (let y = 0, A = l.length; y < A; y++) {
          const C = l[y], N = f.uniforms;
          N.color.value.copy(C.color), N.map.value = C.texture, N.screenPosition.value.x = r.x + x * C.distance, N.screenPosition.value.y = r.y + T * C.distance, w = C.size / g.w;
          const U = g.w / g.z;
          N.scale.value.set(w * U, w), f.uniformsNeedUpdate = !0, v.renderBufferDirect(b, null, s, f, u, null);
        }
      }
    }, this.dispose = function() {
      i.dispose(), o.dispose(), f.dispose(), t.dispose(), n.dispose();
      for (let v = 0, p = l.length; v < p; v++)
        l[v].texture.dispose();
    };
  }
};
let Xa = yo;
Ya(Xa, "Geometry", ui);
class $a {
  constructor(e, t = 1, n = 0, s = new be(16777215)) {
    this.texture = e, this.size = t, this.distance = n, this.color = s;
  }
}
Ya($a, "Shader", {
  uniforms: {
    map: { value: null },
    occlusionMap: { value: null },
    color: { value: null },
    scale: { value: null },
    screenPosition: { value: null }
  },
  vertexShader: (
    /* glsl */
    `

		precision highp float;

		uniform vec3 screenPosition;
		uniform vec2 scale;

		uniform sampler2D occlusionMap;

		attribute vec3 position;
		attribute vec2 uv;

		varying vec2 vUV;
		varying float vVisibility;

		void main() {

			vUV = uv;

			vec2 pos = position.xy;

			vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );
			visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );
			visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );
			visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );
			visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );
			visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );
			visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );
			visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );
			visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );

			vVisibility =        visibility.r / 9.0;
			vVisibility *= 1.0 - visibility.g / 9.0;
			vVisibility *=       visibility.b / 9.0;

			gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		precision highp float;

		uniform sampler2D map;
		uniform vec3 color;

		varying vec2 vUV;
		varying float vVisibility;

		void main() {

			vec4 texture = texture2D( map, vUV );
			texture.a *= vVisibility;
			gl_FragColor = texture;
			gl_FragColor.rgb *= color;

		}`
  )
});
class th extends de {
  constructor(e, t = {}) {
    super(e), this.isWater = !0;
    const n = this, s = t.textureWidth !== void 0 ? t.textureWidth : 512, i = t.textureHeight !== void 0 ? t.textureHeight : 512, o = t.clipBias !== void 0 ? t.clipBias : 0, a = t.alpha !== void 0 ? t.alpha : 1, l = t.time !== void 0 ? t.time : 0, c = t.waterNormals !== void 0 ? t.waterNormals : null, f = t.sunDirection !== void 0 ? t.sunDirection : new $(0.70707, 0.70707, 0), u = new be(t.sunColor !== void 0 ? t.sunColor : 16777215), d = new be(t.waterColor !== void 0 ? t.waterColor : 8355711), h = t.eye !== void 0 ? t.eye : new $(0, 0, 0), m = t.distortionScale !== void 0 ? t.distortionScale : 20, g = t.side !== void 0 ? t.side : ss, v = t.fog !== void 0 ? t.fog : !1, p = new bs(), b = new $(), _ = new $(), M = new $(), R = new Ie(), w = new $(0, 0, -1), E = new at(), x = new $(), T = new $(), y = new at(), A = new Ie(), C = new kt(), N = new Xt(s, i), U = {
      uniforms: Dn.merge([
        ni.fog,
        ni.lights,
        {
          normalSampler: { value: null },
          mirrorSampler: { value: null },
          alpha: { value: 1 },
          time: { value: 0 },
          size: { value: 1 },
          distortionScale: { value: 20 },
          textureMatrix: { value: new Ie() },
          sunColor: { value: new be(8355711) },
          sunDirection: { value: new $(0.70707, 0.70707, 0) },
          eye: { value: new $() },
          waterColor: { value: new be(5592405) }
        }
      ]),
      vertexShader: (
        /* glsl */
        `
				uniform mat4 textureMatrix;
				uniform float time;

				varying vec4 mirrorCoord;
				varying vec4 worldPosition;

				#include <common>
				#include <fog_pars_vertex>
				#include <shadowmap_pars_vertex>
				#include <logdepthbuf_pars_vertex>

				void main() {
					mirrorCoord = modelMatrix * vec4( position, 1.0 );
					worldPosition = mirrorCoord.xyzw;
					mirrorCoord = textureMatrix * mirrorCoord;
					vec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );
					gl_Position = projectionMatrix * mvPosition;

				#include <beginnormal_vertex>
				#include <defaultnormal_vertex>
				#include <logdepthbuf_vertex>
				#include <fog_vertex>
				#include <shadowmap_vertex>
			}`
      ),
      fragmentShader: (
        /* glsl */
        `
				uniform sampler2D mirrorSampler;
				uniform float alpha;
				uniform float time;
				uniform float size;
				uniform float distortionScale;
				uniform sampler2D normalSampler;
				uniform vec3 sunColor;
				uniform vec3 sunDirection;
				uniform vec3 eye;
				uniform vec3 waterColor;

				varying vec4 mirrorCoord;
				varying vec4 worldPosition;

				vec4 getNoise( vec2 uv ) {
					vec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);
					vec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );
					vec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );
					vec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );
					vec4 noise = texture2D( normalSampler, uv0 ) +
						texture2D( normalSampler, uv1 ) +
						texture2D( normalSampler, uv2 ) +
						texture2D( normalSampler, uv3 );
					return noise * 0.5 - 1.0;
				}

				void sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {
					vec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );
					float direction = max( 0.0, dot( eyeDirection, reflection ) );
					specularColor += pow( direction, shiny ) * sunColor * spec;
					diffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;
				}

				#include <common>
				#include <packing>
				#include <bsdfs>
				#include <fog_pars_fragment>
				#include <logdepthbuf_pars_fragment>
				#include <lights_pars_begin>
				#include <shadowmap_pars_fragment>
				#include <shadowmask_pars_fragment>

				void main() {

					#include <logdepthbuf_fragment>
					vec4 noise = getNoise( worldPosition.xz * size );
					vec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );

					vec3 diffuseLight = vec3(0.0);
					vec3 specularLight = vec3(0.0);

					vec3 worldToEye = eye-worldPosition.xyz;
					vec3 eyeDirection = normalize( worldToEye );
					sunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );

					float distance = length(worldToEye);

					vec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;
					vec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );

					float theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );
					float rf0 = 0.3;
					float reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );
					vec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;
					vec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);
					vec3 outgoingLight = albedo;
					gl_FragColor = vec4( outgoingLight, alpha );

					#include <tonemapping_fragment>
					#include <${parseInt(Ts.replace(/\D+/g, "")) >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
					#include <fog_fragment>	
				}`
      )
    }, Y = new bt({
      fragmentShader: U.fragmentShader,
      vertexShader: U.vertexShader,
      uniforms: Dn.clone(U.uniforms),
      lights: !0,
      side: g,
      fog: v
    });
    Y.uniforms.mirrorSampler.value = N.texture, Y.uniforms.textureMatrix.value = A, Y.uniforms.alpha.value = a, Y.uniforms.time.value = l, Y.uniforms.normalSampler.value = c, Y.uniforms.sunColor.value = u, Y.uniforms.waterColor.value = d, Y.uniforms.sunDirection.value = f, Y.uniforms.distortionScale.value = m, Y.uniforms.eye.value = h, n.material = Y, n.onBeforeRender = function(V, ne, Z) {
      if (_.setFromMatrixPosition(n.matrixWorld), M.setFromMatrixPosition(Z.matrixWorld), R.extractRotation(n.matrixWorld), b.set(0, 0, 1), b.applyMatrix4(R), x.subVectors(_, M), x.dot(b) > 0)
        return;
      x.reflect(b).negate(), x.add(_), R.extractRotation(Z.matrixWorld), w.set(0, 0, -1), w.applyMatrix4(R), w.add(M), T.subVectors(_, w), T.reflect(b).negate(), T.add(_), C.position.copy(x), C.up.set(0, 1, 0), C.up.applyMatrix4(R), C.up.reflect(b), C.lookAt(T), C.far = Z.far, C.updateMatrixWorld(), C.projectionMatrix.copy(Z.projectionMatrix), A.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), A.multiply(C.projectionMatrix), A.multiply(C.matrixWorldInverse), p.setFromNormalAndCoplanarPoint(b, _), p.applyMatrix4(C.matrixWorldInverse), E.set(p.normal.x, p.normal.y, p.normal.z, p.constant);
      const ee = C.projectionMatrix;
      y.x = (Math.sign(E.x) + ee.elements[8]) / ee.elements[0], y.y = (Math.sign(E.y) + ee.elements[9]) / ee.elements[5], y.z = -1, y.w = (1 + ee.elements[10]) / ee.elements[14], E.multiplyScalar(2 / E.dot(y)), ee.elements[2] = E.x, ee.elements[6] = E.y, ee.elements[10] = E.z + 1 - o, ee.elements[14] = E.w, h.setFromMatrixPosition(Z.matrixWorld);
      const te = V.getRenderTarget(), fe = V.xr.enabled, he = V.shadowMap.autoUpdate;
      n.visible = !1, V.xr.enabled = !1, V.shadowMap.autoUpdate = !1, V.setRenderTarget(N), V.state.buffers.depth.setMask(!0), V.autoClear === !1 && V.clear(), V.render(ne, C), n.visible = !0, V.xr.enabled = fe, V.shadowMap.autoUpdate = he, V.setRenderTarget(te);
      const we = Z.viewport;
      we !== void 0 && V.state.viewport(we);
    };
  }
}
var nh = Object.defineProperty, sh = (r, e, t) => e in r ? nh(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Za = (r, e, t) => (sh(r, typeof e != "symbol" ? e + "" : e, t), t);
const Qs = {
  uniforms: {
    turbidity: { value: 2 },
    rayleigh: { value: 1 },
    mieCoefficient: { value: 5e-3 },
    mieDirectionalG: { value: 0.8 },
    sunPosition: { value: new $() },
    up: { value: new $(0, 1, 0) }
  },
  vertexShader: (
    /* glsl */
    `
      uniform vec3 sunPosition;
      uniform float rayleigh;
      uniform float turbidity;
      uniform float mieCoefficient;
      uniform vec3 up;

      varying vec3 vWorldPosition;
      varying vec3 vSunDirection;
      varying float vSunfade;
      varying vec3 vBetaR;
      varying vec3 vBetaM;
      varying float vSunE;

      // constants for atmospheric scattering
      const float e = 2.71828182845904523536028747135266249775724709369995957;
      const float pi = 3.141592653589793238462643383279502884197169;

      // wavelength of used primaries, according to preetham
      const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );
      // this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:
      // (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
      const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );

      // mie stuff
      // K coefficient for the primaries
      const float v = 4.0;
      const vec3 K = vec3( 0.686, 0.678, 0.666 );
      // MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
      const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );

      // earth shadow hack
      // cutoffAngle = pi / 1.95;
      const float cutoffAngle = 1.6110731556870734;
      const float steepness = 1.5;
      const float EE = 1000.0;

      float sunIntensity( float zenithAngleCos ) {
        zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );
        return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );
      }

      vec3 totalMie( float T ) {
        float c = ( 0.2 * T ) * 10E-18;
        return 0.434 * c * MieConst;
      }

      void main() {

        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
        vWorldPosition = worldPosition.xyz;

        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        gl_Position.z = gl_Position.w; // set z to camera.far

        vSunDirection = normalize( sunPosition );

        vSunE = sunIntensity( dot( vSunDirection, up ) );

        vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );

        float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );

      // extinction (absorbtion + out scattering)
      // rayleigh coefficients
        vBetaR = totalRayleigh * rayleighCoefficient;

      // mie coefficients
        vBetaM = totalMie( turbidity ) * mieCoefficient;

      }
    `
  ),
  fragmentShader: (
    /* glsl */
    `
      varying vec3 vWorldPosition;
      varying vec3 vSunDirection;
      varying float vSunfade;
      varying vec3 vBetaR;
      varying vec3 vBetaM;
      varying float vSunE;

      uniform float mieDirectionalG;
      uniform vec3 up;

      const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );

      // constants for atmospheric scattering
      const float pi = 3.141592653589793238462643383279502884197169;

      const float n = 1.0003; // refractive index of air
      const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)

      // optical length at zenith for molecules
      const float rayleighZenithLength = 8.4E3;
      const float mieZenithLength = 1.25E3;
      // 66 arc seconds -> degrees, and the cosine of that
      const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;

      // 3.0 / ( 16.0 * pi )
      const float THREE_OVER_SIXTEENPI = 0.05968310365946075;
      // 1.0 / ( 4.0 * pi )
      const float ONE_OVER_FOURPI = 0.07957747154594767;

      float rayleighPhase( float cosTheta ) {
        return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );
      }

      float hgPhase( float cosTheta, float g ) {
        float g2 = pow( g, 2.0 );
        float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );
        return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );
      }

      void main() {

        vec3 direction = normalize( vWorldPosition - cameraPos );

      // optical length
      // cutoff angle at 90 to avoid singularity in next formula.
        float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );
        float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );
        float sR = rayleighZenithLength * inverse;
        float sM = mieZenithLength * inverse;

      // combined extinction factor
        vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );

      // in scattering
        float cosTheta = dot( direction, vSunDirection );

        float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );
        vec3 betaRTheta = vBetaR * rPhase;

        float mPhase = hgPhase( cosTheta, mieDirectionalG );
        vec3 betaMTheta = vBetaM * mPhase;

        vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );
        Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );

      // nightsky
        float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]
        float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]
        vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );
        vec3 L0 = vec3( 0.1 ) * Fex;

      // composition + solar disc
        float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );
        L0 += ( vSunE * 19000.0 * Fex ) * sundisk;

        vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );

        vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );

        gl_FragColor = vec4( retColor, 1.0 );

      #include <tonemapping_fragment>
      #include <${Ss >= 154 ? "colorspace_fragment" : "encodings_fragment"}>

      }
    `
  )
}, Ka = new bt({
  name: "SkyShader",
  fragmentShader: Qs.fragmentShader,
  vertexShader: Qs.vertexShader,
  uniforms: Dn.clone(Qs.uniforms),
  side: li,
  depthWrite: !1
});
class Fo extends de {
  constructor() {
    super(new Ht(1, 1, 1), Ka);
  }
}
Za(Fo, "SkyShader", Qs);
Za(Fo, "material", Ka);
const st = new Il(), Fs = new $();
class ih {
  constructor(e) {
    let t = e.geometry;
    t.index && (console.warn("THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry."), t = t.toNonIndexed()), this.geometry = t, this.randomFunction = Math.random, this.positionAttribute = this.geometry.getAttribute("position"), this.colorAttribute = this.geometry.getAttribute("color"), this.weightAttribute = null, this.distribution = null;
  }
  setWeightAttribute(e) {
    return this.weightAttribute = e ? this.geometry.getAttribute(e) : null, this;
  }
  build() {
    const e = this.positionAttribute, t = this.weightAttribute, n = new Float32Array(e.count / 3);
    for (let i = 0; i < e.count; i += 3) {
      let o = 1;
      t && (o = t.getX(i) + t.getX(i + 1) + t.getX(i + 2)), st.a.fromBufferAttribute(e, i), st.b.fromBufferAttribute(e, i + 1), st.c.fromBufferAttribute(e, i + 2), o *= st.getArea(), n[i / 3] = o;
    }
    this.distribution = new Float32Array(e.count / 3);
    let s = 0;
    for (let i = 0; i < n.length; i++)
      s += n[i], this.distribution[i] = s;
    return this;
  }
  setRandomGenerator(e) {
    return this.randomFunction = e, this;
  }
  sample(e, t, n) {
    const s = this.sampleFaceIndex();
    return this.sampleFace(s, e, t, n);
  }
  sampleFaceIndex() {
    const e = this.distribution[this.distribution.length - 1];
    return this.binarySearch(this.randomFunction() * e);
  }
  binarySearch(e) {
    const t = this.distribution;
    let n = 0, s = t.length - 1, i = -1;
    for (; n <= s; ) {
      const o = Math.ceil((n + s) / 2);
      if (o === 0 || t[o - 1] <= e && t[o] > e) {
        i = o;
        break;
      } else e < t[o] ? s = o - 1 : n = o + 1;
    }
    return i;
  }
  sampleFace(e, t, n, s) {
    let i = this.randomFunction(), o = this.randomFunction();
    return i + o > 1 && (i = 1 - i, o = 1 - o), st.a.fromBufferAttribute(this.positionAttribute, e * 3), st.b.fromBufferAttribute(this.positionAttribute, e * 3 + 1), st.c.fromBufferAttribute(this.positionAttribute, e * 3 + 2), t.set(0, 0, 0).addScaledVector(st.a, i).addScaledVector(st.b, o).addScaledVector(st.c, 1 - (i + o)), n !== void 0 && st.getNormal(n), s !== void 0 && this.colorAttribute !== void 0 && (st.a.fromBufferAttribute(this.colorAttribute, e * 3), st.b.fromBufferAttribute(this.colorAttribute, e * 3 + 1), st.c.fromBufferAttribute(this.colorAttribute, e * 3 + 2), Fs.set(0, 0, 0).addScaledVector(st.a, i).addScaledVector(st.b, o).addScaledVector(st.c, 1 - (i + o)), s.r = Fs.x, s.g = Fs.y, s.b = Fs.z), this;
  }
}
var oh = Object.defineProperty, rh = (r, e, t) => e in r ? oh(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, q = (r, e, t) => (rh(r, typeof e != "symbol" ? e + "" : e, t), t);
class ah extends Rt {
  constructor(e, t) {
    super(), q(this, "isTransformControls", !0), q(this, "visible", !1), q(this, "domElement"), q(this, "raycaster", new ya()), q(this, "gizmo"), q(this, "plane"), q(this, "tempVector", new $()), q(this, "tempVector2", new $()), q(this, "tempQuaternion", new je()), q(this, "unit", {
      X: new $(1, 0, 0),
      Y: new $(0, 1, 0),
      Z: new $(0, 0, 1)
    }), q(this, "pointStart", new $()), q(this, "pointEnd", new $()), q(this, "offset", new $()), q(this, "rotationAxis", new $()), q(this, "startNorm", new $()), q(this, "endNorm", new $()), q(this, "rotationAngle", 0), q(this, "cameraPosition", new $()), q(this, "cameraQuaternion", new je()), q(this, "cameraScale", new $()), q(this, "parentPosition", new $()), q(this, "parentQuaternion", new je()), q(this, "parentQuaternionInv", new je()), q(this, "parentScale", new $()), q(this, "worldPositionStart", new $()), q(this, "worldQuaternionStart", new je()), q(this, "worldScaleStart", new $()), q(this, "worldPosition", new $()), q(this, "worldQuaternion", new je()), q(this, "worldQuaternionInv", new je()), q(this, "worldScale", new $()), q(this, "eye", new $()), q(this, "positionStart", new $()), q(this, "quaternionStart", new je()), q(this, "scaleStart", new $()), q(this, "camera"), q(this, "object"), q(this, "enabled", !0), q(this, "axis", null), q(this, "mode", "translate"), q(this, "translationSnap", null), q(this, "rotationSnap", null), q(this, "scaleSnap", null), q(this, "space", "world"), q(this, "size", 1), q(this, "dragging", !1), q(this, "showX", !0), q(this, "showY", !0), q(this, "showZ", !0), q(this, "changeEvent", { type: "change" }), q(this, "mouseDownEvent", { type: "mouseDown", mode: this.mode }), q(this, "mouseUpEvent", { type: "mouseUp", mode: this.mode }), q(this, "objectChangeEvent", { type: "objectChange" }), q(this, "intersectObjectWithRay", (s, i, o) => {
      const a = i.intersectObject(s, !0);
      for (let l = 0; l < a.length; l++)
        if (a[l].object.visible || o)
          return a[l];
      return !1;
    }), q(this, "attach", (s) => (this.object = s, this.visible = !0, this)), q(this, "detach", () => (this.object = void 0, this.visible = !1, this.axis = null, this)), q(this, "reset", () => this.enabled ? (this.dragging && this.object !== void 0 && (this.object.position.copy(this.positionStart), this.object.quaternion.copy(this.quaternionStart), this.object.scale.copy(this.scaleStart), this.dispatchEvent(this.changeEvent), this.dispatchEvent(this.objectChangeEvent), this.pointStart.copy(this.pointEnd)), this) : this), q(this, "updateMatrixWorld", () => {
      this.object !== void 0 && (this.object.updateMatrixWorld(), this.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : this.object.parent.matrixWorld.decompose(this.parentPosition, this.parentQuaternion, this.parentScale), this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this.worldScale), this.parentQuaternionInv.copy(this.parentQuaternion).invert(), this.worldQuaternionInv.copy(this.worldQuaternion).invert()), this.camera.updateMatrixWorld(), this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this.cameraScale), this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(), super.updateMatrixWorld();
    }), q(this, "pointerHover", (s) => {
      if (this.object === void 0 || this.dragging === !0)
        return;
      this.raycaster.setFromCamera(s, this.camera);
      const i = this.intersectObjectWithRay(this.gizmo.picker[this.mode], this.raycaster);
      i ? this.axis = i.object.name : this.axis = null;
    }), q(this, "pointerDown", (s) => {
      if (!(this.object === void 0 || this.dragging === !0 || s.button !== 0) && this.axis !== null) {
        this.raycaster.setFromCamera(s, this.camera);
        const i = this.intersectObjectWithRay(this.plane, this.raycaster, !0);
        if (i) {
          let o = this.space;
          if (this.mode === "scale" ? o = "local" : (this.axis === "E" || this.axis === "XYZE" || this.axis === "XYZ") && (o = "world"), o === "local" && this.mode === "rotate") {
            const a = this.rotationSnap;
            this.axis === "X" && a && (this.object.rotation.x = Math.round(this.object.rotation.x / a) * a), this.axis === "Y" && a && (this.object.rotation.y = Math.round(this.object.rotation.y / a) * a), this.axis === "Z" && a && (this.object.rotation.z = Math.round(this.object.rotation.z / a) * a);
          }
          this.object.updateMatrixWorld(), this.object.parent && this.object.parent.updateMatrixWorld(), this.positionStart.copy(this.object.position), this.quaternionStart.copy(this.object.quaternion), this.scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this.worldScaleStart), this.pointStart.copy(i.point).sub(this.worldPositionStart);
        }
        this.dragging = !0, this.mouseDownEvent.mode = this.mode, this.dispatchEvent(this.mouseDownEvent);
      }
    }), q(this, "pointerMove", (s) => {
      const i = this.axis, o = this.mode, a = this.object;
      let l = this.space;
      if (o === "scale" ? l = "local" : (i === "E" || i === "XYZE" || i === "XYZ") && (l = "world"), a === void 0 || i === null || this.dragging === !1 || s.button !== -1)
        return;
      this.raycaster.setFromCamera(s, this.camera);
      const c = this.intersectObjectWithRay(this.plane, this.raycaster, !0);
      if (c) {
        if (this.pointEnd.copy(c.point).sub(this.worldPositionStart), o === "translate")
          this.offset.copy(this.pointEnd).sub(this.pointStart), l === "local" && i !== "XYZ" && this.offset.applyQuaternion(this.worldQuaternionInv), i.indexOf("X") === -1 && (this.offset.x = 0), i.indexOf("Y") === -1 && (this.offset.y = 0), i.indexOf("Z") === -1 && (this.offset.z = 0), l === "local" && i !== "XYZ" ? this.offset.applyQuaternion(this.quaternionStart).divide(this.parentScale) : this.offset.applyQuaternion(this.parentQuaternionInv).divide(this.parentScale), a.position.copy(this.offset).add(this.positionStart), this.translationSnap && (l === "local" && (a.position.applyQuaternion(this.tempQuaternion.copy(this.quaternionStart).invert()), i.search("X") !== -1 && (a.position.x = Math.round(a.position.x / this.translationSnap) * this.translationSnap), i.search("Y") !== -1 && (a.position.y = Math.round(a.position.y / this.translationSnap) * this.translationSnap), i.search("Z") !== -1 && (a.position.z = Math.round(a.position.z / this.translationSnap) * this.translationSnap), a.position.applyQuaternion(this.quaternionStart)), l === "world" && (a.parent && a.position.add(this.tempVector.setFromMatrixPosition(a.parent.matrixWorld)), i.search("X") !== -1 && (a.position.x = Math.round(a.position.x / this.translationSnap) * this.translationSnap), i.search("Y") !== -1 && (a.position.y = Math.round(a.position.y / this.translationSnap) * this.translationSnap), i.search("Z") !== -1 && (a.position.z = Math.round(a.position.z / this.translationSnap) * this.translationSnap), a.parent && a.position.sub(this.tempVector.setFromMatrixPosition(a.parent.matrixWorld))));
        else if (o === "scale") {
          if (i.search("XYZ") !== -1) {
            let f = this.pointEnd.length() / this.pointStart.length();
            this.pointEnd.dot(this.pointStart) < 0 && (f *= -1), this.tempVector2.set(f, f, f);
          } else
            this.tempVector.copy(this.pointStart), this.tempVector2.copy(this.pointEnd), this.tempVector.applyQuaternion(this.worldQuaternionInv), this.tempVector2.applyQuaternion(this.worldQuaternionInv), this.tempVector2.divide(this.tempVector), i.search("X") === -1 && (this.tempVector2.x = 1), i.search("Y") === -1 && (this.tempVector2.y = 1), i.search("Z") === -1 && (this.tempVector2.z = 1);
          a.scale.copy(this.scaleStart).multiply(this.tempVector2), this.scaleSnap && this.object && (i.search("X") !== -1 && (this.object.scale.x = Math.round(a.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), i.search("Y") !== -1 && (a.scale.y = Math.round(a.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), i.search("Z") !== -1 && (a.scale.z = Math.round(a.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
        } else if (o === "rotate") {
          this.offset.copy(this.pointEnd).sub(this.pointStart);
          const f = 20 / this.worldPosition.distanceTo(this.tempVector.setFromMatrixPosition(this.camera.matrixWorld));
          i === "E" ? (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this.startNorm.copy(this.pointStart).normalize(), this.endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this.endNorm.cross(this.startNorm).dot(this.eye) < 0 ? 1 : -1) : i === "XYZE" ? (this.rotationAxis.copy(this.offset).cross(this.eye).normalize(), this.rotationAngle = this.offset.dot(this.tempVector.copy(this.rotationAxis).cross(this.eye)) * f) : (i === "X" || i === "Y" || i === "Z") && (this.rotationAxis.copy(this.unit[i]), this.tempVector.copy(this.unit[i]), l === "local" && this.tempVector.applyQuaternion(this.worldQuaternion), this.rotationAngle = this.offset.dot(this.tempVector.cross(this.eye).normalize()) * f), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), l === "local" && i !== "E" && i !== "XYZE" ? (a.quaternion.copy(this.quaternionStart), a.quaternion.multiply(this.tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this.parentQuaternionInv), a.quaternion.copy(this.tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), a.quaternion.multiply(this.quaternionStart).normalize());
        }
        this.dispatchEvent(this.changeEvent), this.dispatchEvent(this.objectChangeEvent);
      }
    }), q(this, "pointerUp", (s) => {
      s.button === 0 && (this.dragging && this.axis !== null && (this.mouseUpEvent.mode = this.mode, this.dispatchEvent(this.mouseUpEvent)), this.dragging = !1, this.axis = null);
    }), q(this, "getPointer", (s) => {
      var i;
      if (this.domElement && ((i = this.domElement.ownerDocument) != null && i.pointerLockElement))
        return {
          x: 0,
          y: 0,
          button: s.button
        };
      {
        const o = s.changedTouches ? s.changedTouches[0] : s, a = this.domElement.getBoundingClientRect();
        return {
          x: (o.clientX - a.left) / a.width * 2 - 1,
          y: -(o.clientY - a.top) / a.height * 2 + 1,
          button: s.button
        };
      }
    }), q(this, "onPointerHover", (s) => {
      if (this.enabled)
        switch (s.pointerType) {
          case "mouse":
          case "pen":
            this.pointerHover(this.getPointer(s));
            break;
        }
    }), q(this, "onPointerDown", (s) => {
      !this.enabled || !this.domElement || (this.domElement.style.touchAction = "none", this.domElement.ownerDocument.addEventListener("pointermove", this.onPointerMove), this.pointerHover(this.getPointer(s)), this.pointerDown(this.getPointer(s)));
    }), q(this, "onPointerMove", (s) => {
      this.enabled && this.pointerMove(this.getPointer(s));
    }), q(this, "onPointerUp", (s) => {
      !this.enabled || !this.domElement || (this.domElement.style.touchAction = "", this.domElement.ownerDocument.removeEventListener("pointermove", this.onPointerMove), this.pointerUp(this.getPointer(s)));
    }), q(this, "getMode", () => this.mode), q(this, "setMode", (s) => {
      this.mode = s;
    }), q(this, "setTranslationSnap", (s) => {
      this.translationSnap = s;
    }), q(this, "setRotationSnap", (s) => {
      this.rotationSnap = s;
    }), q(this, "setScaleSnap", (s) => {
      this.scaleSnap = s;
    }), q(this, "setSize", (s) => {
      this.size = s;
    }), q(this, "setSpace", (s) => {
      this.space = s;
    }), q(this, "update", () => {
      console.warn(
        "THREE.TransformControls: update function has no more functionality and therefore has been deprecated."
      );
    }), q(this, "connect", (s) => {
      s === document && console.error(
        'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
      ), this.domElement = s, this.domElement.addEventListener("pointerdown", this.onPointerDown), this.domElement.addEventListener("pointermove", this.onPointerHover), this.domElement.ownerDocument.addEventListener("pointerup", this.onPointerUp);
    }), q(this, "dispose", () => {
      var s, i, o, a, l, c;
      (s = this.domElement) == null || s.removeEventListener("pointerdown", this.onPointerDown), (i = this.domElement) == null || i.removeEventListener("pointermove", this.onPointerHover), (a = (o = this.domElement) == null ? void 0 : o.ownerDocument) == null || a.removeEventListener("pointermove", this.onPointerMove), (c = (l = this.domElement) == null ? void 0 : l.ownerDocument) == null || c.removeEventListener("pointerup", this.onPointerUp), this.traverse((f) => {
        const u = f;
        u.geometry && u.geometry.dispose(), u.material && u.material.dispose();
      });
    }), this.domElement = t, this.camera = e, this.gizmo = new lh(), this.add(this.gizmo), this.plane = new ch(), this.add(this.plane);
    const n = (s, i) => {
      let o = i;
      Object.defineProperty(this, s, {
        get: function() {
          return o !== void 0 ? o : i;
        },
        set: function(a) {
          o !== a && (o = a, this.plane[s] = a, this.gizmo[s] = a, this.dispatchEvent({ type: s + "-changed", value: a }), this.dispatchEvent(this.changeEvent));
        }
      }), this[s] = i, this.plane[s] = i, this.gizmo[s] = i;
    };
    n("camera", this.camera), n("object", this.object), n("enabled", this.enabled), n("axis", this.axis), n("mode", this.mode), n("translationSnap", this.translationSnap), n("rotationSnap", this.rotationSnap), n("scaleSnap", this.scaleSnap), n("space", this.space), n("size", this.size), n("dragging", this.dragging), n("showX", this.showX), n("showY", this.showY), n("showZ", this.showZ), n("worldPosition", this.worldPosition), n("worldPositionStart", this.worldPositionStart), n("worldQuaternion", this.worldQuaternion), n("worldQuaternionStart", this.worldQuaternionStart), n("cameraPosition", this.cameraPosition), n("cameraQuaternion", this.cameraQuaternion), n("pointStart", this.pointStart), n("pointEnd", this.pointEnd), n("rotationAxis", this.rotationAxis), n("rotationAngle", this.rotationAngle), n("eye", this.eye), t !== void 0 && this.connect(t);
  }
}
class lh extends Rt {
  constructor() {
    super(), q(this, "isTransformControlsGizmo", !0), q(this, "type", "TransformControlsGizmo"), q(this, "tempVector", new $(0, 0, 0)), q(this, "tempEuler", new vt()), q(this, "alignVector", new $(0, 1, 0)), q(this, "zeroVector", new $(0, 0, 0)), q(this, "lookAtMatrix", new Ie()), q(this, "tempQuaternion", new je()), q(this, "tempQuaternion2", new je()), q(this, "identityQuaternion", new je()), q(this, "unitX", new $(1, 0, 0)), q(this, "unitY", new $(0, 1, 0)), q(this, "unitZ", new $(0, 0, 1)), q(this, "gizmo"), q(this, "picker"), q(this, "helper"), q(this, "rotationAxis", new $()), q(this, "cameraPosition", new $()), q(this, "worldPositionStart", new $()), q(this, "worldQuaternionStart", new je()), q(this, "worldPosition", new $()), q(this, "worldQuaternion", new je()), q(this, "eye", new $()), q(this, "camera", null), q(this, "enabled", !0), q(this, "axis", null), q(this, "mode", "translate"), q(this, "space", "world"), q(this, "size", 1), q(this, "dragging", !1), q(this, "showX", !0), q(this, "showY", !0), q(this, "showZ", !0), q(this, "updateMatrixWorld", () => {
      let te = this.space;
      this.mode === "scale" && (te = "local");
      const fe = te === "local" ? this.worldQuaternion : this.identityQuaternion;
      this.gizmo.translate.visible = this.mode === "translate", this.gizmo.rotate.visible = this.mode === "rotate", this.gizmo.scale.visible = this.mode === "scale", this.helper.translate.visible = this.mode === "translate", this.helper.rotate.visible = this.mode === "rotate", this.helper.scale.visible = this.mode === "scale";
      let he = [];
      he = he.concat(this.picker[this.mode].children), he = he.concat(this.gizmo[this.mode].children), he = he.concat(this.helper[this.mode].children);
      for (let we = 0; we < he.length; we++) {
        const I = he[we];
        I.visible = !0, I.rotation.set(0, 0, 0), I.position.copy(this.worldPosition);
        let B;
        if (this.camera.isOrthographicCamera ? B = (this.camera.top - this.camera.bottom) / this.camera.zoom : B = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), I.scale.set(1, 1, 1).multiplyScalar(B * this.size / 7), I.tag === "helper") {
          I.visible = !1, I.name === "AXIS" ? (I.position.copy(this.worldPositionStart), I.visible = !!this.axis, this.axis === "X" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, 0, 0)), I.quaternion.copy(fe).multiply(this.tempQuaternion), Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(fe).dot(this.eye)) > 0.9 && (I.visible = !1)), this.axis === "Y" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, 0, Math.PI / 2)), I.quaternion.copy(fe).multiply(this.tempQuaternion), Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(fe).dot(this.eye)) > 0.9 && (I.visible = !1)), this.axis === "Z" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, Math.PI / 2, 0)), I.quaternion.copy(fe).multiply(this.tempQuaternion), Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(fe).dot(this.eye)) > 0.9 && (I.visible = !1)), this.axis === "XYZE" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, Math.PI / 2, 0)), this.alignVector.copy(this.rotationAxis), I.quaternion.setFromRotationMatrix(
            this.lookAtMatrix.lookAt(this.zeroVector, this.alignVector, this.unitY)
          ), I.quaternion.multiply(this.tempQuaternion), I.visible = this.dragging), this.axis === "E" && (I.visible = !1)) : I.name === "START" ? (I.position.copy(this.worldPositionStart), I.visible = this.dragging) : I.name === "END" ? (I.position.copy(this.worldPosition), I.visible = this.dragging) : I.name === "DELTA" ? (I.position.copy(this.worldPositionStart), I.quaternion.copy(this.worldQuaternionStart), this.tempVector.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), this.tempVector.applyQuaternion(this.worldQuaternionStart.clone().invert()), I.scale.copy(this.tempVector), I.visible = this.dragging) : (I.quaternion.copy(fe), this.dragging ? I.position.copy(this.worldPositionStart) : I.position.copy(this.worldPosition), this.axis && (I.visible = this.axis.search(I.name) !== -1));
          continue;
        }
        I.quaternion.copy(fe), this.mode === "translate" || this.mode === "scale" ? ((I.name === "X" || I.name === "XYZX") && Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(fe).dot(this.eye)) > 0.99 && (I.scale.set(1e-10, 1e-10, 1e-10), I.visible = !1), (I.name === "Y" || I.name === "XYZY") && Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(fe).dot(this.eye)) > 0.99 && (I.scale.set(1e-10, 1e-10, 1e-10), I.visible = !1), (I.name === "Z" || I.name === "XYZZ") && Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(fe).dot(this.eye)) > 0.99 && (I.scale.set(1e-10, 1e-10, 1e-10), I.visible = !1), I.name === "XY" && Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(fe).dot(this.eye)) < 0.2 && (I.scale.set(1e-10, 1e-10, 1e-10), I.visible = !1), I.name === "YZ" && Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(fe).dot(this.eye)) < 0.2 && (I.scale.set(1e-10, 1e-10, 1e-10), I.visible = !1), I.name === "XZ" && Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(fe).dot(this.eye)) < 0.2 && (I.scale.set(1e-10, 1e-10, 1e-10), I.visible = !1), I.name.search("X") !== -1 && (this.alignVector.copy(this.unitX).applyQuaternion(fe).dot(this.eye) < 0 ? I.tag === "fwd" ? I.visible = !1 : I.scale.x *= -1 : I.tag === "bwd" && (I.visible = !1)), I.name.search("Y") !== -1 && (this.alignVector.copy(this.unitY).applyQuaternion(fe).dot(this.eye) < 0 ? I.tag === "fwd" ? I.visible = !1 : I.scale.y *= -1 : I.tag === "bwd" && (I.visible = !1)), I.name.search("Z") !== -1 && (this.alignVector.copy(this.unitZ).applyQuaternion(fe).dot(this.eye) < 0 ? I.tag === "fwd" ? I.visible = !1 : I.scale.z *= -1 : I.tag === "bwd" && (I.visible = !1))) : this.mode === "rotate" && (this.tempQuaternion2.copy(fe), this.alignVector.copy(this.eye).applyQuaternion(this.tempQuaternion.copy(fe).invert()), I.name.search("E") !== -1 && I.quaternion.setFromRotationMatrix(this.lookAtMatrix.lookAt(this.eye, this.zeroVector, this.unitY)), I.name === "X" && (this.tempQuaternion.setFromAxisAngle(this.unitX, Math.atan2(-this.alignVector.y, this.alignVector.z)), this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2, this.tempQuaternion), I.quaternion.copy(this.tempQuaternion)), I.name === "Y" && (this.tempQuaternion.setFromAxisAngle(this.unitY, Math.atan2(this.alignVector.x, this.alignVector.z)), this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2, this.tempQuaternion), I.quaternion.copy(this.tempQuaternion)), I.name === "Z" && (this.tempQuaternion.setFromAxisAngle(this.unitZ, Math.atan2(this.alignVector.y, this.alignVector.x)), this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2, this.tempQuaternion), I.quaternion.copy(this.tempQuaternion))), I.visible = I.visible && (I.name.indexOf("X") === -1 || this.showX), I.visible = I.visible && (I.name.indexOf("Y") === -1 || this.showY), I.visible = I.visible && (I.name.indexOf("Z") === -1 || this.showZ), I.visible = I.visible && (I.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ), I.material.tempOpacity = I.material.tempOpacity || I.material.opacity, I.material.tempColor = I.material.tempColor || I.material.color.clone(), I.material.color.copy(I.material.tempColor), I.material.opacity = I.material.tempOpacity, this.enabled ? this.axis && (I.name === this.axis ? (I.material.opacity = 1, I.material.color.lerp(new be(1, 1, 1), 0.5)) : this.axis.split("").some(function(D) {
          return I.name === D;
        }) ? (I.material.opacity = 1, I.material.color.lerp(new be(1, 1, 1), 0.5)) : (I.material.opacity *= 0.25, I.material.color.lerp(new be(1, 1, 1), 0.5))) : (I.material.opacity *= 0.5, I.material.color.lerp(new be(1, 1, 1), 0.5));
      }
      super.updateMatrixWorld();
    });
    const e = new $t({
      depthTest: !1,
      depthWrite: !1,
      transparent: !0,
      side: on,
      fog: !1,
      toneMapped: !1
    }), t = new ws({
      depthTest: !1,
      depthWrite: !1,
      transparent: !0,
      linewidth: 1,
      fog: !1,
      toneMapped: !1
    }), n = e.clone();
    n.opacity = 0.15;
    const s = e.clone();
    s.opacity = 0.33;
    const i = e.clone();
    i.color.set(16711680);
    const o = e.clone();
    o.color.set(65280);
    const a = e.clone();
    a.color.set(255);
    const l = e.clone();
    l.opacity = 0.25;
    const c = l.clone();
    c.color.set(16776960);
    const f = l.clone();
    f.color.set(65535);
    const u = l.clone();
    u.color.set(16711935), e.clone().color.set(16776960);
    const h = t.clone();
    h.color.set(16711680);
    const m = t.clone();
    m.color.set(65280);
    const g = t.clone();
    g.color.set(255);
    const v = t.clone();
    v.color.set(65535);
    const p = t.clone();
    p.color.set(16711935);
    const b = t.clone();
    b.color.set(16776960);
    const _ = t.clone();
    _.color.set(7895160);
    const M = b.clone();
    M.opacity = 0.25;
    const R = new Ct(0, 0.05, 0.2, 12, 1, !1), w = new Ht(0.125, 0.125, 0.125), E = new ht();
    E.setAttribute("position", new gt([0, 0, 0, 1, 0, 0], 3));
    const x = (te, fe) => {
      const he = new ht(), we = [];
      for (let I = 0; I <= 64 * fe; ++I)
        we.push(0, Math.cos(I / 32 * Math.PI) * te, Math.sin(I / 32 * Math.PI) * te);
      return he.setAttribute("position", new gt(we, 3)), he;
    }, T = () => {
      const te = new ht();
      return te.setAttribute("position", new gt([0, 0, 0, 1, 1, 1], 3)), te;
    }, y = {
      X: [
        [new de(R, i), [1, 0, 0], [0, 0, -Math.PI / 2], null, "fwd"],
        [new de(R, i), [1, 0, 0], [0, 0, Math.PI / 2], null, "bwd"],
        [new ke(E, h)]
      ],
      Y: [
        [new de(R, o), [0, 1, 0], null, null, "fwd"],
        [new de(R, o), [0, 1, 0], [Math.PI, 0, 0], null, "bwd"],
        [new ke(E, m), null, [0, 0, Math.PI / 2]]
      ],
      Z: [
        [new de(R, a), [0, 0, 1], [Math.PI / 2, 0, 0], null, "fwd"],
        [new de(R, a), [0, 0, 1], [-Math.PI / 2, 0, 0], null, "bwd"],
        [new ke(E, g), null, [0, -Math.PI / 2, 0]]
      ],
      XYZ: [[new de(new Mn(0.1, 0), l.clone()), [0, 0, 0], [0, 0, 0]]],
      XY: [
        [new de(new jt(0.295, 0.295), c.clone()), [0.15, 0.15, 0]],
        [new ke(E, b), [0.18, 0.3, 0], null, [0.125, 1, 1]],
        [new ke(E, b), [0.3, 0.18, 0], [0, 0, Math.PI / 2], [0.125, 1, 1]]
      ],
      YZ: [
        [new de(new jt(0.295, 0.295), f.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]],
        [new ke(E, v), [0, 0.18, 0.3], [0, 0, Math.PI / 2], [0.125, 1, 1]],
        [new ke(E, v), [0, 0.3, 0.18], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
      ],
      XZ: [
        [
          new de(new jt(0.295, 0.295), u.clone()),
          [0.15, 0, 0.15],
          [-Math.PI / 2, 0, 0]
        ],
        [new ke(E, p), [0.18, 0, 0.3], null, [0.125, 1, 1]],
        [new ke(E, p), [0.3, 0, 0.18], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
      ]
    }, A = {
      X: [[new de(new Ct(0.2, 0, 1, 4, 1, !1), n), [0.6, 0, 0], [0, 0, -Math.PI / 2]]],
      Y: [[new de(new Ct(0.2, 0, 1, 4, 1, !1), n), [0, 0.6, 0]]],
      Z: [[new de(new Ct(0.2, 0, 1, 4, 1, !1), n), [0, 0, 0.6], [Math.PI / 2, 0, 0]]],
      XYZ: [[new de(new Mn(0.2, 0), n)]],
      XY: [[new de(new jt(0.4, 0.4), n), [0.2, 0.2, 0]]],
      YZ: [[new de(new jt(0.4, 0.4), n), [0, 0.2, 0.2], [0, Math.PI / 2, 0]]],
      XZ: [[new de(new jt(0.4, 0.4), n), [0.2, 0, 0.2], [-Math.PI / 2, 0, 0]]]
    }, C = {
      START: [[new de(new Mn(0.01, 2), s), null, null, null, "helper"]],
      END: [[new de(new Mn(0.01, 2), s), null, null, null, "helper"]],
      DELTA: [[new ke(T(), s), null, null, null, "helper"]],
      X: [[new ke(E, s.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]],
      Y: [[new ke(E, s.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]],
      Z: [[new ke(E, s.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]]
    }, N = {
      X: [
        [new ke(x(1, 0.5), h)],
        [new de(new Mn(0.04, 0), i), [0, 0, 0.99], null, [1, 3, 1]]
      ],
      Y: [
        [new ke(x(1, 0.5), m), null, [0, 0, -Math.PI / 2]],
        [new de(new Mn(0.04, 0), o), [0, 0, 0.99], null, [3, 1, 1]]
      ],
      Z: [
        [new ke(x(1, 0.5), g), null, [0, Math.PI / 2, 0]],
        [new de(new Mn(0.04, 0), a), [0.99, 0, 0], null, [1, 3, 1]]
      ],
      E: [
        [new ke(x(1.25, 1), M), null, [0, Math.PI / 2, 0]],
        [
          new de(new Ct(0.03, 0, 0.15, 4, 1, !1), M),
          [1.17, 0, 0],
          [0, 0, -Math.PI / 2],
          [1, 1, 1e-3]
        ],
        [
          new de(new Ct(0.03, 0, 0.15, 4, 1, !1), M),
          [-1.17, 0, 0],
          [0, 0, Math.PI / 2],
          [1, 1, 1e-3]
        ],
        [
          new de(new Ct(0.03, 0, 0.15, 4, 1, !1), M),
          [0, -1.17, 0],
          [Math.PI, 0, 0],
          [1, 1, 1e-3]
        ],
        [
          new de(new Ct(0.03, 0, 0.15, 4, 1, !1), M),
          [0, 1.17, 0],
          [0, 0, 0],
          [1, 1, 1e-3]
        ]
      ],
      XYZE: [[new ke(x(1, 1), _), null, [0, Math.PI / 2, 0]]]
    }, U = {
      AXIS: [[new ke(E, s.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]]
    }, Y = {
      X: [[new de(new Ds(1, 0.1, 4, 24), n), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]],
      Y: [[new de(new Ds(1, 0.1, 4, 24), n), [0, 0, 0], [Math.PI / 2, 0, 0]]],
      Z: [[new de(new Ds(1, 0.1, 4, 24), n), [0, 0, 0], [0, 0, -Math.PI / 2]]],
      E: [[new de(new Ds(1.25, 0.1, 2, 24), n)]],
      XYZE: [[new de(new Ol(0.7, 10, 8), n)]]
    }, V = {
      X: [
        [new de(w, i), [0.8, 0, 0], [0, 0, -Math.PI / 2]],
        [new ke(E, h), null, null, [0.8, 1, 1]]
      ],
      Y: [
        [new de(w, o), [0, 0.8, 0]],
        [new ke(E, m), null, [0, 0, Math.PI / 2], [0.8, 1, 1]]
      ],
      Z: [
        [new de(w, a), [0, 0, 0.8], [Math.PI / 2, 0, 0]],
        [new ke(E, g), null, [0, -Math.PI / 2, 0], [0.8, 1, 1]]
      ],
      XY: [
        [new de(w, c), [0.85, 0.85, 0], null, [2, 2, 0.2]],
        [new ke(E, b), [0.855, 0.98, 0], null, [0.125, 1, 1]],
        [new ke(E, b), [0.98, 0.855, 0], [0, 0, Math.PI / 2], [0.125, 1, 1]]
      ],
      YZ: [
        [new de(w, f), [0, 0.85, 0.85], null, [0.2, 2, 2]],
        [new ke(E, v), [0, 0.855, 0.98], [0, 0, Math.PI / 2], [0.125, 1, 1]],
        [new ke(E, v), [0, 0.98, 0.855], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
      ],
      XZ: [
        [new de(w, u), [0.85, 0, 0.85], null, [2, 0.2, 2]],
        [new ke(E, p), [0.855, 0, 0.98], null, [0.125, 1, 1]],
        [new ke(E, p), [0.98, 0, 0.855], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
      ],
      XYZX: [[new de(new Ht(0.125, 0.125, 0.125), l.clone()), [1.1, 0, 0]]],
      XYZY: [[new de(new Ht(0.125, 0.125, 0.125), l.clone()), [0, 1.1, 0]]],
      XYZZ: [[new de(new Ht(0.125, 0.125, 0.125), l.clone()), [0, 0, 1.1]]]
    }, ne = {
      X: [[new de(new Ct(0.2, 0, 0.8, 4, 1, !1), n), [0.5, 0, 0], [0, 0, -Math.PI / 2]]],
      Y: [[new de(new Ct(0.2, 0, 0.8, 4, 1, !1), n), [0, 0.5, 0]]],
      Z: [[new de(new Ct(0.2, 0, 0.8, 4, 1, !1), n), [0, 0, 0.5], [Math.PI / 2, 0, 0]]],
      XY: [[new de(w, n), [0.85, 0.85, 0], null, [3, 3, 0.2]]],
      YZ: [[new de(w, n), [0, 0.85, 0.85], null, [0.2, 3, 3]]],
      XZ: [[new de(w, n), [0.85, 0, 0.85], null, [3, 0.2, 3]]],
      XYZX: [[new de(new Ht(0.2, 0.2, 0.2), n), [1.1, 0, 0]]],
      XYZY: [[new de(new Ht(0.2, 0.2, 0.2), n), [0, 1.1, 0]]],
      XYZZ: [[new de(new Ht(0.2, 0.2, 0.2), n), [0, 0, 1.1]]]
    }, Z = {
      X: [[new ke(E, s.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]],
      Y: [[new ke(E, s.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]],
      Z: [[new ke(E, s.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]]
    }, ee = (te) => {
      const fe = new Rt();
      for (let he in te)
        for (let we = te[he].length; we--; ) {
          const I = te[he][we][0].clone(), B = te[he][we][1], D = te[he][we][2], O = te[he][we][3], z = te[he][we][4];
          I.name = he, I.tag = z, B && I.position.set(B[0], B[1], B[2]), D && I.rotation.set(D[0], D[1], D[2]), O && I.scale.set(O[0], O[1], O[2]), I.updateMatrix();
          const S = I.geometry.clone();
          S.applyMatrix4(I.matrix), I.geometry = S, I.renderOrder = 1 / 0, I.position.set(0, 0, 0), I.rotation.set(0, 0, 0), I.scale.set(1, 1, 1), fe.add(I);
        }
      return fe;
    };
    this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = ee(y)), this.add(this.gizmo.rotate = ee(N)), this.add(this.gizmo.scale = ee(V)), this.add(this.picker.translate = ee(A)), this.add(this.picker.rotate = ee(Y)), this.add(this.picker.scale = ee(ne)), this.add(this.helper.translate = ee(C)), this.add(this.helper.rotate = ee(U)), this.add(this.helper.scale = ee(Z)), this.picker.translate.visible = !1, this.picker.rotate.visible = !1, this.picker.scale.visible = !1;
  }
}
class ch extends de {
  constructor() {
    super(
      new jt(1e5, 1e5, 2, 2),
      new $t({
        visible: !1,
        wireframe: !0,
        side: on,
        transparent: !0,
        opacity: 0.1,
        toneMapped: !1
      })
    ), q(this, "isTransformControlsPlane", !0), q(this, "type", "TransformControlsPlane"), q(this, "unitX", new $(1, 0, 0)), q(this, "unitY", new $(0, 1, 0)), q(this, "unitZ", new $(0, 0, 1)), q(this, "tempVector", new $()), q(this, "dirVector", new $()), q(this, "alignVector", new $()), q(this, "tempMatrix", new Ie()), q(this, "identityQuaternion", new je()), q(this, "cameraQuaternion", new je()), q(this, "worldPosition", new $()), q(this, "worldQuaternion", new je()), q(this, "eye", new $()), q(this, "axis", null), q(this, "mode", "translate"), q(this, "space", "world"), q(this, "updateMatrixWorld", () => {
      let e = this.space;
      switch (this.position.copy(this.worldPosition), this.mode === "scale" && (e = "local"), this.unitX.set(1, 0, 0).applyQuaternion(e === "local" ? this.worldQuaternion : this.identityQuaternion), this.unitY.set(0, 1, 0).applyQuaternion(e === "local" ? this.worldQuaternion : this.identityQuaternion), this.unitZ.set(0, 0, 1).applyQuaternion(e === "local" ? this.worldQuaternion : this.identityQuaternion), this.alignVector.copy(this.unitY), this.mode) {
        case "translate":
        case "scale":
          switch (this.axis) {
            case "X":
              this.alignVector.copy(this.eye).cross(this.unitX), this.dirVector.copy(this.unitX).cross(this.alignVector);
              break;
            case "Y":
              this.alignVector.copy(this.eye).cross(this.unitY), this.dirVector.copy(this.unitY).cross(this.alignVector);
              break;
            case "Z":
              this.alignVector.copy(this.eye).cross(this.unitZ), this.dirVector.copy(this.unitZ).cross(this.alignVector);
              break;
            case "XY":
              this.dirVector.copy(this.unitZ);
              break;
            case "YZ":
              this.dirVector.copy(this.unitX);
              break;
            case "XZ":
              this.alignVector.copy(this.unitZ), this.dirVector.copy(this.unitY);
              break;
            case "XYZ":
            case "E":
              this.dirVector.set(0, 0, 0);
              break;
          }
          break;
        case "rotate":
        default:
          this.dirVector.set(0, 0, 0);
      }
      this.dirVector.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (this.tempMatrix.lookAt(this.tempVector.set(0, 0, 0), this.dirVector, this.alignVector), this.quaternion.setFromRotationMatrix(this.tempMatrix)), super.updateMatrixWorld();
    });
  }
}
var uh = Object.defineProperty, hh = (r, e, t) => e in r ? uh(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Je = (r, e, t) => (hh(r, typeof e != "symbol" ? e + "" : e, t), t);
const zn = new vt(0, 0, 0, "YXZ"), Gn = new $(), fh = { type: "change" }, dh = { type: "lock" }, ph = { type: "unlock" }, lr = Math.PI / 2;
class qa extends _a {
  constructor(e, t) {
    super(), Je(this, "camera"), Je(this, "domElement"), Je(this, "isLocked"), Je(this, "minPolarAngle"), Je(this, "maxPolarAngle"), Je(this, "pointerSpeed"), Je(this, "onMouseMove", (n) => {
      if (!this.domElement || this.isLocked === !1)
        return;
      const s = n.movementX || n.mozMovementX || n.webkitMovementX || 0, i = n.movementY || n.mozMovementY || n.webkitMovementY || 0;
      zn.setFromQuaternion(this.camera.quaternion), zn.y -= s * 2e-3 * this.pointerSpeed, zn.x -= i * 2e-3 * this.pointerSpeed, zn.x = Math.max(lr - this.maxPolarAngle, Math.min(lr - this.minPolarAngle, zn.x)), this.camera.quaternion.setFromEuler(zn), this.dispatchEvent(fh);
    }), Je(this, "onPointerlockChange", () => {
      this.domElement && (this.domElement.ownerDocument.pointerLockElement === this.domElement ? (this.dispatchEvent(dh), this.isLocked = !0) : (this.dispatchEvent(ph), this.isLocked = !1));
    }), Je(this, "onPointerlockError", () => {
      console.error("THREE.PointerLockControls: Unable to use Pointer Lock API");
    }), Je(this, "connect", (n) => {
      this.domElement = n || this.domElement, this.domElement && (this.domElement.ownerDocument.addEventListener("mousemove", this.onMouseMove), this.domElement.ownerDocument.addEventListener("pointerlockchange", this.onPointerlockChange), this.domElement.ownerDocument.addEventListener("pointerlockerror", this.onPointerlockError));
    }), Je(this, "disconnect", () => {
      this.domElement && (this.domElement.ownerDocument.removeEventListener("mousemove", this.onMouseMove), this.domElement.ownerDocument.removeEventListener("pointerlockchange", this.onPointerlockChange), this.domElement.ownerDocument.removeEventListener("pointerlockerror", this.onPointerlockError));
    }), Je(this, "dispose", () => {
      this.disconnect();
    }), Je(this, "getObject", () => this.camera), Je(this, "direction", new $(0, 0, -1)), Je(this, "getDirection", (n) => n.copy(this.direction).applyQuaternion(this.camera.quaternion)), Je(this, "moveForward", (n) => {
      Gn.setFromMatrixColumn(this.camera.matrix, 0), Gn.crossVectors(this.camera.up, Gn), this.camera.position.addScaledVector(Gn, n);
    }), Je(this, "moveRight", (n) => {
      Gn.setFromMatrixColumn(this.camera.matrix, 0), this.camera.position.addScaledVector(Gn, n);
    }), Je(this, "lock", () => {
      this.domElement && this.domElement.requestPointerLock();
    }), Je(this, "unlock", () => {
      this.domElement && this.domElement.ownerDocument.exitPointerLock();
    }), this.camera = e, this.domElement = t, this.isLocked = !1, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.pointerSpeed = 1, t && this.connect(t);
  }
}
var mh = Object.defineProperty, gh = (r, e, t) => e in r ? mh(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, _e = (r, e, t) => (gh(r, typeof e != "symbol" ? e + "" : e, t), t);
const zs = new Dl(), cr = new bs(), vh = Math.cos(70 * (Math.PI / 180)), ur = (r, e) => (r % e + e) % e;
class Qa extends _a {
  constructor(e, t) {
    super(), _e(this, "object"), _e(this, "domElement"), _e(this, "enabled", !0), _e(this, "target", new $()), _e(this, "minDistance", 0), _e(this, "maxDistance", 1 / 0), _e(this, "minZoom", 0), _e(this, "maxZoom", 1 / 0), _e(this, "minPolarAngle", 0), _e(this, "maxPolarAngle", Math.PI), _e(this, "minAzimuthAngle", -1 / 0), _e(this, "maxAzimuthAngle", 1 / 0), _e(this, "enableDamping", !1), _e(this, "dampingFactor", 0.05), _e(this, "enableZoom", !0), _e(this, "zoomSpeed", 1), _e(this, "enableRotate", !0), _e(this, "rotateSpeed", 1), _e(this, "enablePan", !0), _e(this, "panSpeed", 1), _e(this, "screenSpacePanning", !0), _e(this, "keyPanSpeed", 7), _e(this, "zoomToCursor", !1), _e(this, "autoRotate", !1), _e(this, "autoRotateSpeed", 2), _e(this, "reverseOrbit", !1), _e(this, "reverseHorizontalOrbit", !1), _e(this, "reverseVerticalOrbit", !1), _e(this, "keys", { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }), _e(this, "mouseButtons", {
      LEFT: Dt.ROTATE,
      MIDDLE: Dt.DOLLY,
      RIGHT: Dt.PAN
    }), _e(this, "touches", { ONE: Vt.ROTATE, TWO: Vt.DOLLY_PAN }), _e(this, "target0"), _e(this, "position0"), _e(this, "zoom0"), _e(this, "_domElementKeyEvents", null), _e(this, "getPolarAngle"), _e(this, "getAzimuthalAngle"), _e(this, "setPolarAngle"), _e(this, "setAzimuthalAngle"), _e(this, "getDistance"), _e(this, "getZoomScale"), _e(this, "listenToKeyEvents"), _e(this, "stopListenToKeyEvents"), _e(this, "saveState"), _e(this, "reset"), _e(this, "update"), _e(this, "connect"), _e(this, "dispose"), _e(this, "dollyIn"), _e(this, "dollyOut"), _e(this, "getScale"), _e(this, "setScale"), this.object = e, this.domElement = t, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = () => f.phi, this.getAzimuthalAngle = () => f.theta, this.setPolarAngle = (W) => {
      let le = ur(W, 2 * Math.PI), Ee = f.phi;
      Ee < 0 && (Ee += 2 * Math.PI), le < 0 && (le += 2 * Math.PI);
      let Ue = Math.abs(le - Ee);
      2 * Math.PI - Ue < Ue && (le < Ee ? le += 2 * Math.PI : Ee += 2 * Math.PI), u.phi = le - Ee, n.update();
    }, this.setAzimuthalAngle = (W) => {
      let le = ur(W, 2 * Math.PI), Ee = f.theta;
      Ee < 0 && (Ee += 2 * Math.PI), le < 0 && (le += 2 * Math.PI);
      let Ue = Math.abs(le - Ee);
      2 * Math.PI - Ue < Ue && (le < Ee ? le += 2 * Math.PI : Ee += 2 * Math.PI), u.theta = le - Ee, n.update();
    }, this.getDistance = () => n.object.position.distanceTo(n.target), this.listenToKeyEvents = (W) => {
      W.addEventListener("keydown", Nt), this._domElementKeyEvents = W;
    }, this.stopListenToKeyEvents = () => {
      this._domElementKeyEvents.removeEventListener("keydown", Nt), this._domElementKeyEvents = null;
    }, this.saveState = () => {
      n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom;
    }, this.reset = () => {
      n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(s), n.update(), l = a.NONE;
    }, this.update = (() => {
      const W = new $(), le = new $(0, 1, 0), Ee = new je().setFromUnitVectors(e.up, le), Ue = Ee.clone().invert(), nt = new $(), qt = new je(), hn = 2 * Math.PI;
      return function() {
        const Xo = n.object.position;
        Ee.setFromUnitVectors(e.up, le), Ue.copy(Ee).invert(), W.copy(Xo).sub(n.target), W.applyQuaternion(Ee), f.setFromVector3(W), n.autoRotate && l === a.NONE && U(C()), n.enableDamping ? (f.theta += u.theta * n.dampingFactor, f.phi += u.phi * n.dampingFactor) : (f.theta += u.theta, f.phi += u.phi);
        let Qt = n.minAzimuthAngle, Jt = n.maxAzimuthAngle;
        isFinite(Qt) && isFinite(Jt) && (Qt < -Math.PI ? Qt += hn : Qt > Math.PI && (Qt -= hn), Jt < -Math.PI ? Jt += hn : Jt > Math.PI && (Jt -= hn), Qt <= Jt ? f.theta = Math.max(Qt, Math.min(Jt, f.theta)) : f.theta = f.theta > (Qt + Jt) / 2 ? Math.max(Qt, f.theta) : Math.min(Jt, f.theta)), f.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, f.phi)), f.makeSafe(), n.enableDamping === !0 ? n.target.addScaledVector(h, n.dampingFactor) : n.target.add(h), n.zoomToCursor && T || n.object.isOrthographicCamera ? f.radius = we(f.radius) : f.radius = we(f.radius * d), W.setFromSpherical(f), W.applyQuaternion(Ue), Xo.copy(n.target).add(W), n.object.matrixAutoUpdate || n.object.updateMatrix(), n.object.lookAt(n.target), n.enableDamping === !0 ? (u.theta *= 1 - n.dampingFactor, u.phi *= 1 - n.dampingFactor, h.multiplyScalar(1 - n.dampingFactor)) : (u.set(0, 0, 0), h.set(0, 0, 0));
        let os = !1;
        if (n.zoomToCursor && T) {
          let rs = null;
          if (n.object instanceof kt && n.object.isPerspectiveCamera) {
            const as = W.length();
            rs = we(as * d);
            const Os = as - rs;
            n.object.position.addScaledVector(E, Os), n.object.updateMatrixWorld();
          } else if (n.object.isOrthographicCamera) {
            const as = new $(x.x, x.y, 0);
            as.unproject(n.object), n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / d)), n.object.updateProjectionMatrix(), os = !0;
            const Os = new $(x.x, x.y, 0);
            Os.unproject(n.object), n.object.position.sub(Os).add(as), n.object.updateMatrixWorld(), rs = W.length();
          } else
            console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), n.zoomToCursor = !1;
          rs !== null && (n.screenSpacePanning ? n.target.set(0, 0, -1).transformDirection(n.object.matrix).multiplyScalar(rs).add(n.object.position) : (zs.origin.copy(n.object.position), zs.direction.set(0, 0, -1).transformDirection(n.object.matrix), Math.abs(n.object.up.dot(zs.direction)) < vh ? e.lookAt(n.target) : (cr.setFromNormalAndCoplanarPoint(n.object.up, n.target), zs.intersectPlane(cr, n.target))));
        } else n.object instanceof _n && n.object.isOrthographicCamera && (os = d !== 1, os && (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / d)), n.object.updateProjectionMatrix()));
        return d = 1, T = !1, os || nt.distanceToSquared(n.object.position) > c || 8 * (1 - qt.dot(n.object.quaternion)) > c ? (n.dispatchEvent(s), nt.copy(n.object.position), qt.copy(n.object.quaternion), os = !1, !0) : !1;
      };
    })(), this.connect = (W) => {
      n.domElement = W, n.domElement.style.touchAction = "none", n.domElement.addEventListener("contextmenu", is), n.domElement.addEventListener("pointerdown", Re), n.domElement.addEventListener("pointercancel", He), n.domElement.addEventListener("wheel", En);
    }, this.dispose = () => {
      var W, le, Ee, Ue, nt, qt;
      n.domElement && (n.domElement.style.touchAction = "auto"), (W = n.domElement) == null || W.removeEventListener("contextmenu", is), (le = n.domElement) == null || le.removeEventListener("pointerdown", Re), (Ee = n.domElement) == null || Ee.removeEventListener("pointercancel", He), (Ue = n.domElement) == null || Ue.removeEventListener("wheel", En), (nt = n.domElement) == null || nt.ownerDocument.removeEventListener("pointermove", Ke), (qt = n.domElement) == null || qt.ownerDocument.removeEventListener("pointerup", He), n._domElementKeyEvents !== null && n._domElementKeyEvents.removeEventListener("keydown", Nt);
    };
    const n = this, s = { type: "change" }, i = { type: "start" }, o = { type: "end" }, a = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    let l = a.NONE;
    const c = 1e-6, f = new si(), u = new si();
    let d = 1;
    const h = new $(), m = new ve(), g = new ve(), v = new ve(), p = new ve(), b = new ve(), _ = new ve(), M = new ve(), R = new ve(), w = new ve(), E = new $(), x = new ve();
    let T = !1;
    const y = [], A = {};
    function C() {
      return 2 * Math.PI / 60 / 60 * n.autoRotateSpeed;
    }
    function N() {
      return Math.pow(0.95, n.zoomSpeed);
    }
    function U(W) {
      n.reverseOrbit || n.reverseHorizontalOrbit ? u.theta += W : u.theta -= W;
    }
    function Y(W) {
      n.reverseOrbit || n.reverseVerticalOrbit ? u.phi += W : u.phi -= W;
    }
    const V = (() => {
      const W = new $();
      return function(Ee, Ue) {
        W.setFromMatrixColumn(Ue, 0), W.multiplyScalar(-Ee), h.add(W);
      };
    })(), ne = (() => {
      const W = new $();
      return function(Ee, Ue) {
        n.screenSpacePanning === !0 ? W.setFromMatrixColumn(Ue, 1) : (W.setFromMatrixColumn(Ue, 0), W.crossVectors(n.object.up, W)), W.multiplyScalar(Ee), h.add(W);
      };
    })(), Z = (() => {
      const W = new $();
      return function(Ee, Ue) {
        const nt = n.domElement;
        if (nt && n.object instanceof kt && n.object.isPerspectiveCamera) {
          const qt = n.object.position;
          W.copy(qt).sub(n.target);
          let hn = W.length();
          hn *= Math.tan(n.object.fov / 2 * Math.PI / 180), V(2 * Ee * hn / nt.clientHeight, n.object.matrix), ne(2 * Ue * hn / nt.clientHeight, n.object.matrix);
        } else nt && n.object instanceof _n && n.object.isOrthographicCamera ? (V(
          Ee * (n.object.right - n.object.left) / n.object.zoom / nt.clientWidth,
          n.object.matrix
        ), ne(
          Ue * (n.object.top - n.object.bottom) / n.object.zoom / nt.clientHeight,
          n.object.matrix
        )) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = !1);
      };
    })();
    function ee(W) {
      n.object instanceof kt && n.object.isPerspectiveCamera || n.object instanceof _n && n.object.isOrthographicCamera ? d = W : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1);
    }
    function te(W) {
      ee(d / W);
    }
    function fe(W) {
      ee(d * W);
    }
    function he(W) {
      if (!n.zoomToCursor || !n.domElement)
        return;
      T = !0;
      const le = n.domElement.getBoundingClientRect(), Ee = W.clientX - le.left, Ue = W.clientY - le.top, nt = le.width, qt = le.height;
      x.x = Ee / nt * 2 - 1, x.y = -(Ue / qt) * 2 + 1, E.set(x.x, x.y, 1).unproject(n.object).sub(n.object.position).normalize();
    }
    function we(W) {
      return Math.max(n.minDistance, Math.min(n.maxDistance, W));
    }
    function I(W) {
      m.set(W.clientX, W.clientY);
    }
    function B(W) {
      he(W), M.set(W.clientX, W.clientY);
    }
    function D(W) {
      p.set(W.clientX, W.clientY);
    }
    function O(W) {
      g.set(W.clientX, W.clientY), v.subVectors(g, m).multiplyScalar(n.rotateSpeed);
      const le = n.domElement;
      le && (U(2 * Math.PI * v.x / le.clientHeight), Y(2 * Math.PI * v.y / le.clientHeight)), m.copy(g), n.update();
    }
    function z(W) {
      R.set(W.clientX, W.clientY), w.subVectors(R, M), w.y > 0 ? te(N()) : w.y < 0 && fe(N()), M.copy(R), n.update();
    }
    function S(W) {
      b.set(W.clientX, W.clientY), _.subVectors(b, p).multiplyScalar(n.panSpeed), Z(_.x, _.y), p.copy(b), n.update();
    }
    function P(W) {
      he(W), W.deltaY < 0 ? fe(N()) : W.deltaY > 0 && te(N()), n.update();
    }
    function L(W) {
      let le = !1;
      switch (W.code) {
        case n.keys.UP:
          Z(0, n.keyPanSpeed), le = !0;
          break;
        case n.keys.BOTTOM:
          Z(0, -n.keyPanSpeed), le = !0;
          break;
        case n.keys.LEFT:
          Z(n.keyPanSpeed, 0), le = !0;
          break;
        case n.keys.RIGHT:
          Z(-n.keyPanSpeed, 0), le = !0;
          break;
      }
      le && (W.preventDefault(), n.update());
    }
    function X() {
      if (y.length == 1)
        m.set(y[0].pageX, y[0].pageY);
      else {
        const W = 0.5 * (y[0].pageX + y[1].pageX), le = 0.5 * (y[0].pageY + y[1].pageY);
        m.set(W, le);
      }
    }
    function H() {
      if (y.length == 1)
        p.set(y[0].pageX, y[0].pageY);
      else {
        const W = 0.5 * (y[0].pageX + y[1].pageX), le = 0.5 * (y[0].pageY + y[1].pageY);
        p.set(W, le);
      }
    }
    function j() {
      const W = y[0].pageX - y[1].pageX, le = y[0].pageY - y[1].pageY, Ee = Math.sqrt(W * W + le * le);
      M.set(0, Ee);
    }
    function K() {
      n.enableZoom && j(), n.enablePan && H();
    }
    function se() {
      n.enableZoom && j(), n.enableRotate && X();
    }
    function ie(W) {
      if (y.length == 1)
        g.set(W.pageX, W.pageY);
      else {
        const Ee = pi(W), Ue = 0.5 * (W.pageX + Ee.x), nt = 0.5 * (W.pageY + Ee.y);
        g.set(Ue, nt);
      }
      v.subVectors(g, m).multiplyScalar(n.rotateSpeed);
      const le = n.domElement;
      le && (U(2 * Math.PI * v.x / le.clientHeight), Y(2 * Math.PI * v.y / le.clientHeight)), m.copy(g);
    }
    function G(W) {
      if (y.length == 1)
        b.set(W.pageX, W.pageY);
      else {
        const le = pi(W), Ee = 0.5 * (W.pageX + le.x), Ue = 0.5 * (W.pageY + le.y);
        b.set(Ee, Ue);
      }
      _.subVectors(b, p).multiplyScalar(n.panSpeed), Z(_.x, _.y), p.copy(b);
    }
    function k(W) {
      const le = pi(W), Ee = W.pageX - le.x, Ue = W.pageY - le.y, nt = Math.sqrt(Ee * Ee + Ue * Ue);
      R.set(0, nt), w.set(0, Math.pow(R.y / M.y, n.zoomSpeed)), te(w.y), M.copy(R);
    }
    function oe(W) {
      n.enableZoom && k(W), n.enablePan && G(W);
    }
    function ge(W) {
      n.enableZoom && k(W), n.enableRotate && ie(W);
    }
    function Re(W) {
      var le, Ee;
      n.enabled !== !1 && (y.length === 0 && ((le = n.domElement) == null || le.ownerDocument.addEventListener("pointermove", Ke), (Ee = n.domElement) == null || Ee.ownerDocument.addEventListener("pointerup", He)), Cs(W), W.pointerType === "touch" ? yt(W) : Et(W));
    }
    function Ke(W) {
      n.enabled !== !1 && (W.pointerType === "touch" ? Bt(W) : un(W));
    }
    function He(W) {
      var le, Ee, Ue;
      di(W), y.length === 0 && ((le = n.domElement) == null || le.releasePointerCapture(W.pointerId), (Ee = n.domElement) == null || Ee.ownerDocument.removeEventListener("pointermove", Ke), (Ue = n.domElement) == null || Ue.ownerDocument.removeEventListener("pointerup", He)), n.dispatchEvent(o), l = a.NONE;
    }
    function Et(W) {
      let le;
      switch (W.button) {
        case 0:
          le = n.mouseButtons.LEFT;
          break;
        case 1:
          le = n.mouseButtons.MIDDLE;
          break;
        case 2:
          le = n.mouseButtons.RIGHT;
          break;
        default:
          le = -1;
      }
      switch (le) {
        case Dt.DOLLY:
          if (n.enableZoom === !1)
            return;
          B(W), l = a.DOLLY;
          break;
        case Dt.ROTATE:
          if (W.ctrlKey || W.metaKey || W.shiftKey) {
            if (n.enablePan === !1)
              return;
            D(W), l = a.PAN;
          } else {
            if (n.enableRotate === !1)
              return;
            I(W), l = a.ROTATE;
          }
          break;
        case Dt.PAN:
          if (W.ctrlKey || W.metaKey || W.shiftKey) {
            if (n.enableRotate === !1)
              return;
            I(W), l = a.ROTATE;
          } else {
            if (n.enablePan === !1)
              return;
            D(W), l = a.PAN;
          }
          break;
        default:
          l = a.NONE;
      }
      l !== a.NONE && n.dispatchEvent(i);
    }
    function un(W) {
      if (n.enabled !== !1)
        switch (l) {
          case a.ROTATE:
            if (n.enableRotate === !1)
              return;
            O(W);
            break;
          case a.DOLLY:
            if (n.enableZoom === !1)
              return;
            z(W);
            break;
          case a.PAN:
            if (n.enablePan === !1)
              return;
            S(W);
            break;
        }
    }
    function En(W) {
      n.enabled === !1 || n.enableZoom === !1 || l !== a.NONE && l !== a.ROTATE || (W.preventDefault(), n.dispatchEvent(i), P(W), n.dispatchEvent(o));
    }
    function Nt(W) {
      n.enabled === !1 || n.enablePan === !1 || L(W);
    }
    function yt(W) {
      switch (Is(W), y.length) {
        case 1:
          switch (n.touches.ONE) {
            case Vt.ROTATE:
              if (n.enableRotate === !1)
                return;
              X(), l = a.TOUCH_ROTATE;
              break;
            case Vt.PAN:
              if (n.enablePan === !1)
                return;
              H(), l = a.TOUCH_PAN;
              break;
            default:
              l = a.NONE;
          }
          break;
        case 2:
          switch (n.touches.TWO) {
            case Vt.DOLLY_PAN:
              if (n.enableZoom === !1 && n.enablePan === !1)
                return;
              K(), l = a.TOUCH_DOLLY_PAN;
              break;
            case Vt.DOLLY_ROTATE:
              if (n.enableZoom === !1 && n.enableRotate === !1)
                return;
              se(), l = a.TOUCH_DOLLY_ROTATE;
              break;
            default:
              l = a.NONE;
          }
          break;
        default:
          l = a.NONE;
      }
      l !== a.NONE && n.dispatchEvent(i);
    }
    function Bt(W) {
      switch (Is(W), l) {
        case a.TOUCH_ROTATE:
          if (n.enableRotate === !1)
            return;
          ie(W), n.update();
          break;
        case a.TOUCH_PAN:
          if (n.enablePan === !1)
            return;
          G(W), n.update();
          break;
        case a.TOUCH_DOLLY_PAN:
          if (n.enableZoom === !1 && n.enablePan === !1)
            return;
          oe(W), n.update();
          break;
        case a.TOUCH_DOLLY_ROTATE:
          if (n.enableZoom === !1 && n.enableRotate === !1)
            return;
          ge(W), n.update();
          break;
        default:
          l = a.NONE;
      }
    }
    function is(W) {
      n.enabled !== !1 && W.preventDefault();
    }
    function Cs(W) {
      y.push(W);
    }
    function di(W) {
      delete A[W.pointerId];
      for (let le = 0; le < y.length; le++)
        if (y[le].pointerId == W.pointerId) {
          y.splice(le, 1);
          return;
        }
    }
    function Is(W) {
      let le = A[W.pointerId];
      le === void 0 && (le = new ve(), A[W.pointerId] = le), le.set(W.pageX, W.pageY);
    }
    function pi(W) {
      const le = W.pointerId === y[0].pointerId ? y[1] : y[0];
      return A[le.pointerId];
    }
    this.dollyIn = (W = N()) => {
      fe(W), n.update();
    }, this.dollyOut = (W = N()) => {
      te(W), n.update();
    }, this.getScale = () => d, this.setScale = (W) => {
      ee(W), n.update();
    }, this.getZoomScale = () => N(), t !== void 0 && this.connect(t), this.update();
  }
}
class yh extends Qa {
  constructor(e, t) {
    super(e, t), this.screenSpacePanning = !1, this.mouseButtons.LEFT = Dt.PAN, this.mouseButtons.RIGHT = Dt.ROTATE, this.touches.ONE = Vt.PAN, this.touches.TWO = Vt.DOLLY_ROTATE;
  }
}
function ns(r) {
  if (typeof TextDecoder < "u")
    return new TextDecoder().decode(r);
  let e = "";
  for (let t = 0, n = r.length; t < n; t++)
    e += String.fromCharCode(r[t]);
  try {
    return decodeURIComponent(escape(e));
  } catch {
    return e;
  }
}
const In = "srgb", sn = "srgb-linear", hr = 3001, _h = 3e3;
class xh extends Un {
  constructor(e) {
    super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
      return new Mh(t);
    }), this.register(function(t) {
      return new Sh(t);
    }), this.register(function(t) {
      return new kh(t);
    }), this.register(function(t) {
      return new Nh(t);
    }), this.register(function(t) {
      return new Bh(t);
    }), this.register(function(t) {
      return new Ph(t);
    }), this.register(function(t) {
      return new Rh(t);
    }), this.register(function(t) {
      return new Ch(t);
    }), this.register(function(t) {
      return new Ih(t);
    }), this.register(function(t) {
      return new Eh(t);
    }), this.register(function(t) {
      return new Oh(t);
    }), this.register(function(t) {
      return new Ah(t);
    }), this.register(function(t) {
      return new Lh(t);
    }), this.register(function(t) {
      return new Dh(t);
    }), this.register(function(t) {
      return new Th(t);
    }), this.register(function(t) {
      return new Uh(t);
    }), this.register(function(t) {
      return new Fh(t);
    });
  }
  load(e, t, n, s) {
    const i = this;
    let o;
    if (this.resourcePath !== "")
      o = this.resourcePath;
    else if (this.path !== "") {
      const c = qn.extractUrlBase(e);
      o = qn.resolveURL(c, this.path);
    } else
      o = qn.extractUrlBase(e);
    this.manager.itemStart(e);
    const a = function(c) {
      s ? s(c) : console.error(c), i.manager.itemError(e), i.manager.itemEnd(e);
    }, l = new kn(this.manager);
    l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(
      e,
      function(c) {
        try {
          i.parse(
            c,
            o,
            function(f) {
              t(f), i.manager.itemEnd(e);
            },
            a
          );
        } catch (f) {
          a(f);
        }
      },
      n,
      a
    );
  }
  setDRACOLoader(e) {
    return this.dracoLoader = e, this;
  }
  setDDSLoader() {
    throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
  }
  setKTX2Loader(e) {
    return this.ktx2Loader = e, this;
  }
  setMeshoptDecoder(e) {
    return this.meshoptDecoder = e, this;
  }
  register(e) {
    return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
  }
  unregister(e) {
    return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
  }
  parse(e, t, n, s) {
    let i;
    const o = {}, a = {};
    if (typeof e == "string")
      i = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (ns(new Uint8Array(e.slice(0, 4))) === Ja) {
        try {
          o[Oe.KHR_BINARY_GLTF] = new zh(e);
        } catch (f) {
          s && s(f);
          return;
        }
        i = JSON.parse(o[Oe.KHR_BINARY_GLTF].content);
      } else
        i = JSON.parse(ns(new Uint8Array(e)));
    else
      i = e;
    if (i.asset === void 0 || i.asset.version[0] < 2) {
      s && s(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const l = new Jh(i, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    l.fileLoader.setRequestHeader(this.requestHeader);
    for (let c = 0; c < this.pluginCallbacks.length; c++) {
      const f = this.pluginCallbacks[c](l);
      f.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), a[f.name] = f, o[f.name] = !0;
    }
    if (i.extensionsUsed)
      for (let c = 0; c < i.extensionsUsed.length; ++c) {
        const f = i.extensionsUsed[c], u = i.extensionsRequired || [];
        switch (f) {
          case Oe.KHR_MATERIALS_UNLIT:
            o[f] = new bh();
            break;
          case Oe.KHR_DRACO_MESH_COMPRESSION:
            o[f] = new Gh(i, this.dracoLoader);
            break;
          case Oe.KHR_TEXTURE_TRANSFORM:
            o[f] = new Hh();
            break;
          case Oe.KHR_MESH_QUANTIZATION:
            o[f] = new jh();
            break;
          default:
            u.indexOf(f) >= 0 && a[f] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + f + '".');
        }
      }
    l.setExtensions(o), l.setPlugins(a), l.parse(n, s);
  }
  parseAsync(e, t) {
    const n = this;
    return new Promise(function(s, i) {
      n.parse(e, t, s, i);
    });
  }
}
function wh() {
  let r = {};
  return {
    get: function(e) {
      return r[e];
    },
    add: function(e, t) {
      r[e] = t;
    },
    remove: function(e) {
      delete r[e];
    },
    removeAll: function() {
      r = {};
    }
  };
}
const Oe = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_MATERIALS_BUMP: "EXT_materials_bump",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class Th {
  constructor(e) {
    this.parser = e, this.name = Oe.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const e = this.parser, t = this.parser.json.nodes || [];
    for (let n = 0, s = t.length; n < s; n++) {
      const i = t[n];
      i.extensions && i.extensions[this.name] && i.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, i.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser, n = "light:" + e;
    let s = t.cache.get(n);
    if (s)
      return s;
    const i = t.json, l = ((i.extensions && i.extensions[this.name] || {}).lights || [])[e];
    let c;
    const f = new be(16777215);
    l.color !== void 0 && f.setRGB(l.color[0], l.color[1], l.color[2], sn);
    const u = l.range !== void 0 ? l.range : 0;
    switch (l.type) {
      case "directional":
        c = new wa(f), c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      case "point":
        c = new ro(f), c.distance = u;
        break;
      case "spot":
        c = new xa(f), c.distance = u, l.spot = l.spot || {}, l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0, l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4, c.angle = l.spot.outerConeAngle, c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle, c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type);
    }
    return c.position.set(0, 0, 0), c.decay = 2, en(c, l), l.intensity !== void 0 && (c.intensity = l.intensity), c.name = t.createUniqueName(l.name || "light_" + e), s = Promise.resolve(c), t.cache.add(n, s), s;
  }
  getDependency(e, t) {
    if (e === "light")
      return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this, n = this.parser, i = n.json.nodes[e], a = (i.extensions && i.extensions[this.name] || {}).light;
    return a === void 0 ? null : this._loadLight(a).then(function(l) {
      return n._getNodeRef(t.cache, a, l);
    });
  }
}
class bh {
  constructor() {
    this.name = Oe.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return $t;
  }
  extendParams(e, t, n) {
    const s = [];
    e.color = new be(1, 1, 1), e.opacity = 1;
    const i = t.pbrMetallicRoughness;
    if (i) {
      if (Array.isArray(i.baseColorFactor)) {
        const o = i.baseColorFactor;
        e.color.setRGB(o[0], o[1], o[2], sn), e.opacity = o[3];
      }
      i.baseColorTexture !== void 0 && s.push(n.assignTexture(e, "map", i.baseColorTexture, In));
    }
    return Promise.all(s);
  }
}
class Eh {
  constructor(e) {
    this.parser = e, this.name = Oe.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(e, t) {
    const s = this.parser.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = s.extensions[this.name].emissiveStrength;
    return i !== void 0 && (t.emissiveIntensity = i), Promise.resolve();
  }
}
class Mh {
  constructor(e) {
    this.parser = e, this.name = Oe.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Kt;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = [], o = s.extensions[this.name];
    if (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor), o.clearcoatTexture !== void 0 && i.push(n.assignTexture(t, "clearcoatMap", o.clearcoatTexture)), o.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = o.clearcoatRoughnessFactor), o.clearcoatRoughnessTexture !== void 0 && i.push(n.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)), o.clearcoatNormalTexture !== void 0 && (i.push(n.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)), o.clearcoatNormalTexture.scale !== void 0)) {
      const a = o.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new ve(a, a);
    }
    return Promise.all(i);
  }
}
class Sh {
  constructor(e) {
    this.parser = e, this.name = Oe.KHR_MATERIALS_DISPERSION;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Kt;
  }
  extendMaterialParams(e, t) {
    const s = this.parser.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = s.extensions[this.name];
    return t.dispersion = i.dispersion !== void 0 ? i.dispersion : 0, Promise.resolve();
  }
}
class Ah {
  constructor(e) {
    this.parser = e, this.name = Oe.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Kt;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = [], o = s.extensions[this.name];
    return o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor), o.iridescenceTexture !== void 0 && i.push(n.assignTexture(t, "iridescenceMap", o.iridescenceTexture)), o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]), o.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum), o.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum), o.iridescenceThicknessTexture !== void 0 && i.push(
      n.assignTexture(t, "iridescenceThicknessMap", o.iridescenceThicknessTexture)
    ), Promise.all(i);
  }
}
class Ph {
  constructor(e) {
    this.parser = e, this.name = Oe.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Kt;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = [];
    t.sheenColor = new be(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
    const o = s.extensions[this.name];
    if (o.sheenColorFactor !== void 0) {
      const a = o.sheenColorFactor;
      t.sheenColor.setRGB(a[0], a[1], a[2], sn);
    }
    return o.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = o.sheenRoughnessFactor), o.sheenColorTexture !== void 0 && i.push(n.assignTexture(t, "sheenColorMap", o.sheenColorTexture, In)), o.sheenRoughnessTexture !== void 0 && i.push(n.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)), Promise.all(i);
  }
}
class Rh {
  constructor(e) {
    this.parser = e, this.name = Oe.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Kt;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = [], o = s.extensions[this.name];
    return o.transmissionFactor !== void 0 && (t.transmission = o.transmissionFactor), o.transmissionTexture !== void 0 && i.push(n.assignTexture(t, "transmissionMap", o.transmissionTexture)), Promise.all(i);
  }
}
class Ch {
  constructor(e) {
    this.parser = e, this.name = Oe.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Kt;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = [], o = s.extensions[this.name];
    t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0, o.thicknessTexture !== void 0 && i.push(n.assignTexture(t, "thicknessMap", o.thicknessTexture)), t.attenuationDistance = o.attenuationDistance || 1 / 0;
    const a = o.attenuationColor || [1, 1, 1];
    return t.attenuationColor = new be().setRGB(
      a[0],
      a[1],
      a[2],
      sn
    ), Promise.all(i);
  }
}
class Ih {
  constructor(e) {
    this.parser = e, this.name = Oe.KHR_MATERIALS_IOR;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Kt;
  }
  extendMaterialParams(e, t) {
    const s = this.parser.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = s.extensions[this.name];
    return t.ior = i.ior !== void 0 ? i.ior : 1.5, Promise.resolve();
  }
}
class Oh {
  constructor(e) {
    this.parser = e, this.name = Oe.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Kt;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = [], o = s.extensions[this.name];
    t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1, o.specularTexture !== void 0 && i.push(n.assignTexture(t, "specularIntensityMap", o.specularTexture));
    const a = o.specularColorFactor || [1, 1, 1];
    return t.specularColor = new be().setRGB(a[0], a[1], a[2], sn), o.specularColorTexture !== void 0 && i.push(
      n.assignTexture(t, "specularColorMap", o.specularColorTexture, In)
    ), Promise.all(i);
  }
}
class Dh {
  constructor(e) {
    this.parser = e, this.name = Oe.EXT_MATERIALS_BUMP;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Kt;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = [], o = s.extensions[this.name];
    return t.bumpScale = o.bumpFactor !== void 0 ? o.bumpFactor : 1, o.bumpTexture !== void 0 && i.push(n.assignTexture(t, "bumpMap", o.bumpTexture)), Promise.all(i);
  }
}
class Lh {
  constructor(e) {
    this.parser = e, this.name = Oe.KHR_MATERIALS_ANISOTROPY;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Kt;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = [], o = s.extensions[this.name];
    return o.anisotropyStrength !== void 0 && (t.anisotropy = o.anisotropyStrength), o.anisotropyRotation !== void 0 && (t.anisotropyRotation = o.anisotropyRotation), o.anisotropyTexture !== void 0 && i.push(n.assignTexture(t, "anisotropyMap", o.anisotropyTexture)), Promise.all(i);
  }
}
class kh {
  constructor(e) {
    this.parser = e, this.name = Oe.KHR_TEXTURE_BASISU;
  }
  loadTexture(e) {
    const t = this.parser, n = t.json, s = n.textures[e];
    if (!s.extensions || !s.extensions[this.name])
      return null;
    const i = s.extensions[this.name], o = t.options.ktx2Loader;
    if (!o) {
      if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      return null;
    }
    return t.loadTextureImage(e, i.source, o);
  }
}
class Nh {
  constructor(e) {
    this.parser = e, this.name = Oe.EXT_TEXTURE_WEBP, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, n = this.parser, s = n.json, i = s.textures[e];
    if (!i.extensions || !i.extensions[t])
      return null;
    const o = i.extensions[t], a = s.images[o.source];
    let l = n.textureLoader;
    if (a.uri) {
      const c = n.options.manager.getHandler(a.uri);
      c !== null && (l = c);
    }
    return this.detectSupport().then(function(c) {
      if (c)
        return n.loadTextureImage(e, o.source, l);
      if (s.extensionsRequired && s.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class Bh {
  constructor(e) {
    this.parser = e, this.name = Oe.EXT_TEXTURE_AVIF, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, n = this.parser, s = n.json, i = s.textures[e];
    if (!i.extensions || !i.extensions[t])
      return null;
    const o = i.extensions[t], a = s.images[o.source];
    let l = n.textureLoader;
    if (a.uri) {
      const c = n.options.manager.getHandler(a.uri);
      c !== null && (l = c);
    }
    return this.detectSupport().then(function(c) {
      if (c)
        return n.loadTextureImage(e, o.source, l);
      if (s.extensionsRequired && s.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class Uh {
  constructor(e) {
    this.name = Oe.EXT_MESHOPT_COMPRESSION, this.parser = e;
  }
  loadBufferView(e) {
    const t = this.parser.json, n = t.bufferViews[e];
    if (n.extensions && n.extensions[this.name]) {
      const s = n.extensions[this.name], i = this.parser.getDependency("buffer", s.buffer), o = this.parser.options.meshoptDecoder;
      if (!o || !o.supported) {
        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        return null;
      }
      return i.then(function(a) {
        const l = s.byteOffset || 0, c = s.byteLength || 0, f = s.count, u = s.byteStride, d = new Uint8Array(a, l, c);
        return o.decodeGltfBufferAsync ? o.decodeGltfBufferAsync(f, u, d, s.mode, s.filter).then(function(h) {
          return h.buffer;
        }) : o.ready.then(function() {
          const h = new ArrayBuffer(f * u);
          return o.decodeGltfBuffer(
            new Uint8Array(h),
            f,
            u,
            d,
            s.mode,
            s.filter
          ), h;
        });
      });
    } else
      return null;
  }
}
class Fh {
  constructor(e) {
    this.name = Oe.EXT_MESH_GPU_INSTANCING, this.parser = e;
  }
  createNodeMesh(e) {
    const t = this.parser.json, n = t.nodes[e];
    if (!n.extensions || !n.extensions[this.name] || n.mesh === void 0)
      return null;
    const s = t.meshes[n.mesh];
    for (const c of s.primitives)
      if (c.mode !== At.TRIANGLES && c.mode !== At.TRIANGLE_STRIP && c.mode !== At.TRIANGLE_FAN && c.mode !== void 0)
        return null;
    const o = n.extensions[this.name].attributes, a = [], l = {};
    for (const c in o)
      a.push(
        this.parser.getDependency("accessor", o[c]).then((f) => (l[c] = f, l[c]))
      );
    return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(e)), Promise.all(a).then((c) => {
      const f = c.pop(), u = f.isGroup ? f.children : [f], d = c[0].count, h = [];
      for (const m of u) {
        const g = new Ie(), v = new $(), p = new je(), b = new $(1, 1, 1), _ = new Ta(m.geometry, m.material, d);
        for (let M = 0; M < d; M++)
          l.TRANSLATION && v.fromBufferAttribute(l.TRANSLATION, M), l.ROTATION && p.fromBufferAttribute(l.ROTATION, M), l.SCALE && b.fromBufferAttribute(l.SCALE, M), _.setMatrixAt(M, g.compose(v, p, b));
        for (const M in l)
          if (M === "_COLOR_0") {
            const R = l[M];
            _.instanceColor = new Ll(R.array, R.itemSize, R.normalized);
          } else M !== "TRANSLATION" && M !== "ROTATION" && M !== "SCALE" && m.geometry.setAttribute(M, l[M]);
        Rt.prototype.copy.call(_, m), this.parser.assignFinalMaterial(_), h.push(_);
      }
      return f.isGroup ? (f.clear(), f.add(...h), f) : h[0];
    }));
  }
}
const Ja = "glTF", ls = 12, fr = { JSON: 1313821514, BIN: 5130562 };
class zh {
  constructor(e) {
    this.name = Oe.KHR_BINARY_GLTF, this.content = null, this.body = null;
    const t = new DataView(e, 0, ls);
    if (this.header = {
      magic: ns(new Uint8Array(e.slice(0, 4))),
      version: t.getUint32(4, !0),
      length: t.getUint32(8, !0)
    }, this.header.magic !== Ja)
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const n = this.header.length - ls, s = new DataView(e, ls);
    let i = 0;
    for (; i < n; ) {
      const o = s.getUint32(i, !0);
      i += 4;
      const a = s.getUint32(i, !0);
      if (i += 4, a === fr.JSON) {
        const l = new Uint8Array(e, ls + i, o);
        this.content = ns(l);
      } else if (a === fr.BIN) {
        const l = ls + i;
        this.body = e.slice(l, l + o);
      }
      i += o;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class Gh {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = Oe.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const n = this.json, s = this.dracoLoader, i = e.extensions[this.name].bufferView, o = e.extensions[this.name].attributes, a = {}, l = {}, c = {};
    for (const f in o) {
      const u = _o[f] || f.toLowerCase();
      a[u] = o[f];
    }
    for (const f in e.attributes) {
      const u = _o[f] || f.toLowerCase();
      if (o[f] !== void 0) {
        const d = n.accessors[e.attributes[f]], h = Qn[d.componentType];
        c[u] = h.name, l[u] = d.normalized === !0;
      }
    }
    return t.getDependency("bufferView", i).then(function(f) {
      return new Promise(function(u, d) {
        s.decodeDracoFile(
          f,
          function(h) {
            for (const m in h.attributes) {
              const g = h.attributes[m], v = l[m];
              v !== void 0 && (g.normalized = v);
            }
            u(h);
          },
          a,
          c,
          sn,
          d
        );
      });
    });
  }
}
class Hh {
  constructor() {
    this.name = Oe.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e;
  }
}
class jh {
  constructor() {
    this.name = Oe.KHR_MESH_QUANTIZATION;
  }
}
class el extends Fl {
  constructor(e, t, n, s) {
    super(e, t, n, s);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, n = this.sampleValues, s = this.valueSize, i = e * s * 3 + s;
    for (let o = 0; o !== s; o++)
      t[o] = n[i + o];
    return t;
  }
  interpolate_(e, t, n, s) {
    const i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = a * 2, c = a * 3, f = s - t, u = (n - t) / f, d = u * u, h = d * u, m = e * c, g = m - c, v = -2 * h + 3 * d, p = h - d, b = 1 - v, _ = p - d + u;
    for (let M = 0; M !== a; M++) {
      const R = o[g + M + a], w = o[g + M + l] * f, E = o[m + M + a], x = o[m + M] * f;
      i[M] = b * R + _ * w + v * E + p * x;
    }
    return i;
  }
}
const Vh = new je();
class Yh extends el {
  interpolate_(e, t, n, s) {
    const i = super.interpolate_(e, t, n, s);
    return Vh.fromArray(i).normalize().toArray(i), i;
  }
}
const At = {
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6
}, Qn = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
}, dr = {
  9728: Kn,
  9729: wt,
  9984: da,
  9985: ma,
  9986: pa,
  9987: Eo
}, pr = {
  33071: Wt,
  33648: ga,
  10497: Ln
}, Ri = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, _o = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  // uv => uv1, 4 uv channels
  // https://github.com/mrdoob/three.js/pull/25943
  // https://github.com/mrdoob/three.js/pull/25788
  ...Ss >= 152 ? {
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv1",
    TEXCOORD_2: "uv2",
    TEXCOORD_3: "uv3"
  } : {
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv2"
  },
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
}, dn = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
}, Wh = {
  CUBICSPLINE: void 0,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: Mo,
  STEP: fa
}, Ci = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function Xh(r) {
  return r.DefaultMaterial === void 0 && (r.DefaultMaterial = new Es({
    color: 16777215,
    emissive: 0,
    metalness: 1,
    roughness: 1,
    transparent: !1,
    depthTest: !0,
    side: ss
  })), r.DefaultMaterial;
}
function An(r, e, t) {
  for (const n in t.extensions)
    r[n] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[n] = t.extensions[n]);
}
function en(r, e) {
  e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(r.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras));
}
function $h(r, e, t) {
  let n = !1, s = !1, i = !1;
  for (let c = 0, f = e.length; c < f; c++) {
    const u = e[c];
    if (u.POSITION !== void 0 && (n = !0), u.NORMAL !== void 0 && (s = !0), u.COLOR_0 !== void 0 && (i = !0), n && s && i)
      break;
  }
  if (!n && !s && !i)
    return Promise.resolve(r);
  const o = [], a = [], l = [];
  for (let c = 0, f = e.length; c < f; c++) {
    const u = e[c];
    if (n) {
      const d = u.POSITION !== void 0 ? t.getDependency("accessor", u.POSITION) : r.attributes.position;
      o.push(d);
    }
    if (s) {
      const d = u.NORMAL !== void 0 ? t.getDependency("accessor", u.NORMAL) : r.attributes.normal;
      a.push(d);
    }
    if (i) {
      const d = u.COLOR_0 !== void 0 ? t.getDependency("accessor", u.COLOR_0) : r.attributes.color;
      l.push(d);
    }
  }
  return Promise.all([
    Promise.all(o),
    Promise.all(a),
    Promise.all(l)
  ]).then(function(c) {
    const f = c[0], u = c[1], d = c[2];
    return n && (r.morphAttributes.position = f), s && (r.morphAttributes.normal = u), i && (r.morphAttributes.color = d), r.morphTargetsRelative = !0, r;
  });
}
function Zh(r, e) {
  if (r.updateMorphTargets(), e.weights !== void 0)
    for (let t = 0, n = e.weights.length; t < n; t++)
      r.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (r.morphTargetInfluences.length === t.length) {
      r.morphTargetDictionary = {};
      for (let n = 0, s = t.length; n < s; n++)
        r.morphTargetDictionary[t[n]] = n;
    } else
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
  }
}
function Kh(r) {
  let e;
  const t = r.extensions && r.extensions[Oe.KHR_DRACO_MESH_COMPRESSION];
  if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + Ii(t.attributes) : e = r.indices + ":" + Ii(r.attributes) + ":" + r.mode, r.targets !== void 0)
    for (let n = 0, s = r.targets.length; n < s; n++)
      e += ":" + Ii(r.targets[n]);
  return e;
}
function Ii(r) {
  let e = "";
  const t = Object.keys(r).sort();
  for (let n = 0, s = t.length; n < s; n++)
    e += t[n] + ":" + r[t[n]] + ";";
  return e;
}
function xo(r) {
  switch (r) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function qh(r) {
  return r.search(/\.jpe?g($|\?)/i) > 0 || r.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : r.search(/\.webp($|\?)/i) > 0 || r.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png";
}
const Qh = new Ie();
class Jh {
  constructor(e = {}, t = {}) {
    this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new wh(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
    let n = !1, s = !1, i = -1;
    typeof navigator < "u" && typeof navigator.userAgent < "u" && (n = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, s = navigator.userAgent.indexOf("Firefox") > -1, i = s ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || n || s && i < 98 ? this.textureLoader = new ai(this.options.manager) : this.textureLoader = new kl(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new kn(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const n = this, s = this.json, i = this.extensions;
    this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(o) {
      return o._markDefs && o._markDefs();
    }), Promise.all(
      this._invokeAll(function(o) {
        return o.beforeRoot && o.beforeRoot();
      })
    ).then(function() {
      return Promise.all([
        n.getDependencies("scene"),
        n.getDependencies("animation"),
        n.getDependencies("camera")
      ]);
    }).then(function(o) {
      const a = {
        scene: o[0][s.scene || 0],
        scenes: o[0],
        animations: o[1],
        cameras: o[2],
        asset: s.asset,
        parser: n,
        userData: {}
      };
      return An(i, a, s), en(a, s), Promise.all(
        n._invokeAll(function(l) {
          return l.afterRoot && l.afterRoot(a);
        })
      ).then(function() {
        for (const l of a.scenes)
          l.updateMatrixWorld();
        e(a);
      });
    }).catch(t);
  }
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */
  _markDefs() {
    const e = this.json.nodes || [], t = this.json.skins || [], n = this.json.meshes || [];
    for (let s = 0, i = t.length; s < i; s++) {
      const o = t[s].joints;
      for (let a = 0, l = o.length; a < l; a++)
        e[o[a]].isBone = !0;
    }
    for (let s = 0, i = e.length; s < i; s++) {
      const o = e[s];
      o.mesh !== void 0 && (this._addNodeRef(this.meshCache, o.mesh), o.skin !== void 0 && (n[o.mesh].isSkinnedMesh = !0)), o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera);
    }
  }
  /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   */
  _addNodeRef(e, t) {
    t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  /** Returns a reference to a shared resource, cloning it if necessary. */
  _getNodeRef(e, t, n) {
    if (e.refs[t] <= 1)
      return n;
    const s = n.clone(), i = (o, a) => {
      const l = this.associations.get(o);
      l != null && this.associations.set(a, l);
      for (const [c, f] of o.children.entries())
        i(f, a.children[c]);
    };
    return i(n, s), s.name += "_instance_" + e.uses[t]++, s;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let n = 0; n < t.length; n++) {
      const s = e(t[n]);
      if (s)
        return s;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const n = [];
    for (let s = 0; s < t.length; s++) {
      const i = e(t[s]);
      i && n.push(i);
    }
    return n;
  }
  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */
  getDependency(e, t) {
    const n = e + ":" + t;
    let s = this.cache.get(n);
    if (!s) {
      switch (e) {
        case "scene":
          s = this.loadScene(t);
          break;
        case "node":
          s = this._invokeOne(function(i) {
            return i.loadNode && i.loadNode(t);
          });
          break;
        case "mesh":
          s = this._invokeOne(function(i) {
            return i.loadMesh && i.loadMesh(t);
          });
          break;
        case "accessor":
          s = this.loadAccessor(t);
          break;
        case "bufferView":
          s = this._invokeOne(function(i) {
            return i.loadBufferView && i.loadBufferView(t);
          });
          break;
        case "buffer":
          s = this.loadBuffer(t);
          break;
        case "material":
          s = this._invokeOne(function(i) {
            return i.loadMaterial && i.loadMaterial(t);
          });
          break;
        case "texture":
          s = this._invokeOne(function(i) {
            return i.loadTexture && i.loadTexture(t);
          });
          break;
        case "skin":
          s = this.loadSkin(t);
          break;
        case "animation":
          s = this._invokeOne(function(i) {
            return i.loadAnimation && i.loadAnimation(t);
          });
          break;
        case "camera":
          s = this.loadCamera(t);
          break;
        default:
          if (s = this._invokeOne(function(i) {
            return i != this && i.getDependency && i.getDependency(e, t);
          }), !s)
            throw new Error("Unknown type: " + e);
          break;
      }
      this.cache.add(n, s);
    }
    return s;
  }
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const n = this, s = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      t = Promise.all(
        s.map(function(i, o) {
          return n.getDependency(e, o);
        })
      ), this.cache.add(e, t);
    }
    return t;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBuffer(e) {
    const t = this.json.buffers[e], n = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[Oe.KHR_BINARY_GLTF].body);
    const s = this.options;
    return new Promise(function(i, o) {
      n.load(qn.resolveURL(t.uri, s.path), i, void 0, function() {
        o(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
      });
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function(n) {
      const s = t.byteLength || 0, i = t.byteOffset || 0;
      return n.slice(i, i + s);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */
  loadAccessor(e) {
    const t = this, n = this.json, s = this.json.accessors[e];
    if (s.bufferView === void 0 && s.sparse === void 0) {
      const o = Ri[s.type], a = Qn[s.componentType], l = s.normalized === !0, c = new a(s.count * o);
      return Promise.resolve(new ut(c, o, l));
    }
    const i = [];
    return s.bufferView !== void 0 ? i.push(this.getDependency("bufferView", s.bufferView)) : i.push(null), s.sparse !== void 0 && (i.push(this.getDependency("bufferView", s.sparse.indices.bufferView)), i.push(this.getDependency("bufferView", s.sparse.values.bufferView))), Promise.all(i).then(function(o) {
      const a = o[0], l = Ri[s.type], c = Qn[s.componentType], f = c.BYTES_PER_ELEMENT, u = f * l, d = s.byteOffset || 0, h = s.bufferView !== void 0 ? n.bufferViews[s.bufferView].byteStride : void 0, m = s.normalized === !0;
      let g, v;
      if (h && h !== u) {
        const p = Math.floor(d / h), b = "InterleavedBuffer:" + s.bufferView + ":" + s.componentType + ":" + p + ":" + s.count;
        let _ = t.cache.get(b);
        _ || (g = new c(a, p * h, s.count * h / f), _ = new Ao(g, h / f), t.cache.add(b, _)), v = new nn(
          _,
          l,
          d % h / f,
          m
        );
      } else
        a === null ? g = new c(s.count * l) : g = new c(a, d, s.count * l), v = new ut(g, l, m);
      if (s.sparse !== void 0) {
        const p = Ri.SCALAR, b = Qn[s.sparse.indices.componentType], _ = s.sparse.indices.byteOffset || 0, M = s.sparse.values.byteOffset || 0, R = new b(
          o[1],
          _,
          s.sparse.count * p
        ), w = new c(o[2], M, s.sparse.count * l);
        a !== null && (v = new ut(
          v.array.slice(),
          v.itemSize,
          v.normalized
        ));
        for (let E = 0, x = R.length; E < x; E++) {
          const T = R[E];
          if (v.setX(T, w[E * l]), l >= 2 && v.setY(T, w[E * l + 1]), l >= 3 && v.setZ(T, w[E * l + 2]), l >= 4 && v.setW(T, w[E * l + 3]), l >= 5)
            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return v;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture|null>}
   */
  loadTexture(e) {
    const t = this.json, n = this.options, i = t.textures[e].source, o = t.images[i];
    let a = this.textureLoader;
    if (o.uri) {
      const l = n.manager.getHandler(o.uri);
      l !== null && (a = l);
    }
    return this.loadTextureImage(e, i, a);
  }
  loadTextureImage(e, t, n) {
    const s = this, i = this.json, o = i.textures[e], a = i.images[t], l = (a.uri || a.bufferView) + ":" + o.sampler;
    if (this.textureCache[l])
      return this.textureCache[l];
    const c = this.loadImageSource(t, n).then(function(f) {
      f.flipY = !1, f.name = o.name || a.name || "", f.name === "" && typeof a.uri == "string" && a.uri.startsWith("data:image/") === !1 && (f.name = a.uri);
      const d = (i.samplers || {})[o.sampler] || {};
      return f.magFilter = dr[d.magFilter] || wt, f.minFilter = dr[d.minFilter] || Eo, f.wrapS = pr[d.wrapS] || Ln, f.wrapT = pr[d.wrapT] || Ln, s.associations.set(f, { textures: e }), f;
    }).catch(function() {
      return null;
    });
    return this.textureCache[l] = c, c;
  }
  loadImageSource(e, t) {
    const n = this, s = this.json, i = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((u) => u.clone());
    const o = s.images[e], a = self.URL || self.webkitURL;
    let l = o.uri || "", c = !1;
    if (o.bufferView !== void 0)
      l = n.getDependency("bufferView", o.bufferView).then(function(u) {
        c = !0;
        const d = new Blob([u], { type: o.mimeType });
        return l = a.createObjectURL(d), l;
      });
    else if (o.uri === void 0)
      throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
    const f = Promise.resolve(l).then(function(u) {
      return new Promise(function(d, h) {
        let m = d;
        t.isImageBitmapLoader === !0 && (m = function(g) {
          const v = new es(g);
          v.needsUpdate = !0, d(v);
        }), t.load(qn.resolveURL(u, i.path), m, void 0, h);
      });
    }).then(function(u) {
      return c === !0 && a.revokeObjectURL(l), en(u, o), u.userData.mimeType = o.mimeType || qh(o.uri), u;
    }).catch(function(u) {
      throw console.error("THREE.GLTFLoader: Couldn't load texture", l), u;
    });
    return this.sourceCache[e] = f, f;
  }
  /**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @return {Promise<Texture>}
   */
  assignTexture(e, t, n, s) {
    const i = this;
    return this.getDependency("texture", n.index).then(function(o) {
      if (!o)
        return null;
      if (n.texCoord !== void 0 && n.texCoord > 0 && (o = o.clone(), o.channel = n.texCoord), i.extensions[Oe.KHR_TEXTURE_TRANSFORM]) {
        const a = n.extensions !== void 0 ? n.extensions[Oe.KHR_TEXTURE_TRANSFORM] : void 0;
        if (a) {
          const l = i.associations.get(o);
          o = i.extensions[Oe.KHR_TEXTURE_TRANSFORM].extendTexture(o, a), i.associations.set(o, l);
        }
      }
      return s !== void 0 && (typeof s == "number" && (s = s === hr ? In : sn), "colorSpace" in o ? o.colorSpace = s : o.encoding = s === In ? hr : _h), e[t] = o, o;
    });
  }
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */
  assignFinalMaterial(e) {
    const t = e.geometry;
    let n = e.material;
    const s = t.attributes.tangent === void 0, i = t.attributes.color !== void 0, o = t.attributes.normal === void 0;
    if (e.isPoints) {
      const a = "PointsMaterial:" + n.uuid;
      let l = this.cache.get(a);
      l || (l = new Nl(), vi.prototype.copy.call(l, n), l.color.copy(n.color), l.map = n.map, l.sizeAttenuation = !1, this.cache.add(a, l)), n = l;
    } else if (e.isLine) {
      const a = "LineBasicMaterial:" + n.uuid;
      let l = this.cache.get(a);
      l || (l = new ws(), vi.prototype.copy.call(l, n), l.color.copy(n.color), l.map = n.map, this.cache.add(a, l)), n = l;
    }
    if (s || i || o) {
      let a = "ClonedMaterial:" + n.uuid + ":";
      s && (a += "derivative-tangents:"), i && (a += "vertex-colors:"), o && (a += "flat-shading:");
      let l = this.cache.get(a);
      l || (l = n.clone(), i && (l.vertexColors = !0), o && (l.flatShading = !0), s && (l.normalScale && (l.normalScale.y *= -1), l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)), this.cache.add(a, l), this.associations.set(l, this.associations.get(n))), n = l;
    }
    e.material = n;
  }
  getMaterialType() {
    return Es;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */
  loadMaterial(e) {
    const t = this, n = this.json, s = this.extensions, i = n.materials[e];
    let o;
    const a = {}, l = i.extensions || {}, c = [];
    if (l[Oe.KHR_MATERIALS_UNLIT]) {
      const u = s[Oe.KHR_MATERIALS_UNLIT];
      o = u.getMaterialType(), c.push(u.extendParams(a, i, t));
    } else {
      const u = i.pbrMetallicRoughness || {};
      if (a.color = new be(1, 1, 1), a.opacity = 1, Array.isArray(u.baseColorFactor)) {
        const d = u.baseColorFactor;
        a.color.setRGB(d[0], d[1], d[2], sn), a.opacity = d[3];
      }
      u.baseColorTexture !== void 0 && c.push(t.assignTexture(a, "map", u.baseColorTexture, In)), a.metalness = u.metallicFactor !== void 0 ? u.metallicFactor : 1, a.roughness = u.roughnessFactor !== void 0 ? u.roughnessFactor : 1, u.metallicRoughnessTexture !== void 0 && (c.push(t.assignTexture(a, "metalnessMap", u.metallicRoughnessTexture)), c.push(t.assignTexture(a, "roughnessMap", u.metallicRoughnessTexture))), o = this._invokeOne(function(d) {
        return d.getMaterialType && d.getMaterialType(e);
      }), c.push(
        Promise.all(
          this._invokeAll(function(d) {
            return d.extendMaterialParams && d.extendMaterialParams(e, a);
          })
        )
      );
    }
    i.doubleSided === !0 && (a.side = on);
    const f = i.alphaMode || Ci.OPAQUE;
    if (f === Ci.BLEND ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, f === Ci.MASK && (a.alphaTest = i.alphaCutoff !== void 0 ? i.alphaCutoff : 0.5)), i.normalTexture !== void 0 && o !== $t && (c.push(t.assignTexture(a, "normalMap", i.normalTexture)), a.normalScale = new ve(1, 1), i.normalTexture.scale !== void 0)) {
      const u = i.normalTexture.scale;
      a.normalScale.set(u, u);
    }
    if (i.occlusionTexture !== void 0 && o !== $t && (c.push(t.assignTexture(a, "aoMap", i.occlusionTexture)), i.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = i.occlusionTexture.strength)), i.emissiveFactor !== void 0 && o !== $t) {
      const u = i.emissiveFactor;
      a.emissive = new be().setRGB(
        u[0],
        u[1],
        u[2],
        sn
      );
    }
    return i.emissiveTexture !== void 0 && o !== $t && c.push(t.assignTexture(a, "emissiveMap", i.emissiveTexture, In)), Promise.all(c).then(function() {
      const u = new o(a);
      return i.name && (u.name = i.name), en(u, i), t.associations.set(u, { materials: e }), i.extensions && An(s, u, i), u;
    });
  }
  /** When Object3D instances are targeted by animation, they need unique names. */
  createUniqueName(e) {
    const t = rn.sanitizeNodeName(e || "");
    return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */
  loadGeometries(e) {
    const t = this, n = this.extensions, s = this.primitiveCache;
    function i(a) {
      return n[Oe.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, t).then(function(l) {
        return mr(l, a, t);
      });
    }
    const o = [];
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a], f = Kh(c), u = s[f];
      if (u)
        o.push(u.promise);
      else {
        let d;
        c.extensions && c.extensions[Oe.KHR_DRACO_MESH_COMPRESSION] ? d = i(c) : d = mr(new ht(), c, t), s[f] = { primitive: c, promise: d }, o.push(d);
      }
    }
    return Promise.all(o);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */
  loadMesh(e) {
    const t = this, n = this.json, s = this.extensions, i = n.meshes[e], o = i.primitives, a = [];
    for (let l = 0, c = o.length; l < c; l++) {
      const f = o[l].material === void 0 ? Xh(this.cache) : this.getDependency("material", o[l].material);
      a.push(f);
    }
    return a.push(t.loadGeometries(o)), Promise.all(a).then(function(l) {
      const c = l.slice(0, l.length - 1), f = l[l.length - 1], u = [];
      for (let h = 0, m = f.length; h < m; h++) {
        const g = f[h], v = o[h];
        let p;
        const b = c[h];
        if (v.mode === At.TRIANGLES || v.mode === At.TRIANGLE_STRIP || v.mode === At.TRIANGLE_FAN || v.mode === void 0)
          p = i.isSkinnedMesh === !0 ? new Po(g, b) : new de(g, b), p.isSkinnedMesh === !0 && p.normalizeSkinWeights(), v.mode === At.TRIANGLE_STRIP ? p.geometry = er(p.geometry, ha) : v.mode === At.TRIANGLE_FAN && (p.geometry = er(p.geometry, oo));
        else if (v.mode === At.LINES)
          p = new Bl(g, b);
        else if (v.mode === At.LINE_STRIP)
          p = new ke(g, b);
        else if (v.mode === At.LINE_LOOP)
          p = new Ul(g, b);
        else if (v.mode === At.POINTS)
          p = new ba(g, b);
        else
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + v.mode);
        Object.keys(p.geometry.morphAttributes).length > 0 && Zh(p, i), p.name = t.createUniqueName(i.name || "mesh_" + e), en(p, i), v.extensions && An(s, p, v), t.assignFinalMaterial(p), u.push(p);
      }
      for (let h = 0, m = u.length; h < m; h++)
        t.associations.set(u[h], {
          meshes: e,
          primitives: h
        });
      if (u.length === 1)
        return i.extensions && An(s, u[0], i), u[0];
      const d = new Zt();
      i.extensions && An(s, d, i), t.associations.set(d, { meshes: e });
      for (let h = 0, m = u.length; h < m; h++)
        d.add(u[h]);
      return d;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */
  loadCamera(e) {
    let t;
    const n = this.json.cameras[e], s = n[n.type];
    if (!s) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return n.type === "perspective" ? t = new kt(
      Ye.radToDeg(s.yfov),
      s.aspectRatio || 1,
      s.znear || 1,
      s.zfar || 2e6
    ) : n.type === "orthographic" && (t = new _n(-s.xmag, s.xmag, s.ymag, -s.ymag, s.znear, s.zfar)), n.name && (t.name = this.createUniqueName(n.name)), en(t, n), Promise.resolve(t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Skeleton>}
   */
  loadSkin(e) {
    const t = this.json.skins[e], n = [];
    for (let s = 0, i = t.joints.length; s < i; s++)
      n.push(this._loadNodeShallow(t.joints[s]));
    return t.inverseBindMatrices !== void 0 ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null), Promise.all(n).then(function(s) {
      const i = s.pop(), o = s, a = [], l = [];
      for (let c = 0, f = o.length; c < f; c++) {
        const u = o[c];
        if (u) {
          a.push(u);
          const d = new Ie();
          i !== null && d.fromArray(i.array, c * 16), l.push(d);
        } else
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[c]);
      }
      return new Ea(a, l);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(e) {
    const t = this.json, n = this, s = t.animations[e], i = s.name ? s.name : "animation_" + e, o = [], a = [], l = [], c = [], f = [];
    for (let u = 0, d = s.channels.length; u < d; u++) {
      const h = s.channels[u], m = s.samplers[h.sampler], g = h.target, v = g.node, p = s.parameters !== void 0 ? s.parameters[m.input] : m.input, b = s.parameters !== void 0 ? s.parameters[m.output] : m.output;
      g.node !== void 0 && (o.push(this.getDependency("node", v)), a.push(this.getDependency("accessor", p)), l.push(this.getDependency("accessor", b)), c.push(m), f.push(g));
    }
    return Promise.all([
      Promise.all(o),
      Promise.all(a),
      Promise.all(l),
      Promise.all(c),
      Promise.all(f)
    ]).then(function(u) {
      const d = u[0], h = u[1], m = u[2], g = u[3], v = u[4], p = [];
      for (let b = 0, _ = d.length; b < _; b++) {
        const M = d[b], R = h[b], w = m[b], E = g[b], x = v[b];
        if (M === void 0)
          continue;
        M.updateMatrix && M.updateMatrix();
        const T = n._createAnimationTracks(M, R, w, E, x);
        if (T)
          for (let y = 0; y < T.length; y++)
            p.push(T[y]);
      }
      return new Ma(i, void 0, p);
    });
  }
  createNodeMesh(e) {
    const t = this.json, n = this, s = t.nodes[e];
    return s.mesh === void 0 ? null : n.getDependency("mesh", s.mesh).then(function(i) {
      const o = n._getNodeRef(n.meshCache, s.mesh, i);
      return s.weights !== void 0 && o.traverse(function(a) {
        if (a.isMesh)
          for (let l = 0, c = s.weights.length; l < c; l++)
            a.morphTargetInfluences[l] = s.weights[l];
      }), o;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */
  loadNode(e) {
    const t = this.json, n = this, s = t.nodes[e], i = n._loadNodeShallow(e), o = [], a = s.children || [];
    for (let c = 0, f = a.length; c < f; c++)
      o.push(n.getDependency("node", a[c]));
    const l = s.skin === void 0 ? Promise.resolve(null) : n.getDependency("skin", s.skin);
    return Promise.all([i, Promise.all(o), l]).then(function(c) {
      const f = c[0], u = c[1], d = c[2];
      d !== null && f.traverse(function(h) {
        h.isSkinnedMesh && h.bind(d, Qh);
      });
      for (let h = 0, m = u.length; h < m; h++)
        f.add(u[h]);
      return f;
    });
  }
  // ._loadNodeShallow() parses a single node.
  // skin and child nodes are created and added in .loadNode() (no '_' prefix).
  _loadNodeShallow(e) {
    const t = this.json, n = this.extensions, s = this;
    if (this.nodeCache[e] !== void 0)
      return this.nodeCache[e];
    const i = t.nodes[e], o = i.name ? s.createUniqueName(i.name) : "", a = [], l = s._invokeOne(function(c) {
      return c.createNodeMesh && c.createNodeMesh(e);
    });
    return l && a.push(l), i.camera !== void 0 && a.push(
      s.getDependency("camera", i.camera).then(function(c) {
        return s._getNodeRef(s.cameraCache, i.camera, c);
      })
    ), s._invokeAll(function(c) {
      return c.createNodeAttachment && c.createNodeAttachment(e);
    }).forEach(function(c) {
      a.push(c);
    }), this.nodeCache[e] = Promise.all(a).then(function(c) {
      let f;
      if (i.isBone === !0 ? f = new ao() : c.length > 1 ? f = new Zt() : c.length === 1 ? f = c[0] : f = new Rt(), f !== c[0])
        for (let u = 0, d = c.length; u < d; u++)
          f.add(c[u]);
      if (i.name && (f.userData.name = i.name, f.name = o), en(f, i), i.extensions && An(n, f, i), i.matrix !== void 0) {
        const u = new Ie();
        u.fromArray(i.matrix), f.applyMatrix4(u);
      } else
        i.translation !== void 0 && f.position.fromArray(i.translation), i.rotation !== void 0 && f.quaternion.fromArray(i.rotation), i.scale !== void 0 && f.scale.fromArray(i.scale);
      return s.associations.has(f) || s.associations.set(f, {}), s.associations.get(f).nodes = e, f;
    }), this.nodeCache[e];
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */
  loadScene(e) {
    const t = this.extensions, n = this.json.scenes[e], s = this, i = new Zt();
    n.name && (i.name = s.createUniqueName(n.name)), en(i, n), n.extensions && An(t, i, n);
    const o = n.nodes || [], a = [];
    for (let l = 0, c = o.length; l < c; l++)
      a.push(s.getDependency("node", o[l]));
    return Promise.all(a).then(function(l) {
      for (let f = 0, u = l.length; f < u; f++)
        i.add(l[f]);
      const c = (f) => {
        const u = /* @__PURE__ */ new Map();
        for (const [d, h] of s.associations)
          (d instanceof vi || d instanceof es) && u.set(d, h);
        return f.traverse((d) => {
          const h = s.associations.get(d);
          h != null && u.set(d, h);
        }), u;
      };
      return s.associations = c(i), i;
    });
  }
  _createAnimationTracks(e, t, n, s, i) {
    const o = [], a = e.name ? e.name : e.uuid, l = [];
    dn[i.path] === dn.weights ? e.traverse(function(d) {
      d.morphTargetInfluences && l.push(d.name ? d.name : d.uuid);
    }) : l.push(a);
    let c;
    switch (dn[i.path]) {
      case dn.weights:
        c = co;
        break;
      case dn.rotation:
        c = uo;
        break;
      case dn.position:
      case dn.scale:
        c = lo;
        break;
      default:
        switch (n.itemSize) {
          case 1:
            c = co;
            break;
          case 2:
          case 3:
          default:
            c = lo;
            break;
        }
        break;
    }
    const f = s.interpolation !== void 0 ? Wh[s.interpolation] : Mo, u = this._getArrayFromAccessor(n);
    for (let d = 0, h = l.length; d < h; d++) {
      const m = new c(
        l[d] + "." + dn[i.path],
        t.array,
        u,
        f
      );
      s.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(m), o.push(m);
    }
    return o;
  }
  _getArrayFromAccessor(e) {
    let t = e.array;
    if (e.normalized) {
      const n = xo(t.constructor), s = new Float32Array(t.length);
      for (let i = 0, o = t.length; i < o; i++)
        s[i] = t[i] * n;
      t = s;
    }
    return t;
  }
  _createCubicSplineTrackInterpolant(e) {
    e.createInterpolant = function(n) {
      const s = this instanceof uo ? Yh : el;
      return new s(this.times, this.values, this.getValueSize() / 3, n);
    }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0;
  }
}
function ef(r, e, t) {
  const n = e.attributes, s = new _t();
  if (n.POSITION !== void 0) {
    const a = t.json.accessors[n.POSITION], l = a.min, c = a.max;
    if (l !== void 0 && c !== void 0) {
      if (s.set(new $(l[0], l[1], l[2]), new $(c[0], c[1], c[2])), a.normalized) {
        const f = xo(Qn[a.componentType]);
        s.min.multiplyScalar(f), s.max.multiplyScalar(f);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else
    return;
  const i = e.targets;
  if (i !== void 0) {
    const a = new $(), l = new $();
    for (let c = 0, f = i.length; c < f; c++) {
      const u = i[c];
      if (u.POSITION !== void 0) {
        const d = t.json.accessors[u.POSITION], h = d.min, m = d.max;
        if (h !== void 0 && m !== void 0) {
          if (l.setX(Math.max(Math.abs(h[0]), Math.abs(m[0]))), l.setY(Math.max(Math.abs(h[1]), Math.abs(m[1]))), l.setZ(Math.max(Math.abs(h[2]), Math.abs(m[2]))), d.normalized) {
            const g = xo(Qn[d.componentType]);
            l.multiplyScalar(g);
          }
          a.max(l);
        } else
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      }
    }
    s.expandByVector(a);
  }
  r.boundingBox = s;
  const o = new Ms();
  s.getCenter(o.center), o.radius = s.min.distanceTo(s.max) / 2, r.boundingSphere = o;
}
function mr(r, e, t) {
  const n = e.attributes, s = [];
  function i(o, a) {
    return t.getDependency("accessor", o).then(function(l) {
      r.setAttribute(a, l);
    });
  }
  for (const o in n) {
    const a = _o[o] || o.toLowerCase();
    a in r.attributes || s.push(i(n[o], a));
  }
  if (e.indices !== void 0 && !r.index) {
    const o = t.getDependency("accessor", e.indices).then(function(a) {
      r.setIndex(a);
    });
    s.push(o);
  }
  return en(r, e), ef(r, e, t), Promise.all(s).then(function() {
    return e.targets !== void 0 ? $h(r, e.targets, t) : r;
  });
}
const cs = new $();
function Mt(r, e, t, n, s, i) {
  const o = 2 * Math.PI * s / 4, a = Math.max(i - 2 * s, 0), l = Math.PI / 4;
  cs.copy(e), cs[n] = 0, cs.normalize();
  const c = 0.5 * o / (o + a), f = 1 - cs.angleTo(r) / l;
  return Math.sign(cs[t]) === 1 ? f * c : a / (o + a) + c + c * (1 - f);
}
class tf extends Ht {
  constructor(e = 1, t = 1, n = 1, s = 2, i = 0.1) {
    if (s = s * 2 + 1, i = Math.min(e / 2, t / 2, n / 2, i), super(1, 1, 1, s, s, s), s === 1)
      return;
    const o = this.toNonIndexed();
    this.index = null, this.attributes.position = o.attributes.position, this.attributes.normal = o.attributes.normal, this.attributes.uv = o.attributes.uv;
    const a = new $(), l = new $(), c = new $(e, t, n).divideScalar(2).subScalar(i), f = this.attributes.position.array, u = this.attributes.normal.array, d = this.attributes.uv.array, h = f.length / 6, m = new $(), g = 0.5 / s;
    for (let v = 0, p = 0; v < f.length; v += 3, p += 2)
      switch (a.fromArray(f, v), l.copy(a), l.x -= Math.sign(l.x) * g, l.y -= Math.sign(l.y) * g, l.z -= Math.sign(l.z) * g, l.normalize(), f[v + 0] = c.x * Math.sign(a.x) + l.x * i, f[v + 1] = c.y * Math.sign(a.y) + l.y * i, f[v + 2] = c.z * Math.sign(a.z) + l.z * i, u[v + 0] = l.x, u[v + 1] = l.y, u[v + 2] = l.z, Math.floor(v / h)) {
        case 0:
          m.set(1, 0, 0), d[p + 0] = Mt(m, l, "z", "y", i, n), d[p + 1] = 1 - Mt(m, l, "y", "z", i, t);
          break;
        case 1:
          m.set(-1, 0, 0), d[p + 0] = 1 - Mt(m, l, "z", "y", i, n), d[p + 1] = 1 - Mt(m, l, "y", "z", i, t);
          break;
        case 2:
          m.set(0, 1, 0), d[p + 0] = 1 - Mt(m, l, "x", "z", i, e), d[p + 1] = Mt(m, l, "z", "x", i, n);
          break;
        case 3:
          m.set(0, -1, 0), d[p + 0] = 1 - Mt(m, l, "x", "z", i, e), d[p + 1] = 1 - Mt(m, l, "z", "x", i, n);
          break;
        case 4:
          m.set(0, 0, 1), d[p + 0] = 1 - Mt(m, l, "x", "y", i, e), d[p + 1] = 1 - Mt(m, l, "y", "x", i, t);
          break;
        case 5:
          m.set(0, 0, -1), d[p + 0] = Mt(m, l, "x", "y", i, e), d[p + 1] = 1 - Mt(m, l, "y", "x", i, t);
          break;
      }
  }
}
class gr extends zl {
  constructor(e, t = {}) {
    const {
      bevelEnabled: n = !1,
      bevelSize: s = 8,
      bevelThickness: i = 10,
      font: o,
      height: a = 50,
      size: l = 100,
      lineHeight: c = 1,
      letterSpacing: f = 0,
      ...u
    } = t;
    if (o === void 0)
      super();
    else {
      const d = o.generateShapes(e, l, { lineHeight: c, letterSpacing: f });
      super(d, { ...u, bevelEnabled: n, bevelSize: s, bevelThickness: i, depth: a });
    }
    this.type = "TextGeometry";
  }
}
const nf = {
  uniforms: {
    tDiffuse: { value: null },
    h: { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `
      varying vec2 vUv;

      void main() {

        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

      }
  `
  ),
  fragmentShader: (
    /* glsl */
    `
    uniform sampler2D tDiffuse;
    uniform float h;

    varying vec2 vUv;

    void main() {

    	vec4 sum = vec4( 0.0 );

    	sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;
    	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;

    	gl_FragColor = sum;

    }
  `
  )
}, sf = {
  uniforms: {
    tDiffuse: { value: null },
    v: { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `
    varying vec2 vUv;

    void main() {

      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

    }
  `
  ),
  fragmentShader: (
    /* glsl */
    `

  uniform sampler2D tDiffuse;
  uniform float v;

  varying vec2 vUv;

  void main() {

    vec4 sum = vec4( 0.0 );

    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;

    gl_FragColor = sum;

  }
  `
  )
};
function tl(r, e, t) {
  const n = t.length - r - 1;
  if (e >= t[n])
    return n - 1;
  if (e <= t[r])
    return r;
  let s = r, i = n, o = Math.floor((s + i) / 2);
  for (; e < t[o] || e >= t[o + 1]; )
    e < t[o] ? i = o : s = o, o = Math.floor((s + i) / 2);
  return o;
}
function of(r, e, t, n) {
  const s = [], i = [], o = [];
  s[0] = 1;
  for (let a = 1; a <= t; ++a) {
    i[a] = e - n[r + 1 - a], o[a] = n[r + a] - e;
    let l = 0;
    for (let c = 0; c < a; ++c) {
      const f = o[c + 1], u = i[a - c], d = s[c] / (f + u);
      s[c] = l + f * d, l = u * d;
    }
    s[a] = l;
  }
  return s;
}
function rf(r, e, t, n) {
  const s = tl(r, n, e), i = of(s, n, r, e), o = new at(0, 0, 0, 0);
  for (let a = 0; a <= r; ++a) {
    const l = t[s - r + a], c = i[a], f = l.w * c;
    o.x += l.x * f, o.y += l.y * f, o.z += l.z * f, o.w += l.w * c;
  }
  return o;
}
function af(r, e, t, n, s) {
  const i = [];
  for (let u = 0; u <= t; ++u)
    i[u] = 0;
  const o = [];
  for (let u = 0; u <= n; ++u)
    o[u] = i.slice(0);
  const a = [];
  for (let u = 0; u <= t; ++u)
    a[u] = i.slice(0);
  a[0][0] = 1;
  const l = i.slice(0), c = i.slice(0);
  for (let u = 1; u <= t; ++u) {
    l[u] = e - s[r + 1 - u], c[u] = s[r + u] - e;
    let d = 0;
    for (let h = 0; h < u; ++h) {
      const m = c[h + 1], g = l[u - h];
      a[u][h] = m + g;
      const v = a[h][u - 1] / a[u][h];
      a[h][u] = d + m * v, d = g * v;
    }
    a[u][u] = d;
  }
  for (let u = 0; u <= t; ++u)
    o[0][u] = a[u][t];
  for (let u = 0; u <= t; ++u) {
    let d = 0, h = 1;
    const m = [];
    for (let g = 0; g <= t; ++g)
      m[g] = i.slice(0);
    m[0][0] = 1;
    for (let g = 1; g <= n; ++g) {
      let v = 0;
      const p = u - g, b = t - g;
      u >= g && (m[h][0] = m[d][0] / a[b + 1][p], v = m[h][0] * a[p][b]);
      const _ = p >= -1 ? 1 : -p, M = u - 1 <= b ? g - 1 : t - u;
      for (let w = _; w <= M; ++w)
        m[h][w] = (m[d][w] - m[d][w - 1]) / a[b + 1][p + w], v += m[h][w] * a[p + w][b];
      u <= b && (m[h][g] = -m[d][g - 1] / a[b + 1][u], v += m[h][g] * a[u][b]), o[g][u] = v;
      const R = d;
      d = h, h = R;
    }
  }
  let f = t;
  for (let u = 1; u <= n; ++u) {
    for (let d = 0; d <= t; ++d)
      o[u][d] *= f;
    f *= t - u;
  }
  return o;
}
function lf(r, e, t, n, s) {
  const i = s < r ? s : r, o = [], a = tl(r, n, e), l = af(a, n, r, i, e), c = [];
  for (let f = 0; f < t.length; ++f) {
    const u = t[f].clone(), d = u.w;
    u.x *= d, u.y *= d, u.z *= d, c[f] = u;
  }
  for (let f = 0; f <= i; ++f) {
    const u = c[a - r].clone().multiplyScalar(l[f][0]);
    for (let d = 1; d <= r; ++d)
      u.add(c[a - r + d].clone().multiplyScalar(l[f][d]));
    o[f] = u;
  }
  for (let f = i + 1; f <= s + 1; ++f)
    o[f] = new at(0, 0, 0);
  return o;
}
function cf(r, e) {
  let t = 1;
  for (let s = 2; s <= r; ++s)
    t *= s;
  let n = 1;
  for (let s = 2; s <= e; ++s)
    n *= s;
  for (let s = 2; s <= r - e; ++s)
    n *= s;
  return t / n;
}
function uf(r) {
  const e = r.length, t = [], n = [];
  for (let i = 0; i < e; ++i) {
    const o = r[i];
    t[i] = new $(o.x, o.y, o.z), n[i] = o.w;
  }
  const s = [];
  for (let i = 0; i < e; ++i) {
    const o = t[i].clone();
    for (let a = 1; a <= i; ++a)
      o.sub(s[i - a].clone().multiplyScalar(cf(i, a) * n[a]));
    s[i] = o.divideScalar(n[0]);
  }
  return s;
}
function hf(r, e, t, n, s) {
  const i = lf(r, e, t, n, s);
  return uf(i);
}
class vr extends Gl {
  constructor(e, t, n, s, i) {
    super(), this.degree = e, this.knots = t, this.controlPoints = [], this.startKnot = s || 0, this.endKnot = i || this.knots.length - 1;
    for (let o = 0; o < n.length; ++o) {
      const a = n[o];
      this.controlPoints[o] = new at(a.x, a.y, a.z, a.w);
    }
  }
  getPoint(e, t) {
    const n = t || new $(), s = this.knots[this.startKnot] + e * (this.knots[this.endKnot] - this.knots[this.startKnot]), i = rf(this.degree, this.knots, this.controlPoints, s);
    return i.w != 1 && i.divideScalar(i.w), n.set(i.x, i.y, i.z);
  }
  getTangent(e, t) {
    const n = t || new $(), s = this.knots[0] + e * (this.knots[this.knots.length - 1] - this.knots[0]), i = hf(this.degree, this.knots, this.controlPoints, s, 1);
    return n.copy(i[1]).normalize(), n;
  }
}
let Ce, Qe, mt;
class ff extends Un {
  constructor(e) {
    super(e);
  }
  load(e, t, n, s) {
    const i = this, o = i.path === "" ? qn.extractUrlBase(e) : i.path, a = new kn(this.manager);
    a.setPath(i.path), a.setResponseType("arraybuffer"), a.setRequestHeader(i.requestHeader), a.setWithCredentials(i.withCredentials), a.load(
      e,
      function(l) {
        try {
          t(i.parse(l, o));
        } catch (c) {
          s ? s(c) : console.error(c), i.manager.itemError(e);
        }
      },
      n,
      s
    );
  }
  parse(e, t) {
    if (yf(e))
      Ce = new vf().parse(e);
    else {
      const s = ol(e);
      if (!_f(s))
        throw new Error("THREE.FBXLoader: Unknown format.");
      if (_r(s) < 7e3)
        throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + _r(s));
      Ce = new gf().parse(s);
    }
    const n = new ai(this.manager).setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin);
    return new df(n, this.manager).parse(Ce);
  }
}
class df {
  constructor(e, t) {
    this.textureLoader = e, this.manager = t;
  }
  parse() {
    Qe = this.parseConnections();
    const e = this.parseImages(), t = this.parseTextures(e), n = this.parseMaterials(t), s = this.parseDeformers(), i = new pf().parse(s);
    return this.parseScene(s, i, n), mt;
  }
  // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )
  // and details the connection type
  parseConnections() {
    const e = /* @__PURE__ */ new Map();
    return "Connections" in Ce && Ce.Connections.connections.forEach(function(n) {
      const s = n[0], i = n[1], o = n[2];
      e.has(s) || e.set(s, {
        parents: [],
        children: []
      });
      const a = { ID: i, relationship: o };
      e.get(s).parents.push(a), e.has(i) || e.set(i, {
        parents: [],
        children: []
      });
      const l = { ID: s, relationship: o };
      e.get(i).children.push(l);
    }), e;
  }
  // Parse FBXTree.Objects.Video for embedded image data
  // These images are connected to textures in FBXTree.Objects.Textures
  // via FBXTree.Connections.
  parseImages() {
    const e = {}, t = {};
    if ("Video" in Ce.Objects) {
      const n = Ce.Objects.Video;
      for (const s in n) {
        const i = n[s], o = parseInt(s);
        if (e[o] = i.RelativeFilename || i.Filename, "Content" in i) {
          const a = i.Content instanceof ArrayBuffer && i.Content.byteLength > 0, l = typeof i.Content == "string" && i.Content !== "";
          if (a || l) {
            const c = this.parseImage(n[s]);
            t[i.RelativeFilename || i.Filename] = c;
          }
        }
      }
    }
    for (const n in e) {
      const s = e[n];
      t[s] !== void 0 ? e[n] = t[s] : e[n] = e[n].split("\\").pop();
    }
    return e;
  }
  // Parse embedded image data in FBXTree.Video.Content
  parseImage(e) {
    const t = e.Content, n = e.RelativeFilename || e.Filename, s = n.slice(n.lastIndexOf(".") + 1).toLowerCase();
    let i;
    switch (s) {
      case "bmp":
        i = "image/bmp";
        break;
      case "jpg":
      case "jpeg":
        i = "image/jpeg";
        break;
      case "png":
        i = "image/png";
        break;
      case "tif":
        i = "image/tiff";
        break;
      case "tga":
        this.manager.getHandler(".tga") === null && console.warn("FBXLoader: TGA loader not found, skipping ", n), i = "image/tga";
        break;
      default:
        console.warn('FBXLoader: Image type "' + s + '" is not supported.');
        return;
    }
    if (typeof t == "string")
      return "data:" + i + ";base64," + t;
    {
      const o = new Uint8Array(t);
      return window.URL.createObjectURL(new Blob([o], { type: i }));
    }
  }
  // Parse nodes in FBXTree.Objects.Texture
  // These contain details such as UV scaling, cropping, rotation etc and are connected
  // to images in FBXTree.Objects.Video
  parseTextures(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Texture" in Ce.Objects) {
      const n = Ce.Objects.Texture;
      for (const s in n) {
        const i = this.parseTexture(n[s], e);
        t.set(parseInt(s), i);
      }
    }
    return t;
  }
  // Parse individual node in FBXTree.Objects.Texture
  parseTexture(e, t) {
    const n = this.loadTexture(e, t);
    n.ID = e.id, n.name = e.attrName;
    const s = e.WrapModeU, i = e.WrapModeV, o = s !== void 0 ? s.value : 0, a = i !== void 0 ? i.value : 0;
    if (n.wrapS = o === 0 ? Ln : Wt, n.wrapT = a === 0 ? Ln : Wt, "Scaling" in e) {
      const l = e.Scaling.value;
      n.repeat.x = l[0], n.repeat.y = l[1];
    }
    return n;
  }
  // load a texture specified as a blob or data URI, or via an external URL using TextureLoader
  loadTexture(e, t) {
    let n;
    const s = this.textureLoader.path, i = Qe.get(e.id).children;
    i !== void 0 && i.length > 0 && t[i[0].ID] !== void 0 && (n = t[i[0].ID], (n.indexOf("blob:") === 0 || n.indexOf("data:") === 0) && this.textureLoader.setPath(void 0));
    let o;
    const a = e.FileName.slice(-3).toLowerCase();
    if (a === "tga") {
      const l = this.manager.getHandler(".tga");
      l === null ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", e.RelativeFilename), o = new es()) : (l.setPath(this.textureLoader.path), o = l.load(n));
    } else a === "psd" ? (console.warn(
      "FBXLoader: PSD textures are not supported, creating placeholder texture for",
      e.RelativeFilename
    ), o = new es()) : o = this.textureLoader.load(n);
    return this.textureLoader.setPath(s), o;
  }
  // Parse nodes in FBXTree.Objects.Material
  parseMaterials(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Material" in Ce.Objects) {
      const n = Ce.Objects.Material;
      for (const s in n) {
        const i = this.parseMaterial(n[s], e);
        i !== null && t.set(parseInt(s), i);
      }
    }
    return t;
  }
  // Parse single node in FBXTree.Objects.Material
  // Materials are connected to texture maps in FBXTree.Objects.Textures
  // FBX format currently only supports Lambert and Phong shading models
  parseMaterial(e, t) {
    const n = e.id, s = e.attrName;
    let i = e.ShadingModel;
    if (typeof i == "object" && (i = i.value), !Qe.has(n))
      return null;
    const o = this.parseParameters(e, t, n);
    let a;
    switch (i.toLowerCase()) {
      case "phong":
        a = new yi();
        break;
      case "lambert":
        a = new Hl();
        break;
      default:
        console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', i), a = new yi();
        break;
    }
    return a.setValues(o), a.name = s, a;
  }
  // Parse FBX material and return parameters suitable for a three.js material
  // Also parse the texture map and return any textures associated with the material
  parseParameters(e, t, n) {
    const s = {};
    e.BumpFactor && (s.bumpScale = e.BumpFactor.value), e.Diffuse ? s.color = new be().fromArray(e.Diffuse.value) : e.DiffuseColor && (e.DiffuseColor.type === "Color" || e.DiffuseColor.type === "ColorRGB") && (s.color = new be().fromArray(e.DiffuseColor.value)), e.DisplacementFactor && (s.displacementScale = e.DisplacementFactor.value), e.Emissive ? s.emissive = new be().fromArray(e.Emissive.value) : e.EmissiveColor && (e.EmissiveColor.type === "Color" || e.EmissiveColor.type === "ColorRGB") && (s.emissive = new be().fromArray(e.EmissiveColor.value)), e.EmissiveFactor && (s.emissiveIntensity = parseFloat(e.EmissiveFactor.value)), e.Opacity && (s.opacity = parseFloat(e.Opacity.value)), s.opacity < 1 && (s.transparent = !0), e.ReflectionFactor && (s.reflectivity = e.ReflectionFactor.value), e.Shininess && (s.shininess = e.Shininess.value), e.Specular ? s.specular = new be().fromArray(e.Specular.value) : e.SpecularColor && e.SpecularColor.type === "Color" && (s.specular = new be().fromArray(e.SpecularColor.value));
    const i = this;
    return Qe.get(n).children.forEach(function(o) {
      const a = o.relationship;
      switch (a) {
        case "Bump":
          s.bumpMap = i.getTexture(t, o.ID);
          break;
        case "Maya|TEX_ao_map":
          s.aoMap = i.getTexture(t, o.ID);
          break;
        case "DiffuseColor":
        case "Maya|TEX_color_map":
          s.map = i.getTexture(t, o.ID), s.map !== void 0 && ("colorSpace" in s.map ? s.map.colorSpace = "srgb" : s.map.encoding = 3001);
          break;
        case "DisplacementColor":
          s.displacementMap = i.getTexture(t, o.ID);
          break;
        case "EmissiveColor":
          s.emissiveMap = i.getTexture(t, o.ID), s.emissiveMap !== void 0 && ("colorSpace" in s.emissiveMap ? s.emissiveMap.colorSpace = "srgb" : s.emissiveMap.encoding = 3001);
          break;
        case "NormalMap":
        case "Maya|TEX_normal_map":
          s.normalMap = i.getTexture(t, o.ID);
          break;
        case "ReflectionColor":
          s.envMap = i.getTexture(t, o.ID), s.envMap !== void 0 && (s.envMap.mapping = ho, "colorSpace" in s.envMap ? s.envMap.colorSpace = "srgb" : s.envMap.encoding = 3001);
          break;
        case "SpecularColor":
          s.specularMap = i.getTexture(t, o.ID), s.specularMap !== void 0 && ("colorSpace" in s.specularMap ? s.specularMap.colorSpace = "srgb" : s.specularMap.encoding = 3001);
          break;
        case "TransparentColor":
        case "TransparencyFactor":
          s.alphaMap = i.getTexture(t, o.ID), s.transparent = !0;
          break;
        case "AmbientColor":
        case "ShininessExponent":
        case "SpecularFactor":
        case "VectorDisplacementColor":
        default:
          console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", a);
          break;
      }
    }), s;
  }
  // get a texture from the textureMap for use by a material.
  getTexture(e, t) {
    return "LayeredTexture" in Ce.Objects && t in Ce.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), t = Qe.get(t).children[0].ID), e.get(t);
  }
  // Parse nodes in FBXTree.Objects.Deformer
  // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here
  // Generates map of Skeleton-like objects for use later when generating and binding skeletons.
  parseDeformers() {
    const e = {}, t = {};
    if ("Deformer" in Ce.Objects) {
      const n = Ce.Objects.Deformer;
      for (const s in n) {
        const i = n[s], o = Qe.get(parseInt(s));
        if (i.attrType === "Skin") {
          const a = this.parseSkeleton(o, n);
          a.ID = s, o.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), a.geometryID = o.parents[0].ID, e[s] = a;
        } else if (i.attrType === "BlendShape") {
          const a = {
            id: s
          };
          a.rawTargets = this.parseMorphTargets(o, n), a.id = s, o.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), t[s] = a;
        }
      }
    }
    return {
      skeletons: e,
      morphTargets: t
    };
  }
  // Parse single nodes in FBXTree.Objects.Deformer
  // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'
  // Each skin node represents a skeleton and each cluster node represents a bone
  parseSkeleton(e, t) {
    const n = [];
    return e.children.forEach(function(s) {
      const i = t[s.ID];
      if (i.attrType !== "Cluster")
        return;
      const o = {
        ID: s.ID,
        indices: [],
        weights: [],
        transformLink: new Ie().fromArray(i.TransformLink.a)
        // transform: new Matrix4().fromArray( boneNode.Transform.a ),
        // linkMode: boneNode.Mode,
      };
      "Indexes" in i && (o.indices = i.Indexes.a, o.weights = i.Weights.a), n.push(o);
    }), {
      rawBones: n,
      bones: []
    };
  }
  // The top level morph deformer node has type "BlendShape" and sub nodes have type "BlendShapeChannel"
  parseMorphTargets(e, t) {
    const n = [];
    for (let s = 0; s < e.children.length; s++) {
      const i = e.children[s], o = t[i.ID], a = {
        name: o.attrName,
        initialWeight: o.DeformPercent,
        id: o.id,
        fullWeights: o.FullWeights.a
      };
      if (o.attrType !== "BlendShapeChannel")
        return;
      a.geoID = Qe.get(parseInt(i.ID)).children.filter(function(l) {
        return l.relationship === void 0;
      })[0].ID, n.push(a);
    }
    return n;
  }
  // create the main Group() to be returned by the loader
  parseScene(e, t, n) {
    mt = new Zt();
    const s = this.parseModels(e.skeletons, t, n), i = Ce.Objects.Model, o = this;
    s.forEach(function(l) {
      const c = i[l.ID];
      o.setLookAtProperties(l, c), Qe.get(l.ID).parents.forEach(function(u) {
        const d = s.get(u.ID);
        d !== void 0 && d.add(l);
      }), l.parent === null && mt.add(l);
    }), this.bindSkeleton(e.skeletons, t, s), this.createAmbientLight(), mt.traverse(function(l) {
      if (l.userData.transformData) {
        l.parent && (l.userData.transformData.parentMatrix = l.parent.matrix, l.userData.transformData.parentMatrixWorld = l.parent.matrixWorld);
        const c = sl(l.userData.transformData);
        l.applyMatrix4(c), l.updateWorldMatrix();
      }
    });
    const a = new mf().parse();
    mt.children.length === 1 && mt.children[0].isGroup && (mt.children[0].animations = a, mt = mt.children[0]), mt.animations = a;
  }
  // parse nodes in FBXTree.Objects.Model
  parseModels(e, t, n) {
    const s = /* @__PURE__ */ new Map(), i = Ce.Objects.Model;
    for (const o in i) {
      const a = parseInt(o), l = i[o], c = Qe.get(a);
      let f = this.buildSkeleton(c, e, a, l.attrName);
      if (!f) {
        switch (l.attrType) {
          case "Camera":
            f = this.createCamera(c);
            break;
          case "Light":
            f = this.createLight(c);
            break;
          case "Mesh":
            f = this.createMesh(c, t, n);
            break;
          case "NurbsCurve":
            f = this.createCurve(c, t);
            break;
          case "LimbNode":
          case "Root":
            f = new ao();
            break;
          case "Null":
          default:
            f = new Zt();
            break;
        }
        f.name = l.attrName ? rn.sanitizeNodeName(l.attrName) : "", f.ID = a;
      }
      this.getTransformData(f, l), s.set(a, f);
    }
    return s;
  }
  buildSkeleton(e, t, n, s) {
    let i = null;
    return e.parents.forEach(function(o) {
      for (const a in t) {
        const l = t[a];
        l.rawBones.forEach(function(c, f) {
          if (c.ID === o.ID) {
            const u = i;
            i = new ao(), i.matrixWorld.copy(c.transformLink), i.name = s ? rn.sanitizeNodeName(s) : "", i.ID = n, l.bones[f] = i, u !== null && i.add(u);
          }
        });
      }
    }), i;
  }
  // create a PerspectiveCamera or OrthographicCamera
  createCamera(e) {
    let t, n;
    if (e.children.forEach(function(s) {
      const i = Ce.Objects.NodeAttribute[s.ID];
      i !== void 0 && (n = i);
    }), n === void 0)
      t = new Rt();
    else {
      let s = 0;
      n.CameraProjectionType !== void 0 && n.CameraProjectionType.value === 1 && (s = 1);
      let i = 1;
      n.NearPlane !== void 0 && (i = n.NearPlane.value / 1e3);
      let o = 1e3;
      n.FarPlane !== void 0 && (o = n.FarPlane.value / 1e3);
      let a = window.innerWidth, l = window.innerHeight;
      n.AspectWidth !== void 0 && n.AspectHeight !== void 0 && (a = n.AspectWidth.value, l = n.AspectHeight.value);
      const c = a / l;
      let f = 45;
      n.FieldOfView !== void 0 && (f = n.FieldOfView.value);
      const u = n.FocalLength ? n.FocalLength.value : null;
      switch (s) {
        case 0:
          t = new kt(f, c, i, o), u !== null && t.setFocalLength(u);
          break;
        case 1:
          t = new _n(
            -a / 2,
            a / 2,
            l / 2,
            -l / 2,
            i,
            o
          );
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown camera type " + s + "."), t = new Rt();
          break;
      }
    }
    return t;
  }
  // Create a DirectionalLight, PointLight or SpotLight
  createLight(e) {
    let t, n;
    if (e.children.forEach(function(s) {
      const i = Ce.Objects.NodeAttribute[s.ID];
      i !== void 0 && (n = i);
    }), n === void 0)
      t = new Rt();
    else {
      let s;
      n.LightType === void 0 ? s = 0 : s = n.LightType.value;
      let i = 16777215;
      n.Color !== void 0 && (i = new be().fromArray(n.Color.value));
      let o = n.Intensity === void 0 ? 1 : n.Intensity.value / 100;
      n.CastLightOnObject !== void 0 && n.CastLightOnObject.value === 0 && (o = 0);
      let a = 0;
      n.FarAttenuationEnd !== void 0 && (n.EnableFarAttenuation !== void 0 && n.EnableFarAttenuation.value === 0 ? a = 0 : a = n.FarAttenuationEnd.value);
      const l = 1;
      switch (s) {
        case 0:
          t = new ro(i, o, a, l);
          break;
        case 1:
          t = new wa(i, o);
          break;
        case 2:
          let c = Math.PI / 3;
          n.InnerAngle !== void 0 && (c = Ye.degToRad(n.InnerAngle.value));
          let f = 0;
          n.OuterAngle !== void 0 && (f = Ye.degToRad(n.OuterAngle.value), f = Math.max(f, 1)), t = new xa(i, o, a, c, f, l);
          break;
        default:
          console.warn(
            "THREE.FBXLoader: Unknown light type " + n.LightType.value + ", defaulting to a PointLight."
          ), t = new ro(i, o);
          break;
      }
      n.CastShadows !== void 0 && n.CastShadows.value === 1 && (t.castShadow = !0);
    }
    return t;
  }
  createMesh(e, t, n) {
    let s, i = null, o = null;
    const a = [];
    return e.children.forEach(function(l) {
      t.has(l.ID) && (i = t.get(l.ID)), n.has(l.ID) && a.push(n.get(l.ID));
    }), a.length > 1 ? o = a : a.length > 0 ? o = a[0] : (o = new yi({ color: 13421772 }), a.push(o)), "color" in i.attributes && a.forEach(function(l) {
      l.vertexColors = !0;
    }), i.FBX_Deformer ? (s = new Po(i, o), s.normalizeSkinWeights()) : s = new de(i, o), s;
  }
  createCurve(e, t) {
    const n = e.children.reduce(function(i, o) {
      return t.has(o.ID) && (i = t.get(o.ID)), i;
    }, null), s = new ws({ color: 3342591, linewidth: 1 });
    return new ke(n, s);
  }
  // parse the model node for transform data
  getTransformData(e, t) {
    const n = {};
    "InheritType" in t && (n.inheritType = parseInt(t.InheritType.value)), "RotationOrder" in t ? n.eulerOrder = il(t.RotationOrder.value) : n.eulerOrder = "ZYX", "Lcl_Translation" in t && (n.translation = t.Lcl_Translation.value), "PreRotation" in t && (n.preRotation = t.PreRotation.value), "Lcl_Rotation" in t && (n.rotation = t.Lcl_Rotation.value), "PostRotation" in t && (n.postRotation = t.PostRotation.value), "Lcl_Scaling" in t && (n.scale = t.Lcl_Scaling.value), "ScalingOffset" in t && (n.scalingOffset = t.ScalingOffset.value), "ScalingPivot" in t && (n.scalingPivot = t.ScalingPivot.value), "RotationOffset" in t && (n.rotationOffset = t.RotationOffset.value), "RotationPivot" in t && (n.rotationPivot = t.RotationPivot.value), e.userData.transformData = n;
  }
  setLookAtProperties(e, t) {
    "LookAtProperty" in t && Qe.get(e.ID).children.forEach(function(s) {
      if (s.relationship === "LookAtProperty") {
        const i = Ce.Objects.Model[s.ID];
        if ("Lcl_Translation" in i) {
          const o = i.Lcl_Translation.value;
          e.target !== void 0 ? (e.target.position.fromArray(o), mt.add(e.target)) : e.lookAt(new $().fromArray(o));
        }
      }
    });
  }
  bindSkeleton(e, t, n) {
    const s = this.parsePoseNodes();
    for (const i in e) {
      const o = e[i];
      Qe.get(parseInt(o.ID)).parents.forEach(function(l) {
        if (t.has(l.ID)) {
          const c = l.ID;
          Qe.get(c).parents.forEach(function(u) {
            n.has(u.ID) && n.get(u.ID).bind(new Ea(o.bones), s[u.ID]);
          });
        }
      });
    }
  }
  parsePoseNodes() {
    const e = {};
    if ("Pose" in Ce.Objects) {
      const t = Ce.Objects.Pose;
      for (const n in t)
        if (t[n].attrType === "BindPose" && t[n].NbPoseNodes > 0) {
          const s = t[n].PoseNode;
          Array.isArray(s) ? s.forEach(function(i) {
            e[i.Node] = new Ie().fromArray(i.Matrix.a);
          }) : e[s.Node] = new Ie().fromArray(s.Matrix.a);
        }
    }
    return e;
  }
  // Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light
  createAmbientLight() {
    if ("GlobalSettings" in Ce && "AmbientColor" in Ce.GlobalSettings) {
      const e = Ce.GlobalSettings.AmbientColor.value, t = e[0], n = e[1], s = e[2];
      if (t !== 0 || n !== 0 || s !== 0) {
        const i = new be(t, n, s);
        mt.add(new jl(i, 1));
      }
    }
  }
}
class pf {
  // Parse nodes in FBXTree.Objects.Geometry
  parse(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Geometry" in Ce.Objects) {
      const n = Ce.Objects.Geometry;
      for (const s in n) {
        const i = Qe.get(parseInt(s)), o = this.parseGeometry(i, n[s], e);
        t.set(parseInt(s), o);
      }
    }
    return t;
  }
  // Parse single node in FBXTree.Objects.Geometry
  parseGeometry(e, t, n) {
    switch (t.attrType) {
      case "Mesh":
        return this.parseMeshGeometry(e, t, n);
      case "NurbsCurve":
        return this.parseNurbsGeometry(t);
    }
  }
  // Parse single node mesh geometry in FBXTree.Objects.Geometry
  parseMeshGeometry(e, t, n) {
    const s = n.skeletons, i = [], o = e.parents.map(function(u) {
      return Ce.Objects.Model[u.ID];
    });
    if (o.length === 0)
      return;
    const a = e.children.reduce(function(u, d) {
      return s[d.ID] !== void 0 && (u = s[d.ID]), u;
    }, null);
    e.children.forEach(function(u) {
      n.morphTargets[u.ID] !== void 0 && i.push(n.morphTargets[u.ID]);
    });
    const l = o[0], c = {};
    "RotationOrder" in l && (c.eulerOrder = il(l.RotationOrder.value)), "InheritType" in l && (c.inheritType = parseInt(l.InheritType.value)), "GeometricTranslation" in l && (c.translation = l.GeometricTranslation.value), "GeometricRotation" in l && (c.rotation = l.GeometricRotation.value), "GeometricScaling" in l && (c.scale = l.GeometricScaling.value);
    const f = sl(c);
    return this.genGeometry(t, a, i, f);
  }
  // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry
  genGeometry(e, t, n, s) {
    const i = new ht();
    e.attrName && (i.name = e.attrName);
    const o = this.parseGeoNode(e, t), a = this.genBuffers(o), l = new gt(a.vertex, 3);
    if (l.applyMatrix4(s), i.setAttribute("position", l), a.colors.length > 0 && i.setAttribute("color", new gt(a.colors, 3)), t && (i.setAttribute("skinIndex", new Vl(a.weightsIndices, 4)), i.setAttribute("skinWeight", new gt(a.vertexWeights, 4)), i.FBX_Deformer = t), a.normal.length > 0) {
      const c = new Cn().getNormalMatrix(s), f = new gt(a.normal, 3);
      f.applyNormalMatrix(c), i.setAttribute("normal", f);
    }
    if (a.uvs.forEach(function(c, f) {
      Bo === "uv2" && f++;
      const u = f === 0 ? "uv" : `uv${f}`;
      i.setAttribute(u, new gt(a.uvs[f], 2));
    }), o.material && o.material.mappingType !== "AllSame") {
      let c = a.materialIndex[0], f = 0;
      if (a.materialIndex.forEach(function(u, d) {
        u !== c && (i.addGroup(f, d - f, c), c = u, f = d);
      }), i.groups.length > 0) {
        const u = i.groups[i.groups.length - 1], d = u.start + u.count;
        d !== a.materialIndex.length && i.addGroup(d, a.materialIndex.length - d, c);
      }
      i.groups.length === 0 && i.addGroup(0, a.materialIndex.length, a.materialIndex[0]);
    }
    return this.addMorphTargets(i, e, n, s), i;
  }
  parseGeoNode(e, t) {
    const n = {};
    if (n.vertexPositions = e.Vertices !== void 0 ? e.Vertices.a : [], n.vertexIndices = e.PolygonVertexIndex !== void 0 ? e.PolygonVertexIndex.a : [], e.LayerElementColor && (n.color = this.parseVertexColors(e.LayerElementColor[0])), e.LayerElementMaterial && (n.material = this.parseMaterialIndices(e.LayerElementMaterial[0])), e.LayerElementNormal && (n.normal = this.parseNormals(e.LayerElementNormal[0])), e.LayerElementUV) {
      n.uv = [];
      let s = 0;
      for (; e.LayerElementUV[s]; )
        e.LayerElementUV[s].UV && n.uv.push(this.parseUVs(e.LayerElementUV[s])), s++;
    }
    return n.weightTable = {}, t !== null && (n.skeleton = t, t.rawBones.forEach(function(s, i) {
      s.indices.forEach(function(o, a) {
        n.weightTable[o] === void 0 && (n.weightTable[o] = []), n.weightTable[o].push({
          id: i,
          weight: s.weights[a]
        });
      });
    })), n;
  }
  genBuffers(e) {
    const t = {
      vertex: [],
      normal: [],
      colors: [],
      uvs: [],
      materialIndex: [],
      vertexWeights: [],
      weightsIndices: []
    };
    let n = 0, s = 0, i = !1, o = [], a = [], l = [], c = [], f = [], u = [];
    const d = this;
    return e.vertexIndices.forEach(function(h, m) {
      let g, v = !1;
      h < 0 && (h = h ^ -1, v = !0);
      let p = [], b = [];
      if (o.push(h * 3, h * 3 + 1, h * 3 + 2), e.color) {
        const _ = Gs(m, n, h, e.color);
        l.push(_[0], _[1], _[2]);
      }
      if (e.skeleton) {
        if (e.weightTable[h] !== void 0 && e.weightTable[h].forEach(function(_) {
          b.push(_.weight), p.push(_.id);
        }), b.length > 4) {
          i || (console.warn(
            "THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."
          ), i = !0);
          const _ = [0, 0, 0, 0], M = [0, 0, 0, 0];
          b.forEach(function(R, w) {
            let E = R, x = p[w];
            M.forEach(function(T, y, A) {
              if (E > T) {
                A[y] = E, E = T;
                const C = _[y];
                _[y] = x, x = C;
              }
            });
          }), p = _, b = M;
        }
        for (; b.length < 4; )
          b.push(0), p.push(0);
        for (let _ = 0; _ < 4; ++_)
          f.push(b[_]), u.push(p[_]);
      }
      if (e.normal) {
        const _ = Gs(m, n, h, e.normal);
        a.push(_[0], _[1], _[2]);
      }
      e.material && e.material.mappingType !== "AllSame" && (g = Gs(m, n, h, e.material)[0]), e.uv && e.uv.forEach(function(_, M) {
        const R = Gs(m, n, h, _);
        c[M] === void 0 && (c[M] = []), c[M].push(R[0]), c[M].push(R[1]);
      }), s++, v && (d.genFace(
        t,
        e,
        o,
        g,
        a,
        l,
        c,
        f,
        u,
        s
      ), n++, s = 0, o = [], a = [], l = [], c = [], f = [], u = []);
    }), t;
  }
  // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris
  genFace(e, t, n, s, i, o, a, l, c, f) {
    for (let u = 2; u < f; u++)
      e.vertex.push(t.vertexPositions[n[0]]), e.vertex.push(t.vertexPositions[n[1]]), e.vertex.push(t.vertexPositions[n[2]]), e.vertex.push(t.vertexPositions[n[(u - 1) * 3]]), e.vertex.push(t.vertexPositions[n[(u - 1) * 3 + 1]]), e.vertex.push(t.vertexPositions[n[(u - 1) * 3 + 2]]), e.vertex.push(t.vertexPositions[n[u * 3]]), e.vertex.push(t.vertexPositions[n[u * 3 + 1]]), e.vertex.push(t.vertexPositions[n[u * 3 + 2]]), t.skeleton && (e.vertexWeights.push(l[0]), e.vertexWeights.push(l[1]), e.vertexWeights.push(l[2]), e.vertexWeights.push(l[3]), e.vertexWeights.push(l[(u - 1) * 4]), e.vertexWeights.push(l[(u - 1) * 4 + 1]), e.vertexWeights.push(l[(u - 1) * 4 + 2]), e.vertexWeights.push(l[(u - 1) * 4 + 3]), e.vertexWeights.push(l[u * 4]), e.vertexWeights.push(l[u * 4 + 1]), e.vertexWeights.push(l[u * 4 + 2]), e.vertexWeights.push(l[u * 4 + 3]), e.weightsIndices.push(c[0]), e.weightsIndices.push(c[1]), e.weightsIndices.push(c[2]), e.weightsIndices.push(c[3]), e.weightsIndices.push(c[(u - 1) * 4]), e.weightsIndices.push(c[(u - 1) * 4 + 1]), e.weightsIndices.push(c[(u - 1) * 4 + 2]), e.weightsIndices.push(c[(u - 1) * 4 + 3]), e.weightsIndices.push(c[u * 4]), e.weightsIndices.push(c[u * 4 + 1]), e.weightsIndices.push(c[u * 4 + 2]), e.weightsIndices.push(c[u * 4 + 3])), t.color && (e.colors.push(o[0]), e.colors.push(o[1]), e.colors.push(o[2]), e.colors.push(o[(u - 1) * 3]), e.colors.push(o[(u - 1) * 3 + 1]), e.colors.push(o[(u - 1) * 3 + 2]), e.colors.push(o[u * 3]), e.colors.push(o[u * 3 + 1]), e.colors.push(o[u * 3 + 2])), t.material && t.material.mappingType !== "AllSame" && (e.materialIndex.push(s), e.materialIndex.push(s), e.materialIndex.push(s)), t.normal && (e.normal.push(i[0]), e.normal.push(i[1]), e.normal.push(i[2]), e.normal.push(i[(u - 1) * 3]), e.normal.push(i[(u - 1) * 3 + 1]), e.normal.push(i[(u - 1) * 3 + 2]), e.normal.push(i[u * 3]), e.normal.push(i[u * 3 + 1]), e.normal.push(i[u * 3 + 2])), t.uv && t.uv.forEach(function(d, h) {
        e.uvs[h] === void 0 && (e.uvs[h] = []), e.uvs[h].push(a[h][0]), e.uvs[h].push(a[h][1]), e.uvs[h].push(a[h][(u - 1) * 2]), e.uvs[h].push(a[h][(u - 1) * 2 + 1]), e.uvs[h].push(a[h][u * 2]), e.uvs[h].push(a[h][u * 2 + 1]);
      });
  }
  addMorphTargets(e, t, n, s) {
    if (n.length === 0)
      return;
    e.morphTargetsRelative = !0, e.morphAttributes.position = [];
    const i = this;
    n.forEach(function(o) {
      o.rawTargets.forEach(function(a) {
        const l = Ce.Objects.Geometry[a.geoID];
        l !== void 0 && i.genMorphGeometry(e, t, l, s, a.name);
      });
    });
  }
  // a morph geometry node is similar to a standard  node, and the node is also contained
  // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal
  // and a special attribute Index defining which vertices of the original geometry are affected
  // Normal and position attributes only have data for the vertices that are affected by the morph
  genMorphGeometry(e, t, n, s, i) {
    const o = t.PolygonVertexIndex !== void 0 ? t.PolygonVertexIndex.a : [], a = n.Vertices !== void 0 ? n.Vertices.a : [], l = n.Indexes !== void 0 ? n.Indexes.a : [], c = e.attributes.position.count * 3, f = new Float32Array(c);
    for (let m = 0; m < l.length; m++) {
      const g = l[m] * 3;
      f[g] = a[m * 3], f[g + 1] = a[m * 3 + 1], f[g + 2] = a[m * 3 + 2];
    }
    const u = {
      vertexIndices: o,
      vertexPositions: f
    }, d = this.genBuffers(u), h = new gt(d.vertex, 3);
    h.name = i || n.attrName, h.applyMatrix4(s), e.morphAttributes.position.push(h);
  }
  // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists
  parseNormals(e) {
    const t = e.MappingInformationType, n = e.ReferenceInformationType, s = e.Normals.a;
    let i = [];
    return n === "IndexToDirect" && ("NormalIndex" in e ? i = e.NormalIndex.a : "NormalsIndex" in e && (i = e.NormalsIndex.a)), {
      dataSize: 3,
      buffer: s,
      indices: i,
      mappingType: t,
      referenceType: n
    };
  }
  // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists
  parseUVs(e) {
    const t = e.MappingInformationType, n = e.ReferenceInformationType, s = e.UV.a;
    let i = [];
    return n === "IndexToDirect" && (i = e.UVIndex.a), {
      dataSize: 2,
      buffer: s,
      indices: i,
      mappingType: t,
      referenceType: n
    };
  }
  // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists
  parseVertexColors(e) {
    const t = e.MappingInformationType, n = e.ReferenceInformationType, s = e.Colors.a;
    let i = [];
    return n === "IndexToDirect" && (i = e.ColorIndex.a), {
      dataSize: 4,
      buffer: s,
      indices: i,
      mappingType: t,
      referenceType: n
    };
  }
  // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists
  parseMaterialIndices(e) {
    const t = e.MappingInformationType, n = e.ReferenceInformationType;
    if (t === "NoMappingInformation")
      return {
        dataSize: 1,
        buffer: [0],
        indices: [0],
        mappingType: "AllSame",
        referenceType: n
      };
    const s = e.Materials.a, i = [];
    for (let o = 0; o < s.length; ++o)
      i.push(o);
    return {
      dataSize: 1,
      buffer: s,
      indices: i,
      mappingType: t,
      referenceType: n
    };
  }
  // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry
  parseNurbsGeometry(e) {
    if (vr === void 0)
      return console.error(
        "THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."
      ), new ht();
    const t = parseInt(e.Order);
    if (isNaN(t))
      return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", e.Order, e.id), new ht();
    const n = t - 1, s = e.KnotVector.a, i = [], o = e.Points.a;
    for (let u = 0, d = o.length; u < d; u += 4)
      i.push(new at().fromArray(o, u));
    let a, l;
    if (e.Form === "Closed")
      i.push(i[0]);
    else if (e.Form === "Periodic") {
      a = n, l = s.length - 1 - a;
      for (let u = 0; u < n; ++u)
        i.push(i[u]);
    }
    const f = new vr(n, s, i, a, l).getPoints(i.length * 12);
    return new ht().setFromPoints(f);
  }
}
class mf {
  // take raw animation clips and turn them into three.js animation clips
  parse() {
    const e = [], t = this.parseClips();
    if (t !== void 0)
      for (const n in t) {
        const s = t[n], i = this.addClip(s);
        e.push(i);
      }
    return e;
  }
  parseClips() {
    if (Ce.Objects.AnimationCurve === void 0)
      return;
    const e = this.parseAnimationCurveNodes();
    this.parseAnimationCurves(e);
    const t = this.parseAnimationLayers(e);
    return this.parseAnimStacks(t);
  }
  // parse nodes in FBXTree.Objects.AnimationCurveNode
  // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )
  // and is referenced by an AnimationLayer
  parseAnimationCurveNodes() {
    const e = Ce.Objects.AnimationCurveNode, t = /* @__PURE__ */ new Map();
    for (const n in e) {
      const s = e[n];
      if (s.attrName.match(/S|R|T|DeformPercent/) !== null) {
        const i = {
          id: s.id,
          attr: s.attrName,
          curves: {}
        };
        t.set(i.id, i);
      }
    }
    return t;
  }
  // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to
  // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated
  // axis ( e.g. times and values of x rotation)
  parseAnimationCurves(e) {
    const t = Ce.Objects.AnimationCurve;
    for (const n in t) {
      const s = {
        id: t[n].id,
        times: t[n].KeyTime.a.map(xf),
        values: t[n].KeyValueFloat.a
      }, i = Qe.get(s.id);
      if (i !== void 0) {
        const o = i.parents[0].ID, a = i.parents[0].relationship;
        a.match(/X/) ? e.get(o).curves.x = s : a.match(/Y/) ? e.get(o).curves.y = s : a.match(/Z/) ? e.get(o).curves.z = s : a.match(/d|DeformPercent/) && e.has(o) && (e.get(o).curves.morph = s);
      }
    }
  }
  // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references
  // to various AnimationCurveNodes and is referenced by an AnimationStack node
  // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack
  parseAnimationLayers(e) {
    const t = Ce.Objects.AnimationLayer, n = /* @__PURE__ */ new Map();
    for (const s in t) {
      const i = [], o = Qe.get(parseInt(s));
      o !== void 0 && (o.children.forEach(function(l, c) {
        if (e.has(l.ID)) {
          const f = e.get(l.ID);
          if (f.curves.x !== void 0 || f.curves.y !== void 0 || f.curves.z !== void 0) {
            if (i[c] === void 0) {
              const u = Qe.get(l.ID).parents.filter(function(d) {
                return d.relationship !== void 0;
              })[0].ID;
              if (u !== void 0) {
                const d = Ce.Objects.Model[u.toString()];
                if (d === void 0) {
                  console.warn("THREE.FBXLoader: Encountered a unused curve.", l);
                  return;
                }
                const h = {
                  modelName: d.attrName ? rn.sanitizeNodeName(d.attrName) : "",
                  ID: d.id,
                  initialPosition: [0, 0, 0],
                  initialRotation: [0, 0, 0],
                  initialScale: [1, 1, 1]
                };
                mt.traverse(function(m) {
                  m.ID === d.id && (h.transform = m.matrix, m.userData.transformData && (h.eulerOrder = m.userData.transformData.eulerOrder));
                }), h.transform || (h.transform = new Ie()), "PreRotation" in d && (h.preRotation = d.PreRotation.value), "PostRotation" in d && (h.postRotation = d.PostRotation.value), i[c] = h;
              }
            }
            i[c] && (i[c][f.attr] = f);
          } else if (f.curves.morph !== void 0) {
            if (i[c] === void 0) {
              const u = Qe.get(l.ID).parents.filter(function(p) {
                return p.relationship !== void 0;
              })[0].ID, d = Qe.get(u).parents[0].ID, h = Qe.get(d).parents[0].ID, m = Qe.get(h).parents[0].ID, g = Ce.Objects.Model[m], v = {
                modelName: g.attrName ? rn.sanitizeNodeName(g.attrName) : "",
                morphName: Ce.Objects.Deformer[u].attrName
              };
              i[c] = v;
            }
            i[c][f.attr] = f;
          }
        }
      }), n.set(parseInt(s), i));
    }
    return n;
  }
  // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation
  // hierarchy. Each Stack node will be used to create a AnimationClip
  parseAnimStacks(e) {
    const t = Ce.Objects.AnimationStack, n = {};
    for (const s in t) {
      const i = Qe.get(parseInt(s)).children;
      i.length > 1 && console.warn(
        "THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers."
      );
      const o = e.get(i[0].ID);
      n[s] = {
        name: t[s].attrName,
        layer: o
      };
    }
    return n;
  }
  addClip(e) {
    let t = [];
    const n = this;
    return e.layer.forEach(function(s) {
      t = t.concat(n.generateTracks(s));
    }), new Ma(e.name, -1, t);
  }
  generateTracks(e) {
    const t = [];
    let n = new $(), s = new je(), i = new $();
    if (e.transform && e.transform.decompose(n, s, i), n = n.toArray(), s = new vt().setFromQuaternion(s, e.eulerOrder).toArray(), i = i.toArray(), e.T !== void 0 && Object.keys(e.T.curves).length > 0) {
      const o = this.generateVectorTrack(
        e.modelName,
        e.T.curves,
        n,
        "position"
      );
      o !== void 0 && t.push(o);
    }
    if (e.R !== void 0 && Object.keys(e.R.curves).length > 0) {
      const o = this.generateRotationTrack(
        e.modelName,
        e.R.curves,
        s,
        e.preRotation,
        e.postRotation,
        e.eulerOrder
      );
      o !== void 0 && t.push(o);
    }
    if (e.S !== void 0 && Object.keys(e.S.curves).length > 0) {
      const o = this.generateVectorTrack(e.modelName, e.S.curves, i, "scale");
      o !== void 0 && t.push(o);
    }
    if (e.DeformPercent !== void 0) {
      const o = this.generateMorphTrack(e);
      o !== void 0 && t.push(o);
    }
    return t;
  }
  generateVectorTrack(e, t, n, s) {
    const i = this.getTimesForAllAxes(t), o = this.getKeyframeTrackValues(i, t, n);
    return new lo(e + "." + s, i, o);
  }
  generateRotationTrack(e, t, n, s, i, o) {
    t.x !== void 0 && (this.interpolateRotations(t.x), t.x.values = t.x.values.map(Ye.degToRad)), t.y !== void 0 && (this.interpolateRotations(t.y), t.y.values = t.y.values.map(Ye.degToRad)), t.z !== void 0 && (this.interpolateRotations(t.z), t.z.values = t.z.values.map(Ye.degToRad));
    const a = this.getTimesForAllAxes(t), l = this.getKeyframeTrackValues(a, t, n);
    s !== void 0 && (s = s.map(Ye.degToRad), s.push(o), s = new vt().fromArray(s), s = new je().setFromEuler(s)), i !== void 0 && (i = i.map(Ye.degToRad), i.push(o), i = new vt().fromArray(i), i = new je().setFromEuler(i).invert());
    const c = new je(), f = new vt(), u = [];
    for (let d = 0; d < l.length; d += 3)
      f.set(l[d], l[d + 1], l[d + 2], o), c.setFromEuler(f), s !== void 0 && c.premultiply(s), i !== void 0 && c.multiply(i), c.toArray(u, d / 3 * 4);
    return new uo(e + ".quaternion", a, u);
  }
  generateMorphTrack(e) {
    const t = e.DeformPercent.curves.morph, n = t.values.map(function(i) {
      return i / 100;
    }), s = mt.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];
    return new co(
      e.modelName + ".morphTargetInfluences[" + s + "]",
      t.times,
      n
    );
  }
  // For all animated objects, times are defined separately for each axis
  // Here we'll combine the times into one sorted array without duplicates
  getTimesForAllAxes(e) {
    let t = [];
    if (e.x !== void 0 && (t = t.concat(e.x.times)), e.y !== void 0 && (t = t.concat(e.y.times)), e.z !== void 0 && (t = t.concat(e.z.times)), t = t.sort(function(n, s) {
      return n - s;
    }), t.length > 1) {
      let n = 1, s = t[0];
      for (let i = 1; i < t.length; i++) {
        const o = t[i];
        o !== s && (t[n] = o, s = o, n++);
      }
      t = t.slice(0, n);
    }
    return t;
  }
  getKeyframeTrackValues(e, t, n) {
    const s = n, i = [];
    let o = -1, a = -1, l = -1;
    return e.forEach(function(c) {
      if (t.x && (o = t.x.times.indexOf(c)), t.y && (a = t.y.times.indexOf(c)), t.z && (l = t.z.times.indexOf(c)), o !== -1) {
        const f = t.x.values[o];
        i.push(f), s[0] = f;
      } else
        i.push(s[0]);
      if (a !== -1) {
        const f = t.y.values[a];
        i.push(f), s[1] = f;
      } else
        i.push(s[1]);
      if (l !== -1) {
        const f = t.z.values[l];
        i.push(f), s[2] = f;
      } else
        i.push(s[2]);
    }), i;
  }
  // Rotations are defined as Euler angles which can have values  of any size
  // These will be converted to quaternions which don't support values greater than
  // PI, so we'll interpolate large rotations
  interpolateRotations(e) {
    for (let t = 1; t < e.values.length; t++) {
      const n = e.values[t - 1], s = e.values[t] - n, i = Math.abs(s);
      if (i >= 180) {
        const o = i / 180, a = s / o;
        let l = n + a;
        const c = e.times[t - 1], u = (e.times[t] - c) / o;
        let d = c + u;
        const h = [], m = [];
        for (; d < e.times[t]; )
          h.push(d), d += u, m.push(l), l += a;
        e.times = xr(e.times, t, h), e.values = xr(e.values, t, m);
      }
    }
  }
}
class gf {
  getPrevNode() {
    return this.nodeStack[this.currentIndent - 2];
  }
  getCurrentNode() {
    return this.nodeStack[this.currentIndent - 1];
  }
  getCurrentProp() {
    return this.currentProp;
  }
  pushStack(e) {
    this.nodeStack.push(e), this.currentIndent += 1;
  }
  popStack() {
    this.nodeStack.pop(), this.currentIndent -= 1;
  }
  setCurrentProp(e, t) {
    this.currentProp = e, this.currentPropName = t;
  }
  parse(e) {
    this.currentIndent = 0, this.allNodes = new nl(), this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
    const t = this, n = e.split(/[\r\n]+/);
    return n.forEach(function(s, i) {
      const o = s.match(/^[\s\t]*;/), a = s.match(/^[\s\t]*$/);
      if (o || a)
        return;
      const l = s.match("^\\t{" + t.currentIndent + "}(\\w+):(.*){", ""), c = s.match("^\\t{" + t.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"), f = s.match("^\\t{" + (t.currentIndent - 1) + "}}");
      l ? t.parseNodeBegin(s, l) : c ? t.parseNodeProperty(s, c, n[++i]) : f ? t.popStack() : s.match(/^[^\s\t}]/) && t.parseNodePropertyContinued(s);
    }), this.allNodes;
  }
  parseNodeBegin(e, t) {
    const n = t[1].trim().replace(/^"/, "").replace(/"$/, ""), s = t[2].split(",").map(function(l) {
      return l.trim().replace(/^"/, "").replace(/"$/, "");
    }), i = { name: n }, o = this.parseNodeAttr(s), a = this.getCurrentNode();
    this.currentIndent === 0 ? this.allNodes.add(n, i) : n in a ? (n === "PoseNode" ? a.PoseNode.push(i) : a[n].id !== void 0 && (a[n] = {}, a[n][a[n].id] = a[n]), o.id !== "" && (a[n][o.id] = i)) : typeof o.id == "number" ? (a[n] = {}, a[n][o.id] = i) : n !== "Properties70" && (n === "PoseNode" ? a[n] = [i] : a[n] = i), typeof o.id == "number" && (i.id = o.id), o.name !== "" && (i.attrName = o.name), o.type !== "" && (i.attrType = o.type), this.pushStack(i);
  }
  parseNodeAttr(e) {
    let t = e[0];
    e[0] !== "" && (t = parseInt(e[0]), isNaN(t) && (t = e[0]));
    let n = "", s = "";
    return e.length > 1 && (n = e[1].replace(/^(\w+)::/, ""), s = e[2]), { id: t, name: n, type: s };
  }
  parseNodeProperty(e, t, n) {
    let s = t[1].replace(/^"/, "").replace(/"$/, "").trim(), i = t[2].replace(/^"/, "").replace(/"$/, "").trim();
    s === "Content" && i === "," && (i = n.replace(/"/g, "").replace(/,$/, "").trim());
    const o = this.getCurrentNode();
    if (o.name === "Properties70") {
      this.parseNodeSpecialProperty(e, s, i);
      return;
    }
    if (s === "C") {
      const l = i.split(",").slice(1), c = parseInt(l[0]), f = parseInt(l[1]);
      let u = i.split(",").slice(3);
      u = u.map(function(d) {
        return d.trim().replace(/^"/, "");
      }), s = "connections", i = [c, f], Tf(i, u), o[s] === void 0 && (o[s] = []);
    }
    s === "Node" && (o.id = i), s in o && Array.isArray(o[s]) ? o[s].push(i) : s !== "a" ? o[s] = i : o.a = i, this.setCurrentProp(o, s), s === "a" && i.slice(-1) !== "," && (o.a = Di(i));
  }
  parseNodePropertyContinued(e) {
    const t = this.getCurrentNode();
    t.a += e, e.slice(-1) !== "," && (t.a = Di(t.a));
  }
  // parse "Property70"
  parseNodeSpecialProperty(e, t, n) {
    const s = n.split('",').map(function(f) {
      return f.trim().replace(/^\"/, "").replace(/\s/, "_");
    }), i = s[0], o = s[1], a = s[2], l = s[3];
    let c = s[4];
    switch (o) {
      case "int":
      case "enum":
      case "bool":
      case "ULongLong":
      case "double":
      case "Number":
      case "FieldOfView":
        c = parseFloat(c);
        break;
      case "Color":
      case "ColorRGB":
      case "Vector3D":
      case "Lcl_Translation":
      case "Lcl_Rotation":
      case "Lcl_Scaling":
        c = Di(c);
        break;
    }
    this.getPrevNode()[i] = {
      type: o,
      type2: a,
      flag: l,
      value: c
    }, this.setCurrentProp(this.getPrevNode(), i);
  }
}
class vf {
  parse(e) {
    const t = new yr(e);
    t.skip(23);
    const n = t.getUint32();
    if (n < 6400)
      throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + n);
    const s = new nl();
    for (; !this.endOfContent(t); ) {
      const i = this.parseNode(t, n);
      i !== null && s.add(i.name, i);
    }
    return s;
  }
  // Check if reader has reached the end of content.
  endOfContent(e) {
    return e.size() % 16 === 0 ? (e.getOffset() + 160 + 16 & -16) >= e.size() : e.getOffset() + 160 + 16 >= e.size();
  }
  // recursively parse nodes until the end of the file is reached
  parseNode(e, t) {
    const n = {}, s = t >= 7500 ? e.getUint64() : e.getUint32(), i = t >= 7500 ? e.getUint64() : e.getUint32();
    t >= 7500 ? e.getUint64() : e.getUint32();
    const o = e.getUint8(), a = e.getString(o);
    if (s === 0)
      return null;
    const l = [];
    for (let d = 0; d < i; d++)
      l.push(this.parseProperty(e));
    const c = l.length > 0 ? l[0] : "", f = l.length > 1 ? l[1] : "", u = l.length > 2 ? l[2] : "";
    for (n.singleProperty = i === 1 && e.getOffset() === s; s > e.getOffset(); ) {
      const d = this.parseNode(e, t);
      d !== null && this.parseSubNode(a, n, d);
    }
    return n.propertyList = l, typeof c == "number" && (n.id = c), f !== "" && (n.attrName = f), u !== "" && (n.attrType = u), a !== "" && (n.name = a), n;
  }
  parseSubNode(e, t, n) {
    if (n.singleProperty === !0) {
      const s = n.propertyList[0];
      Array.isArray(s) ? (t[n.name] = n, n.a = s) : t[n.name] = s;
    } else if (e === "Connections" && n.name === "C") {
      const s = [];
      n.propertyList.forEach(function(i, o) {
        o !== 0 && s.push(i);
      }), t.connections === void 0 && (t.connections = []), t.connections.push(s);
    } else if (n.name === "Properties70")
      Object.keys(n).forEach(function(i) {
        t[i] = n[i];
      });
    else if (e === "Properties70" && n.name === "P") {
      let s = n.propertyList[0], i = n.propertyList[1];
      const o = n.propertyList[2], a = n.propertyList[3];
      let l;
      s.indexOf("Lcl ") === 0 && (s = s.replace("Lcl ", "Lcl_")), i.indexOf("Lcl ") === 0 && (i = i.replace("Lcl ", "Lcl_")), i === "Color" || i === "ColorRGB" || i === "Vector" || i === "Vector3D" || i.indexOf("Lcl_") === 0 ? l = [n.propertyList[4], n.propertyList[5], n.propertyList[6]] : l = n.propertyList[4], t[s] = {
        type: i,
        type2: o,
        flag: a,
        value: l
      };
    } else t[n.name] === void 0 ? typeof n.id == "number" ? (t[n.name] = {}, t[n.name][n.id] = n) : t[n.name] = n : n.name === "PoseNode" ? (Array.isArray(t[n.name]) || (t[n.name] = [t[n.name]]), t[n.name].push(n)) : t[n.name][n.id] === void 0 && (t[n.name][n.id] = n);
  }
  parseProperty(e) {
    const t = e.getString(1);
    let n;
    switch (t) {
      case "C":
        return e.getBoolean();
      case "D":
        return e.getFloat64();
      case "F":
        return e.getFloat32();
      case "I":
        return e.getInt32();
      case "L":
        return e.getInt64();
      case "R":
        return n = e.getUint32(), e.getArrayBuffer(n);
      case "S":
        return n = e.getUint32(), e.getString(n);
      case "Y":
        return e.getInt16();
      case "b":
      case "c":
      case "d":
      case "f":
      case "i":
      case "l":
        const s = e.getUint32(), i = e.getUint32(), o = e.getUint32();
        if (i === 0)
          switch (t) {
            case "b":
            case "c":
              return e.getBooleanArray(s);
            case "d":
              return e.getFloat64Array(s);
            case "f":
              return e.getFloat32Array(s);
            case "i":
              return e.getInt32Array(s);
            case "l":
              return e.getInt64Array(s);
          }
        const a = Wu(new Uint8Array(e.getArrayBuffer(o))), l = new yr(a.buffer);
        switch (t) {
          case "b":
          case "c":
            return l.getBooleanArray(s);
          case "d":
            return l.getFloat64Array(s);
          case "f":
            return l.getFloat32Array(s);
          case "i":
            return l.getInt32Array(s);
          case "l":
            return l.getInt64Array(s);
        }
      default:
        throw new Error("THREE.FBXLoader: Unknown property type " + t);
    }
  }
}
class yr {
  constructor(e, t) {
    this.dv = new DataView(e), this.offset = 0, this.littleEndian = t !== void 0 ? t : !0;
  }
  getOffset() {
    return this.offset;
  }
  size() {
    return this.dv.buffer.byteLength;
  }
  skip(e) {
    this.offset += e;
  }
  // seems like true/false representation depends on exporter.
  // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
  // then sees LSB.
  getBoolean() {
    return (this.getUint8() & 1) === 1;
  }
  getBooleanArray(e) {
    const t = [];
    for (let n = 0; n < e; n++)
      t.push(this.getBoolean());
    return t;
  }
  getUint8() {
    const e = this.dv.getUint8(this.offset);
    return this.offset += 1, e;
  }
  getInt16() {
    const e = this.dv.getInt16(this.offset, this.littleEndian);
    return this.offset += 2, e;
  }
  getInt32() {
    const e = this.dv.getInt32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  getInt32Array(e) {
    const t = [];
    for (let n = 0; n < e; n++)
      t.push(this.getInt32());
    return t;
  }
  getUint32() {
    const e = this.dv.getUint32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  // JavaScript doesn't support 64-bit integer so calculate this here
  // 1 << 32 will return 1 so using multiply operation instead here.
  // There's a possibility that this method returns wrong value if the value
  // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
  // TODO: safely handle 64-bit integer
  getInt64() {
    let e, t;
    return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t & 2147483648 ? (t = ~t & 4294967295, e = ~e & 4294967295, e === 4294967295 && (t = t + 1 & 4294967295), e = e + 1 & 4294967295, -(t * 4294967296 + e)) : t * 4294967296 + e;
  }
  getInt64Array(e) {
    const t = [];
    for (let n = 0; n < e; n++)
      t.push(this.getInt64());
    return t;
  }
  // Note: see getInt64() comment
  getUint64() {
    let e, t;
    return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t * 4294967296 + e;
  }
  getFloat32() {
    const e = this.dv.getFloat32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  getFloat32Array(e) {
    const t = [];
    for (let n = 0; n < e; n++)
      t.push(this.getFloat32());
    return t;
  }
  getFloat64() {
    const e = this.dv.getFloat64(this.offset, this.littleEndian);
    return this.offset += 8, e;
  }
  getFloat64Array(e) {
    const t = [];
    for (let n = 0; n < e; n++)
      t.push(this.getFloat64());
    return t;
  }
  getArrayBuffer(e) {
    const t = this.dv.buffer.slice(this.offset, this.offset + e);
    return this.offset += e, t;
  }
  getString(e) {
    let t = [];
    for (let s = 0; s < e; s++)
      t[s] = this.getUint8();
    const n = t.indexOf(0);
    return n >= 0 && (t = t.slice(0, n)), ns(new Uint8Array(t));
  }
}
class nl {
  add(e, t) {
    this[e] = t;
  }
}
function yf(r) {
  const e = "Kaydara FBX Binary  \0";
  return r.byteLength >= e.length && e === ol(r, 0, e.length);
}
function _f(r) {
  const e = [
    "K",
    "a",
    "y",
    "d",
    "a",
    "r",
    "a",
    "\\",
    "F",
    "B",
    "X",
    "\\",
    "B",
    "i",
    "n",
    "a",
    "r",
    "y",
    "\\",
    "\\"
  ];
  let t = 0;
  function n(s) {
    const i = r[s - 1];
    return r = r.slice(t + s), t++, i;
  }
  for (let s = 0; s < e.length; ++s)
    if (n(1) === e[s])
      return !1;
  return !0;
}
function _r(r) {
  const e = /FBXVersion: (\d+)/, t = r.match(e);
  if (t)
    return parseInt(t[1]);
  throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
}
function xf(r) {
  return r / 46186158e3;
}
const wf = [];
function Gs(r, e, t, n) {
  let s;
  switch (n.mappingType) {
    case "ByPolygonVertex":
      s = r;
      break;
    case "ByPolygon":
      s = e;
      break;
    case "ByVertice":
      s = t;
      break;
    case "AllSame":
      s = n.indices[0];
      break;
    default:
      console.warn("THREE.FBXLoader: unknown attribute mapping type " + n.mappingType);
  }
  n.referenceType === "IndexToDirect" && (s = n.indices[s]);
  const i = s * n.dataSize, o = i + n.dataSize;
  return bf(wf, n.buffer, i, o);
}
const Oi = new vt(), Hn = new $();
function sl(r) {
  const e = new Ie(), t = new Ie(), n = new Ie(), s = new Ie(), i = new Ie(), o = new Ie(), a = new Ie(), l = new Ie(), c = new Ie(), f = new Ie(), u = new Ie(), d = new Ie(), h = r.inheritType ? r.inheritType : 0;
  if (r.translation && e.setPosition(Hn.fromArray(r.translation)), r.preRotation) {
    const y = r.preRotation.map(Ye.degToRad);
    y.push(r.eulerOrder), t.makeRotationFromEuler(Oi.fromArray(y));
  }
  if (r.rotation) {
    const y = r.rotation.map(Ye.degToRad);
    y.push(r.eulerOrder), n.makeRotationFromEuler(Oi.fromArray(y));
  }
  if (r.postRotation) {
    const y = r.postRotation.map(Ye.degToRad);
    y.push(r.eulerOrder), s.makeRotationFromEuler(Oi.fromArray(y)), s.invert();
  }
  r.scale && i.scale(Hn.fromArray(r.scale)), r.scalingOffset && a.setPosition(Hn.fromArray(r.scalingOffset)), r.scalingPivot && o.setPosition(Hn.fromArray(r.scalingPivot)), r.rotationOffset && l.setPosition(Hn.fromArray(r.rotationOffset)), r.rotationPivot && c.setPosition(Hn.fromArray(r.rotationPivot)), r.parentMatrixWorld && (u.copy(r.parentMatrix), f.copy(r.parentMatrixWorld));
  const m = t.clone().multiply(n).multiply(s), g = new Ie();
  g.extractRotation(f);
  const v = new Ie();
  v.copyPosition(f);
  const p = v.clone().invert().multiply(f), b = g.clone().invert().multiply(p), _ = i, M = new Ie();
  if (h === 0)
    M.copy(g).multiply(m).multiply(b).multiply(_);
  else if (h === 1)
    M.copy(g).multiply(b).multiply(m).multiply(_);
  else {
    const A = new Ie().scale(new $().setFromMatrixScale(u)).clone().invert(), C = b.clone().multiply(A);
    M.copy(g).multiply(m).multiply(C).multiply(_);
  }
  const R = c.clone().invert(), w = o.clone().invert();
  let E = e.clone().multiply(l).multiply(c).multiply(t).multiply(n).multiply(s).multiply(R).multiply(a).multiply(o).multiply(i).multiply(w);
  const x = new Ie().copyPosition(E), T = f.clone().multiply(x);
  return d.copyPosition(T), E = d.clone().multiply(M), E.premultiply(f.invert()), E;
}
function il(r) {
  r = r || 0;
  const e = [
    "ZYX",
    // -> XYZ extrinsic
    "YZX",
    // -> XZY extrinsic
    "XZY",
    // -> YZX extrinsic
    "ZXY",
    // -> YXZ extrinsic
    "YXZ",
    // -> ZXY extrinsic
    "XYZ"
    // -> ZYX extrinsic
    //'SphericXYZ', // not possible to support
  ];
  return r === 6 ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), e[0]) : e[r];
}
function Di(r) {
  return r.split(",").map(function(t) {
    return parseFloat(t);
  });
}
function ol(r, e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = r.byteLength), ns(new Uint8Array(r, e, t));
}
function Tf(r, e) {
  for (let t = 0, n = r.length, s = e.length; t < s; t++, n++)
    r[n] = e[t];
}
function bf(r, e, t, n) {
  for (let s = t, i = 0; s < n; s++, i++)
    r[i] = e[s];
  return r;
}
function xr(r, e, t) {
  return r.slice(0, e).concat(t).concat(r.slice(e));
}
var Ef = Object.defineProperty, Mf = (r, e, t) => e in r ? Ef(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, zo = (r, e, t) => (Mf(r, typeof e != "symbol" ? e + "" : e, t), t);
class Sf extends Un {
  constructor(e) {
    super(e);
  }
  load(e, t, n, s) {
    const i = new kn(this.manager);
    i.setPath(this.path), i.setRequestHeader(this.requestHeader), i.setWithCredentials(this.withCredentials), i.load(
      e,
      (o) => {
        if (typeof o != "string")
          throw new Error("unsupported data type");
        const a = JSON.parse(o), l = this.parse(a);
        t && t(l);
      },
      n,
      s
    );
  }
  loadAsync(e, t) {
    return super.loadAsync(e, t);
  }
  parse(e) {
    return new Go(e);
  }
}
class Go {
  constructor(e) {
    zo(this, "data"), this.data = e;
  }
  generateShapes(e, t = 100, n) {
    const s = [], i = { letterSpacing: 0, lineHeight: 1, ...n }, o = Af(e, t, this.data, i);
    for (let a = 0, l = o.length; a < l; a++)
      Array.prototype.push.apply(s, o[a].toShapes(!1));
    return s;
  }
}
zo(Go, "isFont");
zo(Go, "type");
function Af(r, e, t, n) {
  const s = Array.from(r), i = e / t.resolution, o = (t.boundingBox.yMax - t.boundingBox.yMin + t.underlineThickness) * i, a = [];
  let l = 0, c = 0;
  for (let f = 0; f < s.length; f++) {
    const u = s[f];
    if (u === `
`)
      l = 0, c -= o * n.lineHeight;
    else {
      const d = Pf(u, i, l, c, t);
      d && (l += d.offsetX + n.letterSpacing, a.push(d.path));
    }
  }
  return a;
}
function Pf(r, e, t, n, s) {
  const i = s.glyphs[r] || s.glyphs["?"];
  if (!i) {
    console.error('THREE.Font: character "' + r + '" does not exists in font family ' + s.familyName + ".");
    return;
  }
  const o = new pn();
  let a, l, c, f, u, d, h, m;
  if (i.o) {
    const g = i._cachedOutline || (i._cachedOutline = i.o.split(" "));
    for (let v = 0, p = g.length; v < p; )
      switch (g[v++]) {
        case "m":
          a = parseInt(g[v++]) * e + t, l = parseInt(g[v++]) * e + n, o.moveTo(a, l);
          break;
        case "l":
          a = parseInt(g[v++]) * e + t, l = parseInt(g[v++]) * e + n, o.lineTo(a, l);
          break;
        case "q":
          c = parseInt(g[v++]) * e + t, f = parseInt(g[v++]) * e + n, u = parseInt(g[v++]) * e + t, d = parseInt(g[v++]) * e + n, o.quadraticCurveTo(u, d, c, f);
          break;
        case "b":
          c = parseInt(g[v++]) * e + t, f = parseInt(g[v++]) * e + n, u = parseInt(g[v++]) * e + t, d = parseInt(g[v++]) * e + n, h = parseInt(g[v++]) * e + t, m = parseInt(g[v++]) * e + n, o.bezierCurveTo(u, d, h, m, c, f);
          break;
      }
  }
  return { offsetX: i.ha * e, path: o };
}
class wr extends Yl {
  constructor(e) {
    super(e), this.type = Lt;
  }
  // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html
  parse(e) {
    const o = function(x, T) {
      switch (x) {
        case 1:
          throw new Error("THREE.RGBELoader: Read Error: " + (T || ""));
        case 2:
          throw new Error("THREE.RGBELoader: Write Error: " + (T || ""));
        case 3:
          throw new Error("THREE.RGBELoader: Bad File Format: " + (T || ""));
        default:
        case 4:
          throw new Error("THREE.RGBELoader: Memory Error: " + (T || ""));
      }
    }, f = `
`, u = function(x, T, y) {
      T = T || 1024;
      let C = x.pos, N = -1, U = 0, Y = "", V = String.fromCharCode.apply(null, new Uint16Array(x.subarray(C, C + 128)));
      for (; 0 > (N = V.indexOf(f)) && U < T && C < x.byteLength; )
        Y += V, U += V.length, C += 128, V += String.fromCharCode.apply(null, new Uint16Array(x.subarray(C, C + 128)));
      return -1 < N ? (x.pos += U + N + 1, Y + V.slice(0, N)) : !1;
    }, d = function(x) {
      const T = /^#\?(\S+)/, y = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, A = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, C = /^\s*FORMAT=(\S+)\s*$/, N = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, U = {
        valid: 0,
        string: "",
        comments: "",
        programtype: "RGBE",
        format: "",
        gamma: 1,
        exposure: 1,
        width: 0,
        height: 0
      };
      let Y, V;
      for ((x.pos >= x.byteLength || !(Y = u(x))) && o(1, "no header found"), (V = Y.match(T)) || o(3, "bad initial token"), U.valid |= 1, U.programtype = V[1], U.string += Y + `
`; Y = u(x), Y !== !1; ) {
        if (U.string += Y + `
`, Y.charAt(0) === "#") {
          U.comments += Y + `
`;
          continue;
        }
        if ((V = Y.match(y)) && (U.gamma = parseFloat(V[1])), (V = Y.match(A)) && (U.exposure = parseFloat(V[1])), (V = Y.match(C)) && (U.valid |= 2, U.format = V[1]), (V = Y.match(N)) && (U.valid |= 4, U.height = parseInt(V[1], 10), U.width = parseInt(V[2], 10)), U.valid & 2 && U.valid & 4)
          break;
      }
      return U.valid & 2 || o(3, "missing format specifier"), U.valid & 4 || o(3, "missing image size specifier"), U;
    }, h = function(x, T, y) {
      const A = T;
      if (
        // run length encoding is not allowed so read flat
        A < 8 || A > 32767 || // this file is not run length encoded
        x[0] !== 2 || x[1] !== 2 || x[2] & 128
      )
        return new Uint8Array(x);
      A !== (x[2] << 8 | x[3]) && o(3, "wrong scanline width");
      const C = new Uint8Array(4 * T * y);
      C.length || o(4, "unable to allocate buffer space");
      let N = 0, U = 0;
      const Y = 4 * A, V = new Uint8Array(4), ne = new Uint8Array(Y);
      let Z = y;
      for (; Z > 0 && U < x.byteLength; ) {
        U + 4 > x.byteLength && o(1), V[0] = x[U++], V[1] = x[U++], V[2] = x[U++], V[3] = x[U++], (V[0] != 2 || V[1] != 2 || (V[2] << 8 | V[3]) != A) && o(3, "bad rgbe scanline format");
        let ee = 0, te;
        for (; ee < Y && U < x.byteLength; ) {
          te = x[U++];
          const he = te > 128;
          if (he && (te -= 128), (te === 0 || ee + te > Y) && o(3, "bad scanline data"), he) {
            const we = x[U++];
            for (let I = 0; I < te; I++)
              ne[ee++] = we;
          } else
            ne.set(x.subarray(U, U + te), ee), ee += te, U += te;
        }
        const fe = A;
        for (let he = 0; he < fe; he++) {
          let we = 0;
          C[N] = ne[he + we], we += A, C[N + 1] = ne[he + we], we += A, C[N + 2] = ne[he + we], we += A, C[N + 3] = ne[he + we], N += 4;
        }
        Z--;
      }
      return C;
    }, m = function(x, T, y, A) {
      const C = x[T + 3], N = Math.pow(2, C - 128) / 255;
      y[A + 0] = x[T + 0] * N, y[A + 1] = x[T + 1] * N, y[A + 2] = x[T + 2] * N, y[A + 3] = 1;
    }, g = function(x, T, y, A) {
      const C = x[T + 3], N = Math.pow(2, C - 128) / 255;
      y[A + 0] = Ls.toHalfFloat(Math.min(x[T + 0] * N, 65504)), y[A + 1] = Ls.toHalfFloat(Math.min(x[T + 1] * N, 65504)), y[A + 2] = Ls.toHalfFloat(Math.min(x[T + 2] * N, 65504)), y[A + 3] = Ls.toHalfFloat(1);
    }, v = new Uint8Array(e);
    v.pos = 0;
    const p = d(v), b = p.width, _ = p.height, M = h(v.subarray(v.pos), b, _);
    let R, w, E;
    switch (this.type) {
      case qs:
        E = M.length / 4;
        const x = new Float32Array(E * 4);
        for (let y = 0; y < E; y++)
          m(M, y * 4, x, y * 4);
        R = x, w = qs;
        break;
      case Lt:
        E = M.length / 4;
        const T = new Uint16Array(E * 4);
        for (let y = 0; y < E; y++)
          g(M, y * 4, T, y * 4);
        R = T, w = Lt;
        break;
      default:
        throw new Error("THREE.RGBELoader: Unsupported type: " + this.type);
    }
    return {
      width: b,
      height: _,
      data: R,
      header: p.string,
      gamma: p.gamma,
      exposure: p.exposure,
      type: w
    };
  }
  setDataType(e) {
    return this.type = e, this;
  }
  load(e, t, n, s) {
    function i(o, a) {
      switch (o.type) {
        case qs:
        case Lt:
          "colorSpace" in o ? o.colorSpace = "srgb-linear" : o.encoding = 3e3, o.minFilter = wt, o.magFilter = wt, o.generateMipmaps = !1, o.flipY = !0;
          break;
      }
      t && t(o, a);
    }
    return super.load(e, i, n, s);
  }
}
const Rf = "srgb";
class _s extends Un {
  constructor(e) {
    super(e), this.defaultDPI = 90, this.defaultUnit = "px";
  }
  load(e, t, n, s) {
    const i = this, o = new kn(i.manager);
    o.setPath(i.path), o.setRequestHeader(i.requestHeader), o.setWithCredentials(i.withCredentials), o.load(
      e,
      function(a) {
        try {
          t(i.parse(a));
        } catch (l) {
          s ? s(l) : console.error(l), i.manager.itemError(e);
        }
      },
      n,
      s
    );
  }
  parse(e) {
    const t = this;
    function n(I, B) {
      if (I.nodeType !== 1)
        return;
      const D = M(I);
      let O = !1, z = null;
      switch (I.nodeName) {
        case "svg":
          B = m(I, B);
          break;
        case "style":
          i(I);
          break;
        case "g":
          B = m(I, B);
          break;
        case "path":
          B = m(I, B), I.hasAttribute("d") && (z = s(I));
          break;
        case "rect":
          B = m(I, B), z = l(I);
          break;
        case "polygon":
          B = m(I, B), z = c(I);
          break;
        case "polyline":
          B = m(I, B), z = f(I);
          break;
        case "circle":
          B = m(I, B), z = u(I);
          break;
        case "ellipse":
          B = m(I, B), z = d(I);
          break;
        case "line":
          B = m(I, B), z = h(I);
          break;
        case "defs":
          O = !0;
          break;
        case "use":
          B = m(I, B);
          const L = (I.getAttributeNS("http://www.w3.org/1999/xlink", "href") || "").substring(1), X = I.viewportElement.getElementById(L);
          X ? n(X, B) : console.warn("SVGLoader: 'use node' references non-existent node id: " + L);
          break;
      }
      z && (B.fill !== void 0 && B.fill !== "none" && z.color.setStyle(B.fill, Rf), w(z, fe), C.push(z), z.userData = { node: I, style: B });
      const S = I.childNodes;
      for (let P = 0; P < S.length; P++) {
        const L = S[P];
        O && L.nodeName !== "style" && L.nodeName !== "defs" || n(L, B);
      }
      D && (U.pop(), U.length > 0 ? fe.copy(U[U.length - 1]) : fe.identity());
    }
    function s(I) {
      const B = new pn(), D = new ve(), O = new ve(), z = new ve();
      let S = !0, P = !1;
      const L = I.getAttribute("d");
      if (L === "" || L === "none")
        return null;
      const X = L.match(/[a-df-z][^a-df-z]*/gi);
      for (let H = 0, j = X.length; H < j; H++) {
        const K = X[H], se = K.charAt(0), ie = K.slice(1).trim();
        S === !0 && (P = !0, S = !1);
        let G;
        switch (se) {
          case "M":
            G = v(ie);
            for (let k = 0, oe = G.length; k < oe; k += 2)
              D.x = G[k + 0], D.y = G[k + 1], O.x = D.x, O.y = D.y, k === 0 ? B.moveTo(D.x, D.y) : B.lineTo(D.x, D.y), k === 0 && z.copy(D);
            break;
          case "H":
            G = v(ie);
            for (let k = 0, oe = G.length; k < oe; k++)
              D.x = G[k], O.x = D.x, O.y = D.y, B.lineTo(D.x, D.y), k === 0 && P === !0 && z.copy(D);
            break;
          case "V":
            G = v(ie);
            for (let k = 0, oe = G.length; k < oe; k++)
              D.y = G[k], O.x = D.x, O.y = D.y, B.lineTo(D.x, D.y), k === 0 && P === !0 && z.copy(D);
            break;
          case "L":
            G = v(ie);
            for (let k = 0, oe = G.length; k < oe; k += 2)
              D.x = G[k + 0], D.y = G[k + 1], O.x = D.x, O.y = D.y, B.lineTo(D.x, D.y), k === 0 && P === !0 && z.copy(D);
            break;
          case "C":
            G = v(ie);
            for (let k = 0, oe = G.length; k < oe; k += 6)
              B.bezierCurveTo(
                G[k + 0],
                G[k + 1],
                G[k + 2],
                G[k + 3],
                G[k + 4],
                G[k + 5]
              ), O.x = G[k + 2], O.y = G[k + 3], D.x = G[k + 4], D.y = G[k + 5], k === 0 && P === !0 && z.copy(D);
            break;
          case "S":
            G = v(ie);
            for (let k = 0, oe = G.length; k < oe; k += 4)
              B.bezierCurveTo(
                g(D.x, O.x),
                g(D.y, O.y),
                G[k + 0],
                G[k + 1],
                G[k + 2],
                G[k + 3]
              ), O.x = G[k + 0], O.y = G[k + 1], D.x = G[k + 2], D.y = G[k + 3], k === 0 && P === !0 && z.copy(D);
            break;
          case "Q":
            G = v(ie);
            for (let k = 0, oe = G.length; k < oe; k += 4)
              B.quadraticCurveTo(G[k + 0], G[k + 1], G[k + 2], G[k + 3]), O.x = G[k + 0], O.y = G[k + 1], D.x = G[k + 2], D.y = G[k + 3], k === 0 && P === !0 && z.copy(D);
            break;
          case "T":
            G = v(ie);
            for (let k = 0, oe = G.length; k < oe; k += 2) {
              const ge = g(D.x, O.x), Re = g(D.y, O.y);
              B.quadraticCurveTo(ge, Re, G[k + 0], G[k + 1]), O.x = ge, O.y = Re, D.x = G[k + 0], D.y = G[k + 1], k === 0 && P === !0 && z.copy(D);
            }
            break;
          case "A":
            G = v(ie, [3, 4], 7);
            for (let k = 0, oe = G.length; k < oe; k += 7) {
              if (G[k + 5] == D.x && G[k + 6] == D.y)
                continue;
              const ge = D.clone();
              D.x = G[k + 5], D.y = G[k + 6], O.x = D.x, O.y = D.y, o(
                B,
                G[k],
                G[k + 1],
                G[k + 2],
                G[k + 3],
                G[k + 4],
                ge,
                D
              ), k === 0 && P === !0 && z.copy(D);
            }
            break;
          case "m":
            G = v(ie);
            for (let k = 0, oe = G.length; k < oe; k += 2)
              D.x += G[k + 0], D.y += G[k + 1], O.x = D.x, O.y = D.y, k === 0 ? B.moveTo(D.x, D.y) : B.lineTo(D.x, D.y), k === 0 && z.copy(D);
            break;
          case "h":
            G = v(ie);
            for (let k = 0, oe = G.length; k < oe; k++)
              D.x += G[k], O.x = D.x, O.y = D.y, B.lineTo(D.x, D.y), k === 0 && P === !0 && z.copy(D);
            break;
          case "v":
            G = v(ie);
            for (let k = 0, oe = G.length; k < oe; k++)
              D.y += G[k], O.x = D.x, O.y = D.y, B.lineTo(D.x, D.y), k === 0 && P === !0 && z.copy(D);
            break;
          case "l":
            G = v(ie);
            for (let k = 0, oe = G.length; k < oe; k += 2)
              D.x += G[k + 0], D.y += G[k + 1], O.x = D.x, O.y = D.y, B.lineTo(D.x, D.y), k === 0 && P === !0 && z.copy(D);
            break;
          case "c":
            G = v(ie);
            for (let k = 0, oe = G.length; k < oe; k += 6)
              B.bezierCurveTo(
                D.x + G[k + 0],
                D.y + G[k + 1],
                D.x + G[k + 2],
                D.y + G[k + 3],
                D.x + G[k + 4],
                D.y + G[k + 5]
              ), O.x = D.x + G[k + 2], O.y = D.y + G[k + 3], D.x += G[k + 4], D.y += G[k + 5], k === 0 && P === !0 && z.copy(D);
            break;
          case "s":
            G = v(ie);
            for (let k = 0, oe = G.length; k < oe; k += 4)
              B.bezierCurveTo(
                g(D.x, O.x),
                g(D.y, O.y),
                D.x + G[k + 0],
                D.y + G[k + 1],
                D.x + G[k + 2],
                D.y + G[k + 3]
              ), O.x = D.x + G[k + 0], O.y = D.y + G[k + 1], D.x += G[k + 2], D.y += G[k + 3], k === 0 && P === !0 && z.copy(D);
            break;
          case "q":
            G = v(ie);
            for (let k = 0, oe = G.length; k < oe; k += 4)
              B.quadraticCurveTo(
                D.x + G[k + 0],
                D.y + G[k + 1],
                D.x + G[k + 2],
                D.y + G[k + 3]
              ), O.x = D.x + G[k + 0], O.y = D.y + G[k + 1], D.x += G[k + 2], D.y += G[k + 3], k === 0 && P === !0 && z.copy(D);
            break;
          case "t":
            G = v(ie);
            for (let k = 0, oe = G.length; k < oe; k += 2) {
              const ge = g(D.x, O.x), Re = g(D.y, O.y);
              B.quadraticCurveTo(ge, Re, D.x + G[k + 0], D.y + G[k + 1]), O.x = ge, O.y = Re, D.x = D.x + G[k + 0], D.y = D.y + G[k + 1], k === 0 && P === !0 && z.copy(D);
            }
            break;
          case "a":
            G = v(ie, [3, 4], 7);
            for (let k = 0, oe = G.length; k < oe; k += 7) {
              if (G[k + 5] == 0 && G[k + 6] == 0)
                continue;
              const ge = D.clone();
              D.x += G[k + 5], D.y += G[k + 6], O.x = D.x, O.y = D.y, o(
                B,
                G[k],
                G[k + 1],
                G[k + 2],
                G[k + 3],
                G[k + 4],
                ge,
                D
              ), k === 0 && P === !0 && z.copy(D);
            }
            break;
          case "Z":
          case "z":
            B.currentPath.autoClose = !0, B.currentPath.curves.length > 0 && (D.copy(z), B.currentPath.currentPoint.copy(D), S = !0);
            break;
          default:
            console.warn(K);
        }
        P = !1;
      }
      return B;
    }
    function i(I) {
      if (!(!I.sheet || !I.sheet.cssRules || !I.sheet.cssRules.length))
        for (let B = 0; B < I.sheet.cssRules.length; B++) {
          const D = I.sheet.cssRules[B];
          if (D.type !== 1)
            continue;
          const O = D.selectorText.split(/,/gm).filter(Boolean).map((z) => z.trim());
          for (let z = 0; z < O.length; z++) {
            const S = Object.fromEntries(Object.entries(D.style).filter(([, P]) => P !== ""));
            N[O[z]] = Object.assign(N[O[z]] || {}, S);
          }
        }
    }
    function o(I, B, D, O, z, S, P, L) {
      if (B == 0 || D == 0) {
        I.lineTo(L.x, L.y);
        return;
      }
      O = O * Math.PI / 180, B = Math.abs(B), D = Math.abs(D);
      const X = (P.x - L.x) / 2, H = (P.y - L.y) / 2, j = Math.cos(O) * X + Math.sin(O) * H, K = -Math.sin(O) * X + Math.cos(O) * H;
      let se = B * B, ie = D * D;
      const G = j * j, k = K * K, oe = G / se + k / ie;
      if (oe > 1) {
        const Bt = Math.sqrt(oe);
        B = Bt * B, D = Bt * D, se = B * B, ie = D * D;
      }
      const ge = se * k + ie * G, Re = (se * ie - ge) / ge;
      let Ke = Math.sqrt(Math.max(0, Re));
      z === S && (Ke = -Ke);
      const He = Ke * B * K / D, Et = -Ke * D * j / B, un = Math.cos(O) * He - Math.sin(O) * Et + (P.x + L.x) / 2, En = Math.sin(O) * He + Math.cos(O) * Et + (P.y + L.y) / 2, Nt = a(1, 0, (j - He) / B, (K - Et) / D), yt = a((j - He) / B, (K - Et) / D, (-j - He) / B, (-K - Et) / D) % (Math.PI * 2);
      I.currentPath.absellipse(un, En, B, D, Nt, Nt + yt, S === 0, O);
    }
    function a(I, B, D, O) {
      const z = I * D + B * O, S = Math.sqrt(I * I + B * B) * Math.sqrt(D * D + O * O);
      let P = Math.acos(Math.max(-1, Math.min(1, z / S)));
      return I * O - B * D < 0 && (P = -P), P;
    }
    function l(I) {
      const B = _(I.getAttribute("x") || 0), D = _(I.getAttribute("y") || 0), O = _(I.getAttribute("rx") || I.getAttribute("ry") || 0), z = _(I.getAttribute("ry") || I.getAttribute("rx") || 0), S = _(I.getAttribute("width")), P = _(I.getAttribute("height")), L = 1 - 0.551915024494, X = new pn();
      return X.moveTo(B + O, D), X.lineTo(B + S - O, D), (O !== 0 || z !== 0) && X.bezierCurveTo(B + S - O * L, D, B + S, D + z * L, B + S, D + z), X.lineTo(B + S, D + P - z), (O !== 0 || z !== 0) && X.bezierCurveTo(B + S, D + P - z * L, B + S - O * L, D + P, B + S - O, D + P), X.lineTo(B + O, D + P), (O !== 0 || z !== 0) && X.bezierCurveTo(B + O * L, D + P, B, D + P - z * L, B, D + P - z), X.lineTo(B, D + z), (O !== 0 || z !== 0) && X.bezierCurveTo(B, D + z * L, B + O * L, D, B + O, D), X;
    }
    function c(I) {
      function B(S, P, L) {
        const X = _(P), H = _(L);
        z === 0 ? O.moveTo(X, H) : O.lineTo(X, H), z++;
      }
      const D = /([+-]?\d*\.?\d+(?:e[+-]?\d+)?)(?:,|\s)([+-]?\d*\.?\d+(?:e[+-]?\d+)?)/g, O = new pn();
      let z = 0;
      return I.getAttribute("points").replace(D, B), O.currentPath.autoClose = !0, O;
    }
    function f(I) {
      function B(S, P, L) {
        const X = _(P), H = _(L);
        z === 0 ? O.moveTo(X, H) : O.lineTo(X, H), z++;
      }
      const D = /([+-]?\d*\.?\d+(?:e[+-]?\d+)?)(?:,|\s)([+-]?\d*\.?\d+(?:e[+-]?\d+)?)/g, O = new pn();
      let z = 0;
      return I.getAttribute("points").replace(D, B), O.currentPath.autoClose = !1, O;
    }
    function u(I) {
      const B = _(I.getAttribute("cx") || 0), D = _(I.getAttribute("cy") || 0), O = _(I.getAttribute("r") || 0), z = new _i();
      z.absarc(B, D, O, 0, Math.PI * 2);
      const S = new pn();
      return S.subPaths.push(z), S;
    }
    function d(I) {
      const B = _(I.getAttribute("cx") || 0), D = _(I.getAttribute("cy") || 0), O = _(I.getAttribute("rx") || 0), z = _(I.getAttribute("ry") || 0), S = new _i();
      S.absellipse(B, D, O, z, 0, Math.PI * 2);
      const P = new pn();
      return P.subPaths.push(S), P;
    }
    function h(I) {
      const B = _(I.getAttribute("x1") || 0), D = _(I.getAttribute("y1") || 0), O = _(I.getAttribute("x2") || 0), z = _(I.getAttribute("y2") || 0), S = new pn();
      return S.moveTo(B, D), S.lineTo(O, z), S.currentPath.autoClose = !1, S;
    }
    function m(I, B) {
      B = Object.assign({}, B);
      let D = {};
      if (I.hasAttribute("class")) {
        const P = I.getAttribute("class").split(/\s/).filter(Boolean).map((L) => L.trim());
        for (let L = 0; L < P.length; L++)
          D = Object.assign(D, N["." + P[L]]);
      }
      I.hasAttribute("id") && (D = Object.assign(D, N["#" + I.getAttribute("id")]));
      function O(P, L, X) {
        X === void 0 && (X = function(j) {
          return j.startsWith("url") && console.warn("SVGLoader: url access in attributes is not implemented."), j;
        }), I.hasAttribute(P) && (B[L] = X(I.getAttribute(P))), D[P] && (B[L] = X(D[P])), I.style && I.style[P] !== "" && (B[L] = X(I.style[P]));
      }
      function z(P) {
        return Math.max(0, Math.min(1, _(P)));
      }
      function S(P) {
        return Math.max(0, _(P));
      }
      return O("fill", "fill"), O("fill-opacity", "fillOpacity", z), O("fill-rule", "fillRule"), O("opacity", "opacity", z), O("stroke", "stroke"), O("stroke-opacity", "strokeOpacity", z), O("stroke-width", "strokeWidth", S), O("stroke-linejoin", "strokeLineJoin"), O("stroke-linecap", "strokeLineCap"), O("stroke-miterlimit", "strokeMiterLimit", S), O("visibility", "visibility"), B;
    }
    function g(I, B) {
      return I - (B - I);
    }
    function v(I, B, D) {
      if (typeof I != "string")
        throw new TypeError("Invalid input: " + typeof I);
      const O = {
        WHITESPACE: /[ \t\r\n]/,
        DIGIT: /[\d]/,
        SIGN: /[-+]/,
        POINT: /\./,
        COMMA: /,/,
        EXP: /e/i,
        FLAGS: /[01]/
      }, z = 0, S = 1, P = 2, L = 3;
      let X = z, H = !0, j = "", K = "";
      const se = [];
      function ie(ge, Re, Ke) {
        const He = new SyntaxError('Unexpected character "' + ge + '" at index ' + Re + ".");
        throw He.partial = Ke, He;
      }
      function G() {
        j !== "" && (K === "" ? se.push(Number(j)) : se.push(Number(j) * Math.pow(10, Number(K)))), j = "", K = "";
      }
      let k;
      const oe = I.length;
      for (let ge = 0; ge < oe; ge++) {
        if (k = I[ge], Array.isArray(B) && B.includes(se.length % D) && O.FLAGS.test(k)) {
          X = S, j = k, G();
          continue;
        }
        if (X === z) {
          if (O.WHITESPACE.test(k))
            continue;
          if (O.DIGIT.test(k) || O.SIGN.test(k)) {
            X = S, j = k;
            continue;
          }
          if (O.POINT.test(k)) {
            X = P, j = k;
            continue;
          }
          O.COMMA.test(k) && (H && ie(k, ge, se), H = !0);
        }
        if (X === S) {
          if (O.DIGIT.test(k)) {
            j += k;
            continue;
          }
          if (O.POINT.test(k)) {
            j += k, X = P;
            continue;
          }
          if (O.EXP.test(k)) {
            X = L;
            continue;
          }
          O.SIGN.test(k) && j.length === 1 && O.SIGN.test(j[0]) && ie(k, ge, se);
        }
        if (X === P) {
          if (O.DIGIT.test(k)) {
            j += k;
            continue;
          }
          if (O.EXP.test(k)) {
            X = L;
            continue;
          }
          O.POINT.test(k) && j[j.length - 1] === "." && ie(k, ge, se);
        }
        if (X === L) {
          if (O.DIGIT.test(k)) {
            K += k;
            continue;
          }
          if (O.SIGN.test(k)) {
            if (K === "") {
              K += k;
              continue;
            }
            K.length === 1 && O.SIGN.test(K) && ie(k, ge, se);
          }
        }
        O.WHITESPACE.test(k) ? (G(), X = z, H = !1) : O.COMMA.test(k) ? (G(), X = z, H = !0) : O.SIGN.test(k) ? (G(), X = S, j = k) : O.POINT.test(k) ? (G(), X = P, j = k) : ie(k, ge, se);
      }
      return G(), se;
    }
    const p = ["mm", "cm", "in", "pt", "pc", "px"], b = {
      mm: {
        mm: 1,
        cm: 0.1,
        in: 1 / 25.4,
        pt: 72 / 25.4,
        pc: 6 / 25.4,
        px: -1
      },
      cm: {
        mm: 10,
        cm: 1,
        in: 1 / 2.54,
        pt: 72 / 2.54,
        pc: 6 / 2.54,
        px: -1
      },
      in: {
        mm: 25.4,
        cm: 2.54,
        in: 1,
        pt: 72,
        pc: 6,
        px: -1
      },
      pt: {
        mm: 25.4 / 72,
        cm: 2.54 / 72,
        in: 1 / 72,
        pt: 1,
        pc: 6 / 72,
        px: -1
      },
      pc: {
        mm: 25.4 / 6,
        cm: 2.54 / 6,
        in: 1 / 6,
        pt: 72 / 6,
        pc: 1,
        px: -1
      },
      px: {
        px: 1
      }
    };
    function _(I) {
      let B = "px";
      if (typeof I == "string" || I instanceof String)
        for (let O = 0, z = p.length; O < z; O++) {
          const S = p[O];
          if (I.endsWith(S)) {
            B = S, I = I.substring(0, I.length - S.length);
            break;
          }
        }
      let D;
      return B === "px" && t.defaultUnit !== "px" ? D = b.in[t.defaultUnit] / t.defaultDPI : (D = b[B][t.defaultUnit], D < 0 && (D = b[B].in * t.defaultDPI)), D * parseFloat(I);
    }
    function M(I) {
      if (!(I.hasAttribute("transform") || I.nodeName === "use" && (I.hasAttribute("x") || I.hasAttribute("y"))))
        return null;
      const B = R(I);
      return U.length > 0 && B.premultiply(U[U.length - 1]), fe.copy(B), U.push(B), B;
    }
    function R(I) {
      const B = new Cn(), D = Y;
      if (I.nodeName === "use" && (I.hasAttribute("x") || I.hasAttribute("y"))) {
        const O = _(I.getAttribute("x")), z = _(I.getAttribute("y"));
        B.translate(O, z);
      }
      if (I.hasAttribute("transform")) {
        const O = I.getAttribute("transform").split(")");
        for (let z = O.length - 1; z >= 0; z--) {
          const S = O[z].trim();
          if (S === "")
            continue;
          const P = S.indexOf("("), L = S.length;
          if (P > 0 && P < L) {
            const X = S.slice(0, P), H = v(S.slice(P + 1));
            switch (D.identity(), X) {
              case "translate":
                if (H.length >= 1) {
                  const j = H[0];
                  let K = 0;
                  H.length >= 2 && (K = H[1]), D.translate(j, K);
                }
                break;
              case "rotate":
                if (H.length >= 1) {
                  let j = 0, K = 0, se = 0;
                  j = H[0] * Math.PI / 180, H.length >= 3 && (K = H[1], se = H[2]), V.makeTranslation(-K, -se), ne.makeRotation(j), Z.multiplyMatrices(ne, V), V.makeTranslation(K, se), D.multiplyMatrices(V, Z);
                }
                break;
              case "scale":
                if (H.length >= 1) {
                  const j = H[0];
                  let K = j;
                  H.length >= 2 && (K = H[1]), D.scale(j, K);
                }
                break;
              case "skewX":
                H.length === 1 && D.set(1, Math.tan(H[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);
                break;
              case "skewY":
                H.length === 1 && D.set(1, 0, 0, Math.tan(H[0] * Math.PI / 180), 1, 0, 0, 0, 1);
                break;
              case "matrix":
                H.length === 6 && D.set(H[0], H[2], H[4], H[1], H[3], H[5], 0, 0, 1);
                break;
            }
          }
          B.premultiply(D);
        }
      }
      return B;
    }
    function w(I, B) {
      function D(P) {
        te.set(P.x, P.y, 1).applyMatrix3(B), P.set(te.x, te.y);
      }
      function O(P) {
        const L = P.xRadius, X = P.yRadius, H = Math.cos(P.aRotation), j = Math.sin(P.aRotation), K = new $(L * H, L * j, 0), se = new $(-X * j, X * H, 0), ie = K.applyMatrix3(B), G = se.applyMatrix3(B), k = Y.set(ie.x, G.x, 0, ie.y, G.y, 0, 0, 0, 1), oe = V.copy(k).invert(), Ke = ne.copy(oe).transpose().multiply(oe).elements, He = A(Ke[0], Ke[1], Ke[4]), Et = Math.sqrt(He.rt1), un = Math.sqrt(He.rt2);
        if (P.xRadius = 1 / Et, P.yRadius = 1 / un, P.aRotation = Math.atan2(He.sn, He.cs), !((P.aEndAngle - P.aStartAngle) % (2 * Math.PI) < Number.EPSILON)) {
          const Nt = V.set(Et, 0, 0, 0, un, 0, 0, 0, 1), yt = ne.set(He.cs, He.sn, 0, -He.sn, He.cs, 0, 0, 0, 1), Bt = Nt.multiply(yt).multiply(k), is = (Cs) => {
            const { x: di, y: Is } = new $(Math.cos(Cs), Math.sin(Cs), 0).applyMatrix3(Bt);
            return Math.atan2(Is, di);
          };
          P.aStartAngle = is(P.aStartAngle), P.aEndAngle = is(P.aEndAngle), E(B) && (P.aClockwise = !P.aClockwise);
        }
      }
      function z(P) {
        const L = T(B), X = y(B);
        P.xRadius *= L, P.yRadius *= X;
        const H = L > Number.EPSILON ? Math.atan2(B.elements[1], B.elements[0]) : Math.atan2(-B.elements[3], B.elements[4]);
        P.aRotation += H, E(B) && (P.aStartAngle *= -1, P.aEndAngle *= -1, P.aClockwise = !P.aClockwise);
      }
      const S = I.subPaths;
      for (let P = 0, L = S.length; P < L; P++) {
        const H = S[P].curves;
        for (let j = 0; j < H.length; j++) {
          const K = H[j];
          K.isLineCurve ? (D(K.v1), D(K.v2)) : K.isCubicBezierCurve ? (D(K.v0), D(K.v1), D(K.v2), D(K.v3)) : K.isQuadraticBezierCurve ? (D(K.v0), D(K.v1), D(K.v2)) : K.isEllipseCurve && (ee.set(K.aX, K.aY), D(ee), K.aX = ee.x, K.aY = ee.y, x(B) ? O(K) : z(K));
        }
      }
    }
    function E(I) {
      const B = I.elements;
      return B[0] * B[4] - B[1] * B[3] < 0;
    }
    function x(I) {
      const B = I.elements, D = B[0] * B[3] + B[1] * B[4];
      if (D === 0)
        return !1;
      const O = T(I), z = y(I);
      return Math.abs(D / (O * z)) > Number.EPSILON;
    }
    function T(I) {
      const B = I.elements;
      return Math.sqrt(B[0] * B[0] + B[1] * B[1]);
    }
    function y(I) {
      const B = I.elements;
      return Math.sqrt(B[3] * B[3] + B[4] * B[4]);
    }
    function A(I, B, D) {
      let O, z, S, P, L;
      const X = I + D, H = I - D, j = Math.sqrt(H * H + 4 * B * B);
      return X > 0 ? (O = 0.5 * (X + j), L = 1 / O, z = I * L * D - B * L * B) : X < 0 ? z = 0.5 * (X - j) : (O = 0.5 * j, z = -0.5 * j), H > 0 ? S = H + j : S = H - j, Math.abs(S) > 2 * Math.abs(B) ? (L = -2 * B / S, P = 1 / Math.sqrt(1 + L * L), S = L * P) : Math.abs(B) === 0 ? (S = 1, P = 0) : (L = -0.5 * S / B, S = 1 / Math.sqrt(1 + L * L), P = L * S), H > 0 && (L = S, S = -P, P = L), { rt1: O, rt2: z, cs: S, sn: P };
    }
    const C = [], N = {}, U = [], Y = new Cn(), V = new Cn(), ne = new Cn(), Z = new Cn(), ee = new ve(), te = new $(), fe = new Cn(), he = new DOMParser().parseFromString(e, "image/svg+xml");
    return n(he.documentElement, {
      fill: "#000",
      fillOpacity: 1,
      strokeOpacity: 1,
      strokeWidth: 1,
      strokeLineJoin: "miter",
      strokeLineCap: "butt",
      strokeMiterLimit: 4
    }), { paths: C, xml: he.documentElement };
  }
  static createShapes(e) {
    const n = {
      ORIGIN: 0,
      DESTINATION: 1,
      BETWEEN: 2,
      LEFT: 3,
      RIGHT: 4,
      BEHIND: 5,
      BEYOND: 6
    }, s = {
      loc: n.ORIGIN,
      t: 0
    };
    function i(g, v, p, b) {
      const _ = g.x, M = v.x, R = p.x, w = b.x, E = g.y, x = v.y, T = p.y, y = b.y, A = (w - R) * (E - T) - (y - T) * (_ - R), C = (M - _) * (E - T) - (x - E) * (_ - R), N = (y - T) * (M - _) - (w - R) * (x - E), U = A / N, Y = C / N;
      if (N === 0 && A !== 0 || U <= 0 || U >= 1 || Y < 0 || Y > 1)
        return null;
      if (A === 0 && N === 0) {
        for (let V = 0; V < 2; V++)
          if (o(V === 0 ? p : b, g, v), s.loc == n.ORIGIN) {
            const ne = V === 0 ? p : b;
            return { x: ne.x, y: ne.y, t: s.t };
          } else if (s.loc == n.BETWEEN) {
            const ne = +(_ + s.t * (M - _)).toPrecision(10), Z = +(E + s.t * (x - E)).toPrecision(10);
            return { x: ne, y: Z, t: s.t };
          }
        return null;
      } else {
        for (let Z = 0; Z < 2; Z++)
          if (o(Z === 0 ? p : b, g, v), s.loc == n.ORIGIN) {
            const ee = Z === 0 ? p : b;
            return { x: ee.x, y: ee.y, t: s.t };
          }
        const V = +(_ + U * (M - _)).toPrecision(10), ne = +(E + U * (x - E)).toPrecision(10);
        return { x: V, y: ne, t: U };
      }
    }
    function o(g, v, p) {
      const b = p.x - v.x, _ = p.y - v.y, M = g.x - v.x, R = g.y - v.y, w = b * R - M * _;
      if (g.x === v.x && g.y === v.y) {
        s.loc = n.ORIGIN, s.t = 0;
        return;
      }
      if (g.x === p.x && g.y === p.y) {
        s.loc = n.DESTINATION, s.t = 1;
        return;
      }
      if (w < -Number.EPSILON) {
        s.loc = n.LEFT;
        return;
      }
      if (w > Number.EPSILON) {
        s.loc = n.RIGHT;
        return;
      }
      if (b * M < 0 || _ * R < 0) {
        s.loc = n.BEHIND;
        return;
      }
      if (Math.sqrt(b * b + _ * _) < Math.sqrt(M * M + R * R)) {
        s.loc = n.BEYOND;
        return;
      }
      let E;
      b !== 0 ? E = M / b : E = R / _, s.loc = n.BETWEEN, s.t = E;
    }
    function a(g, v) {
      const p = [], b = [];
      for (let _ = 1; _ < g.length; _++) {
        const M = g[_ - 1], R = g[_];
        for (let w = 1; w < v.length; w++) {
          const E = v[w - 1], x = v[w], T = i(M, R, E, x);
          T !== null && p.find(
            (y) => y.t <= T.t + Number.EPSILON && y.t >= T.t - Number.EPSILON
          ) === void 0 && (p.push(T), b.push(new ve(T.x, T.y)));
        }
      }
      return b;
    }
    function l(g, v, p) {
      const b = new ve();
      v.getCenter(b);
      const _ = [];
      return p.forEach((M) => {
        M.boundingBox.containsPoint(b) && a(g, M.points).forEach((w) => {
          _.push({ identifier: M.identifier, isCW: M.isCW, point: w });
        });
      }), _.sort((M, R) => M.point.x - R.point.x), _;
    }
    function c(g, v, p, b, _) {
      (_ == null || _ === "") && (_ = "nonzero");
      const M = new ve();
      g.boundingBox.getCenter(M);
      const R = [new ve(p, M.y), new ve(b, M.y)], w = l(R, g.boundingBox, v);
      w.sort((C, N) => C.point.x - N.point.x);
      const E = [], x = [];
      w.forEach((C) => {
        C.identifier === g.identifier ? E.push(C) : x.push(C);
      });
      const T = E[0].point.x, y = [];
      let A = 0;
      for (; A < x.length && x[A].point.x < T; )
        y.length > 0 && y[y.length - 1] === x[A].identifier ? y.pop() : y.push(x[A].identifier), A++;
      if (y.push(g.identifier), _ === "evenodd") {
        const C = y.length % 2 === 0, N = y[y.length - 2];
        return { identifier: g.identifier, isHole: C, for: N };
      } else if (_ === "nonzero") {
        let C = !0, N = null, U = null;
        for (let Y = 0; Y < y.length; Y++) {
          const V = y[Y];
          C ? (U = v[V].isCW, C = !1, N = V) : U !== v[V].isCW && (U = v[V].isCW, C = !0);
        }
        return { identifier: g.identifier, isHole: C, for: N };
      } else
        console.warn('fill-rule: "' + _ + '" is currently not implemented.');
    }
    let f = 999999999, u = -999999999, d = e.subPaths.map((g) => {
      const v = g.getPoints();
      let p = -999999999, b = 999999999, _ = -999999999, M = 999999999;
      for (let R = 0; R < v.length; R++) {
        const w = v[R];
        w.y > p && (p = w.y), w.y < b && (b = w.y), w.x > _ && (_ = w.x), w.x < M && (M = w.x);
      }
      return u <= _ && (u = _ + 1), f >= M && (f = M - 1), {
        curves: g.curves,
        points: v,
        isCW: Wl.isClockWise(v),
        identifier: -1,
        boundingBox: new va(new ve(M, b), new ve(_, p))
      };
    });
    d = d.filter((g) => g.points.length > 1);
    for (let g = 0; g < d.length; g++)
      d[g].identifier = g;
    const h = d.map(
      (g) => c(
        g,
        d,
        f,
        u,
        e.userData ? e.userData.style.fillRule : void 0
      )
    ), m = [];
    return d.forEach((g) => {
      if (!h[g.identifier].isHole) {
        const p = new Xl();
        p.curves = g.curves, h.filter((_) => _.isHole && _.for === g.identifier).forEach((_) => {
          const M = d[_.identifier], R = new _i();
          R.curves = M.curves, p.holes.push(R);
        }), m.push(p);
      }
    }), m;
  }
  static getStrokeStyle(e, t, n, s, i) {
    return e = e !== void 0 ? e : 1, t = t !== void 0 ? t : "#000", n = n !== void 0 ? n : "miter", s = s !== void 0 ? s : "butt", i = i !== void 0 ? i : 4, {
      strokeColor: t,
      strokeWidth: e,
      strokeLineJoin: n,
      strokeLineCap: s,
      strokeMiterLimit: i
    };
  }
  static pointsToStroke(e, t, n, s) {
    const i = [], o = [], a = [];
    if (_s.pointsToStrokeWithBuffers(e, t, n, s, i, o, a) === 0)
      return null;
    const l = new ht();
    return l.setAttribute("position", new gt(i, 3)), l.setAttribute("normal", new gt(o, 3)), l.setAttribute("uv", new gt(a, 2)), l;
  }
  static pointsToStrokeWithBuffers(e, t, n, s, i, o, a, l) {
    const c = new ve(), f = new ve(), u = new ve(), d = new ve(), h = new ve(), m = new ve(), g = new ve(), v = new ve(), p = new ve(), b = new ve(), _ = new ve(), M = new ve(), R = new ve(), w = new ve(), E = new ve(), x = new ve(), T = new ve();
    n = n !== void 0 ? n : 12, s = s !== void 0 ? s : 1e-3, l = l !== void 0 ? l : 0, e = H(e);
    const y = e.length;
    if (y < 2)
      return 0;
    const A = e[0].equals(e[y - 1]);
    let C, N = e[0], U;
    const Y = t.strokeWidth / 2, V = 1 / (y - 1);
    let ne = 0, Z, ee, te, fe, he = !1, we = 0, I = l * 3, B = l * 2;
    D(e[0], e[1], c).multiplyScalar(Y), v.copy(e[0]).sub(c), p.copy(e[0]).add(c), b.copy(v), _.copy(p);
    for (let j = 1; j < y; j++) {
      C = e[j], j === y - 1 ? A ? U = e[1] : U = void 0 : U = e[j + 1];
      const K = c;
      if (D(N, C, K), u.copy(K).multiplyScalar(Y), M.copy(C).sub(u), R.copy(C).add(u), Z = ne + V, ee = !1, U !== void 0) {
        D(C, U, f), u.copy(f).multiplyScalar(Y), w.copy(C).sub(u), E.copy(C).add(u), te = !0, u.subVectors(U, N), K.dot(u) < 0 && (te = !1), j === 1 && (he = te), u.subVectors(U, C), u.normalize();
        const se = Math.abs(K.dot(u));
        if (se > Number.EPSILON) {
          const ie = Y / se;
          u.multiplyScalar(-ie), d.subVectors(C, N), h.copy(d).setLength(ie).add(u), x.copy(h).negate();
          const G = h.length(), k = d.length();
          d.divideScalar(k), m.subVectors(U, C);
          const oe = m.length();
          switch (m.divideScalar(oe), d.dot(x) < k && m.dot(x) < oe && (ee = !0), T.copy(h).add(C), x.add(C), fe = !1, ee ? te ? (E.copy(x), R.copy(x)) : (w.copy(x), M.copy(x)) : S(), t.strokeLineJoin) {
            case "bevel":
              P(te, ee, Z);
              break;
            case "round":
              L(te, ee), te ? z(C, M, w, Z, 0) : z(C, E, R, Z, 1);
              break;
            case "miter":
            case "miter-clip":
            default:
              const ge = Y * t.strokeMiterLimit / G;
              if (ge < 1)
                if (t.strokeLineJoin !== "miter-clip") {
                  P(te, ee, Z);
                  break;
                } else
                  L(te, ee), te ? (m.subVectors(T, M).multiplyScalar(ge).add(M), g.subVectors(T, w).multiplyScalar(ge).add(w), O(M, Z, 0), O(m, Z, 0), O(C, Z, 0.5), O(C, Z, 0.5), O(m, Z, 0), O(g, Z, 0), O(C, Z, 0.5), O(g, Z, 0), O(w, Z, 0)) : (m.subVectors(T, R).multiplyScalar(ge).add(R), g.subVectors(T, E).multiplyScalar(ge).add(E), O(R, Z, 1), O(m, Z, 1), O(C, Z, 0.5), O(C, Z, 0.5), O(m, Z, 1), O(g, Z, 1), O(C, Z, 0.5), O(g, Z, 1), O(E, Z, 1));
              else
                ee ? (te ? (O(p, ne, 1), O(v, ne, 0), O(T, Z, 0), O(p, ne, 1), O(T, Z, 0), O(x, Z, 1)) : (O(p, ne, 1), O(v, ne, 0), O(T, Z, 1), O(v, ne, 0), O(x, Z, 0), O(T, Z, 1)), te ? w.copy(T) : E.copy(T)) : te ? (O(M, Z, 0), O(T, Z, 0), O(C, Z, 0.5), O(C, Z, 0.5), O(T, Z, 0), O(w, Z, 0)) : (O(R, Z, 1), O(T, Z, 1), O(C, Z, 0.5), O(C, Z, 0.5), O(T, Z, 1), O(E, Z, 1)), fe = !0;
              break;
          }
        } else
          S();
      } else
        S();
      !A && j === y - 1 && X(e[0], b, _, te, !0, ne), ne = Z, N = C, v.copy(w), p.copy(E);
    }
    if (!A)
      X(C, M, R, te, !1, Z);
    else if (ee && i) {
      let j = T, K = x;
      he !== te && (j = x, K = T), te ? (fe || he) && (K.toArray(i, 0 * 3), K.toArray(i, 3 * 3), fe && j.toArray(i, 1 * 3)) : (fe || !he) && (K.toArray(i, 1 * 3), K.toArray(i, 3 * 3), fe && j.toArray(i, 0 * 3));
    }
    return we;
    function D(j, K, se) {
      return se.subVectors(K, j), se.set(-se.y, se.x).normalize();
    }
    function O(j, K, se) {
      i && (i[I] = j.x, i[I + 1] = j.y, i[I + 2] = 0, o && (o[I] = 0, o[I + 1] = 0, o[I + 2] = 1), I += 3, a && (a[B] = K, a[B + 1] = se, B += 2)), we += 3;
    }
    function z(j, K, se, ie, G) {
      c.copy(K).sub(j).normalize(), f.copy(se).sub(j).normalize();
      let k = Math.PI;
      const oe = c.dot(f);
      Math.abs(oe) < 1 && (k = Math.abs(Math.acos(oe))), k /= n, u.copy(K);
      for (let ge = 0, Re = n - 1; ge < Re; ge++)
        d.copy(u).rotateAround(j, k), O(u, ie, G), O(d, ie, G), O(j, ie, 0.5), u.copy(d);
      O(d, ie, G), O(se, ie, G), O(j, ie, 0.5);
    }
    function S() {
      O(p, ne, 1), O(v, ne, 0), O(M, Z, 0), O(p, ne, 1), O(M, Z, 0), O(R, Z, 1);
    }
    function P(j, K, se) {
      K ? j ? (O(p, ne, 1), O(v, ne, 0), O(M, Z, 0), O(p, ne, 1), O(M, Z, 0), O(x, Z, 1), O(M, se, 0), O(w, se, 0), O(x, se, 0.5)) : (O(p, ne, 1), O(v, ne, 0), O(R, Z, 1), O(v, ne, 0), O(x, Z, 0), O(R, Z, 1), O(R, se, 1), O(x, se, 0), O(E, se, 1)) : j ? (O(M, se, 0), O(w, se, 0), O(C, se, 0.5)) : (O(R, se, 1), O(E, se, 0), O(C, se, 0.5));
    }
    function L(j, K) {
      K && (j ? (O(p, ne, 1), O(v, ne, 0), O(M, Z, 0), O(p, ne, 1), O(M, Z, 0), O(x, Z, 1), O(M, ne, 0), O(C, Z, 0.5), O(x, Z, 1), O(C, Z, 0.5), O(w, ne, 0), O(x, Z, 1)) : (O(p, ne, 1), O(v, ne, 0), O(R, Z, 1), O(v, ne, 0), O(x, Z, 0), O(R, Z, 1), O(R, ne, 1), O(x, Z, 0), O(C, Z, 0.5), O(C, Z, 0.5), O(x, Z, 0), O(E, ne, 1)));
    }
    function X(j, K, se, ie, G, k) {
      switch (t.strokeLineCap) {
        case "round":
          G ? z(j, se, K, k, 0.5) : z(j, K, se, k, 0.5);
          break;
        case "square":
          if (G)
            c.subVectors(K, j), f.set(c.y, -c.x), u.addVectors(c, f).add(j), d.subVectors(f, c).add(j), ie ? (u.toArray(i, 1 * 3), d.toArray(i, 0 * 3), d.toArray(i, 3 * 3)) : (u.toArray(i, 1 * 3), a[3 * 2 + 1] === 1 ? d.toArray(i, 3 * 3) : u.toArray(i, 3 * 3), d.toArray(i, 0 * 3));
          else {
            c.subVectors(se, j), f.set(c.y, -c.x), u.addVectors(c, f).add(j), d.subVectors(f, c).add(j);
            const oe = i.length;
            ie ? (u.toArray(i, oe - 1 * 3), d.toArray(i, oe - 2 * 3), d.toArray(i, oe - 4 * 3)) : (d.toArray(i, oe - 2 * 3), u.toArray(i, oe - 1 * 3), d.toArray(i, oe - 4 * 3));
          }
          break;
      }
    }
    function H(j) {
      let K = !1;
      for (let ie = 1, G = j.length - 1; ie < G; ie++)
        if (j[ie].distanceTo(j[ie + 1]) < s) {
          K = !0;
          break;
        }
      if (!K)
        return j;
      const se = [];
      se.push(j[0]);
      for (let ie = 1, G = j.length - 1; ie < G; ie++)
        j[ie].distanceTo(j[ie + 1]) >= s && se.push(j[ie]);
      return se.push(j[j.length - 1]), se;
    }
  }
}
const Li = /* @__PURE__ */ new WeakMap();
class Cf extends Un {
  constructor(e) {
    super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
      position: "POSITION",
      normal: "NORMAL",
      color: "COLOR",
      uv: "TEX_COORD"
    }, this.defaultAttributeTypes = {
      position: "Float32Array",
      normal: "Float32Array",
      color: "Float32Array",
      uv: "Float32Array"
    };
  }
  setDecoderPath(e) {
    return this.decoderPath = e, this;
  }
  setDecoderConfig(e) {
    return this.decoderConfig = e, this;
  }
  setWorkerLimit(e) {
    return this.workerLimit = e, this;
  }
  load(e, t, n, s) {
    const i = new kn(this.manager);
    i.setPath(this.path), i.setResponseType("arraybuffer"), i.setRequestHeader(this.requestHeader), i.setWithCredentials(this.withCredentials), i.load(
      e,
      (o) => {
        const a = {
          attributeIDs: this.defaultAttributeIDs,
          attributeTypes: this.defaultAttributeTypes,
          useUniqueIDs: !1
        };
        this.decodeGeometry(o, a).then(t).catch(s);
      },
      n,
      s
    );
  }
  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */
  decodeDracoFile(e, t, n, s) {
    const i = {
      attributeIDs: n || this.defaultAttributeIDs,
      attributeTypes: s || this.defaultAttributeTypes,
      useUniqueIDs: !!n
    };
    this.decodeGeometry(e, i).then(t);
  }
  decodeGeometry(e, t) {
    for (const l in t.attributeTypes) {
      const c = t.attributeTypes[l];
      c.BYTES_PER_ELEMENT !== void 0 && (t.attributeTypes[l] = c.name);
    }
    const n = JSON.stringify(t);
    if (Li.has(e)) {
      const l = Li.get(e);
      if (l.key === n)
        return l.promise;
      if (e.byteLength === 0)
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
    }
    let s;
    const i = this.workerNextTaskID++, o = e.byteLength, a = this._getWorker(i, o).then((l) => (s = l, new Promise((c, f) => {
      s._callbacks[i] = { resolve: c, reject: f }, s.postMessage({ type: "decode", id: i, taskConfig: t, buffer: e }, [e]);
    }))).then((l) => this._createGeometry(l.geometry));
    return a.catch(() => !0).then(() => {
      s && i && this._releaseTask(s, i);
    }), Li.set(e, {
      key: n,
      promise: a
    }), a;
  }
  _createGeometry(e) {
    const t = new ht();
    e.index && t.setIndex(new ut(e.index.array, 1));
    for (let n = 0; n < e.attributes.length; n++) {
      const s = e.attributes[n], i = s.name, o = s.array, a = s.itemSize;
      t.setAttribute(i, new ut(o, a));
    }
    return t;
  }
  _loadLibrary(e, t) {
    const n = new kn(this.manager);
    return n.setPath(this.decoderPath), n.setResponseType(t), n.setWithCredentials(this.withCredentials), new Promise((s, i) => {
      n.load(e, s, void 0, i);
    });
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending)
      return this.decoderPending;
    const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js", t = [];
    return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((n) => {
      const s = n[0];
      e || (this.decoderConfig.wasmBinary = n[1]);
      const i = If.toString(), o = [
        "/* draco decoder */",
        s,
        "",
        "/* worker */",
        i.substring(i.indexOf("{") + 1, i.lastIndexOf("}"))
      ].join(`
`);
      this.workerSourceURL = URL.createObjectURL(new Blob([o]));
    }), this.decoderPending;
  }
  _getWorker(e, t) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const s = new Worker(this.workerSourceURL);
        s._callbacks = {}, s._taskCosts = {}, s._taskLoad = 0, s.postMessage({ type: "init", decoderConfig: this.decoderConfig }), s.onmessage = function(i) {
          const o = i.data;
          switch (o.type) {
            case "decode":
              s._callbacks[o.id].resolve(o);
              break;
            case "error":
              s._callbacks[o.id].reject(o);
              break;
            default:
              console.error('THREE.DRACOLoader: Unexpected message, "' + o.type + '"');
          }
        }, this.workerPool.push(s);
      } else
        this.workerPool.sort(function(s, i) {
          return s._taskLoad > i._taskLoad ? -1 : 1;
        });
      const n = this.workerPool[this.workerPool.length - 1];
      return n._taskCosts[e] = t, n._taskLoad += t, n;
    });
  }
  _releaseTask(e, t) {
    e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t];
  }
  debug() {
    console.log(
      "Task load: ",
      this.workerPool.map((e) => e._taskLoad)
    );
  }
  dispose() {
    for (let e = 0; e < this.workerPool.length; ++e)
      this.workerPool[e].terminate();
    return this.workerPool.length = 0, this;
  }
}
function If() {
  let r, e;
  onmessage = function(o) {
    const a = o.data;
    switch (a.type) {
      case "init":
        r = a.decoderConfig, e = new Promise(function(f) {
          r.onModuleLoaded = function(u) {
            f({ draco: u });
          }, DracoDecoderModule(r);
        });
        break;
      case "decode":
        const l = a.buffer, c = a.taskConfig;
        e.then((f) => {
          const u = f.draco, d = new u.Decoder(), h = new u.DecoderBuffer();
          h.Init(new Int8Array(l), l.byteLength);
          try {
            const m = t(u, d, h, c), g = m.attributes.map((v) => v.array.buffer);
            m.index && g.push(m.index.array.buffer), self.postMessage({ type: "decode", id: a.id, geometry: m }, g);
          } catch (m) {
            console.error(m), self.postMessage({ type: "error", id: a.id, error: m.message });
          } finally {
            u.destroy(h), u.destroy(d);
          }
        });
        break;
    }
  };
  function t(o, a, l, c) {
    const f = c.attributeIDs, u = c.attributeTypes;
    let d, h;
    const m = a.GetEncodedGeometryType(l);
    if (m === o.TRIANGULAR_MESH)
      d = new o.Mesh(), h = a.DecodeBufferToMesh(l, d);
    else if (m === o.POINT_CLOUD)
      d = new o.PointCloud(), h = a.DecodeBufferToPointCloud(l, d);
    else
      throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    if (!h.ok() || d.ptr === 0)
      throw new Error("THREE.DRACOLoader: Decoding failed: " + h.error_msg());
    const g = { index: null, attributes: [] };
    for (const v in f) {
      const p = self[u[v]];
      let b, _;
      if (c.useUniqueIDs)
        _ = f[v], b = a.GetAttributeByUniqueId(d, _);
      else {
        if (_ = a.GetAttributeId(d, o[f[v]]), _ === -1)
          continue;
        b = a.GetAttribute(d, _);
      }
      g.attributes.push(s(o, a, d, v, p, b));
    }
    return m === o.TRIANGULAR_MESH && (g.index = n(o, a, d)), o.destroy(d), g;
  }
  function n(o, a, l) {
    const f = l.num_faces() * 3, u = f * 4, d = o._malloc(u);
    a.GetTrianglesUInt32Array(l, u, d);
    const h = new Uint32Array(o.HEAPF32.buffer, d, f).slice();
    return o._free(d), { array: h, itemSize: 1 };
  }
  function s(o, a, l, c, f, u) {
    const d = u.num_components(), m = l.num_points() * d, g = m * f.BYTES_PER_ELEMENT, v = i(o, f), p = o._malloc(g);
    a.GetAttributeDataArrayForAllPoints(l, u, v, g, p);
    const b = new f(o.HEAPF32.buffer, p, m).slice();
    return o._free(p), {
      name: c,
      array: b,
      itemSize: d
    };
  }
  function i(o, a) {
    switch (a) {
      case Float32Array:
        return o.DT_FLOAT32;
      case Int8Array:
        return o.DT_INT8;
      case Int16Array:
        return o.DT_INT16;
      case Int32Array:
        return o.DT_INT32;
      case Uint8Array:
        return o.DT_UINT8;
      case Uint16Array:
        return o.DT_UINT16;
      case Uint32Array:
        return o.DT_UINT32;
    }
  }
}
const Tr = new _t(), Hs = new $();
class rl extends $l {
  constructor() {
    super(), this.isLineSegmentsGeometry = !0, this.type = "LineSegmentsGeometry";
    const e = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], t = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], n = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
    this.setIndex(n), this.setAttribute("position", new gt(e, 3)), this.setAttribute("uv", new gt(t, 2));
  }
  applyMatrix4(e) {
    const t = this.attributes.instanceStart, n = this.attributes.instanceEnd;
    return t !== void 0 && (t.applyMatrix4(e), n.applyMatrix4(e), t.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  setPositions(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const n = new fo(t, 6, 1);
    return this.setAttribute("instanceStart", new nn(n, 3, 0)), this.setAttribute("instanceEnd", new nn(n, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this;
  }
  setColors(e, t = 3) {
    let n;
    e instanceof Float32Array ? n = e : Array.isArray(e) && (n = new Float32Array(e));
    const s = new fo(n, t * 2, 1);
    return this.setAttribute("instanceColorStart", new nn(s, t, 0)), this.setAttribute("instanceColorEnd", new nn(s, t, t)), this;
  }
  fromWireframeGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromEdgesGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromMesh(e) {
    return this.fromWireframeGeometry(new Zl(e.geometry)), this;
  }
  fromLineSegments(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new _t());
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    e !== void 0 && t !== void 0 && (this.boundingBox.setFromBufferAttribute(e), Tr.setFromBufferAttribute(t), this.boundingBox.union(Tr));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Ms()), this.boundingBox === null && this.computeBoundingBox();
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    if (e !== void 0 && t !== void 0) {
      const n = this.boundingSphere.center;
      this.boundingBox.getCenter(n);
      let s = 0;
      for (let i = 0, o = e.count; i < o; i++)
        Hs.fromBufferAttribute(e, i), s = Math.max(s, n.distanceToSquared(Hs)), Hs.fromBufferAttribute(t, i), s = Math.max(s, n.distanceToSquared(Hs));
      this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && console.error(
        "THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",
        this
      );
    }
  }
  toJSON() {
  }
  applyMatrix(e) {
    return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(e);
  }
}
class al extends rl {
  constructor() {
    super(), this.isLineGeometry = !0, this.type = "LineGeometry";
  }
  setPositions(e) {
    const t = e.length - 3, n = new Float32Array(2 * t);
    for (let s = 0; s < t; s += 3)
      n[2 * s] = e[s], n[2 * s + 1] = e[s + 1], n[2 * s + 2] = e[s + 2], n[2 * s + 3] = e[s + 3], n[2 * s + 4] = e[s + 4], n[2 * s + 5] = e[s + 5];
    return super.setPositions(n), this;
  }
  setColors(e, t = 3) {
    const n = e.length - t, s = new Float32Array(2 * n);
    if (t === 3)
      for (let i = 0; i < n; i += t)
        s[2 * i] = e[i], s[2 * i + 1] = e[i + 1], s[2 * i + 2] = e[i + 2], s[2 * i + 3] = e[i + 3], s[2 * i + 4] = e[i + 4], s[2 * i + 5] = e[i + 5];
    else
      for (let i = 0; i < n; i += t)
        s[2 * i] = e[i], s[2 * i + 1] = e[i + 1], s[2 * i + 2] = e[i + 2], s[2 * i + 3] = e[i + 3], s[2 * i + 4] = e[i + 4], s[2 * i + 5] = e[i + 5], s[2 * i + 6] = e[i + 6], s[2 * i + 7] = e[i + 7];
    return super.setColors(s, t), this;
  }
  fromLine(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
}
class Ho extends bt {
  constructor(e) {
    super({
      type: "LineMaterial",
      uniforms: Dn.clone(
        Dn.merge([
          ni.common,
          ni.fog,
          {
            worldUnits: { value: 1 },
            linewidth: { value: 1 },
            resolution: { value: new ve(1, 1) },
            dashOffset: { value: 0 },
            dashScale: { value: 1 },
            dashSize: { value: 1 },
            gapSize: { value: 1 }
            // todo FIX - maybe change to totalSize
          }
        ])
      ),
      vertexShader: (
        /* glsl */
        `
				#include <common>
				#include <fog_pars_vertex>
				#include <logdepthbuf_pars_vertex>
				#include <clipping_planes_pars_vertex>

				uniform float linewidth;
				uniform vec2 resolution;

				attribute vec3 instanceStart;
				attribute vec3 instanceEnd;

				#ifdef USE_COLOR
					#ifdef USE_LINE_COLOR_ALPHA
						varying vec4 vLineColor;
						attribute vec4 instanceColorStart;
						attribute vec4 instanceColorEnd;
					#else
						varying vec3 vLineColor;
						attribute vec3 instanceColorStart;
						attribute vec3 instanceColorEnd;
					#endif
				#endif

				#ifdef WORLD_UNITS

					varying vec4 worldPos;
					varying vec3 worldStart;
					varying vec3 worldEnd;

					#ifdef USE_DASH

						varying vec2 vUv;

					#endif

				#else

					varying vec2 vUv;

				#endif

				#ifdef USE_DASH

					uniform float dashScale;
					attribute float instanceDistanceStart;
					attribute float instanceDistanceEnd;
					varying float vLineDistance;

				#endif

				void trimSegment( const in vec4 start, inout vec4 end ) {

					// trim end segment so it terminates between the camera plane and the near plane

					// conservative estimate of the near plane
					float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
					float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
					float nearEstimate = - 0.5 * b / a;

					float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

					end.xyz = mix( start.xyz, end.xyz, alpha );

				}

				void main() {

					#ifdef USE_COLOR

						vLineColor = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

					#endif

					#ifdef USE_DASH

						vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
						vUv = uv;

					#endif

					float aspect = resolution.x / resolution.y;

					// camera space
					vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
					vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

					#ifdef WORLD_UNITS

						worldStart = start.xyz;
						worldEnd = end.xyz;

					#else

						vUv = uv;

					#endif

					// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
					// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
					// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
					// perhaps there is a more elegant solution -- WestLangley

					bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

					if ( perspective ) {

						if ( start.z < 0.0 && end.z >= 0.0 ) {

							trimSegment( start, end );

						} else if ( end.z < 0.0 && start.z >= 0.0 ) {

							trimSegment( end, start );

						}

					}

					// clip space
					vec4 clipStart = projectionMatrix * start;
					vec4 clipEnd = projectionMatrix * end;

					// ndc space
					vec3 ndcStart = clipStart.xyz / clipStart.w;
					vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

					// direction
					vec2 dir = ndcEnd.xy - ndcStart.xy;

					// account for clip-space aspect ratio
					dir.x *= aspect;
					dir = normalize( dir );

					#ifdef WORLD_UNITS

						// get the offset direction as perpendicular to the view vector
						vec3 worldDir = normalize( end.xyz - start.xyz );
						vec3 offset;
						if ( position.y < 0.5 ) {

							offset = normalize( cross( start.xyz, worldDir ) );

						} else {

							offset = normalize( cross( end.xyz, worldDir ) );

						}

						// sign flip
						if ( position.x < 0.0 ) offset *= - 1.0;

						float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

						// don't extend the line if we're rendering dashes because we
						// won't be rendering the endcaps
						#ifndef USE_DASH

							// extend the line bounds to encompass  endcaps
							start.xyz += - worldDir * linewidth * 0.5;
							end.xyz += worldDir * linewidth * 0.5;

							// shift the position of the quad so it hugs the forward edge of the line
							offset.xy -= dir * forwardOffset;
							offset.z += 0.5;

						#endif

						// endcaps
						if ( position.y > 1.0 || position.y < 0.0 ) {

							offset.xy += dir * 2.0 * forwardOffset;

						}

						// adjust for linewidth
						offset *= linewidth * 0.5;

						// set the world position
						worldPos = ( position.y < 0.5 ) ? start : end;
						worldPos.xyz += offset;

						// project the worldpos
						vec4 clip = projectionMatrix * worldPos;

						// shift the depth of the projected points so the line
						// segments overlap neatly
						vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
						clip.z = clipPose.z * clip.w;

					#else

						vec2 offset = vec2( dir.y, - dir.x );
						// undo aspect ratio adjustment
						dir.x /= aspect;
						offset.x /= aspect;

						// sign flip
						if ( position.x < 0.0 ) offset *= - 1.0;

						// endcaps
						if ( position.y < 0.0 ) {

							offset += - dir;

						} else if ( position.y > 1.0 ) {

							offset += dir;

						}

						// adjust for linewidth
						offset *= linewidth;

						// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
						offset /= resolution.y;

						// select end
						vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

						// back to clip space
						offset *= clip.w;

						clip.xy += offset;

					#endif

					gl_Position = clip;

					vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

					#include <logdepthbuf_vertex>
					#include <clipping_planes_vertex>
					#include <fog_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `
				uniform vec3 diffuse;
				uniform float opacity;
				uniform float linewidth;

				#ifdef USE_DASH

					uniform float dashOffset;
					uniform float dashSize;
					uniform float gapSize;

				#endif

				varying float vLineDistance;

				#ifdef WORLD_UNITS

					varying vec4 worldPos;
					varying vec3 worldStart;
					varying vec3 worldEnd;

					#ifdef USE_DASH

						varying vec2 vUv;

					#endif

				#else

					varying vec2 vUv;

				#endif

				#include <common>
				#include <fog_pars_fragment>
				#include <logdepthbuf_pars_fragment>
				#include <clipping_planes_pars_fragment>

				#ifdef USE_COLOR
					#ifdef USE_LINE_COLOR_ALPHA
						varying vec4 vLineColor;
					#else
						varying vec3 vLineColor;
					#endif
				#endif

				vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

					float mua;
					float mub;

					vec3 p13 = p1 - p3;
					vec3 p43 = p4 - p3;

					vec3 p21 = p2 - p1;

					float d1343 = dot( p13, p43 );
					float d4321 = dot( p43, p21 );
					float d1321 = dot( p13, p21 );
					float d4343 = dot( p43, p43 );
					float d2121 = dot( p21, p21 );

					float denom = d2121 * d4343 - d4321 * d4321;

					float numer = d1343 * d4321 - d1321 * d4343;

					mua = numer / denom;
					mua = clamp( mua, 0.0, 1.0 );
					mub = ( d1343 + d4321 * ( mua ) ) / d4343;
					mub = clamp( mub, 0.0, 1.0 );

					return vec2( mua, mub );

				}

				void main() {

					#include <clipping_planes_fragment>

					#ifdef USE_DASH

						if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

						if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

					#endif

					float alpha = opacity;

					#ifdef WORLD_UNITS

						// Find the closest points on the view ray and the line segment
						vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
						vec3 lineDir = worldEnd - worldStart;
						vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

						vec3 p1 = worldStart + lineDir * params.x;
						vec3 p2 = rayEnd * params.y;
						vec3 delta = p1 - p2;
						float len = length( delta );
						float norm = len / linewidth;

						#ifndef USE_DASH

							#ifdef USE_ALPHA_TO_COVERAGE

								float dnorm = fwidth( norm );
								alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

							#else

								if ( norm > 0.5 ) {

									discard;

								}

							#endif

						#endif

					#else

						#ifdef USE_ALPHA_TO_COVERAGE

							// artifacts appear on some hardware if a derivative is taken within a conditional
							float a = vUv.x;
							float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
							float len2 = a * a + b * b;
							float dlen = fwidth( len2 );

							if ( abs( vUv.y ) > 1.0 ) {

								alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

							}

						#else

							if ( abs( vUv.y ) > 1.0 ) {

								float a = vUv.x;
								float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
								float len2 = a * a + b * b;

								if ( len2 > 1.0 ) discard;

							}

						#endif

					#endif

					vec4 diffuseColor = vec4( diffuse, alpha );
					#ifdef USE_COLOR
						#ifdef USE_LINE_COLOR_ALPHA
							diffuseColor *= vLineColor;
						#else
							diffuseColor.rgb *= vLineColor;
						#endif
					#endif

					#include <logdepthbuf_fragment>

					gl_FragColor = diffuseColor;

					#include <tonemapping_fragment>
					#include <${parseInt(Ts.replace(/\D+/g, "")) >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
					#include <fog_fragment>
					#include <premultiplied_alpha_fragment>

				}
			`
      ),
      clipping: !0
      // required for clipping support
    }), this.isLineMaterial = !0, this.onBeforeCompile = function() {
      this.transparent ? this.defines.USE_LINE_COLOR_ALPHA = "1" : delete this.defines.USE_LINE_COLOR_ALPHA;
    }, Object.defineProperties(this, {
      color: {
        enumerable: !0,
        get: function() {
          return this.uniforms.diffuse.value;
        },
        set: function(t) {
          this.uniforms.diffuse.value = t;
        }
      },
      worldUnits: {
        enumerable: !0,
        get: function() {
          return "WORLD_UNITS" in this.defines;
        },
        set: function(t) {
          t === !0 ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS;
        }
      },
      linewidth: {
        enumerable: !0,
        get: function() {
          return this.uniforms.linewidth.value;
        },
        set: function(t) {
          this.uniforms.linewidth.value = t;
        }
      },
      dashed: {
        enumerable: !0,
        get: function() {
          return "USE_DASH" in this.defines;
        },
        set(t) {
          !!t != "USE_DASH" in this.defines && (this.needsUpdate = !0), t === !0 ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH;
        }
      },
      dashScale: {
        enumerable: !0,
        get: function() {
          return this.uniforms.dashScale.value;
        },
        set: function(t) {
          this.uniforms.dashScale.value = t;
        }
      },
      dashSize: {
        enumerable: !0,
        get: function() {
          return this.uniforms.dashSize.value;
        },
        set: function(t) {
          this.uniforms.dashSize.value = t;
        }
      },
      dashOffset: {
        enumerable: !0,
        get: function() {
          return this.uniforms.dashOffset.value;
        },
        set: function(t) {
          this.uniforms.dashOffset.value = t;
        }
      },
      gapSize: {
        enumerable: !0,
        get: function() {
          return this.uniforms.gapSize.value;
        },
        set: function(t) {
          this.uniforms.gapSize.value = t;
        }
      },
      opacity: {
        enumerable: !0,
        get: function() {
          return this.uniforms.opacity.value;
        },
        set: function(t) {
          this.uniforms.opacity.value = t;
        }
      },
      resolution: {
        enumerable: !0,
        get: function() {
          return this.uniforms.resolution.value;
        },
        set: function(t) {
          this.uniforms.resolution.value.copy(t);
        }
      },
      alphaToCoverage: {
        enumerable: !0,
        get: function() {
          return "USE_ALPHA_TO_COVERAGE" in this.defines;
        },
        set: function(t) {
          !!t != "USE_ALPHA_TO_COVERAGE" in this.defines && (this.needsUpdate = !0), t === !0 ? (this.defines.USE_ALPHA_TO_COVERAGE = "", this.extensions.derivatives = !0) : (delete this.defines.USE_ALPHA_TO_COVERAGE, this.extensions.derivatives = !1);
        }
      }
    }), this.setValues(e);
  }
}
const ki = new at(), br = new $(), Er = new $(), it = new at(), ot = new at(), Ut = new at(), Ni = new $(), Bi = new Ie(), rt = new Kl(), Mr = new $(), js = new _t(), Vs = new Ms(), Ft = new at();
let Yt, On;
function Sr(r, e, t) {
  return Ft.set(0, 0, -e, 1).applyMatrix4(r.projectionMatrix), Ft.multiplyScalar(1 / Ft.w), Ft.x = On / t.width, Ft.y = On / t.height, Ft.applyMatrix4(r.projectionMatrixInverse), Ft.multiplyScalar(1 / Ft.w), Math.abs(Math.max(Ft.x, Ft.y));
}
function Of(r, e) {
  const t = r.matrixWorld, n = r.geometry, s = n.attributes.instanceStart, i = n.attributes.instanceEnd, o = Math.min(n.instanceCount, s.count);
  for (let a = 0, l = o; a < l; a++) {
    rt.start.fromBufferAttribute(s, a), rt.end.fromBufferAttribute(i, a), rt.applyMatrix4(t);
    const c = new $(), f = new $();
    Yt.distanceSqToSegment(rt.start, rt.end, f, c), f.distanceTo(c) < On * 0.5 && e.push({
      point: f,
      pointOnLine: c,
      distance: Yt.origin.distanceTo(f),
      object: r,
      face: null,
      faceIndex: a,
      uv: null,
      [Bo]: null
    });
  }
}
function Df(r, e, t) {
  const n = e.projectionMatrix, i = r.material.resolution, o = r.matrixWorld, a = r.geometry, l = a.attributes.instanceStart, c = a.attributes.instanceEnd, f = Math.min(a.instanceCount, l.count), u = -e.near;
  Yt.at(1, Ut), Ut.w = 1, Ut.applyMatrix4(e.matrixWorldInverse), Ut.applyMatrix4(n), Ut.multiplyScalar(1 / Ut.w), Ut.x *= i.x / 2, Ut.y *= i.y / 2, Ut.z = 0, Ni.copy(Ut), Bi.multiplyMatrices(e.matrixWorldInverse, o);
  for (let d = 0, h = f; d < h; d++) {
    if (it.fromBufferAttribute(l, d), ot.fromBufferAttribute(c, d), it.w = 1, ot.w = 1, it.applyMatrix4(Bi), ot.applyMatrix4(Bi), it.z > u && ot.z > u)
      continue;
    if (it.z > u) {
      const _ = it.z - ot.z, M = (it.z - u) / _;
      it.lerp(ot, M);
    } else if (ot.z > u) {
      const _ = ot.z - it.z, M = (ot.z - u) / _;
      ot.lerp(it, M);
    }
    it.applyMatrix4(n), ot.applyMatrix4(n), it.multiplyScalar(1 / it.w), ot.multiplyScalar(1 / ot.w), it.x *= i.x / 2, it.y *= i.y / 2, ot.x *= i.x / 2, ot.y *= i.y / 2, rt.start.copy(it), rt.start.z = 0, rt.end.copy(ot), rt.end.z = 0;
    const g = rt.closestPointToPointParameter(Ni, !0);
    rt.at(g, Mr);
    const v = Ye.lerp(it.z, ot.z, g), p = v >= -1 && v <= 1, b = Ni.distanceTo(Mr) < On * 0.5;
    if (p && b) {
      rt.start.fromBufferAttribute(l, d), rt.end.fromBufferAttribute(c, d), rt.start.applyMatrix4(o), rt.end.applyMatrix4(o);
      const _ = new $(), M = new $();
      Yt.distanceSqToSegment(rt.start, rt.end, M, _), t.push({
        point: M,
        pointOnLine: _,
        distance: Yt.origin.distanceTo(M),
        object: r,
        face: null,
        faceIndex: d,
        uv: null,
        [Bo]: null
      });
    }
  }
}
class Lf extends de {
  constructor(e = new rl(), t = new Ho({ color: Math.random() * 16777215 })) {
    super(e, t), this.isLineSegments2 = !0, this.type = "LineSegments2";
  }
  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...
  computeLineDistances() {
    const e = this.geometry, t = e.attributes.instanceStart, n = e.attributes.instanceEnd, s = new Float32Array(2 * t.count);
    for (let o = 0, a = 0, l = t.count; o < l; o++, a += 2)
      br.fromBufferAttribute(t, o), Er.fromBufferAttribute(n, o), s[a] = a === 0 ? 0 : s[a - 1], s[a + 1] = s[a] + br.distanceTo(Er);
    const i = new fo(s, 2, 1);
    return e.setAttribute("instanceDistanceStart", new nn(i, 1, 0)), e.setAttribute("instanceDistanceEnd", new nn(i, 1, 1)), this;
  }
  raycast(e, t) {
    const n = this.material.worldUnits, s = e.camera;
    s === null && !n && console.error(
      'LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.'
    );
    const i = e.params.Line2 !== void 0 && e.params.Line2.threshold || 0;
    Yt = e.ray;
    const o = this.matrixWorld, a = this.geometry, l = this.material;
    On = l.linewidth + i, a.boundingSphere === null && a.computeBoundingSphere(), Vs.copy(a.boundingSphere).applyMatrix4(o);
    let c;
    if (n)
      c = On * 0.5;
    else {
      const u = Math.max(s.near, Vs.distanceToPoint(Yt.origin));
      c = Sr(s, u, l.resolution);
    }
    if (Vs.radius += c, Yt.intersectsSphere(Vs) === !1)
      return;
    a.boundingBox === null && a.computeBoundingBox(), js.copy(a.boundingBox).applyMatrix4(o);
    let f;
    if (n)
      f = On * 0.5;
    else {
      const u = Math.max(s.near, js.distanceToPoint(Yt.origin));
      f = Sr(s, u, l.resolution);
    }
    js.expandByScalar(f), Yt.intersectsBox(js) !== !1 && (n ? Of(this, t) : Df(this, s, t));
  }
  onBeforeRender(e) {
    const t = this.material.uniforms;
    t && t.resolution && (e.getViewport(ki), this.material.uniforms.resolution.value.set(ki.z, ki.w));
  }
}
class kf extends Lf {
  constructor(e = new al(), t = new Ho({ color: Math.random() * 16777215 })) {
    super(e, t), this.isLine2 = !0, this.type = "Line2";
  }
}
class Nf extends ke {
  constructor(e, t = 1, n = 16, s = 2) {
    const i = new ht(), o = n + s * 2, a = new Float32Array((o * 3 + 3) * 3);
    i.setAttribute("position", new ut(a, 3));
    const l = new ws({ color: 65280 }), c = new ws({ color: 16776960 });
    super(i, [c, l]), this.type = "PositionalAudioHelper", this.audio = e, this.range = t, this.divisionsInnerAngle = n, this.divisionsOuterAngle = s, this.update();
  }
  update() {
    const e = this.audio, t = this.range, n = this.divisionsInnerAngle, s = this.divisionsOuterAngle, i = Ye.degToRad(e.panner.coneInnerAngle), o = Ye.degToRad(e.panner.coneOuterAngle), a = i / 2, l = o / 2;
    let c = 0, f = 0, u, d;
    const h = this.geometry, m = h.attributes.position;
    h.clearGroups();
    function g(v, p, b, _) {
      const M = (p - v) / b;
      for (m.setXYZ(c, 0, 0, 0), f++, u = v; u < p; u += M)
        d = c + f, m.setXYZ(d, Math.sin(u) * t, 0, Math.cos(u) * t), m.setXYZ(
          d + 1,
          Math.sin(Math.min(u + M, p)) * t,
          0,
          Math.cos(Math.min(u + M, p)) * t
        ), m.setXYZ(d + 2, 0, 0, 0), f += 3;
      h.addGroup(c, f, _), c += f, f = 0;
    }
    g(-l, -a, s, 0), g(-a, a, n, 1), g(a, l, s, 0), m.needsUpdate = !0, i === o && (this.material[0].visible = !1);
  }
  dispose() {
    this.geometry.dispose(), this.material[0].dispose(), this.material[1].dispose();
  }
}
function Bf(r) {
  return r;
}
function Uf(r) {
  return r * r * r;
}
function Ff(r) {
  return r < 0.5 ? 4 * r * r * r : 1 - (-2 * r + 2) ** 3 / 2;
}
function zf(r) {
  return r * r * r * r;
}
function Gf(r) {
  return r < 1 / 2.75 ? 7.5625 * r * r : r < 2 / 2.75 ? 7.5625 * (r -= 1.5 / 2.75) * r + 0.75 : r < 2.5 / 2.75 ? 7.5625 * (r -= 2.25 / 2.75) * r + 0.9375 : 7.5625 * (r -= 2.625 / 2.75) * r + 0.984375;
}
const cn = "https://raw.githubusercontent.com/Tresjs/assets/93976c7d63ac83d4a254a41a10b2362bc17e90c9/textures/lensflare/", jo = `${cn}circle.png`, hi = `${cn}circleBlur.png`, Hf = `${cn}circleRainbow.png`, jf = `${cn}line.png`, ll = `${cn}poly6.png`, cl = `${cn}polyStroke6.png`, Vf = `${cn}rays.png`, fi = `${cn}ring.png`, Yf = `${cn}starThin6.png`, Wf = {
  texture: [jf, fi],
  color: ["white"],
  distance: [0, 0],
  size: [750, 1024],
  length: [0, 2]
}, Xf = {
  texture: [hi],
  color: ["white"],
  distance: [0, 0],
  size: [180, 512],
  length: [1, 1]
}, $f = {
  texture: [Vf],
  color: ["white"],
  distance: [0, 0],
  size: [180, 512],
  length: [1, 1]
}, Zf = {
  texture: [jo, Hf, fi, Yf],
  color: ["white"],
  distance: [0, 0],
  size: [180, 512],
  length: [2, 3]
}, [ul, hl] = [3679071, 132442], Kf = {
  texture: [hi, jo, fi, ll, cl],
  color: ["dimgray", "gray", "darkgray", ul, hl],
  distance: [0.5, 2.5],
  size: [20, 180],
  length: [5, 21]
}, qf = {
  texture: [hi, jo, fi, ll, cl],
  color: ["dimgray", "gray", "darkgray", ul, hl],
  distance: [-0.6, -0.1],
  size: [180, 360],
  length: [0, 5]
}, wo = [Wf, Xf, $f, Zf, Kf, qf], oi = {
  color: "white",
  distance: 0,
  size: 512,
  texture: hi
}, Ar = Ye.clamp;
class Pr {
  /**
   * Create a new seeded pseudorandom number generator.
   * @param [seed] - the seed for the generator
   * @param [getSeededRandomGenerator] - a function that returns a pseudorandom number generator
   * @constructor
   */
  constructor(e = 0, t) {
    pe(this, "_getNext");
    pe(this, "_getGenerator");
    this._getGenerator = t ?? this.getMulberry32, this._getNext = this._getGenerator(e);
  }
  /**
   * Reseed the pseudorandom number generator
   */
  seed(e) {
    this._getNext = this._getGenerator(e);
  }
  /**
   * Return the next pseudorandom number in the interval [0, 1]
   */
  rand() {
    return this._getNext();
  }
  /**
   * Random float from <low, high> interval
   * @param low - Low value of the interval
   * @param high - High value of the interval
   */
  float(e, t) {
    return e + this._getNext() * (t - e);
  }
  /**
   * Random float from <-range/2, range/2> interval
   * @param range - Interval range
   */
  floatSpread(e) {
    return this.float(-0.5 * e, 0.5 * e);
  }
  /**
   * Random integer from <low, high> interval
   * @param low Low value of the interval
   * @param high High value of the interval
   */
  int(e, t) {
    return e + Math.floor(this._getNext() * (t - e + 1));
  }
  /**
   * Choose an element from an array.
   * @param array The array to choose from
   * @returns An element from the array or null if the array is empty
   */
  choice(e) {
    return e.length ? e[Math.floor(this._getNext() * e.length)] : null;
  }
  /**
   * Choose an element from an array or return defaultValue if array is empty.
   * @param array The array to choose from
   * @param defaultValue The value to return if the array is empty
   * @returns An element from the array or defaultValue if the array is empty
   */
  defaultChoice(e, t) {
    return e.length ? e[Math.floor(this._getNext() * e.length)] : t;
  }
  /**
   * Return n elements from an array.
   * @param array The array to sample
   * @param sampleSizeMin The minimum sample size
   * @param sampleSizeMax The maximum sample size
   */
  sample(e, t, n) {
    const s = e.length;
    t = Ar(t, 0, s - 1), n = Ar(n ?? s - 1, 0, s - 1);
    const i = this.int(t, n), o = this.shuffle(e.map((l, c) => c)), a = Math.min(e.length, i);
    return o.slice(0, a).sort().map((l) => e[l]);
  }
  /**
   * Shuffle an array. Not in-place.
   * @param array The array to shuffle
   */
  shuffle(e) {
    return e.map((t) => ({ value: t, sort: this._getNext() })).sort((t, n) => t.sort - n.sort).map(({ value: t }) => t);
  }
  /**
   * The default pseudorandom generator.
   */
  getMulberry32(e = 0) {
    return e > 0 && e < 1 && (e = Math.floor(e * 2 ** 16)), () => {
      e += 1831565813;
      let t = e;
      return t = Math.imul(t ^ t >>> 15, t | 1), t ^= t + Math.imul(t ^ t >>> 7, t | 61), ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
  }
}
const Qf = [
  Bf,
  Uf,
  Ff,
  zf,
  Gf
], Rr = Ye.lerp, Cr = (r = 0, e = wo) => {
  const n = new Pr(r).choice(Qf);
  return e.map((s, i) => {
    const o = new Pr(
      r * (i * 7907 + 1) + (typeof s.seed == "number" ? s.seed : 0)
    ), a = o.int(s.length[0], s.length[1]);
    return Array.from({ length: a }).fill(0).map(() => {
      const l = n(o.rand());
      return {
        texture: o.defaultChoice(
          s.texture,
          oi.texture
        ),
        size: Rr(s.size[0], s.size[1], n(1 - l)),
        distance: Rr(s.distance[0], s.distance[1], l),
        color: o.defaultChoice(
          s.color,
          oi.color
        )
      };
    });
  }).flat();
}, Ir = (r, e, t = void 0, n = void 0, s = oi) => {
  if (r !== void 0 && r.length > 0 && (typeof t == "number" || typeof n < "u")) {
    const a = Cr(t ?? 0, n ?? wo), l = a.length, c = r.length;
    return l >= c ? a.map(
      (f, u) => Object.assign(f, e, u < c ? r[u] : {})
    ) : r.map(
      (f, u) => Object.assign({}, s, u < l ? a[u] : {}, e, f)
    );
  }
  if (r !== void 0 && r.length > 0) {
    const a = Object.assign({}, s, e);
    return r.map((l) => Object.assign({}, a, l));
  }
  const i = n === void 0 || n.length === 0 ? wo : n;
  return Cr(t ?? 0, i).map((a) => Object.assign({}, a, e));
};
function Jf(r) {
  return ed(r, (e, t) => t in oi && e !== void 0);
}
function ed(r, e) {
  const t = {};
  return Object.keys(r).forEach((n) => {
    e(r[n], n) && (t[n] = r[n]);
  }), t;
}
const jg = /* @__PURE__ */ ue({
  __name: "component",
  props: {
    scale: { default: 1 },
    elements: { default: void 0 },
    seed: { default: void 0 },
    seedProps: { default: void 0 },
    color: { default: void 0 },
    distance: { default: void 0 },
    size: { default: void 0 },
    texture: { default: void 0 }
  },
  setup(r, { expose: e }) {
    const t = r, n = re(), s = re([]), i = re(Jf(t));
    e({
      instance: n
    });
    const o = new ai(), a = new Xa(), l = [], c = () => {
      var h, m, g;
      for (; l.length; )
        l.pop();
      (h = n.value) == null || h.children.forEach((v) => {
        "dispose" in v && v.dispose();
      }), (m = n.value) == null || m.remove(...n.value.children), (g = n.value) == null || g.dispose();
    }, f = (h) => {
      if (typeof h.texture == "string") {
        const m = h.texture;
        h.texture = o.load(m), h.texture.name = m;
      }
      return h.color = tn(h.color), h;
    }, u = () => {
      for (let h = s.value.length - 1; h < l.length; h++)
        l[h].size = 0;
      s.value.forEach((h, m) => {
        l[m].size = h.size * t.scale;
      });
    }, d = () => {
      for (; s.value.length > l.length; ) {
        const m = { ...f(s.value[l.length]) };
        l.push(m), a.addElement(m);
      }
      s.value.forEach((h, m) => {
        const g = l[m], { texture: v, size: p, distance: b, color: _ } = h;
        if (typeof v == "string") {
          if (g.texture.name !== v) {
            g.texture.dispose();
            const M = v;
            g.texture = o.load(M), g.texture.name = M;
          }
        } else
          g.texture !== v && (g.texture.dispose(), g.texture = v);
        g.size = p, g.distance = b, g.color = tn(_);
      }), u();
    };
    return tt(() => {
      c();
    }), bn(() => {
      var h;
      (h = n.value) == null || h.add(a), s.value = Ir(t.elements, i.value, t.seed, t.seedProps);
    }), J(() => [t.color, t.distance, t.size, t.texture], () => {
      i.value = {
        color: t.color,
        distance: t.distance,
        size: t.size,
        texture: t.texture
      };
    }), J(() => [i.value, t.elements, t.seed, t.seedProps], () => {
      s.value = Ir(t.elements, i.value, t.seed, t.seedProps);
    }), J(() => t.scale, () => {
      u();
    }), J(() => s.value, () => {
      d();
    }), (h, m) => (ae(), ce("TresGroup", {
      ref_key: "lensflareRef",
      ref: n
    }, null, 512));
  }
}), Vg = /* @__PURE__ */ ue({
  __name: "Levioso",
  props: {
    speed: { default: 1 },
    rotationFactor: { default: 1 },
    floatFactor: { default: 1 },
    range: { default: () => [-0.1, 0.1] }
  },
  setup(r, { expose: e }) {
    const t = r, n = re();
    e({
      instance: n
    });
    {
      const l = Math.random() * 1e4, { onBeforeRender: c } = Ve();
      let f = l;
      c(({ delta: u, invalidate: d }) => {
        if (!n.value)
          return;
        f += u * t.speed;
        const h = f * 0.25, m = n.value;
        m.rotation.x = Math.cos(h) * 0.125 * t.rotationFactor, m.rotation.y = Math.sin(h) * 0.125 * t.rotationFactor, m.rotation.z = Math.sin(h) * 0.05 * t.rotationFactor, m.position.y = Ye.mapLinear(Math.sin(h), -1, 1, t.range[0], t.range[1]) * t.floatFactor, d();
      });
    }
    return (s, i) => (ae(), ce("TresGroup", $e(s.$attrs, {
      ref_key: "groupRef",
      ref: n
    }), [
      Ne(s.$slots, "default")
    ], 16));
  }
}), td = ["render-order"], Yg = /* @__PURE__ */ ue({
  __name: "component",
  props: {
    id: { default: 1 },
    colorWrite: { type: Boolean, default: !0 },
    depthWrite: { type: Boolean, default: !1 }
  },
  setup(r, { expose: e }) {
    const t = r, n = re();
    function s() {
      var o, a;
      const i = Array.isArray((o = n.value) == null ? void 0 : o.material) ? n.value.material[0] : (a = n.value) == null ? void 0 : a.material;
      i && (i.colorWrite = t.colorWrite, i.depthWrite = t.depthWrite, i.stencilWrite = !0, i.stencilRef = t.id, i.stencilFunc = ql, i.stencilFail = xi, i.stencilZFail = xi, i.stencilZPass = xi);
    }
    return et(s), e({ instance: n }), (i, o) => (ae(), ce("TresMesh", {
      ref_key: "meshRef",
      ref: n,
      "render-order": -t.id
    }, [
      Ne(i.$slots, "default")
    ], 8, td));
  }
}), Wg = /* @__PURE__ */ ue({
  __name: "MouseParallax",
  props: {
    disabled: { type: Boolean, default: !1 },
    factor: { default: 2.5 },
    ease: { default: 0.1 },
    local: { type: Boolean, default: !1 }
  },
  setup(r) {
    const e = r, { camera: t, renderer: n } = xe(), { disabled: s, factor: i, ease: o, local: a } = Le(e), l = {};
    a.value && (l.target = n.value.domElement, l.type = "client");
    const { x: c, y: f } = nu(l), { width: u, height: d } = a.value ? qc(n.value.domElement) : Na(), h = re(), m = me(), g = me();
    J(
      [i, o],
      () => {
        m.value = Array.isArray(i.value) ? i.value : [i.value, i.value], g.value = Array.isArray(o.value) ? o.value : [o.value, o.value];
      },
      { immediate: !0 }
    );
    const v = Pe(() => (c.value / u.value - 0.5) * m.value[0]), p = Pe(() => -(f.value / d.value - 0.5) * m.value[1]), { onBeforeRender: b } = Ve();
    return b(({ delta: _, invalidate: M }) => {
      s.value || !h.value || Number.isNaN(v.value) || Number.isNaN(p.value) || (h.value.position.x += (v.value - h.value.position.x) * g.value[0] * _, h.value.position.y += (p.value - h.value.position.y) * g.value[1] * _, M());
    }), J(
      () => h.value,
      (_) => _ == null ? void 0 : _.add(t.value)
    ), (_, M) => (ae(), ce("TresGroup", {
      ref_key: "cameraGroupRef",
      ref: h
    }, null, 512));
  }
}), nd = No(
  {
    screenspace: !1,
    color: new be("black"),
    opacity: 1,
    thickness: 0.05,
    size: new ve(1, 1)
  },
  `#include <common>
   #include <morphtarget_pars_vertex>
   #include <skinning_pars_vertex>
   uniform float thickness;
   uniform bool screenspace;
   uniform vec2 size;
   void main() {
     #if defined (USE_SKINNING)
       #include <beginnormal_vertex>
       #include <morphnormal_vertex>
       #include <skinbase_vertex>
       #include <skinnormal_vertex>
       #include <defaultnormal_vertex>
     #endif
     #include <begin_vertex>
     #include <morphtarget_vertex>
     #include <skinning_vertex>
     #include <project_vertex>
     vec4 tNormal = vec4(normal, 0.0);
     vec4 tPosition = vec4(transformed, 1.0);
     #ifdef USE_INSTANCING
       tNormal = instanceMatrix * tNormal;
       tPosition = instanceMatrix * tPosition;
     #endif
     if (screenspace) {
       vec3 newPosition = tPosition.xyz + tNormal.xyz * thickness;
       gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0); 
     } else {
       vec4 clipPosition = projectionMatrix * modelViewMatrix * tPosition;
       vec4 clipNormal = projectionMatrix * modelViewMatrix * tNormal;
       vec2 offset = normalize(clipNormal.xy) * thickness / size * clipPosition.w * 2.0;
       clipPosition.xy += offset;
       gl_Position = clipPosition;
     }
   }`,
  `uniform vec3 color;
   uniform float opacity;
   void main(){
     gl_FragColor = vec4(color, opacity);
     #include <tonemapping_fragment>
     #include <colorspace_fragment>
   }`
), Xg = /* @__PURE__ */ ue({
  __name: "component",
  props: {
    color: { default: "black" },
    screenspace: { type: Boolean, default: !1 },
    opacity: { default: 1 },
    transparent: { type: Boolean, default: !1 },
    thickness: { default: 0.05 },
    angle: { default: Math.PI },
    toneMapped: { type: Boolean, default: !0 },
    polygonOffset: { type: Boolean, default: !1 },
    polygonOffsetFactor: { default: 0 },
    renderOrder: { default: 0 }
  },
  setup(r, { expose: e }) {
    const t = r, n = re();
    e({ instance: n });
    const s = new nd({ ...t }), i = new ve(1, 1);
    let o = 0, a = null;
    function l(u) {
      var h;
      const d = u.parent;
      if (!(!d || !d.geometry) && (o !== t.angle || a !== d.geometry)) {
        o = t.angle, a = d.geometry;
        let m = (h = u.children) == null ? void 0 : h[0];
        m && (t.angle && m.geometry.dispose(), u.remove(m)), d.skeleton ? (m = new Po(), m.material = s, m.bind(d.skeleton, d.bindMatrix), u.add(m)) : d.isInstancedMesh ? (m = new Ta(d.geometry, s, d.count), m.instanceMatrix = d.instanceMatrix, u.add(m)) : (m = new de(), m.material = s, u.add(m)), m.geometry = t.angle ? hu(d.geometry, t.angle) : d.geometry;
      }
    }
    function c() {
      s.side = li, s.transparent = t.transparent, s.thickness = t.thickness, s.color = tn(t.color), s.opacity = t.opacity, s.size = i, s.screenspace = t.screenspace, s.toneMapped = t.toneMapped, s.polygonOffset = t.polygonOffset, s.polygonOffsetFactor = t.polygonOffsetFactor;
    }
    const f = xn().sizes;
    return J(() => [f.width.value, f.height.value], ([u, d]) => {
      i.set(u, d);
    }), J(() => [t.angle], () => {
      n.value && l(n.value);
    }), J(
      () => [t.transparent, t.thickness, t.color, t.opacity, i, t.screenspace, t.toneMapped, t.polygonOffset, t.polygonOffsetFactor],
      () => c(),
      { immediate: !0 }
    ), bn(() => l(n.value)), tt(() => {
      var d;
      const u = (d = n.value) == null ? void 0 : d.children[0];
      u && (u.geometry.dispose(), s.dispose(), u.removeFromParent());
    }), (u, d) => (ae(), ce("TresGroup", {
      ref_key: "groupRef",
      ref: n
    }, null, 512));
  }
}), sd = ["args"], $g = /* @__PURE__ */ ue({
  __name: "PositionalAudio",
  props: {
    ready: { type: Boolean, default: !1 },
    url: {},
    distance: { default: 2 },
    helper: { type: Boolean, default: !1 },
    loop: { type: Boolean, default: !1 },
    autoplay: { type: Boolean, default: !1 },
    innerAngle: { default: 360 },
    outerAngle: { default: 360 },
    outerGain: { default: 0 }
  },
  emits: ["isPlaying"],
  async setup(r, { expose: e, emit: t }) {
    let n, s;
    const i = r, o = t, { ready: a, url: l, distance: c, helper: f, loop: u, autoplay: d, innerAngle: h, outerAngle: m, outerGain: g } = Le(i), { camera: v } = xe(), p = re(null), b = re(null), _ = re(null), M = Pa(new ca()), R = () => {
      var N, U, Y;
      (N = p == null ? void 0 : p.value) != null && N.isPlaying || ((U = p == null ? void 0 : p.value) == null || U.play(), o("isPlaying", (Y = p == null ? void 0 : p.value) == null ? void 0 : Y.isPlaying));
    }, w = () => {
      var N, U;
      (N = p == null ? void 0 : p.value) != null && N.isPlaying && (p.value.pause(), o("isPlaying", (U = p == null ? void 0 : p.value) == null ? void 0 : U.isPlaying));
    }, E = () => {
      var N;
      p.value && (p.value.stop(), o("isPlaying", (N = p == null ? void 0 : p.value) == null ? void 0 : N.isPlaying));
    }, x = () => {
      if (!(p != null && p.value))
        return;
      E();
      const N = p.value;
      N.source && N.disconnect();
    }, T = () => {
      var N, U;
      !(p != null && p.value) || !(b != null && b.value) || ((N = b == null ? void 0 : b.value) == null || N.dispose(), (U = p == null ? void 0 : p.value) == null || U.remove(b == null ? void 0 : b.value));
    }, y = () => {
      var N;
      if (p.value && (p.value.setBuffer(_.value), p.value.setRefDistance(c.value), p.value.setLoop(u.value), p.value.setDirectionalCone(h.value, m.value, g.value), (N = b == null ? void 0 : b.value) == null || N.update(), b != null && b.value)) {
        const U = b.value.material[0];
        !U.visible && m.value !== h.value && (U.visible = !0);
      }
    }, A = () => {
      var V, ne;
      y();
      const N = (V = p.value) == null ? void 0 : V.parent, U = new _t().setFromObject(N), Y = (U.max.z - U.min.z) * 2;
      b.value = new Nf(p.value, Y, 32, 16), (ne = p == null ? void 0 : p.value) == null || ne.add(b.value), b.value.update();
    }, C = () => {
      var N;
      (N = v == null ? void 0 : v.value) == null || N.remove(M), x(), T();
    };
    return e({
      instance: p,
      play: R,
      stop: E,
      pause: w,
      dispose: C
    }), _.value = ([n, s] = Tn(() => Nn(ua, l.value)), n = await n, s(), n), J(p, () => {
      p != null && p.value && (f.value && A(), a.value && d && R());
    }), J(f, () => {
      f.value ? A() : T();
    }), J(a, () => {
      a.value && y(), d.value && a.value && R(), !d.value && a.value && E();
    }), J([c, u, _, h, m, g, d], () => {
      y();
    }), bn(() => {
      var N;
      (N = v == null ? void 0 : v.value) == null || N.add(M);
    }), Co(() => {
      C();
    }), (N, U) => (ae(), ce("TresPositionalAudio", $e({
      ref_key: "positionalAudioRef",
      ref: p,
      args: [F(M)]
    }, N.$attrs), null, 16, sd));
  }
}), id = ["args", "material-uniforms-color-value"], Zg = /* @__PURE__ */ ue({
  __name: "Reflector",
  props: {
    color: { default: "#333" },
    textureWidth: { default: 512 },
    textureHeight: { default: 512 },
    clipBias: { default: 0 },
    multisample: { default: 4 },
    shader: { default: vo.ReflectorShader }
  },
  setup(r, { expose: e }) {
    const t = r, { extend: n, invalidate: s } = xe(), i = re();
    n({ Reflector: vo });
    const { color: o, textureWidth: a, textureHeight: l, clipBias: c, multisample: f, shader: u } = Le(t);
    return J(t, () => s()), e({
      instance: i
    }), (d, h) => (ae(), ce("TresReflector", {
      ref_key: "reflectorRef",
      ref: i,
      args: [void 0, { textureWidth: F(a), textureHeight: F(l), clipBias: F(c), multisample: F(f), shader: F(u) }],
      "material-uniforms-color-value": F(o)
    }, [
      Ne(d.$slots, "default", {}, () => [
        h[0] || (h[0] = ye("TresPlaneGeometry", { args: [5, 5] }, null, -1))
      ])
    ], 8, id));
  }
}), od = ["position-z"], Kg = /* @__PURE__ */ ue({
  __name: "ScreenSpace",
  props: {
    depth: { default: -1 }
  },
  setup(r, { expose: e }) {
    const t = re();
    return Ve().onBeforeRender(({ camera: n }) => {
      t.value && (t.value.quaternion.copy(n.quaternion), t.value.position.copy(n.position));
    }), e({ instance: t }), (n, s) => (ae(), ce("TresGroup", {
      ref_key: "outerRef",
      ref: t
    }, [
      ye("TresGroup", {
        "position-z": -n.depth
      }, [
        Ne(n.$slots, "default")
      ], 8, od)
    ], 512));
  }
}), rd = ["args", "center"], qg = /* @__PURE__ */ ue({
  __name: "Text3D",
  props: {
    font: {},
    text: {},
    size: { default: 0.5 },
    height: { default: 0.2 },
    curveSegments: { default: 5 },
    bevelEnabled: { type: Boolean, default: !0 },
    bevelThickness: { default: 0.05 },
    bevelSize: { default: 0.02 },
    bevelOffset: { default: 0 },
    bevelSegments: { default: 4 },
    center: { type: Boolean, default: !1 },
    needUpdates: { type: Boolean, default: !1 }
  },
  async setup(r, { expose: e }) {
    let t, n;
    const s = r, {
      center: i,
      font: o,
      text: a,
      needUpdates: l,
      size: c,
      height: f,
      curveSegments: u,
      bevelEnabled: d,
      bevelThickness: h,
      bevelSize: m,
      bevelOffset: g,
      bevelSegments: v
    } = Le(s), { extend: p, invalidate: b } = xe();
    J(s, () => b()), p({ TextGeometry: gr });
    const _ = new Sf(), M = Io(), R = Pe(() => {
      var T;
      return a != null && a.value ? a.value : M.default ? (T = M.default()[0].children) == null ? void 0 : T.trim() : l.value ? "" : "TresJS";
    }), w = re();
    e({
      instance: w
    });
    const E = ([t, n] = Tn(() => new Promise((T, y) => {
      try {
        typeof o.value == "string" ? _.load(o.value, (A) => {
          T(A);
        }) : T(o.value);
      } catch (A) {
        y(console.error("cientos", A));
      }
    })), t = await t, n(), t), x = Pe(() => ({
      font: E,
      size: ze(c),
      height: ze(f),
      curveSegments: ze(u),
      bevelEnabled: ze(d),
      bevelThickness: ze(h),
      bevelSize: ze(m),
      bevelOffset: ze(g),
      bevelSegments: ze(v)
    }));
    return et(() => {
      w.value && l.value && (w.value.geometry.dispose(), w.value.geometry = new gr(R.value, x.value), i.value && w.value.geometry.center());
    }), (T, y) => F(o) ? (ae(), ce("TresMesh", {
      key: 0,
      ref_key: "text3DRef",
      ref: w
    }, [
      R.value ? (ae(), ce("TresTextGeometry", {
        key: 0,
        args: [R.value, x.value],
        center: F(i)
      }, null, 8, rd)) : an("", !0),
      Ne(T.$slots, "default")
    ], 512)) : an("", !0);
  }
});
function Qg(r, e) {
  const t = me(e), n = new Ql(t.value), s = Pa({});
  r.forEach((o) => {
    const a = n.clipAction(o, t.value);
    s[o.name] = a;
  });
  const { onBeforeRender: i } = Ve();
  return i(({ delta: o }) => {
    n.update(o);
  }), {
    actions: s,
    mixer: n
  };
}
function Jg(r, e = !1) {
  const t = ts({
    stencilWrite: !0,
    stencilRef: ze(r),
    stencilFunc: ze(e) ? $o : Zo,
    stencilFail: wi,
    stencilZFail: wi,
    stencilZPass: wi
  });
  return et(() => {
    t.stencilRef = ze(r), t.stencilFunc = ze(e) ? $o : Zo;
  }), t;
}
function ad(r) {
  const e = me(null), { height: t, width: n, settings: s, depth: i, autoRender: o = me(!0) } = po(r) ? Le(r) : Le(ts(r)), { onBeforeRender: a } = Ve(), { camera: l, renderer: c, scene: f, sizes: u, invalidate: d } = xe();
  return J(() => [n == null ? void 0 : n.value, u.width.value, t == null ? void 0 : t.value, u.height.value], () => {
    var h;
    (h = e.value) == null || h.dispose(), e.value = new Xt((n == null ? void 0 : n.value) || u.width.value, (t == null ? void 0 : t.value) || u.height.value, {
      minFilter: wt,
      magFilter: wt,
      type: Lt,
      ...s == null ? void 0 : s.value
    }), i != null && i.value && (e.value.depthTexture = new Sa(
      (n == null ? void 0 : n.value) || u.width.value,
      (t == null ? void 0 : t.value) || u.height.value,
      qs
    )), d();
  }, { immediate: !0 }), a(() => {
    o.value && (c.value.setRenderTarget(e.value), c.value.clear(), c.value.render(f.value, l.value), c.value.setRenderTarget(null));
  }, Number.POSITIVE_INFINITY), Co(() => {
    var h;
    (h = e.value) == null || h.dispose();
  }), e;
}
const ev = /* @__PURE__ */ ue({
  __name: "component",
  props: {
    width: {},
    height: {},
    depth: { type: Boolean, default: !1 },
    settings: { default: void 0 },
    autoRender: { type: Boolean, default: !0 }
  },
  setup(r, { expose: e }) {
    const n = ad(r);
    return e({
      instance: n
    }), () => {
    };
  }
}), ld = (r, e = 16, t, n, s) => {
  const i = new Float32Array(e * 16), o = me(new Ao(i, 16));
  return (() => {
    if (!r)
      return;
    const l = new ih(r);
    n && l.setWeightAttribute(n), l.build();
    const c = new $(), f = new $(), u = new be(), d = new Rt();
    r.updateMatrixWorld(!0);
    for (let h = 0; h < e; h++)
      l.sample(c, f, u), typeof s == "function" ? s(
        {
          dummy: d,
          sampledMesh: r,
          position: c,
          normal: f,
          color: u
        },
        h
      ) : d.position.copy(c), d.updateMatrix(), t && t.setMatrixAt(h, d.matrix), d.matrix.toArray(o.value.array, h * 16);
    t && (t.instanceMatrix.needsUpdate = !0), o.value.needsUpdate = !0;
  })(), { buffer: o };
}, tv = /* @__PURE__ */ ue({
  __name: "component",
  props: {
    transform: { type: Function },
    weight: {},
    count: {},
    mesh: {},
    instanceMesh: {}
  },
  setup(r, { expose: e }) {
    const t = r, n = me(), s = me(), i = me(), { invalidate: o } = xe();
    return J(t, () => o()), et(() => {
      var a, l;
      s.value = t.instanceMesh ?? ((a = n.value) == null ? void 0 : a.children.find((c) => Object.prototype.hasOwnProperty.call(c, "instanceMatrix"))), i.value = t.mesh ?? ((l = n.value) == null ? void 0 : l.children.find((c) => c.type === "Mesh")), ld(i.value, t.count, s.value, t.weight, t.transform);
    }), e({
      samplerRef: n
    }), (a, l) => (ae(), ce("TresGroup", {
      ref_key: "samplerRef",
      ref: n
    }, [
      Ne(a.$slots, "default")
    ], 512));
  }
}), cd = new Jn.Vector3(), ud = new Jn.Vector3(), hd = new Jn.Vector3(), fd = (r, e, t) => {
  const n = t.width / 2, s = t.height / 2;
  e.updateMatrixWorld(!1);
  const i = r.project(e);
  return i.x = i.x * n + n, i.y = -(i.y * s) + s, i;
}, dd = (r, e, t, n = 1) => {
  const s = cd.set(r.x / t.width * 2 - 1, -(r.y / t.height) * 2 + 1, n);
  return s.unproject(e), s;
}, pd = (r, e, t, n) => {
  const s = fd(hd.copy(r), t, n);
  let i = 0;
  for (let o = 0; o < 2; ++o) {
    const a = ud.copy(s).setComponent(o, s.getComponent(o) + e), l = dd(a, t, n, a.z);
    i = Math.max(i, r.distanceTo(l));
  }
  return i;
}, nv = /* @__PURE__ */ ue({
  __name: "ScreenSizer",
  setup(r, { expose: e }) {
    const t = new $(), n = re(), s = re(), i = xn().sizes, o = Pe(() => ({ width: i.width.value, height: i.height.value }));
    return Ve().onBeforeRender(({ camera: a }) => {
      const l = s.value;
      if (!l)
        return;
      const c = pd(l.getWorldPosition(t), 1, a, o.value);
      l.scale.setScalar(c);
    }), e({ instance: n }), (a, l) => (ae(), ce("TresObject3D", {
      ref_key: "outerRef",
      ref: n
    }, [
      ye("TresObject3D", {
        ref_key: "innerRef",
        ref: s
      }, [
        Ne(a.$slots, "default")
      ], 512)
    ], 512));
  }
}), md = ["color"], sv = /* @__PURE__ */ ue({
  __name: "Edges",
  props: {
    color: { default: "#ff0000" },
    threshold: { default: 15 }
  },
  setup(r, { expose: e }) {
    const t = r, { color: n, threshold: s } = Le(t), i = re(), o = me(null), a = me(1);
    return e({
      instance: i
    }), J(
      () => [i.value, s.value],
      () => {
        if (i.value) {
          const l = i.value.parent;
          if (l && "geometry" in l && l.geometry instanceof ht) {
            const c = l.geometry;
            (c !== o.value || s.value !== a.value) && (o.value = c, a.value = s.value, i.value.geometry = new Jl(c, s.value));
          }
        }
      }
    ), (l, c) => (ae(), ce("TresLineSegments", $e({
      ref_key: "lineSegmentsRef",
      ref: i
    }, l.$attrs), [
      Ne(l.$slots, "default", {}, () => [
        ye("TresLineBasicMaterial", { color: F(n) }, null, 8, md)
      ])
    ], 16));
  }
}), Ys = {
  sunset: "venice/venice_sunset_1k.hdr",
  studio: "studio/poly_haven_studio_1k.hdr",
  city: "city/canary_wharf_1k.hdr",
  umbrellas: "outdoor/outdoor_umbrellas_1k.hdr",
  night: "outdoor/satara_night_1k.hdr",
  forest: "outood/mossy_forest_1k.hdr",
  snow: "outdoor/snowy_forest_path_01_1k.hdr",
  dawn: "kiara/kiara_1_dawn_1k.hdr",
  hangar: "indoor/small_hangar_01_1k.hdr",
  urban: "indoor/abandoned_games_room_02_1k.hdr",
  modern: "city/modern_buildings_2_1k.hdr",
  shangai: "city/shanghai_bund_1k.hdr"
}, gd = "https://raw.githubusercontent.com/Tresjs/assets/main/textures/hdr/";
function Ui(r) {
  return r instanceof vt ? r : Array.isArray(r) ? new vt(r[0], r[1], r[2]) : typeof r == "number" ? new vt(r, r, r) : r instanceof $ ? new vt(r.x, r.y, r.z) : typeof r == "object" && "x" in r && "y" in r && "z" in r ? new vt(r.x, r.y, r.z) : null;
}
function Or(r) {
  r.traverse((e) => {
    e instanceof de && e.material && (e.material.needsUpdate = !0);
  });
}
async function vd(r, e) {
  const { scene: t, invalidate: n } = xe(), {
    preset: s,
    blur: i,
    files: o = me([]),
    path: a = me(""),
    background: l,
    backgroundIntensity: c = me(1),
    environmentIntensity: f = me(1),
    backgroundRotation: u = me([0, 0, 0]),
    environmentRotation: d = me([0, 0, 0]),
    syncMaterials: h = me(!1)
  } = Le(r);
  J(r, () => {
    n();
  });
  const m = me(null), g = Pe(() => Array.isArray(o.value)), v = Pe(() => g.value ? ec : wr);
  return J([o, a], async ([p, b]) => {
    if (p && p.length > 0 && !(s != null && s.value)) {
      try {
        const _ = await Nn(
          v.value,
          g.value ? [...F(p)] : F(p),
          (M) => {
            b && M.setPath(F(b));
          }
        );
        m.value = Array.isArray(_) ? _[0] : _;
      } catch (_) {
        throw new Error(`Failed to load environment map: ${_}`);
      }
      m.value && (m.value.mapping = g.value ? tc : ho);
    }
  }, {
    immediate: !0
  }), J(m, (p) => {
    t.value && p && (t.value.environment = p);
  }, {
    immediate: !0
  }), J([l, m], ([p, b]) => {
    if (t.value) {
      const _ = e != null && e.value ? e.value.texture : b;
      _ && (t.value.background = p ? _ : null);
    }
  }, {
    immediate: !0
  }), J(() => i == null ? void 0 : i.value, (p) => {
    t.value && p && (t.value.backgroundBlurriness = p);
  }, {
    immediate: !0
  }), J(() => c == null ? void 0 : c.value, (p) => {
    t.value && (t.value.backgroundIntensity = p ?? 1);
  }, {
    immediate: !0
  }), J(() => f == null ? void 0 : f.value, (p) => {
    t.value && (t.value.environmentIntensity = p ?? 1);
  }, {
    immediate: !0
  }), J(() => u == null ? void 0 : u.value, (p) => {
    if (t.value) {
      const b = Ui(p);
      b && (t.value.backgroundRotation = b);
    }
  }, {
    immediate: !0
  }), J(() => d == null ? void 0 : d.value, (p) => {
    if (t.value && !(h != null && h.value)) {
      const b = Ui(p);
      b && (t.value.environmentRotation = b, Or(t.value));
    }
  }, {
    immediate: !0
  }), J(() => s == null ? void 0 : s.value, async (p) => {
    if (p && p in Ys) {
      const b = gd, _ = Ys[p];
      try {
        const M = await Nn(
          wr,
          _,
          (R) => {
            b && R.setPath(b);
          }
        );
        m.value = Array.isArray(M) ? M[0] : M;
      } catch (M) {
        throw new Error(`Failed to load environment map: ${M}`);
      }
      m.value && (m.value.mapping = ho), n();
    } else if (p && !(p in Ys))
      throw new Error(`Preset must be one of: ${Object.keys(Ys).join(", ")}`);
  }, {
    immediate: !0
  }), J([h, u], ([p, b]) => {
    if (p && t.value) {
      const _ = Ui(b);
      _ && (t.value.environmentRotation = _, Or(t.value));
    }
  }, {
    immediate: !0
  }), m;
}
/*!
 * camera-controls
 * https://github.com/yomotsu/camera-controls
 * (c) 2017 @yomotsu
 * Released under the MIT License.
 */
const qe = {
  LEFT: 1,
  RIGHT: 2,
  MIDDLE: 4
}, Q = Object.freeze({
  NONE: 0,
  ROTATE: 1,
  TRUCK: 2,
  OFFSET: 4,
  DOLLY: 8,
  ZOOM: 16,
  TOUCH_ROTATE: 32,
  TOUCH_TRUCK: 64,
  TOUCH_OFFSET: 128,
  TOUCH_DOLLY: 256,
  TOUCH_ZOOM: 512,
  TOUCH_DOLLY_TRUCK: 1024,
  TOUCH_DOLLY_OFFSET: 2048,
  TOUCH_DOLLY_ROTATE: 4096,
  TOUCH_ZOOM_TRUCK: 8192,
  TOUCH_ZOOM_OFFSET: 16384,
  TOUCH_ZOOM_ROTATE: 32768
}), jn = {
  NONE: 0,
  IN: 1,
  OUT: -1
};
function Pn(r) {
  return r.isPerspectiveCamera;
}
function mn(r) {
  return r.isOrthographicCamera;
}
const Vn = Math.PI * 2, Dr = Math.PI / 2, fl = 1e-5, us = Math.PI / 180;
function Ot(r, e, t) {
  return Math.max(e, Math.min(t, r));
}
function We(r, e = fl) {
  return Math.abs(r) < e;
}
function Fe(r, e, t = fl) {
  return We(r - e, t);
}
function Lr(r, e) {
  return Math.round(r / e) * e;
}
function hs(r) {
  return isFinite(r) ? r : r < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
}
function fs(r) {
  return Math.abs(r) < Number.MAX_VALUE ? r : r * (1 / 0);
}
function Ws(r, e, t, n, s = 1 / 0, i) {
  n = Math.max(1e-4, n);
  const o = 2 / n, a = o * i, l = 1 / (1 + a + 0.48 * a * a + 0.235 * a * a * a);
  let c = r - e;
  const f = e, u = s * n;
  c = Ot(c, -u, u), e = r - c;
  const d = (t.value + o * c) * i;
  t.value = (t.value - o * d) * l;
  let h = e + (c + d) * l;
  return f - r > 0 == h > f && (h = f, t.value = (h - f) / i), h;
}
function kr(r, e, t, n, s = 1 / 0, i, o) {
  n = Math.max(1e-4, n);
  const a = 2 / n, l = a * i, c = 1 / (1 + l + 0.48 * l * l + 0.235 * l * l * l);
  let f = e.x, u = e.y, d = e.z, h = r.x - f, m = r.y - u, g = r.z - d;
  const v = f, p = u, b = d, _ = s * n, M = _ * _, R = h * h + m * m + g * g;
  if (R > M) {
    const Y = Math.sqrt(R);
    h = h / Y * _, m = m / Y * _, g = g / Y * _;
  }
  f = r.x - h, u = r.y - m, d = r.z - g;
  const w = (t.x + a * h) * i, E = (t.y + a * m) * i, x = (t.z + a * g) * i;
  t.x = (t.x - a * w) * c, t.y = (t.y - a * E) * c, t.z = (t.z - a * x) * c, o.x = f + (h + w) * c, o.y = u + (m + E) * c, o.z = d + (g + x) * c;
  const T = v - r.x, y = p - r.y, A = b - r.z, C = o.x - v, N = o.y - p, U = o.z - b;
  return T * C + y * N + A * U > 0 && (o.x = v, o.y = p, o.z = b, t.x = (o.x - v) / i, t.y = (o.y - p) / i, t.z = (o.z - b) / i), o;
}
function Fi(r, e) {
  e.set(0, 0), r.forEach((t) => {
    e.x += t.clientX, e.y += t.clientY;
  }), e.x /= r.length, e.y /= r.length;
}
function zi(r, e) {
  return mn(r) ? (console.warn(`${e} is not supported in OrthographicCamera`), !0) : !1;
}
class yd {
  constructor() {
    this._listeners = {};
  }
  /**
   * Adds the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(e, t) {
    const n = this._listeners;
    n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
  }
  /**
   * Presence of the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  hasEventListener(e, t) {
    const n = this._listeners;
    return n[e] !== void 0 && n[e].indexOf(t) !== -1;
  }
  /**
   * Removes the specified event listener
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(e, t) {
    const s = this._listeners[e];
    if (s !== void 0) {
      const i = s.indexOf(t);
      i !== -1 && s.splice(i, 1);
    }
  }
  /**
   * Removes all event listeners
   * @param type event name
   * @category Methods
   */
  removeAllEventListeners(e) {
    if (!e) {
      this._listeners = {};
      return;
    }
    Array.isArray(this._listeners[e]) && (this._listeners[e].length = 0);
  }
  /**
   * Fire an event type.
   * @param event DispatcherEvent
   * @category Methods
   */
  dispatchEvent(e) {
    const n = this._listeners[e.type];
    if (n !== void 0) {
      e.target = this;
      const s = n.slice(0);
      for (let i = 0, o = s.length; i < o; i++)
        s[i].call(this, e);
    }
  }
}
var Gi;
const _d = "2.9.0", Xs = 1 / 8, xd = /Mac/.test((Gi = globalThis == null ? void 0 : globalThis.navigator) === null || Gi === void 0 ? void 0 : Gi.platform);
let Te, Nr, $s, Hi, ft, Ae, Be, Yn, ds, zt, Gt, Rn, Br, Ur, St, ps, Wn, Fr, ji, zr, Vi, Yi, Zs;
class lt extends yd {
  /**
       * Injects THREE as the dependency. You can then proceed to use CameraControls.
       *
       * e.g
       * ```javascript
       * CameraControls.install( { THREE: THREE } );
       * ```
       *
       * Note: If you do not wish to use enter three.js to reduce file size(tree-shaking for example), make a subset to install.
       *
       * ```js
       * import {
       * 	Vector2,
       * 	Vector3,
       * 	Vector4,
       * 	Quaternion,
       * 	Matrix4,
       * 	Spherical,
       * 	Box3,
       * 	Sphere,
       * 	Raycaster,
       * 	MathUtils,
       * } from 'three';
       *
       * const subsetOfTHREE = {
       * 	Vector2   : Vector2,
       * 	Vector3   : Vector3,
       * 	Vector4   : Vector4,
       * 	Quaternion: Quaternion,
       * 	Matrix4   : Matrix4,
       * 	Spherical : Spherical,
       * 	Box3      : Box3,
       * 	Sphere    : Sphere,
       * 	Raycaster : Raycaster,
       * };
  
       * CameraControls.install( { THREE: subsetOfTHREE } );
       * ```
       * @category Statics
       */
  static install(e) {
    Te = e.THREE, Nr = Object.freeze(new Te.Vector3(0, 0, 0)), $s = Object.freeze(new Te.Vector3(0, 1, 0)), Hi = Object.freeze(new Te.Vector3(0, 0, 1)), ft = new Te.Vector2(), Ae = new Te.Vector3(), Be = new Te.Vector3(), Yn = new Te.Vector3(), ds = new Te.Vector3(), zt = new Te.Vector3(), Gt = new Te.Vector3(), Rn = new Te.Vector3(), Br = new Te.Vector3(), Ur = new Te.Vector3(), St = new Te.Spherical(), ps = new Te.Spherical(), Wn = new Te.Box3(), Fr = new Te.Box3(), ji = new Te.Sphere(), zr = new Te.Quaternion(), Vi = new Te.Quaternion(), Yi = new Te.Matrix4(), Zs = new Te.Raycaster();
  }
  /**
   * list all ACTIONs
   * @category Statics
   */
  static get ACTION() {
    return Q;
  }
  /**
   * Creates a `CameraControls` instance.
   *
   * Note:
   * You **must install** three.js before using camera-controls. see [#install](#install)
   * Not doing so will lead to runtime errors (`undefined` references to THREE).
   *
   * e.g.
   * ```
   * CameraControls.install( { THREE } );
   * const cameraControls = new CameraControls( camera, domElement );
   * ```
   *
   * @param camera A `THREE.PerspectiveCamera` or `THREE.OrthographicCamera` to be controlled.
   * @param domElement A `HTMLElement` for the draggable area, usually `renderer.domElement`.
   * @category Constructor
   */
  constructor(e, t) {
    super(), this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.minDistance = Number.EPSILON, this.maxDistance = 1 / 0, this.infinityDolly = !1, this.minZoom = 0.01, this.maxZoom = 1 / 0, this.smoothTime = 0.25, this.draggingSmoothTime = 0.125, this.maxSpeed = 1 / 0, this.azimuthRotateSpeed = 1, this.polarRotateSpeed = 1, this.dollySpeed = 1, this.dollyDragInverted = !1, this.truckSpeed = 2, this.dollyToCursor = !1, this.dragToOffset = !1, this.verticalDragToForward = !1, this.boundaryFriction = 0, this.restThreshold = 0.01, this.colliderMeshes = [], this.cancel = () => {
    }, this._enabled = !0, this._state = Q.NONE, this._viewport = null, this._changedDolly = 0, this._changedZoom = 0, this._hasRested = !0, this._boundaryEnclosesCamera = !1, this._needsUpdate = !0, this._updatedLastTime = !1, this._elementRect = new DOMRect(), this._isDragging = !1, this._dragNeedsUpdate = !0, this._activePointers = [], this._lockedPointer = null, this._interactiveArea = new DOMRect(0, 0, 1, 1), this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._isUserControllingOffset = !1, this._isUserControllingZoom = !1, this._lastDollyDirection = jn.NONE, this._thetaVelocity = { value: 0 }, this._phiVelocity = { value: 0 }, this._radiusVelocity = { value: 0 }, this._targetVelocity = new Te.Vector3(), this._focalOffsetVelocity = new Te.Vector3(), this._zoomVelocity = { value: 0 }, this._truckInternal = (p, b, _) => {
      let M, R;
      if (Pn(this._camera)) {
        const w = Ae.copy(this._camera.position).sub(this._target), E = this._camera.getEffectiveFOV() * us, x = w.length() * Math.tan(E * 0.5);
        M = this.truckSpeed * p * x / this._elementRect.height, R = this.truckSpeed * b * x / this._elementRect.height;
      } else if (mn(this._camera)) {
        const w = this._camera;
        M = p * (w.right - w.left) / w.zoom / this._elementRect.width, R = b * (w.top - w.bottom) / w.zoom / this._elementRect.height;
      } else
        return;
      this.verticalDragToForward ? (_ ? this.setFocalOffset(this._focalOffsetEnd.x + M, this._focalOffsetEnd.y, this._focalOffsetEnd.z, !0) : this.truck(M, 0, !0), this.forward(-R, !0)) : _ ? this.setFocalOffset(this._focalOffsetEnd.x + M, this._focalOffsetEnd.y + R, this._focalOffsetEnd.z, !0) : this.truck(M, R, !0);
    }, this._rotateInternal = (p, b) => {
      const _ = Vn * this.azimuthRotateSpeed * p / this._elementRect.height, M = Vn * this.polarRotateSpeed * b / this._elementRect.height;
      this.rotate(_, M, !0);
    }, this._dollyInternal = (p, b, _) => {
      const M = Math.pow(0.95, -p * this.dollySpeed), R = this._sphericalEnd.radius, w = this._sphericalEnd.radius * M, E = Ot(w, this.minDistance, this.maxDistance), x = E - w;
      this.infinityDolly && this.dollyToCursor ? this._dollyToNoClamp(w, !0) : this.infinityDolly && !this.dollyToCursor ? (this.dollyInFixed(x, !0), this._dollyToNoClamp(E, !0)) : this._dollyToNoClamp(E, !0), this.dollyToCursor && (this._changedDolly += (this.infinityDolly ? w : E) - R, this._dollyControlCoord.set(b, _)), this._lastDollyDirection = Math.sign(-p);
    }, this._zoomInternal = (p, b, _) => {
      const M = Math.pow(0.95, p * this.dollySpeed), R = this._zoom, w = this._zoom * M;
      this.zoomTo(w, !0), this.dollyToCursor && (this._changedZoom += w - R, this._dollyControlCoord.set(b, _));
    }, typeof Te > "u" && console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."), this._camera = e, this._yAxisUpSpace = new Te.Quaternion().setFromUnitVectors(this._camera.up, $s), this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert(), this._state = Q.NONE, this._target = new Te.Vector3(), this._targetEnd = this._target.clone(), this._focalOffset = new Te.Vector3(), this._focalOffsetEnd = this._focalOffset.clone(), this._spherical = new Te.Spherical().setFromVector3(Ae.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)), this._sphericalEnd = this._spherical.clone(), this._lastDistance = this._spherical.radius, this._zoom = this._camera.zoom, this._zoomEnd = this._zoom, this._lastZoom = this._zoom, this._nearPlaneCorners = [
      new Te.Vector3(),
      new Te.Vector3(),
      new Te.Vector3(),
      new Te.Vector3()
    ], this._updateNearPlaneCorners(), this._boundary = new Te.Box3(new Te.Vector3(-1 / 0, -1 / 0, -1 / 0), new Te.Vector3(1 / 0, 1 / 0, 1 / 0)), this._cameraUp0 = this._camera.up.clone(), this._target0 = this._target.clone(), this._position0 = this._camera.position.clone(), this._zoom0 = this._zoom, this._focalOffset0 = this._focalOffset.clone(), this._dollyControlCoord = new Te.Vector2(), this.mouseButtons = {
      left: Q.ROTATE,
      middle: Q.DOLLY,
      right: Q.TRUCK,
      wheel: Pn(this._camera) ? Q.DOLLY : mn(this._camera) ? Q.ZOOM : Q.NONE
    }, this.touches = {
      one: Q.TOUCH_ROTATE,
      two: Pn(this._camera) ? Q.TOUCH_DOLLY_TRUCK : mn(this._camera) ? Q.TOUCH_ZOOM_TRUCK : Q.NONE,
      three: Q.TOUCH_TRUCK
    };
    const n = new Te.Vector2(), s = new Te.Vector2(), i = new Te.Vector2(), o = (p) => {
      if (!this._enabled || !this._domElement)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const M = this._domElement.getBoundingClientRect(), R = p.clientX / M.width, w = p.clientY / M.height;
        if (R < this._interactiveArea.left || R > this._interactiveArea.right || w < this._interactiveArea.top || w > this._interactiveArea.bottom)
          return;
      }
      const b = p.pointerType !== "mouse" ? null : (p.buttons & qe.LEFT) === qe.LEFT ? qe.LEFT : (p.buttons & qe.MIDDLE) === qe.MIDDLE ? qe.MIDDLE : (p.buttons & qe.RIGHT) === qe.RIGHT ? qe.RIGHT : null;
      if (b !== null) {
        const M = this._findPointerByMouseButton(b);
        M && this._disposePointer(M);
      }
      if ((p.buttons & qe.LEFT) === qe.LEFT && this._lockedPointer)
        return;
      const _ = {
        pointerId: p.pointerId,
        clientX: p.clientX,
        clientY: p.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton: b
      };
      this._activePointers.push(_), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", l), this._domElement.ownerDocument.addEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.addEventListener("pointerup", l), this._isDragging = !0, d(p);
    }, a = (p) => {
      p.cancelable && p.preventDefault();
      const b = p.pointerId, _ = this._lockedPointer || this._findPointerById(b);
      if (_) {
        if (_.clientX = p.clientX, _.clientY = p.clientY, _.deltaX = p.movementX, _.deltaY = p.movementY, this._state = 0, p.pointerType === "touch")
          switch (this._activePointers.length) {
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          (!this._isDragging && this._lockedPointer || this._isDragging && (p.buttons & qe.LEFT) === qe.LEFT) && (this._state = this._state | this.mouseButtons.left), this._isDragging && (p.buttons & qe.MIDDLE) === qe.MIDDLE && (this._state = this._state | this.mouseButtons.middle), this._isDragging && (p.buttons & qe.RIGHT) === qe.RIGHT && (this._state = this._state | this.mouseButtons.right);
        h();
      }
    }, l = (p) => {
      const b = this._findPointerById(p.pointerId);
      if (!(b && b === this._lockedPointer)) {
        if (b && this._disposePointer(b), p.pointerType === "touch")
          switch (this._activePointers.length) {
            case 0:
              this._state = Q.NONE;
              break;
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          this._state = Q.NONE;
        m();
      }
    };
    let c = -1;
    const f = (p) => {
      if (!this._domElement || !this._enabled || this.mouseButtons.wheel === Q.NONE)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const w = this._domElement.getBoundingClientRect(), E = p.clientX / w.width, x = p.clientY / w.height;
        if (E < this._interactiveArea.left || E > this._interactiveArea.right || x < this._interactiveArea.top || x > this._interactiveArea.bottom)
          return;
      }
      if (p.preventDefault(), this.dollyToCursor || this.mouseButtons.wheel === Q.ROTATE || this.mouseButtons.wheel === Q.TRUCK) {
        const w = performance.now();
        c - w < 1e3 && this._getClientRect(this._elementRect), c = w;
      }
      const b = xd ? -1 : -3, _ = p.deltaMode === 1 ? p.deltaY / b : p.deltaY / (b * 10), M = this.dollyToCursor ? (p.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, R = this.dollyToCursor ? (p.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
      switch (this.mouseButtons.wheel) {
        case Q.ROTATE: {
          this._rotateInternal(p.deltaX, p.deltaY), this._isUserControllingRotate = !0;
          break;
        }
        case Q.TRUCK: {
          this._truckInternal(p.deltaX, p.deltaY, !1), this._isUserControllingTruck = !0;
          break;
        }
        case Q.OFFSET: {
          this._truckInternal(p.deltaX, p.deltaY, !0), this._isUserControllingOffset = !0;
          break;
        }
        case Q.DOLLY: {
          this._dollyInternal(-_, M, R), this._isUserControllingDolly = !0;
          break;
        }
        case Q.ZOOM: {
          this._zoomInternal(-_, M, R), this._isUserControllingZoom = !0;
          break;
        }
      }
      this.dispatchEvent({ type: "control" });
    }, u = (p) => {
      if (!(!this._domElement || !this._enabled)) {
        if (this.mouseButtons.right === lt.ACTION.NONE) {
          const b = p instanceof PointerEvent ? p.pointerId : 0, _ = this._findPointerById(b);
          _ && this._disposePointer(_), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", l);
          return;
        }
        p.preventDefault();
      }
    }, d = (p) => {
      if (!this._enabled)
        return;
      if (Fi(this._activePointers, ft), this._getClientRect(this._elementRect), n.copy(ft), s.copy(ft), this._activePointers.length >= 2) {
        const _ = ft.x - this._activePointers[1].clientX, M = ft.y - this._activePointers[1].clientY, R = Math.sqrt(_ * _ + M * M);
        i.set(0, R);
        const w = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5, E = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;
        s.set(w, E);
      }
      if (this._state = 0, !p)
        this._lockedPointer && (this._state = this._state | this.mouseButtons.left);
      else if ("pointerType" in p && p.pointerType === "touch")
        switch (this._activePointers.length) {
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      else
        !this._lockedPointer && (p.buttons & qe.LEFT) === qe.LEFT && (this._state = this._state | this.mouseButtons.left), (p.buttons & qe.MIDDLE) === qe.MIDDLE && (this._state = this._state | this.mouseButtons.middle), (p.buttons & qe.RIGHT) === qe.RIGHT && (this._state = this._state | this.mouseButtons.right);
      ((this._state & Q.ROTATE) === Q.ROTATE || (this._state & Q.TOUCH_ROTATE) === Q.TOUCH_ROTATE || (this._state & Q.TOUCH_DOLLY_ROTATE) === Q.TOUCH_DOLLY_ROTATE || (this._state & Q.TOUCH_ZOOM_ROTATE) === Q.TOUCH_ZOOM_ROTATE) && (this._sphericalEnd.theta = this._spherical.theta, this._sphericalEnd.phi = this._spherical.phi, this._thetaVelocity.value = 0, this._phiVelocity.value = 0), ((this._state & Q.TRUCK) === Q.TRUCK || (this._state & Q.TOUCH_TRUCK) === Q.TOUCH_TRUCK || (this._state & Q.TOUCH_DOLLY_TRUCK) === Q.TOUCH_DOLLY_TRUCK || (this._state & Q.TOUCH_ZOOM_TRUCK) === Q.TOUCH_ZOOM_TRUCK) && (this._targetEnd.copy(this._target), this._targetVelocity.set(0, 0, 0)), ((this._state & Q.DOLLY) === Q.DOLLY || (this._state & Q.TOUCH_DOLLY) === Q.TOUCH_DOLLY || (this._state & Q.TOUCH_DOLLY_TRUCK) === Q.TOUCH_DOLLY_TRUCK || (this._state & Q.TOUCH_DOLLY_OFFSET) === Q.TOUCH_DOLLY_OFFSET || (this._state & Q.TOUCH_DOLLY_ROTATE) === Q.TOUCH_DOLLY_ROTATE) && (this._sphericalEnd.radius = this._spherical.radius, this._radiusVelocity.value = 0), ((this._state & Q.ZOOM) === Q.ZOOM || (this._state & Q.TOUCH_ZOOM) === Q.TOUCH_ZOOM || (this._state & Q.TOUCH_ZOOM_TRUCK) === Q.TOUCH_ZOOM_TRUCK || (this._state & Q.TOUCH_ZOOM_OFFSET) === Q.TOUCH_ZOOM_OFFSET || (this._state & Q.TOUCH_ZOOM_ROTATE) === Q.TOUCH_ZOOM_ROTATE) && (this._zoomEnd = this._zoom, this._zoomVelocity.value = 0), ((this._state & Q.OFFSET) === Q.OFFSET || (this._state & Q.TOUCH_OFFSET) === Q.TOUCH_OFFSET || (this._state & Q.TOUCH_DOLLY_OFFSET) === Q.TOUCH_DOLLY_OFFSET || (this._state & Q.TOUCH_ZOOM_OFFSET) === Q.TOUCH_ZOOM_OFFSET) && (this._focalOffsetEnd.copy(this._focalOffset), this._focalOffsetVelocity.set(0, 0, 0)), this.dispatchEvent({ type: "controlstart" });
    }, h = () => {
      if (!this._enabled || !this._dragNeedsUpdate)
        return;
      this._dragNeedsUpdate = !1, Fi(this._activePointers, ft);
      const b = this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement ? this._lockedPointer || this._activePointers[0] : null, _ = b ? -b.deltaX : s.x - ft.x, M = b ? -b.deltaY : s.y - ft.y;
      if (s.copy(ft), ((this._state & Q.ROTATE) === Q.ROTATE || (this._state & Q.TOUCH_ROTATE) === Q.TOUCH_ROTATE || (this._state & Q.TOUCH_DOLLY_ROTATE) === Q.TOUCH_DOLLY_ROTATE || (this._state & Q.TOUCH_ZOOM_ROTATE) === Q.TOUCH_ZOOM_ROTATE) && (this._rotateInternal(_, M), this._isUserControllingRotate = !0), (this._state & Q.DOLLY) === Q.DOLLY || (this._state & Q.ZOOM) === Q.ZOOM) {
        const R = this.dollyToCursor ? (n.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, w = this.dollyToCursor ? (n.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0, E = this.dollyDragInverted ? -1 : 1;
        (this._state & Q.DOLLY) === Q.DOLLY ? (this._dollyInternal(E * M * Xs, R, w), this._isUserControllingDolly = !0) : (this._zoomInternal(E * M * Xs, R, w), this._isUserControllingZoom = !0);
      }
      if ((this._state & Q.TOUCH_DOLLY) === Q.TOUCH_DOLLY || (this._state & Q.TOUCH_ZOOM) === Q.TOUCH_ZOOM || (this._state & Q.TOUCH_DOLLY_TRUCK) === Q.TOUCH_DOLLY_TRUCK || (this._state & Q.TOUCH_ZOOM_TRUCK) === Q.TOUCH_ZOOM_TRUCK || (this._state & Q.TOUCH_DOLLY_OFFSET) === Q.TOUCH_DOLLY_OFFSET || (this._state & Q.TOUCH_ZOOM_OFFSET) === Q.TOUCH_ZOOM_OFFSET || (this._state & Q.TOUCH_DOLLY_ROTATE) === Q.TOUCH_DOLLY_ROTATE || (this._state & Q.TOUCH_ZOOM_ROTATE) === Q.TOUCH_ZOOM_ROTATE) {
        const R = ft.x - this._activePointers[1].clientX, w = ft.y - this._activePointers[1].clientY, E = Math.sqrt(R * R + w * w), x = i.y - E;
        i.set(0, E);
        const T = this.dollyToCursor ? (s.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, y = this.dollyToCursor ? (s.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        (this._state & Q.TOUCH_DOLLY) === Q.TOUCH_DOLLY || (this._state & Q.TOUCH_DOLLY_ROTATE) === Q.TOUCH_DOLLY_ROTATE || (this._state & Q.TOUCH_DOLLY_TRUCK) === Q.TOUCH_DOLLY_TRUCK || (this._state & Q.TOUCH_DOLLY_OFFSET) === Q.TOUCH_DOLLY_OFFSET ? (this._dollyInternal(x * Xs, T, y), this._isUserControllingDolly = !0) : (this._zoomInternal(x * Xs, T, y), this._isUserControllingZoom = !0);
      }
      ((this._state & Q.TRUCK) === Q.TRUCK || (this._state & Q.TOUCH_TRUCK) === Q.TOUCH_TRUCK || (this._state & Q.TOUCH_DOLLY_TRUCK) === Q.TOUCH_DOLLY_TRUCK || (this._state & Q.TOUCH_ZOOM_TRUCK) === Q.TOUCH_ZOOM_TRUCK) && (this._truckInternal(_, M, !1), this._isUserControllingTruck = !0), ((this._state & Q.OFFSET) === Q.OFFSET || (this._state & Q.TOUCH_OFFSET) === Q.TOUCH_OFFSET || (this._state & Q.TOUCH_DOLLY_OFFSET) === Q.TOUCH_DOLLY_OFFSET || (this._state & Q.TOUCH_ZOOM_OFFSET) === Q.TOUCH_ZOOM_OFFSET) && (this._truckInternal(_, M, !0), this._isUserControllingOffset = !0), this.dispatchEvent({ type: "control" });
    }, m = () => {
      Fi(this._activePointers, ft), s.copy(ft), this._dragNeedsUpdate = !1, (this._activePointers.length === 0 || this._activePointers.length === 1 && this._activePointers[0] === this._lockedPointer) && (this._isDragging = !1), this._activePointers.length === 0 && this._domElement && (this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", l), this.dispatchEvent({ type: "controlend" }));
    };
    this.lockPointer = () => {
      !this._enabled || !this._domElement || (this.cancel(), this._lockedPointer = {
        pointerId: -1,
        clientX: 0,
        clientY: 0,
        deltaX: 0,
        deltaY: 0,
        mouseButton: null
      }, this._activePointers.push(this._lockedPointer), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", l), this._domElement.requestPointerLock(), this._domElement.ownerDocument.addEventListener("pointerlockchange", g), this._domElement.ownerDocument.addEventListener("pointerlockerror", v), this._domElement.ownerDocument.addEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.addEventListener("pointerup", l), d());
    }, this.unlockPointer = () => {
      var p, b, _;
      this._lockedPointer !== null && (this._disposePointer(this._lockedPointer), this._lockedPointer = null), (p = this._domElement) === null || p === void 0 || p.ownerDocument.exitPointerLock(), (b = this._domElement) === null || b === void 0 || b.ownerDocument.removeEventListener("pointerlockchange", g), (_ = this._domElement) === null || _ === void 0 || _.ownerDocument.removeEventListener("pointerlockerror", v), this.cancel();
    };
    const g = () => {
      this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement || this.unlockPointer();
    }, v = () => {
      this.unlockPointer();
    };
    this._addAllEventListeners = (p) => {
      this._domElement = p, this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none", this._domElement.addEventListener("pointerdown", o), this._domElement.addEventListener("pointercancel", l), this._domElement.addEventListener("wheel", f, { passive: !1 }), this._domElement.addEventListener("contextmenu", u);
    }, this._removeAllEventListeners = () => {
      this._domElement && (this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = "", this._domElement.removeEventListener("pointerdown", o), this._domElement.removeEventListener("pointercancel", l), this._domElement.removeEventListener("wheel", f, { passive: !1 }), this._domElement.removeEventListener("contextmenu", u), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", l), this._domElement.ownerDocument.removeEventListener("pointerlockchange", g), this._domElement.ownerDocument.removeEventListener("pointerlockerror", v));
    }, this.cancel = () => {
      this._state !== Q.NONE && (this._state = Q.NONE, this._activePointers.length = 0, m());
    }, t && this.connect(t), this.update(0);
  }
  /**
   * The camera to be controlled
   * @category Properties
   */
  get camera() {
    return this._camera;
  }
  set camera(e) {
    this._camera = e, this.updateCameraUp(), this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = !0;
  }
  /**
   * Whether or not the controls are enabled.
   * `false` to disable user dragging/touch-move, but all methods works.
   * @category Properties
   */
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    this._enabled = e, this._domElement && (e ? (this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none") : (this.cancel(), this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = ""));
  }
  /**
   * Returns `true` if the controls are active updating.
   * readonly value.
   * @category Properties
   */
  get active() {
    return !this._hasRested;
  }
  /**
   * Getter for the current `ACTION`.
   * readonly value.
   * @category Properties
   */
  get currentAction() {
    return this._state;
  }
  /**
   * get/set Current distance.
   * @category Properties
   */
  get distance() {
    return this._spherical.radius;
  }
  set distance(e) {
    this._spherical.radius === e && this._sphericalEnd.radius === e || (this._spherical.radius = e, this._sphericalEnd.radius = e, this._needsUpdate = !0);
  }
  // horizontal angle
  /**
   * get/set the azimuth angle (horizontal) in radians.
   * Every 360 degrees turn is added to `.azimuthAngle` value, which is accumulative.
   * @category Properties
   */
  get azimuthAngle() {
    return this._spherical.theta;
  }
  set azimuthAngle(e) {
    this._spherical.theta === e && this._sphericalEnd.theta === e || (this._spherical.theta = e, this._sphericalEnd.theta = e, this._needsUpdate = !0);
  }
  // vertical angle
  /**
   * get/set the polar angle (vertical) in radians.
   * @category Properties
   */
  get polarAngle() {
    return this._spherical.phi;
  }
  set polarAngle(e) {
    this._spherical.phi === e && this._sphericalEnd.phi === e || (this._spherical.phi = e, this._sphericalEnd.phi = e, this._needsUpdate = !0);
  }
  /**
   * Whether camera position should be enclosed in the boundary or not.
   * @category Properties
   */
  get boundaryEnclosesCamera() {
    return this._boundaryEnclosesCamera;
  }
  set boundaryEnclosesCamera(e) {
    this._boundaryEnclosesCamera = e, this._needsUpdate = !0;
  }
  /**
   * Set drag-start, touches and wheel enable area in the domElement.
   * each values are between `0` and `1` inclusive, where `0` is left/top and `1` is right/bottom of the screen.
   * e.g. `{ x: 0, y: 0, width: 1, height: 1 }` for entire area.
   * @category Properties
   */
  set interactiveArea(e) {
    this._interactiveArea.width = Ot(e.width, 0, 1), this._interactiveArea.height = Ot(e.height, 0, 1), this._interactiveArea.x = Ot(e.x, 0, 1 - this._interactiveArea.width), this._interactiveArea.y = Ot(e.y, 0, 1 - this._interactiveArea.height);
  }
  /**
   * Adds the specified event listener.
   * Applicable event types (which is `K`) are:
   * | Event name          | Timing |
   * | ------------------- | ------ |
   * | `'controlstart'`    | When the user starts to control the camera via mouse / touches. ¹ |
   * | `'control'`         | When the user controls the camera (dragging). |
   * | `'controlend'`      | When the user ends to control the camera. ¹ |
   * | `'transitionstart'` | When any kind of transition starts, either user control or using a method with `enableTransition = true` |
   * | `'update'`          | When the camera position is updated. |
   * | `'wake'`            | When the camera starts moving. |
   * | `'rest'`            | When the camera movement is below `.restThreshold` ². |
   * | `'sleep'`           | When the camera end moving. |
   *
   * 1. `mouseButtons.wheel` (Mouse wheel control) does not emit `'controlstart'` and `'controlend'`. `mouseButtons.wheel` uses scroll-event internally, and scroll-event happens intermittently. That means "start" and "end" cannot be detected.
   * 2. Due to damping, `sleep` will usually fire a few seconds after the camera _appears_ to have stopped moving. If you want to do something (e.g. enable UI, perform another transition) at the point when the camera has stopped, you probably want the `rest` event. This can be fine tuned using the `.restThreshold` parameter. See the [Rest and Sleep Example](https://yomotsu.github.io/camera-controls/examples/rest-and-sleep.html).
   *
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(e, t) {
    super.addEventListener(e, t);
  }
  /**
   * Removes the specified event listener
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(e, t) {
    super.removeEventListener(e, t);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical).
   * Every value is added to the current value.
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotate(e, t, n = !1) {
    return this.rotateTo(this._sphericalEnd.theta + e, this._sphericalEnd.phi + t, n);
  }
  /**
   * Rotate azimuthal angle(horizontal) to the given angle and keep the same polar angle(vertical) target.
   *
   * e.g.
   * ```
   * cameraControls.rotateAzimuthTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotateAzimuthTo(e, t = !1) {
    return this.rotateTo(e, this._sphericalEnd.phi, t);
  }
  /**
   * Rotate polar angle(vertical) to the given angle and keep the same azimuthal angle(horizontal) target.
   *
   * e.g.
   * ```
   * cameraControls.rotatePolarTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotatePolarTo(e, t = !1) {
    return this.rotateTo(this._sphericalEnd.theta, e, t);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical) to the given angle.
   * Camera view will rotate over the orbit pivot absolutely:
   *
   * azimuthAngle
   * ```
   *       0º
   *         \
   * 90º -----+----- -90º
   *           \
   *           180º
   * ```
   * | direction | angle                  |
   * | --------- | ---------------------- |
   * | front     | 0º                     |
   * | left      | 90º (`Math.PI / 2`)    |
   * | right     | -90º (`- Math.PI / 2`) |
   * | back      | 180º (`Math.PI`)       |
   *
   * polarAngle
   * ```
   *     180º
   *      |
   *      90º
   *      |
   *      0º
   * ```
   * | direction            | angle                  |
   * | -------------------- | ---------------------- |
   * | top/sky              | 180º (`Math.PI`)       |
   * | horizontal from view | 90º (`Math.PI / 2`)    |
   * | bottom/floor         | 0º                     |
   *
   * @param azimuthAngle Azimuth rotate angle to. In radian.
   * @param polarAngle Polar rotate angle to. In radian.
   * @param enableTransition  Whether to move smoothly or immediately
   * @category Methods
   */
  rotateTo(e, t, n = !1) {
    this._isUserControllingRotate = !1;
    const s = Ot(e, this.minAzimuthAngle, this.maxAzimuthAngle), i = Ot(t, this.minPolarAngle, this.maxPolarAngle);
    this._sphericalEnd.theta = s, this._sphericalEnd.phi = i, this._sphericalEnd.makeSafe(), this._needsUpdate = !0, n || (this._spherical.theta = this._sphericalEnd.theta, this._spherical.phi = this._sphericalEnd.phi);
    const o = !n || Fe(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && Fe(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);
    return this._createOnRestPromise(o);
  }
  /**
   * Dolly in/out camera position.
   * @param distance Distance of dollyIn. Negative number for dollyOut.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dolly(e, t = !1) {
    return this.dollyTo(this._sphericalEnd.radius - e, t);
  }
  /**
   * Dolly in/out camera position to given distance.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyTo(e, t = !1) {
    return this._isUserControllingDolly = !1, this._lastDollyDirection = jn.NONE, this._changedDolly = 0, this._dollyToNoClamp(Ot(e, this.minDistance, this.maxDistance), t);
  }
  _dollyToNoClamp(e, t = !1) {
    const n = this._sphericalEnd.radius;
    if (this.colliderMeshes.length >= 1) {
      const o = this._collisionTest(), a = Fe(o, this._spherical.radius);
      if (!(n > e) && a)
        return Promise.resolve();
      this._sphericalEnd.radius = Math.min(e, o);
    } else
      this._sphericalEnd.radius = e;
    this._needsUpdate = !0, t || (this._spherical.radius = this._sphericalEnd.radius);
    const i = !t || Fe(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(i);
  }
  /**
   * Dolly in, but does not change the distance between the target and the camera, and moves the target position instead.
   * Specify a negative value for dolly out.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyInFixed(e, t = !1) {
    this._targetEnd.add(this._getCameraDirection(ds).multiplyScalar(e)), t || this._target.copy(this._targetEnd);
    const n = !t || Fe(this._target.x, this._targetEnd.x, this.restThreshold) && Fe(this._target.y, this._targetEnd.y, this.restThreshold) && Fe(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(n);
  }
  /**
   * Zoom in/out camera. The value is added to camera zoom.
   * Limits set with `.minZoom` and `.maxZoom`
   * @param zoomStep zoom scale
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  zoom(e, t = !1) {
    return this.zoomTo(this._zoomEnd + e, t);
  }
  /**
   * Zoom in/out camera to given scale. The value overwrites camera zoom.
   * Limits set with .minZoom and .maxZoom
   * @param zoom
   * @param enableTransition
   * @category Methods
   */
  zoomTo(e, t = !1) {
    this._isUserControllingZoom = !1, this._zoomEnd = Ot(e, this.minZoom, this.maxZoom), this._needsUpdate = !0, t || (this._zoom = this._zoomEnd);
    const n = !t || Fe(this._zoom, this._zoomEnd, this.restThreshold);
    return this._changedZoom = 0, this._createOnRestPromise(n);
  }
  /**
   * @deprecated `pan()` has been renamed to `truck()`
   * @category Methods
   */
  pan(e, t, n = !1) {
    return console.warn("`pan` has been renamed to `truck`"), this.truck(e, t, n);
  }
  /**
   * Truck and pedestal camera using current azimuthal angle
   * @param x Horizontal translate amount
   * @param y Vertical translate amount
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  truck(e, t, n = !1) {
    this._camera.updateMatrix(), zt.setFromMatrixColumn(this._camera.matrix, 0), Gt.setFromMatrixColumn(this._camera.matrix, 1), zt.multiplyScalar(e), Gt.multiplyScalar(-t);
    const s = Ae.copy(zt).add(Gt), i = Be.copy(this._targetEnd).add(s);
    return this.moveTo(i.x, i.y, i.z, n);
  }
  /**
   * Move forward / backward.
   * @param distance Amount to move forward / backward. Negative value to move backward
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  forward(e, t = !1) {
    Ae.setFromMatrixColumn(this._camera.matrix, 0), Ae.crossVectors(this._camera.up, Ae), Ae.multiplyScalar(e);
    const n = Be.copy(this._targetEnd).add(Ae);
    return this.moveTo(n.x, n.y, n.z, t);
  }
  /**
   * Move up / down.
   * @param height Amount to move up / down. Negative value to move down
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  elevate(e, t = !1) {
    return Ae.copy(this._camera.up).multiplyScalar(e), this.moveTo(this._targetEnd.x + Ae.x, this._targetEnd.y + Ae.y, this._targetEnd.z + Ae.z, t);
  }
  /**
   * Move target position to given point.
   * @param x x coord to move center position
   * @param y y coord to move center position
   * @param z z coord to move center position
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  moveTo(e, t, n, s = !1) {
    this._isUserControllingTruck = !1;
    const i = Ae.set(e, t, n).sub(this._targetEnd);
    this._encloseToBoundary(this._targetEnd, i, this.boundaryFriction), this._needsUpdate = !0, s || this._target.copy(this._targetEnd);
    const o = !s || Fe(this._target.x, this._targetEnd.x, this.restThreshold) && Fe(this._target.y, this._targetEnd.y, this.restThreshold) && Fe(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(o);
  }
  /**
   * Look in the given point direction.
   * @param x point x.
   * @param y point y.
   * @param z point z.
   * @param enableTransition Whether to move smoothly or immediately.
   * @returns Transition end promise
   * @category Methods
   */
  lookInDirectionOf(e, t, n, s = !1) {
    const a = Ae.set(e, t, n).sub(this._targetEnd).normalize().multiplyScalar(-this._sphericalEnd.radius).add(this._targetEnd);
    return this.setPosition(a.x, a.y, a.z, s);
  }
  /**
   * Fit the viewport to the box or the bounding box of the object, using the nearest axis. paddings are in unit.
   * set `cover: true` to fill enter screen.
   * e.g.
   * ```
   * cameraControls.fitToBox( myMesh );
   * ```
   * @param box3OrObject Axis aligned bounding box to fit the view.
   * @param enableTransition Whether to move smoothly or immediately.
   * @param options | `<object>` { cover: boolean, paddingTop: number, paddingLeft: number, paddingBottom: number, paddingRight: number }
   * @returns Transition end promise
   * @category Methods
   */
  fitToBox(e, t, { cover: n = !1, paddingLeft: s = 0, paddingRight: i = 0, paddingBottom: o = 0, paddingTop: a = 0 } = {}) {
    const l = [], c = e.isBox3 ? Wn.copy(e) : Wn.setFromObject(e);
    c.isEmpty() && (console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"), Promise.resolve());
    const f = Lr(this._sphericalEnd.theta, Dr), u = Lr(this._sphericalEnd.phi, Dr);
    l.push(this.rotateTo(f, u, t));
    const d = Ae.setFromSpherical(this._sphericalEnd).normalize(), h = zr.setFromUnitVectors(d, Hi), m = Fe(Math.abs(d.y), 1);
    m && h.multiply(Vi.setFromAxisAngle($s, f)), h.multiply(this._yAxisUpSpaceInverse);
    const g = Fr.makeEmpty();
    Be.copy(c.min).applyQuaternion(h), g.expandByPoint(Be), Be.copy(c.min).setX(c.max.x).applyQuaternion(h), g.expandByPoint(Be), Be.copy(c.min).setY(c.max.y).applyQuaternion(h), g.expandByPoint(Be), Be.copy(c.max).setZ(c.min.z).applyQuaternion(h), g.expandByPoint(Be), Be.copy(c.min).setZ(c.max.z).applyQuaternion(h), g.expandByPoint(Be), Be.copy(c.max).setY(c.min.y).applyQuaternion(h), g.expandByPoint(Be), Be.copy(c.max).setX(c.min.x).applyQuaternion(h), g.expandByPoint(Be), Be.copy(c.max).applyQuaternion(h), g.expandByPoint(Be), g.min.x -= s, g.min.y -= o, g.max.x += i, g.max.y += a, h.setFromUnitVectors(Hi, d), m && h.premultiply(Vi.invert()), h.premultiply(this._yAxisUpSpace);
    const v = g.getSize(Ae), p = g.getCenter(Be).applyQuaternion(h);
    if (Pn(this._camera)) {
      const b = this.getDistanceToFitBox(v.x, v.y, v.z, n);
      l.push(this.moveTo(p.x, p.y, p.z, t)), l.push(this.dollyTo(b, t)), l.push(this.setFocalOffset(0, 0, 0, t));
    } else if (mn(this._camera)) {
      const b = this._camera, _ = b.right - b.left, M = b.top - b.bottom, R = n ? Math.max(_ / v.x, M / v.y) : Math.min(_ / v.x, M / v.y);
      l.push(this.moveTo(p.x, p.y, p.z, t)), l.push(this.zoomTo(R, t)), l.push(this.setFocalOffset(0, 0, 0, t));
    }
    return Promise.all(l);
  }
  /**
   * Fit the viewport to the sphere or the bounding sphere of the object.
   * @param sphereOrMesh
   * @param enableTransition
   * @category Methods
   */
  fitToSphere(e, t) {
    const n = [], i = "isObject3D" in e ? lt.createBoundingSphere(e, ji) : ji.copy(e);
    if (n.push(this.moveTo(i.center.x, i.center.y, i.center.z, t)), Pn(this._camera)) {
      const o = this.getDistanceToFitSphere(i.radius);
      n.push(this.dollyTo(o, t));
    } else if (mn(this._camera)) {
      const o = this._camera.right - this._camera.left, a = this._camera.top - this._camera.bottom, l = 2 * i.radius, c = Math.min(o / l, a / l);
      n.push(this.zoomTo(c, t));
    }
    return n.push(this.setFocalOffset(0, 0, 0, t)), Promise.all(n);
  }
  /**
   * Look at the `target` from the `position`.
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setLookAt(e, t, n, s, i, o, a = !1) {
    this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._lastDollyDirection = jn.NONE, this._changedDolly = 0;
    const l = Be.set(s, i, o), c = Ae.set(e, t, n);
    this._targetEnd.copy(l), this._sphericalEnd.setFromVector3(c.sub(l).applyQuaternion(this._yAxisUpSpace)), this.normalizeRotations(), this._needsUpdate = !0, a || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const f = !a || Fe(this._target.x, this._targetEnd.x, this.restThreshold) && Fe(this._target.y, this._targetEnd.y, this.restThreshold) && Fe(this._target.z, this._targetEnd.z, this.restThreshold) && Fe(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && Fe(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && Fe(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(f);
  }
  /**
   * Similar to setLookAt, but it interpolates between two states.
   * @param positionAX
   * @param positionAY
   * @param positionAZ
   * @param targetAX
   * @param targetAY
   * @param targetAZ
   * @param positionBX
   * @param positionBY
   * @param positionBZ
   * @param targetBX
   * @param targetBY
   * @param targetBZ
   * @param t
   * @param enableTransition
   * @category Methods
   */
  lerpLookAt(e, t, n, s, i, o, a, l, c, f, u, d, h, m = !1) {
    this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._lastDollyDirection = jn.NONE, this._changedDolly = 0;
    const g = Ae.set(s, i, o), v = Be.set(e, t, n);
    St.setFromVector3(v.sub(g).applyQuaternion(this._yAxisUpSpace));
    const p = Yn.set(f, u, d), b = Be.set(a, l, c);
    ps.setFromVector3(b.sub(p).applyQuaternion(this._yAxisUpSpace)), this._targetEnd.copy(g.lerp(p, h));
    const _ = ps.theta - St.theta, M = ps.phi - St.phi, R = ps.radius - St.radius;
    this._sphericalEnd.set(St.radius + R * h, St.phi + M * h, St.theta + _ * h), this.normalizeRotations(), this._needsUpdate = !0, m || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const w = !m || Fe(this._target.x, this._targetEnd.x, this.restThreshold) && Fe(this._target.y, this._targetEnd.y, this.restThreshold) && Fe(this._target.z, this._targetEnd.z, this.restThreshold) && Fe(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && Fe(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && Fe(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(w);
  }
  /**
   * Set angle and distance by given position.
   * An alias of `setLookAt()`, without target change. Thus keep gazing at the current target
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param enableTransition
   * @category Methods
   */
  setPosition(e, t, n, s = !1) {
    return this.setLookAt(e, t, n, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, s);
  }
  /**
   * Set the target position where gaze at.
   * An alias of `setLookAt()`, without position change. Thus keep the same position.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setTarget(e, t, n, s = !1) {
    const i = this.getPosition(Ae), o = this.setLookAt(i.x, i.y, i.z, e, t, n, s);
    return this._sphericalEnd.phi = Ot(this._sphericalEnd.phi, this.minPolarAngle, this.maxPolarAngle), o;
  }
  /**
   * Set focal offset using the screen parallel coordinates. z doesn't affect in Orthographic as with Dolly.
   * @param x
   * @param y
   * @param z
   * @param enableTransition
   * @category Methods
   */
  setFocalOffset(e, t, n, s = !1) {
    this._isUserControllingOffset = !1, this._focalOffsetEnd.set(e, t, n), this._needsUpdate = !0, s || this._focalOffset.copy(this._focalOffsetEnd);
    const i = !s || Fe(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) && Fe(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) && Fe(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);
    return this._createOnRestPromise(i);
  }
  /**
   * Set orbit point without moving the camera.
   * SHOULD NOT RUN DURING ANIMATIONS. `setOrbitPoint()` will immediately fix the positions.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @category Methods
   */
  setOrbitPoint(e, t, n) {
    this._camera.updateMatrixWorld(), zt.setFromMatrixColumn(this._camera.matrixWorldInverse, 0), Gt.setFromMatrixColumn(this._camera.matrixWorldInverse, 1), Rn.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
    const s = Ae.set(e, t, n), i = s.distanceTo(this._camera.position), o = s.sub(this._camera.position);
    zt.multiplyScalar(o.x), Gt.multiplyScalar(o.y), Rn.multiplyScalar(o.z), Ae.copy(zt).add(Gt).add(Rn), Ae.z = Ae.z + i, this.dollyTo(i, !1), this.setFocalOffset(-Ae.x, Ae.y, -Ae.z, !1), this.moveTo(e, t, n, !1);
  }
  /**
   * Set the boundary box that encloses the target of the camera. box3 is in THREE.Box3
   * @param box3
   * @category Methods
   */
  setBoundary(e) {
    if (!e) {
      this._boundary.min.set(-1 / 0, -1 / 0, -1 / 0), this._boundary.max.set(1 / 0, 1 / 0, 1 / 0), this._needsUpdate = !0;
      return;
    }
    this._boundary.copy(e), this._boundary.clampPoint(this._targetEnd, this._targetEnd), this._needsUpdate = !0;
  }
  /**
   * Set (or unset) the current viewport.
   * Set this when you want to use renderer viewport and .dollyToCursor feature at the same time.
   * @param viewportOrX
   * @param y
   * @param width
   * @param height
   * @category Methods
   */
  setViewport(e, t, n, s) {
    if (e === null) {
      this._viewport = null;
      return;
    }
    this._viewport = this._viewport || new Te.Vector4(), typeof e == "number" ? this._viewport.set(e, t, n, s) : this._viewport.copy(e);
  }
  /**
   * Calculate the distance to fit the box.
   * @param width box width
   * @param height box height
   * @param depth box depth
   * @returns distance
   * @category Methods
   */
  getDistanceToFitBox(e, t, n, s = !1) {
    if (zi(this._camera, "getDistanceToFitBox"))
      return this._spherical.radius;
    const i = e / t, o = this._camera.getEffectiveFOV() * us, a = this._camera.aspect;
    return ((s ? i > a : i < a) ? t : e / a) * 0.5 / Math.tan(o * 0.5) + n * 0.5;
  }
  /**
   * Calculate the distance to fit the sphere.
   * @param radius sphere radius
   * @returns distance
   * @category Methods
   */
  getDistanceToFitSphere(e) {
    if (zi(this._camera, "getDistanceToFitSphere"))
      return this._spherical.radius;
    const t = this._camera.getEffectiveFOV() * us, n = Math.atan(Math.tan(t * 0.5) * this._camera.aspect) * 2, s = 1 < this._camera.aspect ? t : n;
    return e / Math.sin(s * 0.5);
  }
  /**
   * Returns the orbit center position, where the camera looking at.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getTarget(e, t = !0) {
    return (e && e.isVector3 ? e : new Te.Vector3()).copy(t ? this._targetEnd : this._target);
  }
  /**
   * Returns the camera position.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getPosition(e, t = !0) {
    return (e && e.isVector3 ? e : new Te.Vector3()).setFromSpherical(t ? this._sphericalEnd : this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(t ? this._targetEnd : this._target);
  }
  /**
   * Returns the spherical coordinates of the orbit.
   * @param out The receiving Spherical instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getSpherical(e, t = !0) {
    return (e || new Te.Spherical()).copy(t ? this._sphericalEnd : this._spherical);
  }
  /**
   * Returns the focal offset, which is how much the camera appears to be translated in screen parallel coordinates.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getFocalOffset(e, t = !0) {
    return (e && e.isVector3 ? e : new Te.Vector3()).copy(t ? this._focalOffsetEnd : this._focalOffset);
  }
  /**
   * Normalize camera azimuth angle rotation between 0 and 360 degrees.
   * @category Methods
   */
  normalizeRotations() {
    this._sphericalEnd.theta = this._sphericalEnd.theta % Vn, this._sphericalEnd.theta < 0 && (this._sphericalEnd.theta += Vn), this._spherical.theta += Vn * Math.round((this._sphericalEnd.theta - this._spherical.theta) / Vn);
  }
  /**
   * stop all transitions.
   */
  stop() {
    this._focalOffset.copy(this._focalOffsetEnd), this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd), this._zoom = this._zoomEnd;
  }
  /**
   * Reset all rotation and position to defaults.
   * @param enableTransition
   * @category Methods
   */
  reset(e = !1) {
    if (!Fe(this._camera.up.x, this._cameraUp0.x) || !Fe(this._camera.up.y, this._cameraUp0.y) || !Fe(this._camera.up.z, this._cameraUp0.z)) {
      this._camera.up.copy(this._cameraUp0);
      const n = this.getPosition(Ae);
      this.updateCameraUp(), this.setPosition(n.x, n.y, n.z);
    }
    const t = [
      this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, e),
      this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, e),
      this.zoomTo(this._zoom0, e)
    ];
    return Promise.all(t);
  }
  /**
   * Set current camera position as the default position.
   * @category Methods
   */
  saveState() {
    this._cameraUp0.copy(this._camera.up), this.getTarget(this._target0), this.getPosition(this._position0), this._zoom0 = this._zoom, this._focalOffset0.copy(this._focalOffset);
  }
  /**
   * Sync camera-up direction.
   * When camera-up vector is changed, `.updateCameraUp()` must be called.
   * @category Methods
   */
  updateCameraUp() {
    this._yAxisUpSpace.setFromUnitVectors(this._camera.up, $s), this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert();
  }
  /**
   * Apply current camera-up direction to the camera.
   * The orbit system will be re-initialized with the current position.
   * @category Methods
   */
  applyCameraUp() {
    const e = Ae.subVectors(this._target, this._camera.position).normalize(), t = Be.crossVectors(e, this._camera.up);
    this._camera.up.crossVectors(t, e).normalize(), this._camera.updateMatrixWorld();
    const n = this.getPosition(Ae);
    this.updateCameraUp(), this.setPosition(n.x, n.y, n.z);
  }
  /**
   * Update camera position and directions.
   * This should be called in your tick loop every time, and returns true if re-rendering is needed.
   * @param delta
   * @returns updated
   * @category Methods
   */
  update(e) {
    const t = this._sphericalEnd.theta - this._spherical.theta, n = this._sphericalEnd.phi - this._spherical.phi, s = this._sphericalEnd.radius - this._spherical.radius, i = Br.subVectors(this._targetEnd, this._target), o = Ur.subVectors(this._focalOffsetEnd, this._focalOffset), a = this._zoomEnd - this._zoom;
    if (We(t))
      this._thetaVelocity.value = 0, this._spherical.theta = this._sphericalEnd.theta;
    else {
      const u = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.theta = Ws(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, u, 1 / 0, e), this._needsUpdate = !0;
    }
    if (We(n))
      this._phiVelocity.value = 0, this._spherical.phi = this._sphericalEnd.phi;
    else {
      const u = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.phi = Ws(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, u, 1 / 0, e), this._needsUpdate = !0;
    }
    if (We(s))
      this._radiusVelocity.value = 0, this._spherical.radius = this._sphericalEnd.radius;
    else {
      const u = this._isUserControllingDolly ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.radius = Ws(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, u, this.maxSpeed, e), this._needsUpdate = !0;
    }
    if (We(i.x) && We(i.y) && We(i.z))
      this._targetVelocity.set(0, 0, 0), this._target.copy(this._targetEnd);
    else {
      const u = this._isUserControllingTruck ? this.draggingSmoothTime : this.smoothTime;
      kr(this._target, this._targetEnd, this._targetVelocity, u, this.maxSpeed, e, this._target), this._needsUpdate = !0;
    }
    if (We(o.x) && We(o.y) && We(o.z))
      this._focalOffsetVelocity.set(0, 0, 0), this._focalOffset.copy(this._focalOffsetEnd);
    else {
      const u = this._isUserControllingOffset ? this.draggingSmoothTime : this.smoothTime;
      kr(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, u, this.maxSpeed, e, this._focalOffset), this._needsUpdate = !0;
    }
    if (We(a))
      this._zoomVelocity.value = 0, this._zoom = this._zoomEnd;
    else {
      const u = this._isUserControllingZoom ? this.draggingSmoothTime : this.smoothTime;
      this._zoom = Ws(this._zoom, this._zoomEnd, this._zoomVelocity, u, 1 / 0, e);
    }
    if (this.dollyToCursor) {
      if (Pn(this._camera) && this._changedDolly !== 0) {
        const u = this._spherical.radius - this._lastDistance, d = this._camera, h = this._getCameraDirection(ds), m = Ae.copy(h).cross(d.up).normalize();
        m.lengthSq() === 0 && (m.x = 1);
        const g = Be.crossVectors(m, h), v = this._sphericalEnd.radius * Math.tan(d.getEffectiveFOV() * us * 0.5), b = (this._sphericalEnd.radius - u - this._sphericalEnd.radius) / this._sphericalEnd.radius, _ = Yn.copy(this._targetEnd).add(m.multiplyScalar(this._dollyControlCoord.x * v * d.aspect)).add(g.multiplyScalar(this._dollyControlCoord.y * v)), M = Ae.copy(this._targetEnd).lerp(_, b), R = this._lastDollyDirection === jn.IN && this._spherical.radius <= this.minDistance, w = this._lastDollyDirection === jn.OUT && this.maxDistance <= this._spherical.radius;
        if (this.infinityDolly && (R || w)) {
          this._sphericalEnd.radius -= u, this._spherical.radius -= u;
          const x = Be.copy(h).multiplyScalar(-u);
          M.add(x);
        }
        this._boundary.clampPoint(M, M);
        const E = Be.subVectors(M, this._targetEnd);
        this._targetEnd.copy(M), this._target.add(E), this._changedDolly -= u, We(this._changedDolly) && (this._changedDolly = 0);
      } else if (mn(this._camera) && this._changedZoom !== 0) {
        const u = this._zoom - this._lastZoom, d = this._camera, h = Ae.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (d.near + d.far) / (d.near - d.far)).unproject(d), m = Be.set(0, 0, -1).applyQuaternion(d.quaternion), g = Yn.copy(h).add(m.multiplyScalar(-h.dot(d.up))), p = -(this._zoom - u - this._zoom) / this._zoom, b = this._getCameraDirection(ds), _ = this._targetEnd.dot(b), M = Ae.copy(this._targetEnd).lerp(g, p), R = M.dot(b), w = b.multiplyScalar(R - _);
        M.sub(w), this._boundary.clampPoint(M, M);
        const E = Be.subVectors(M, this._targetEnd);
        this._targetEnd.copy(M), this._target.add(E), this._changedZoom -= u, We(this._changedZoom) && (this._changedZoom = 0);
      }
    }
    this._camera.zoom !== this._zoom && (this._camera.zoom = this._zoom, this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = !0), this._dragNeedsUpdate = !0;
    const l = this._collisionTest();
    this._spherical.radius = Math.min(this._spherical.radius, l), this._spherical.makeSafe(), this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target), this._camera.lookAt(this._target), (!We(this._focalOffset.x) || !We(this._focalOffset.y) || !We(this._focalOffset.z)) && (this._camera.updateMatrixWorld(), zt.setFromMatrixColumn(this._camera.matrix, 0), Gt.setFromMatrixColumn(this._camera.matrix, 1), Rn.setFromMatrixColumn(this._camera.matrix, 2), zt.multiplyScalar(this._focalOffset.x), Gt.multiplyScalar(-this._focalOffset.y), Rn.multiplyScalar(this._focalOffset.z), Ae.copy(zt).add(Gt).add(Rn), this._camera.position.add(Ae)), this._boundaryEnclosesCamera && this._encloseToBoundary(this._camera.position.copy(this._target), Ae.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);
    const f = this._needsUpdate;
    return f && !this._updatedLastTime ? (this._hasRested = !1, this.dispatchEvent({ type: "wake" }), this.dispatchEvent({ type: "update" })) : f ? (this.dispatchEvent({ type: "update" }), We(t, this.restThreshold) && We(n, this.restThreshold) && We(s, this.restThreshold) && We(i.x, this.restThreshold) && We(i.y, this.restThreshold) && We(i.z, this.restThreshold) && We(o.x, this.restThreshold) && We(o.y, this.restThreshold) && We(o.z, this.restThreshold) && We(a, this.restThreshold) && !this._hasRested && (this._hasRested = !0, this.dispatchEvent({ type: "rest" }))) : !f && this._updatedLastTime && this.dispatchEvent({ type: "sleep" }), this._lastDistance = this._spherical.radius, this._lastZoom = this._zoom, this._updatedLastTime = f, this._needsUpdate = !1, f;
  }
  /**
   * Get all state in JSON string
   * @category Methods
   */
  toJSON() {
    return JSON.stringify({
      enabled: this._enabled,
      minDistance: this.minDistance,
      maxDistance: hs(this.maxDistance),
      minZoom: this.minZoom,
      maxZoom: hs(this.maxZoom),
      minPolarAngle: this.minPolarAngle,
      maxPolarAngle: hs(this.maxPolarAngle),
      minAzimuthAngle: hs(this.minAzimuthAngle),
      maxAzimuthAngle: hs(this.maxAzimuthAngle),
      smoothTime: this.smoothTime,
      draggingSmoothTime: this.draggingSmoothTime,
      dollySpeed: this.dollySpeed,
      truckSpeed: this.truckSpeed,
      dollyToCursor: this.dollyToCursor,
      verticalDragToForward: this.verticalDragToForward,
      target: this._targetEnd.toArray(),
      position: Ae.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),
      zoom: this._zoomEnd,
      focalOffset: this._focalOffsetEnd.toArray(),
      target0: this._target0.toArray(),
      position0: this._position0.toArray(),
      zoom0: this._zoom0,
      focalOffset0: this._focalOffset0.toArray()
    });
  }
  /**
   * Reproduce the control state with JSON. enableTransition is where anim or not in a boolean.
   * @param json
   * @param enableTransition
   * @category Methods
   */
  fromJSON(e, t = !1) {
    const n = JSON.parse(e);
    this.enabled = n.enabled, this.minDistance = n.minDistance, this.maxDistance = fs(n.maxDistance), this.minZoom = n.minZoom, this.maxZoom = fs(n.maxZoom), this.minPolarAngle = n.minPolarAngle, this.maxPolarAngle = fs(n.maxPolarAngle), this.minAzimuthAngle = fs(n.minAzimuthAngle), this.maxAzimuthAngle = fs(n.maxAzimuthAngle), this.smoothTime = n.smoothTime, this.draggingSmoothTime = n.draggingSmoothTime, this.dollySpeed = n.dollySpeed, this.truckSpeed = n.truckSpeed, this.dollyToCursor = n.dollyToCursor, this.verticalDragToForward = n.verticalDragToForward, this._target0.fromArray(n.target0), this._position0.fromArray(n.position0), this._zoom0 = n.zoom0, this._focalOffset0.fromArray(n.focalOffset0), this.moveTo(n.target[0], n.target[1], n.target[2], t), St.setFromVector3(Ae.fromArray(n.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)), this.rotateTo(St.theta, St.phi, t), this.dollyTo(St.radius, t), this.zoomTo(n.zoom, t), this.setFocalOffset(n.focalOffset[0], n.focalOffset[1], n.focalOffset[2], t), this._needsUpdate = !0;
  }
  /**
   * Attach all internal event handlers to enable drag control.
   * @category Methods
   */
  connect(e) {
    if (this._domElement) {
      console.warn("camera-controls is already connected.");
      return;
    }
    e.setAttribute("data-camera-controls-version", _d), this._addAllEventListeners(e), this._getClientRect(this._elementRect);
  }
  /**
   * Detach all internal event handlers to disable drag control.
   */
  disconnect() {
    this.cancel(), this._removeAllEventListeners(), this._domElement && (this._domElement.removeAttribute("data-camera-controls-version"), this._domElement = void 0);
  }
  /**
   * Dispose the cameraControls instance itself, remove all eventListeners.
   * @category Methods
   */
  dispose() {
    this.removeAllEventListeners(), this.disconnect();
  }
  // it's okay to expose public though
  _getTargetDirection(e) {
    return e.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse);
  }
  // it's okay to expose public though
  _getCameraDirection(e) {
    return this._getTargetDirection(e).negate();
  }
  _findPointerById(e) {
    return this._activePointers.find((t) => t.pointerId === e);
  }
  _findPointerByMouseButton(e) {
    return this._activePointers.find((t) => t.mouseButton === e);
  }
  _disposePointer(e) {
    this._activePointers.splice(this._activePointers.indexOf(e), 1);
  }
  _encloseToBoundary(e, t, n) {
    const s = t.lengthSq();
    if (s === 0)
      return e;
    const i = Be.copy(t).add(e), a = this._boundary.clampPoint(i, Yn).sub(i), l = a.lengthSq();
    if (l === 0)
      return e.add(t);
    if (l === s)
      return e;
    if (n === 0)
      return e.add(t).add(a);
    {
      const c = 1 + n * l / t.dot(a);
      return e.add(Be.copy(t).multiplyScalar(c)).add(a.multiplyScalar(1 - n));
    }
  }
  _updateNearPlaneCorners() {
    if (Pn(this._camera)) {
      const e = this._camera, t = e.near, n = e.getEffectiveFOV() * us, s = Math.tan(n * 0.5) * t, i = s * e.aspect;
      this._nearPlaneCorners[0].set(-i, -s, 0), this._nearPlaneCorners[1].set(i, -s, 0), this._nearPlaneCorners[2].set(i, s, 0), this._nearPlaneCorners[3].set(-i, s, 0);
    } else if (mn(this._camera)) {
      const e = this._camera, t = 1 / e.zoom, n = e.left * t, s = e.right * t, i = e.top * t, o = e.bottom * t;
      this._nearPlaneCorners[0].set(n, i, 0), this._nearPlaneCorners[1].set(s, i, 0), this._nearPlaneCorners[2].set(s, o, 0), this._nearPlaneCorners[3].set(n, o, 0);
    }
  }
  // lateUpdate
  _collisionTest() {
    let e = 1 / 0;
    if (!(this.colliderMeshes.length >= 1) || zi(this._camera, "_collisionTest"))
      return e;
    const n = this._getTargetDirection(ds);
    Yi.lookAt(Nr, n, this._camera.up);
    for (let s = 0; s < 4; s++) {
      const i = Be.copy(this._nearPlaneCorners[s]);
      i.applyMatrix4(Yi);
      const o = Yn.addVectors(this._target, i);
      Zs.set(o, n), Zs.far = this._spherical.radius + 1;
      const a = Zs.intersectObjects(this.colliderMeshes);
      a.length !== 0 && a[0].distance < e && (e = a[0].distance);
    }
    return e;
  }
  /**
   * Get its client rect and package into given `DOMRect` .
   */
  _getClientRect(e) {
    if (!this._domElement)
      return;
    const t = this._domElement.getBoundingClientRect();
    return e.x = t.left, e.y = t.top, this._viewport ? (e.x += this._viewport.x, e.y += t.height - this._viewport.w - this._viewport.y, e.width = this._viewport.z, e.height = this._viewport.w) : (e.width = t.width, e.height = t.height), e;
  }
  _createOnRestPromise(e) {
    return e ? Promise.resolve() : (this._hasRested = !1, this.dispatchEvent({ type: "transitionstart" }), new Promise((t) => {
      const n = () => {
        this.removeEventListener("rest", n), t();
      };
      this.addEventListener("rest", n);
    }));
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _addAllEventListeners(e) {
  }
  _removeAllEventListeners() {
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  get dampingFactor() {
    return console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  set dampingFactor(e) {
    console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.");
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  get draggingDampingFactor() {
    return console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  set draggingDampingFactor(e) {
    console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
  }
  static createBoundingSphere(e, t = new Te.Sphere()) {
    const n = t, s = n.center;
    Wn.makeEmpty(), e.traverseVisible((o) => {
      o.isMesh && Wn.expandByObject(o);
    }), Wn.getCenter(s);
    let i = 0;
    return e.traverseVisible((o) => {
      if (!o.isMesh)
        return;
      const a = o, l = a.geometry.clone();
      l.applyMatrix4(a.matrixWorld);
      const f = l.attributes.position;
      for (let u = 0, d = f.count; u < d; u++)
        Ae.fromBufferAttribute(f, u), i = Math.max(i, s.distanceToSquared(Ae));
    }), n.radius = Math.sqrt(i), n;
  }
}
const dl = (r) => !!(r && r.isPerspectiveCamera), pl = (r) => !!(r && r.isOrthographicCamera), wd = ["min-polar-angle", "max-polar-angle", "min-azimuth-angle", "max-azimuth-angle", "distance", "min-distance", "max-distance", "infinity-dolly", "min-zoom", "max-zoom", "smooth-time", "dragging-smooth-time", "max-speed", "azimuth-rotate-speed", "polar-rotate-speed", "dolly-speed", "dolly-drag-inverted", "truck-speed", "dolly-to-cursor", "drag-to-offset", "vertical-drag-to-forward", "boundary-friction", "rest-threshold", "collider-meshes", "args", "mouse-buttons", "touches"], Gr = (r, e) => ({
  left: lt.ACTION.ROTATE,
  middle: lt.ACTION.DOLLY,
  right: lt.ACTION.TRUCK,
  wheel: dl(r) ? lt.ACTION.DOLLY : pl(r) ? lt.ACTION.ZOOM : lt.ACTION.NONE,
  ...e
}), Hr = (r, e) => ({
  one: lt.ACTION.TOUCH_ROTATE,
  two: dl(r) ? lt.ACTION.TOUCH_DOLLY_TRUCK : pl(r) ? lt.ACTION.TOUCH_ZOOM_TRUCK : lt.ACTION.NONE,
  three: lt.ACTION.TOUCH_TRUCK,
  ...e
}), iv = /* @__PURE__ */ ue({
  __name: "CameraControls",
  props: {
    makeDefault: { type: Boolean, default: !1 },
    camera: {},
    domElement: {},
    minPolarAngle: { default: 0 },
    maxPolarAngle: { default: Math.PI },
    minAzimuthAngle: { default: Number.NEGATIVE_INFINITY },
    maxAzimuthAngle: { default: Number.POSITIVE_INFINITY },
    distance: { default: () => xe().camera.value.position.z },
    minDistance: { default: Number.EPSILON },
    maxDistance: { default: Number.POSITIVE_INFINITY },
    infinityDolly: { type: Boolean, default: !1 },
    minZoom: { default: 0.01 },
    maxZoom: { default: Number.POSITIVE_INFINITY },
    smoothTime: { default: 0.25 },
    draggingSmoothTime: { default: 0.125 },
    maxSpeed: { default: Number.POSITIVE_INFINITY },
    azimuthRotateSpeed: { default: 1 },
    polarRotateSpeed: { default: 1 },
    dollySpeed: { default: 1 },
    dollyDragInverted: { type: Boolean, default: !1 },
    truckSpeed: { default: 2 },
    dollyToCursor: { type: Boolean, default: !1 },
    dragToOffset: { type: Boolean, default: !1 },
    verticalDragToForward: { type: Boolean, default: !1 },
    boundaryFriction: { default: 0 },
    restThreshold: { default: 0.01 },
    colliderMeshes: { default: () => [] },
    mouseButtons: { default: () => Gr(xe().camera.value) },
    touches: { default: () => Hr(xe().camera.value) }
  },
  emits: ["change", "start", "end"],
  setup(r, { expose: e, emit: t }) {
    const n = r, s = t, {
      makeDefault: i,
      minPolarAngle: o,
      maxPolarAngle: a,
      minAzimuthAngle: l,
      maxAzimuthAngle: c,
      distance: f,
      minDistance: u,
      maxDistance: d,
      infinityDolly: h,
      minZoom: m,
      maxZoom: g,
      smoothTime: v,
      draggingSmoothTime: p,
      maxSpeed: b,
      azimuthRotateSpeed: _,
      polarRotateSpeed: M,
      dollySpeed: R,
      dollyDragInverted: w,
      truckSpeed: E,
      dollyToCursor: x,
      dragToOffset: T,
      verticalDragToForward: y,
      boundaryFriction: A,
      restThreshold: C,
      colliderMeshes: N
    } = Le(n), U = {
      Box3: _t,
      MathUtils: {
        clamp: Ye.clamp
      },
      Matrix4: Ie,
      Quaternion: je,
      Raycaster: ya,
      Sphere: Ms,
      Spherical: si,
      Vector2: ve,
      Vector3: $,
      Vector4: at
    };
    lt.install({ THREE: U });
    const { camera: Y, renderer: V, extend: ne, controls: Z, invalidate: ee } = xe();
    J(n, () => {
      ee();
    });
    const te = Pe(() => Gr(
      n.camera || Y.value,
      n.mouseButtons
    )), fe = Pe(() => Hr(
      n.camera || Y.value,
      n.touches
    )), he = re(null);
    ne({ CameraControls: lt }), et(() => {
      we(), he.value && i.value ? Z.value = he.value : Z.value = null;
    });
    function we() {
      Xe(he.value, "update", () => {
        s("change", he.value), ee();
      }), Xe(he.value, "controlend", () => s("end", he.value)), Xe(he.value, "controlstart", () => s("start", he.value));
    }
    const { onBeforeRender: I } = Ve();
    return I(({ delta: B, invalidate: D }) => {
      var O, z;
      (O = he.value) != null && O.enabled && ((z = he.value) == null || z.update(B), D());
    }), tt(() => {
      he.value && he.value.disconnect();
    }), e({
      instance: he
    }), (B, D) => (B.camera || F(Y)) && (B.domElement || F(V)) ? (ae(), ce("TresCameraControls", {
      key: 0,
      ref_key: "controlsRef",
      ref: he,
      "min-polar-angle": F(o),
      "max-polar-angle": F(a),
      "min-azimuth-angle": F(l),
      "max-azimuth-angle": F(c),
      distance: F(f),
      "min-distance": F(u),
      "max-distance": F(d),
      "infinity-dolly": F(h),
      "min-zoom": F(m),
      "max-zoom": F(g),
      "smooth-time": F(v),
      "dragging-smooth-time": F(p),
      "max-speed": F(b),
      "azimuth-rotate-speed": F(_),
      "polar-rotate-speed": F(M),
      "dolly-speed": F(R),
      "dolly-drag-inverted": F(w),
      "truck-speed": F(E),
      "dolly-to-cursor": F(x),
      "drag-to-offset": F(T),
      "vertical-drag-to-forward": F(y),
      "boundary-friction": F(A),
      "rest-threshold": F(C),
      "collider-meshes": F(N),
      args: [B.camera || F(Y), B.domElement || F(V).domElement],
      "mouse-buttons": te.value,
      touches: fe.value
    }, null, 8, wd)) : an("", !0);
  }
}), ov = /* @__PURE__ */ ue({
  __name: "KeyboardControls",
  props: {
    makeDefault: { type: Boolean, default: !0 },
    camera: {},
    domElement: {},
    moveSpeed: { default: 0.2 },
    selector: {}
  },
  emits: ["isLock", "change"],
  setup(r, { expose: e, emit: t }) {
    const n = r, s = t, { moveSpeed: i } = Le(n), { camera: o, controls: a, renderer: l, invalidate: c } = xe();
    J(n, () => {
      c();
    });
    const f = me(0), u = me(0), { KeyW: d, KeyA: h, KeyS: m, KeyD: g, Up: v, Down: p, Left: b, Right: _ } = eu();
    et(() => {
      h.value || b.value ? f.value = -i.value : g.value || _.value ? f.value = i.value : f.value = 0, d.value || v.value ? u.value = i.value : m.value || p.value ? u.value = -i.value : u.value = 0;
    }), e({
      instance: a
    });
    const M = (A) => s("isLock", A), R = (A) => s("change", A), w = new $(), E = new $(), x = new je(), T = (A, C) => {
      var Y;
      if (!((Y = o.value) != null && Y.position) && !w)
        return;
      const N = o.value, U = A * 1e-3;
      N == null || N.translateZ(-C), x.set(E.x * U, E.y * U, E.z * U, 1).normalize(), N == null || N.quaternion.multiply(x), (f.value || u.value) && s("change", a.value);
    }, { onBeforeRender: y } = Ve();
    return y(({ delta: A, invalidate: C }) => {
      var N;
      a.value instanceof qa && ((N = a.value) != null && N.isLocked) && (T(A, u.value), a.value.moveRight(f.value), C());
    }), (A, C) => (ae(), Oo(F(Md), {
      selector: A.selector,
      "make-default": A.makeDefault,
      camera: A.camera || F(o),
      "dom-element": A.domElement || F(l).domElement,
      onIsLock: M,
      onChange: R
    }, null, 8, ["selector", "make-default", "camera", "dom-element"]));
  }
}), Td = ["args", "auto-rotate", "auto-rotate-speed", "enable-damping", "damping-factor", "enable-pan", "key-pan-speed", "keys", "max-azimuth-angle", "min-azimuth-angle", "max-polar-angle", "min-polar-angle", "min-distance", "max-distance", "min-zoom", "max-zoom", "enable-zoom", "zoom-speed", "enable-rotate", "rotate-speed"], rv = /* @__PURE__ */ ue({
  __name: "MapControls",
  props: {
    makeDefault: { type: Boolean, default: !1 },
    camera: {},
    domElement: {},
    target: {},
    enableDamping: { type: Boolean, default: !0 },
    dampingFactor: { default: 0.05 },
    autoRotate: { type: Boolean, default: !1 },
    autoRotateSpeed: { default: 2 },
    enablePan: { type: Boolean, default: !0 },
    keyPanSpeed: { default: 7 },
    keys: {},
    maxAzimuthAngle: { default: Number.POSITIVE_INFINITY },
    minAzimuthAngle: { default: Number.NEGATIVE_INFINITY },
    maxPolarAngle: { default: Math.PI },
    minPolarAngle: { default: 0 },
    minDistance: { default: 0 },
    maxDistance: { default: Number.POSITIVE_INFINITY },
    minZoom: { default: 0 },
    maxZoom: { default: Number.POSITIVE_INFINITY },
    touches: {},
    enableZoom: { type: Boolean, default: !0 },
    zoomSpeed: { default: 1 },
    enableRotate: { type: Boolean, default: !0 },
    rotateSpeed: { default: 1 }
  },
  emits: ["change", "start", "end"],
  setup(r, { expose: e, emit: t }) {
    const n = r, {
      autoRotate: s,
      autoRotateSpeed: i,
      enableDamping: o,
      dampingFactor: a,
      enablePan: l,
      keyPanSpeed: c,
      maxAzimuthAngle: f,
      minAzimuthAngle: u,
      maxPolarAngle: d,
      minPolarAngle: h,
      minDistance: m,
      maxDistance: g,
      minZoom: v,
      maxZoom: p,
      enableZoom: b,
      zoomSpeed: _,
      enableRotate: M,
      rotateSpeed: R
    } = Le(n), { camera: w, renderer: E, extend: x, controls: T, invalidate: y } = xe();
    J(n, () => {
      y();
    });
    const A = re(null);
    x({ MapControls: yh }), J(T, (N) => {
      N && n.makeDefault ? T.value = N : T.value = null;
    });
    const { onBeforeRender: C } = Ve();
    return C(({ invalidate: N }) => {
      A.value && (o.value || s.value) && (A.value.update(), N());
    }), tt(() => {
      A.value && A.value.dispose();
    }), e({
      instance: A
    }), (N, U) => (N.camera || F(w)) && (N.domElement || F(E)) ? (ae(), ce("TresMapControls", {
      key: 0,
      ref_key: "controlsRef",
      ref: A,
      args: [N.camera || F(w), N.domElement || F(E).domElement],
      "auto-rotate": F(s),
      "auto-rotate-speed": F(i),
      "enable-damping": F(o),
      "damping-factor": F(a),
      "enable-pan": F(l),
      "key-pan-speed": F(c),
      keys: N.keys,
      "max-azimuth-angle": F(f),
      "min-azimuth-angle": F(u),
      "max-polar-angle": F(d),
      "min-polar-angle": F(h),
      "min-distance": F(m),
      "max-distance": F(g),
      "min-zoom": F(v),
      "max-zoom": F(p),
      "enable-zoom": F(b),
      "zoom-speed": F(_),
      "enable-rotate": F(M),
      "rotate-speed": F(R)
    }, null, 8, Td)) : an("", !0);
  }
}), bd = ["target", "auto-rotate", "auto-rotate-speed", "enable-damping", "damping-factor", "enable-pan", "key-pan-speed", "keys", "max-azimuth-angle", "min-azimuth-angle", "max-polar-angle", "min-polar-angle", "min-distance", "max-distance", "min-zoom", "max-zoom", "touches", "enable-zoom", "zoom-speed", "enable-rotate", "rotate-speed", "mouse-buttons", "args"], av = /* @__PURE__ */ ue({
  __name: "OrbitControls",
  props: {
    makeDefault: { type: Boolean, default: !1 },
    camera: {},
    domElement: {},
    target: { default: () => [0, 0, 0] },
    enableDamping: { type: Boolean, default: !0 },
    dampingFactor: { default: 0.05 },
    autoRotate: { type: Boolean, default: !1 },
    autoRotateSpeed: { default: 2 },
    enablePan: { type: Boolean, default: !0 },
    keyPanSpeed: { default: 7 },
    keys: {},
    maxAzimuthAngle: { default: Number.POSITIVE_INFINITY },
    minAzimuthAngle: { default: Number.NEGATIVE_INFINITY },
    maxPolarAngle: { default: Math.PI },
    minPolarAngle: { default: 0 },
    minDistance: { default: 0 },
    maxDistance: { default: Number.POSITIVE_INFINITY },
    minZoom: { default: 0 },
    maxZoom: { default: Number.POSITIVE_INFINITY },
    touches: { default: () => ({ ONE: Vt.ROTATE, TWO: Vt.DOLLY_PAN }) },
    enableZoom: { type: Boolean, default: !0 },
    zoomSpeed: { default: 1 },
    enableRotate: { type: Boolean, default: !0 },
    rotateSpeed: { default: 1 },
    mouseButtons: { default: () => ({ LEFT: Dt.ROTATE, MIDDLE: Dt.DOLLY, RIGHT: Dt.PAN }) }
  },
  emits: ["change", "start", "end"],
  setup(r, { expose: e, emit: t }) {
    const n = r, s = t, {
      makeDefault: i,
      autoRotate: o,
      autoRotateSpeed: a,
      enableDamping: l,
      dampingFactor: c,
      enablePan: f,
      keyPanSpeed: u,
      maxAzimuthAngle: d,
      minAzimuthAngle: h,
      maxPolarAngle: m,
      minPolarAngle: g,
      minDistance: v,
      maxDistance: p,
      minZoom: b,
      maxZoom: _,
      enableZoom: M,
      zoomSpeed: R,
      enableRotate: w,
      touches: E,
      rotateSpeed: x,
      target: T,
      mouseButtons: y
    } = Le(n), { camera: A, renderer: C, extend: N, controls: U, invalidate: Y } = xe(), V = re(null);
    N({ OrbitControls: Qa }), J(V, (ee) => {
      ne(), ee && i.value ? U.value = ee : U.value = null;
    });
    function ne() {
      Xe(V.value, "change", () => {
        s("change", V.value), Y();
      }), Xe(V.value, "start", () => s("start", V.value)), Xe(V.value, "end", () => s("end", V.value));
    }
    const { onBeforeRender: Z } = Ve();
    return Z(({ invalidate: ee }) => {
      V.value && (l.value || o.value) && (V.value.update(), o.value && ee());
    }), tt(() => {
      V.value && V.value.dispose();
    }), e({ instance: V }), (ee, te) => (ee.camera || F(A)) && (ee.domElement || F(C)) ? (ae(), ce("TresOrbitControls", {
      key: 0,
      ref_key: "controlsRef",
      ref: V,
      target: F(T),
      "auto-rotate": F(o),
      "auto-rotate-speed": F(a),
      "enable-damping": F(l),
      "damping-factor": F(c),
      "enable-pan": F(f),
      "key-pan-speed": F(u),
      keys: ee.keys,
      "max-azimuth-angle": F(d),
      "min-azimuth-angle": F(h),
      "max-polar-angle": F(m),
      "min-polar-angle": F(g),
      "min-distance": F(v),
      "max-distance": F(p),
      "min-zoom": F(b),
      "max-zoom": F(_),
      touches: F(E),
      "enable-zoom": F(M),
      "zoom-speed": F(R),
      "enable-rotate": F(w),
      "rotate-speed": F(x),
      "mouse-buttons": F(y),
      args: [ee.camera || F(A), ee.domElement || F(C).domElement]
    }, null, 8, bd)) : an("", !0);
  }
}), Ed = ["args"], Md = /* @__PURE__ */ ue({
  __name: "PointerLockControls",
  props: {
    makeDefault: { type: Boolean, default: !1 },
    camera: {},
    domElement: {},
    selector: {}
  },
  emits: ["isLock", "change"],
  setup(r, { expose: e, emit: t }) {
    const n = r, s = t, { camera: i, renderer: o, extend: a, controls: l, invalidate: c } = xe();
    J(n, () => {
      c();
    });
    const f = re(null);
    let u;
    a({ PointerLockControls: qa });
    const d = (h) => {
      s("isLock", h);
    };
    return J(f, (h) => {
      h && n.makeDefault ? l.value = h : l.value = null, u = document.getElementById(n.selector || "") || o.value.domElement, Xe(u, "click", () => {
        f.value && (f.value.lock(), f.value.addEventListener("lock", () => d(!0)), f.value.addEventListener("unlock", () => d(!1)), c());
      });
    }), tt(() => {
      const h = f.value;
      h && (h.removeEventListener("lock", () => d(!0)), h.removeEventListener("unlock", () => d(!1)), h.dispose());
    }), e({
      instance: l
    }), (h, m) => (h.camera || F(i)) && (h.domElement || F(o)) ? (ae(), ce("TresPointerLockControls", {
      key: 0,
      ref_key: "controlsRef",
      ref: f,
      args: [h.camera || F(i), h.domElement || F(o).domElement]
    }, null, 8, Ed)) : an("", !0);
  }
}), lv = /* @__PURE__ */ ue({
  __name: "ScrollControls",
  props: {
    pages: { default: 4 },
    distance: { default: 4 },
    smoothScroll: { default: 0.1 },
    horizontal: { type: Boolean, default: !1 },
    htmlScroll: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue"],
  setup(r, { expose: e, emit: t }) {
    const n = r, s = t, { logWarning: i } = xt();
    n.smoothScroll < 0 && i("SmoothControl must be greater than zero"), n.pages < 0 && i("Pages must be greater than zero");
    const { camera: o, controls: a, renderer: l, invalidate: c } = xe();
    J(n, () => {
      c();
    });
    const f = re(), u = document.createElement("div"), { y: d } = su(), { x: h, y: m, isScrolling: g } = Qc(u), { height: v, width: p } = Na();
    let b = 0;
    const _ = me(!1), M = me(0), R = me(0), w = me(0), E = n.horizontal ? "x" : "y", x = J(
      o,
      (y) => {
        if (_.value) {
          x();
          return;
        }
        b = n.horizontal ? (y == null ? void 0 : y.position.x) || 0 : (y == null ? void 0 : y.position.y) || 0, _.value = !0;
      },
      {
        immediate: !0
      }
    );
    J(
      g,
      (y) => {
        a.value && (a.value.enabled = !y);
      },
      {
        immediate: !0
      }
    ), J(d, (y) => {
      !g.value && !n.htmlScroll || (R.value = y / v.value / (w.value / v.value - 1), M.value = -1 * R.value, s("update:modelValue", R.value));
    }), J(m, (y) => {
      R.value = y / v.value / (w.value / v.value), M.value = -1 * R.value, s("update:modelValue", R.value);
    }), J(h, (y) => {
      R.value = y / p.value / (w.value / p.value - 1), M.value = +R.value, s("update:modelValue", R.value);
    }), J(
      l,
      (y) => {
        var C, N;
        const A = y == null ? void 0 : y.domElement;
        if (n.htmlScroll && (y != null && y.domElement))
          A != null && A.style.width && (A != null && A.style.position) && (A != null && A.style.top) && (A != null && A.style.left) && (A.style.width = "100%", A.style.position = "fixed", A.style.zIndex = " -99999", A.style.top = "0", A.style.left = "0"), w.value = document.body.scrollHeight;
        else {
          const U = document.createElement("div"), Y = document.createElement("div");
          u.style[n.horizontal ? "overflowX" : "overflowY"] = "auto", u.style[n.horizontal ? "overflowY" : "overflowX"] = "hidden", u.style.position = "absolute", u.style.width = "100%", u.style.height = " 100%", u.style.top = "0", u.style.left = "0", u.classList.add("scrollContainer"), U.style.position = "sticky", U.style.top = "0px", U.style.left = "0px", U.style.width = "100%", U.style.height = "100%", U.style.overflow = "hidden", u.appendChild(U), Y.style.height = n.horizontal ? "100%" : `${v.value * n.pages}px`, Y.style.width = n.horizontal ? `${p.value * n.pages}px` : "100vw", Y.style.pointerEvents = "none", A.style.position = "fixed", A.style.zIndex = "0", A != null && A.style.width && (A.style.width = "100%"), u.appendChild(Y), y != null && y.domElement.parentNode && (y.domElement.parentNode.style.position = "relative"), (N = (C = y == null ? void 0 : y.domElement) == null ? void 0 : C.parentNode) == null || N.appendChild(u), w.value = n.horizontal ? p.value * n.pages : v.value * n.pages;
        }
      },
      {
        immediate: !0
      }
    );
    const { onBeforeRender: T } = Ve();
    return T(({ invalidate: y }) => {
      var A;
      if ((A = o.value) != null && A.position) {
        const C = (M.value * n.distance - o.value.position[E] + b) * n.smoothScroll;
        o.value.position[E] += C, f.value.children.length > 0 && (f.value.position[E] += C), y();
      }
    }), e({
      instance: f
    }), (y, A) => (ae(), ce("TresGroup", {
      ref_key: "wrapperRef",
      ref: f
    }, [
      Ne(y.$slots, "default")
    ], 512));
  }
}), Sd = ["object", "args", "mode", "enabled", "axis", "translation-snap", "rotation-snap", "scale-snap", "space", "size", "show-x", "show-y", "show-z"], cv = /* @__PURE__ */ ue({
  __name: "TransformControls",
  props: {
    object: {},
    camera: {},
    mode: { default: "translate" },
    enabled: { type: Boolean, default: !0 },
    axis: { default: "XYZ" },
    translationSnap: {},
    rotationSnap: {},
    scaleSnap: {},
    space: { default: "world" },
    size: { default: 1 },
    showX: { type: Boolean, default: !0 },
    showY: { type: Boolean, default: !0 },
    showZ: { type: Boolean, default: !0 }
  },
  emits: ["dragging", "change", "mouseDown", "mouseUp", "objectChange"],
  setup(r, { expose: e, emit: t }) {
    const n = r, s = t, { object: i, mode: o, enabled: a, axis: l, translationSnap: c, rotationSnap: f, scaleSnap: u, space: d, size: h, showX: m, showY: g, showZ: v } = Le(n), p = re(null), { controls: b, camera: _, renderer: M, extend: R, invalidate: w } = xe();
    J([i, o, a, l, c, f, u, d, h, m, g, v], () => {
      w();
    }), R({ TransformControls: ah });
    const E = () => {
      w(), s("change");
    }, x = (N) => {
      b.value && (b.value.enabled = !N.value), w(), s("dragging", N.value);
    }, T = () => {
      w(), s("mouseDown");
    }, y = () => {
      w(), s("mouseDown");
    }, A = () => {
      w(), s("objectChange");
    };
    function C() {
      Xe(p.value, "change", E), Xe(p.value, "dragging-changed", x), Xe(p.value, "mouseDown", T), Xe(p.value, "mouseUp", y), Xe(p.value, "objectChange", A);
    }
    return J(p, (N) => {
      N && C();
    }), tt(() => {
      p.value && p.value.dispose();
    }), e({
      instance: p
    }), (N, U) => {
      var Y;
      return (N.camera || F(_)) && F(M) ? (ae(), ce("TresTransformControls", {
        ref_key: "controlsRef",
        ref: p,
        key: (Y = N.camera || F(_)) == null ? void 0 : Y.uuid,
        object: F(i),
        args: [N.camera || F(_), F(M).domElement],
        mode: F(o),
        enabled: F(a),
        axis: F(l),
        "translation-snap": F(c),
        "rotation-snap": F(f),
        "scale-snap": F(u),
        space: F(d),
        size: F(h),
        "show-x": F(m),
        "show-y": F(g),
        "show-z": F(v),
        visible: !0
      }, null, 8, Sd)) : an("", !0);
    };
  }
}), Ad = ["geometry", "render-order"], uv = /* @__PURE__ */ ue({
  __name: "component",
  props: {
    src: {},
    skipStrokes: { type: Boolean, default: !1 },
    skipFills: { type: Boolean, default: !1 },
    fillMaterial: {},
    strokeMaterial: {},
    fillMeshProps: {},
    strokeMeshProps: {},
    depth: { default: "renderOrder" }
  },
  setup(r, { expose: e }) {
    const t = r;
    class n extends _s {
      load(_, M, R, w) {
        const E = Array.isArray(_) ? _[0] : _;
        super.load(E, M, R, w);
      }
    }
    const { src: s, skipStrokes: i, skipFills: o, fillMaterial: a, strokeMaterial: l, fillMeshProps: c, strokeMeshProps: f, depth: u } = Le(t), d = re(), h = re([]), m = re([]);
    e({ instance: d }), et(async () => g(s.value).then((b) => m.value = b.paths)), J([o, i, a, l, m], p);
    async function g(b) {
      const _ = b.startsWith("<svg") ? encodeURI(`data:image/svg+xml;utf8,${b}`) : b;
      return Nn(n, _);
    }
    tt(v);
    function v() {
      h.value.forEach((b) => b.geometry.dispose());
    }
    function p() {
      var w, E, x;
      v();
      const b = [], [_, M] = (() => {
        const T = { flat: !1, renderOrder: !1, offsetZ: !0 }, y = { flat: 0, renderOrder: 0, offsetZ: 0.025 }, A = u.value;
        return typeof A == "number" ? [!0, A] : [T[A], y[A]];
      })();
      let R = 0;
      for (const T of m.value) {
        const y = ((w = T.userData) == null ? void 0 : w.style) ?? {}, A = Object.assign({
          color: y.fill,
          opacity: y.fillOpacity,
          transparent: !0,
          side: on,
          depthWrite: _
        }, t.fillMaterial);
        if (!o.value && y.fill !== void 0 && y.fill !== "none")
          for (const C of _s.createShapes(T)) {
            const N = new nc(C);
            N.scale(1, -1, 1), M && N.translate(0, 0, R++ * M), b.push({
              geometry: N,
              material: A,
              isStroke: !1
            });
          }
        if (!i.value && y.stroke !== void 0 && y.stroke !== "none") {
          const C = Object.assign({
            color: (E = T.userData) == null ? void 0 : E.style.stroke,
            opacity: (x = T.userData) == null ? void 0 : x.style.strokeOpacity,
            transparent: !0,
            side: on,
            depthWrite: _
          }, t.strokeMaterial);
          for (const N of T.subPaths) {
            const U = N.getPoints().map((V) => new ve(V.x, -V.y)), Y = _s.pointsToStroke(U, y || "none");
            M && Y.translate(0, 0, R++ * M), b.push({
              geometry: Y,
              material: C,
              isStroke: !0
            });
          }
        }
      }
      h.value = b;
    }
    return (b, _) => (ae(), ce("TresGroup", {
      ref_key: "svgRef",
      ref: d
    }, [
      (ae(!0), ce(Ra, null, Ca(h.value, ({ geometry: M, material: R, isStroke: w }, E) => (ae(), ce("TresMesh", $e({
        key: `${E}`,
        ref_for: !0
      }, w ? F(f) : F(c), {
        geometry: M,
        "render-order": F(u) === "renderOrder" ? E : 0
      }), [
        ye("TresMeshBasicMaterial", $e({ ref_for: !0 }, R), null, 16)
      ], 16, Ad))), 128))
    ], 512));
  }
});
class Pd extends Un {
  constructor(t) {
    super(t);
    pe(this, "fbxLoader");
    this.fbxLoader = new ff(t);
  }
  /**
   * Load an FBX model from a URL or array of URLs.
   * If an array is provided, only the first URL will be used.
   *
   * @param {(string | string[])} url - URL or array of URLs to load
   * @param {(result: Group) => void} onLoad - Callback when the model is loaded
   * @param {(event: ProgressEvent<EventTarget>) => void} [onProgress] - Loading progress callback
   * @param {(event: ErrorEvent) => void} [onError] - Error callback
   */
  load(t, n, s, i) {
    const o = Array.isArray(t) ? t[0] : t;
    this.fbxLoader.load(o, n, s, i);
  }
  /**
   * Asynchronously load an FBX model.
   *
   * @param {string | string[]} url - URL or array of URLs to load
   * @returns {Promise<Group>} Promise that resolves with the loaded model
   */
  async loadAsync(t) {
    const n = Array.isArray(t) ? t[0] : t;
    return this.fbxLoader.loadAsync(n);
  }
}
const Rd = Pd;
async function Cd(r) {
  return await Nn(Rd, r);
}
const Id = ["object"], hv = /* @__PURE__ */ ue({
  __name: "component",
  props: {
    path: {},
    castShadow: { type: Boolean, default: !1 },
    receiveShadow: { type: Boolean, default: !1 }
  },
  async setup(r, { expose: e }) {
    let t, n;
    const s = r, i = me();
    e({
      instance: i
    });
    const o = ([t, n] = Tn(() => Cd(s.path)), t = await t, n(), t);
    return (s.castShadow || s.receiveShadow) && o.traverse((a) => {
      a.isMesh && (a.castShadow = s.castShadow, a.receiveShadow = s.receiveShadow);
    }), (a, l) => (ae(), ce("primitive", $e({
      ref_key: "modelRef",
      ref: i,
      object: F(o)
    }, a.$attrs), null, 16, Id));
  }
});
class Od extends Un {
  constructor(t) {
    super(t);
    pe(this, "gltfLoader");
    this.gltfLoader = new xh(t);
  }
  /**
   * Load a GLTF model from a URL or array of URLs.
   * If an array is provided, only the first URL will be used.
   *
   * @param {(string | string[])} url - URL or array of URLs to load
   * @param {(result: GLTF) => void} onLoad - Callback when the model is loaded
   * @param {(event: ProgressEvent<EventTarget>) => void} [onProgress] - Loading progress callback
   * @param {(event: ErrorEvent) => void} [onError] - Error callback
   */
  load(t, n, s, i) {
    const o = Array.isArray(t) ? t[0] : t;
    this.gltfLoader.load(o, n, s, i);
  }
  /**
   * Asynchronously load a GLTF model.
   *
   * @param {string | string[]} url - URL or array of URLs to load
   * @returns {Promise<GLTF>} Promise that resolves with the loaded model
   */
  async loadAsync(t) {
    const n = Array.isArray(t) ? t[0] : t;
    return this.gltfLoader.loadAsync(n);
  }
  /**
   * Set the DRACO loader for compressed models.
   *
   * @param {DRACOLoader} dracoLoader - The DRACO loader instance
   * @returns {GLTFLoader} The loader instance for chaining
   */
  setDRACOLoader(t) {
    return this.gltfLoader.setDRACOLoader(t);
  }
}
const Dd = Od;
let yn = null;
function Ld(r, e) {
  return (t) => {
    e && e(t), r.draco && (yn || (yn = new Cf()), yn.setDecoderPath(r.decoderPath || "https://www.gstatic.com/draco/versioned/decoders/1.4.3/"), t.setDRACOLoader && t.setDRACOLoader(yn));
  };
}
async function kd(r, e = {
  draco: !1
}, t) {
  const n = await Nn(Dd, r, Ld(e, t));
  return yn == null || yn.dispose(), yn = null, n;
}
const Nd = ["object"], fv = /* @__PURE__ */ ue({
  __name: "component",
  props: {
    path: {},
    draco: { type: Boolean, default: !1 },
    decoderPath: { default: "https://www.gstatic.com/draco/versioned/decoders/1.4.1/" },
    castShadow: { type: Boolean, default: !1 },
    receiveShadow: { type: Boolean, default: !1 }
  },
  async setup(r, { expose: e }) {
    let t, n;
    const s = r, i = me();
    e({
      instance: i
    });
    const { scene: o } = ([t, n] = Tn(() => kd(s.path, {
      draco: s.draco,
      decoderPath: s.decoderPath
    })), t = await t, n(), t);
    return (s.castShadow || s.receiveShadow) && o.traverse((a) => {
      a.isMesh && (a.castShadow = s.castShadow, a.receiveShadow = s.receiveShadow);
    }), (a, l) => (ae(), ce("primitive", $e({
      ref_key: "modelRef",
      ref: i,
      object: F(o)
    }, a.$attrs), null, 16, Nd));
  }
}), ml = "[TresJS - Cientos ▲ ■ ♥] ";
function Bd(r, e) {
  console.error(`${ml} ${r}`, e || "");
}
function Ud(r) {
  console.warn(`${ml} ${r}`);
}
function Fd(r, e) {
}
function gl() {
  return {
    logError: Bd,
    logWarning: Ud,
    logMessage: Fd
  };
}
let Wi = 0;
function dv() {
  const r = me(!1), e = me(0), t = me([]), { logError: n } = gl();
  return new Promise((s) => {
    ks.onStart = () => {
      r.value = !1;
    }, ks.onLoad = () => {
      r.value = !0;
    }, ks.onProgress = (i, o, a) => {
      o === a && (Wi = a, r.value = !0, t.value.push(i)), e.value = Math.round((o - Wi) / (a - Wi) * 100 || 100);
    }, ks.onError = (i) => {
      n("Error loading assets", new Error(i)), r.value = !0;
    }, s({
      items: t,
      hasFinishLoading: r,
      progress: e
    });
  });
}
async function pv(r, e) {
  const { logError: t } = gl();
  if (!r)
    return t("Error no path provided");
  const { unsuspend: n, start: s, crossOrigin: i, muted: o, loop: a, ...l } = {
    unsuspend: "loadedmetadata",
    crossOrigin: "Anonymous",
    muted: !0,
    loop: !0,
    start: !0,
    playsInline: !0,
    ...e
  };
  function c() {
    return new Promise((f, u) => {
      const d = Object.assign(document.createElement("video"), {
        src: typeof r == "string" && r || void 0,
        crossOrigin: i,
        loop: a,
        muted: o,
        autoplay: !0,
        ...l
      }), h = new sc(d);
      return d.addEventListener(n, () => f(h)), d.addEventListener("error", () => u(new Error("Error loading video"))), h;
    });
  }
  try {
    const f = await c();
    return s && f.image && f.image.play(), f;
  } catch {
    t("Error loading resource");
  }
}
function Ps(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
function Ks(r) {
  throw new Error('Could not dynamically require "' + r + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var Xi = { exports: {} }, jr;
function zd() {
  return jr || (jr = 1, function(r, e) {
    (function(t) {
      r.exports = t();
    })(function() {
      return function t(n, s, i) {
        function o(c, f) {
          if (!s[c]) {
            if (!n[c]) {
              var u = typeof Ks == "function" && Ks;
              if (!f && u) return u(c, !0);
              if (a) return a(c, !0);
              throw new Error("Cannot find module '" + c + "'");
            }
            f = s[c] = { exports: {} }, n[c][0].call(f.exports, function(d) {
              var h = n[c][1][d];
              return o(h || d);
            }, f, f.exports, t, n, s, i);
          }
          return s[c].exports;
        }
        for (var a = typeof Ks == "function" && Ks, l = 0; l < i.length; l++) o(i[l]);
        return o;
      }({ 1: [function(t, n, s) {
        (function(i, o, a, l, c, f, u, d, h) {
          var m = t("crypto");
          function g(w, E) {
            E = b(w, E);
            var x;
            return (x = E.algorithm !== "passthrough" ? m.createHash(E.algorithm) : new R()).write === void 0 && (x.write = x.update, x.end = x.update), M(E, x).dispatch(w), x.update || x.end(""), x.digest ? x.digest(E.encoding === "buffer" ? void 0 : E.encoding) : (w = x.read(), E.encoding !== "buffer" ? w.toString(E.encoding) : w);
          }
          (s = n.exports = g).sha1 = function(w) {
            return g(w);
          }, s.keys = function(w) {
            return g(w, { excludeValues: !0, algorithm: "sha1", encoding: "hex" });
          }, s.MD5 = function(w) {
            return g(w, { algorithm: "md5", encoding: "hex" });
          }, s.keysMD5 = function(w) {
            return g(w, { algorithm: "md5", encoding: "hex", excludeValues: !0 });
          };
          var v = m.getHashes ? m.getHashes().slice() : ["sha1", "md5"], p = (v.push("passthrough"), ["buffer", "hex", "binary", "base64"]);
          function b(w, E) {
            var x = {};
            if (x.algorithm = (E = E || {}).algorithm || "sha1", x.encoding = E.encoding || "hex", x.excludeValues = !!E.excludeValues, x.algorithm = x.algorithm.toLowerCase(), x.encoding = x.encoding.toLowerCase(), x.ignoreUnknown = E.ignoreUnknown === !0, x.respectType = E.respectType !== !1, x.respectFunctionNames = E.respectFunctionNames !== !1, x.respectFunctionProperties = E.respectFunctionProperties !== !1, x.unorderedArrays = E.unorderedArrays === !0, x.unorderedSets = E.unorderedSets !== !1, x.unorderedObjects = E.unorderedObjects !== !1, x.replacer = E.replacer || void 0, x.excludeKeys = E.excludeKeys || void 0, w === void 0) throw new Error("Object argument required.");
            for (var T = 0; T < v.length; ++T) v[T].toLowerCase() === x.algorithm.toLowerCase() && (x.algorithm = v[T]);
            if (v.indexOf(x.algorithm) === -1) throw new Error('Algorithm "' + x.algorithm + '"  not supported. supported values: ' + v.join(", "));
            if (p.indexOf(x.encoding) === -1 && x.algorithm !== "passthrough") throw new Error('Encoding "' + x.encoding + '"  not supported. supported values: ' + p.join(", "));
            return x;
          }
          function _(w) {
            if (typeof w == "function") return /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(w)) != null;
          }
          function M(w, E, x) {
            x = x || [];
            function T(y) {
              return E.update ? E.update(y, "utf8") : E.write(y, "utf8");
            }
            return { dispatch: function(y) {
              return this["_" + ((y = w.replacer ? w.replacer(y) : y) === null ? "null" : typeof y)](y);
            }, _object: function(y) {
              var A, C = Object.prototype.toString.call(y), N = /\[object (.*)\]/i.exec(C);
              if (N = (N = N ? N[1] : "unknown:[" + C + "]").toLowerCase(), 0 <= (C = x.indexOf(y))) return this.dispatch("[CIRCULAR:" + C + "]");
              if (x.push(y), a !== void 0 && a.isBuffer && a.isBuffer(y)) return T("buffer:"), T(y);
              if (N === "object" || N === "function" || N === "asyncfunction") return C = Object.keys(y), w.unorderedObjects && (C = C.sort()), w.respectType === !1 || _(y) || C.splice(0, 0, "prototype", "__proto__", "constructor"), w.excludeKeys && (C = C.filter(function(U) {
                return !w.excludeKeys(U);
              })), T("object:" + C.length + ":"), A = this, C.forEach(function(U) {
                A.dispatch(U), T(":"), w.excludeValues || A.dispatch(y[U]), T(",");
              });
              if (!this["_" + N]) {
                if (w.ignoreUnknown) return T("[" + N + "]");
                throw new Error('Unknown object type "' + N + '"');
              }
              this["_" + N](y);
            }, _array: function(y, U) {
              U = U !== void 0 ? U : w.unorderedArrays !== !1;
              var C = this;
              if (T("array:" + y.length + ":"), !U || y.length <= 1) return y.forEach(function(Y) {
                return C.dispatch(Y);
              });
              var N = [], U = y.map(function(Y) {
                var V = new R(), ne = x.slice();
                return M(w, V, ne).dispatch(Y), N = N.concat(ne.slice(x.length)), V.read().toString();
              });
              return x = x.concat(N), U.sort(), this._array(U, !1);
            }, _date: function(y) {
              return T("date:" + y.toJSON());
            }, _symbol: function(y) {
              return T("symbol:" + y.toString());
            }, _error: function(y) {
              return T("error:" + y.toString());
            }, _boolean: function(y) {
              return T("bool:" + y.toString());
            }, _string: function(y) {
              T("string:" + y.length + ":"), T(y.toString());
            }, _function: function(y) {
              T("fn:"), _(y) ? this.dispatch("[native]") : this.dispatch(y.toString()), w.respectFunctionNames !== !1 && this.dispatch("function-name:" + String(y.name)), w.respectFunctionProperties && this._object(y);
            }, _number: function(y) {
              return T("number:" + y.toString());
            }, _xml: function(y) {
              return T("xml:" + y.toString());
            }, _null: function() {
              return T("Null");
            }, _undefined: function() {
              return T("Undefined");
            }, _regexp: function(y) {
              return T("regex:" + y.toString());
            }, _uint8array: function(y) {
              return T("uint8array:"), this.dispatch(Array.prototype.slice.call(y));
            }, _uint8clampedarray: function(y) {
              return T("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(y));
            }, _int8array: function(y) {
              return T("int8array:"), this.dispatch(Array.prototype.slice.call(y));
            }, _uint16array: function(y) {
              return T("uint16array:"), this.dispatch(Array.prototype.slice.call(y));
            }, _int16array: function(y) {
              return T("int16array:"), this.dispatch(Array.prototype.slice.call(y));
            }, _uint32array: function(y) {
              return T("uint32array:"), this.dispatch(Array.prototype.slice.call(y));
            }, _int32array: function(y) {
              return T("int32array:"), this.dispatch(Array.prototype.slice.call(y));
            }, _float32array: function(y) {
              return T("float32array:"), this.dispatch(Array.prototype.slice.call(y));
            }, _float64array: function(y) {
              return T("float64array:"), this.dispatch(Array.prototype.slice.call(y));
            }, _arraybuffer: function(y) {
              return T("arraybuffer:"), this.dispatch(new Uint8Array(y));
            }, _url: function(y) {
              return T("url:" + y.toString());
            }, _map: function(y) {
              return T("map:"), y = Array.from(y), this._array(y, w.unorderedSets !== !1);
            }, _set: function(y) {
              return T("set:"), y = Array.from(y), this._array(y, w.unorderedSets !== !1);
            }, _file: function(y) {
              return T("file:"), this.dispatch([y.name, y.size, y.type, y.lastModfied]);
            }, _blob: function() {
              if (w.ignoreUnknown) return T("[blob]");
              throw Error(`Hashing Blob objects is currently not supported
(see https://github.com/puleos/object-hash/issues/26)
Use "options.replacer" or "options.ignoreUnknown"
`);
            }, _domwindow: function() {
              return T("domwindow");
            }, _bigint: function(y) {
              return T("bigint:" + y.toString());
            }, _process: function() {
              return T("process");
            }, _timer: function() {
              return T("timer");
            }, _pipe: function() {
              return T("pipe");
            }, _tcp: function() {
              return T("tcp");
            }, _udp: function() {
              return T("udp");
            }, _tty: function() {
              return T("tty");
            }, _statwatcher: function() {
              return T("statwatcher");
            }, _securecontext: function() {
              return T("securecontext");
            }, _connection: function() {
              return T("connection");
            }, _zlib: function() {
              return T("zlib");
            }, _context: function() {
              return T("context");
            }, _nodescript: function() {
              return T("nodescript");
            }, _httpparser: function() {
              return T("httpparser");
            }, _dataview: function() {
              return T("dataview");
            }, _signal: function() {
              return T("signal");
            }, _fsevent: function() {
              return T("fsevent");
            }, _tlswrap: function() {
              return T("tlswrap");
            } };
          }
          function R() {
            return { buf: "", write: function(w) {
              this.buf += w;
            }, end: function(w) {
              this.buf += w;
            }, read: function() {
              return this.buf;
            } };
          }
          s.writeToStream = function(w, E, x) {
            return x === void 0 && (x = E, E = {}), M(E = b(w, E), x).dispatch(w);
          };
        }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/fake_9a5aa49d.js", "/");
      }, { buffer: 3, crypto: 5, lYpoI2: 11 }], 2: [function(t, n, s) {
        (function(i, o, a, l, c, f, u, d, h) {
          (function(m) {
            var g = typeof Uint8Array < "u" ? Uint8Array : Array, v = 43, p = 47, b = 48, _ = 97, M = 65, R = 45, w = 95;
            function E(x) {
              return x = x.charCodeAt(0), x === v || x === R ? 62 : x === p || x === w ? 63 : x < b ? -1 : x < b + 10 ? x - b + 26 + 26 : x < M + 26 ? x - M : x < _ + 26 ? x - _ + 26 : void 0;
            }
            m.toByteArray = function(x) {
              var T, y;
              if (0 < x.length % 4) throw new Error("Invalid string. Length must be a multiple of 4");
              var A = x.length, A = x.charAt(A - 2) === "=" ? 2 : x.charAt(A - 1) === "=" ? 1 : 0, C = new g(3 * x.length / 4 - A), N = 0 < A ? x.length - 4 : x.length, U = 0;
              function Y(V) {
                C[U++] = V;
              }
              for (T = 0; T < N; T += 4, 0) Y((16711680 & (y = E(x.charAt(T)) << 18 | E(x.charAt(T + 1)) << 12 | E(x.charAt(T + 2)) << 6 | E(x.charAt(T + 3)))) >> 16), Y((65280 & y) >> 8), Y(255 & y);
              return A == 2 ? Y(255 & (y = E(x.charAt(T)) << 2 | E(x.charAt(T + 1)) >> 4)) : A == 1 && (Y((y = E(x.charAt(T)) << 10 | E(x.charAt(T + 1)) << 4 | E(x.charAt(T + 2)) >> 2) >> 8 & 255), Y(255 & y)), C;
            }, m.fromByteArray = function(x) {
              var T, y, A, C, N = x.length % 3, U = "";
              function Y(V) {
                return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(V);
              }
              for (T = 0, A = x.length - N; T < A; T += 3) y = (x[T] << 16) + (x[T + 1] << 8) + x[T + 2], U += Y((C = y) >> 18 & 63) + Y(C >> 12 & 63) + Y(C >> 6 & 63) + Y(63 & C);
              switch (N) {
                case 1:
                  U = (U += Y((y = x[x.length - 1]) >> 2)) + Y(y << 4 & 63) + "==";
                  break;
                case 2:
                  U = (U = (U += Y((y = (x[x.length - 2] << 8) + x[x.length - 1]) >> 10)) + Y(y >> 4 & 63)) + Y(y << 2 & 63) + "=";
              }
              return U;
            };
          })(s === void 0 ? this.base64js = {} : s);
        }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js", "/node_modules/gulp-browserify/node_modules/base64-js/lib");
      }, { buffer: 3, lYpoI2: 11 }], 3: [function(t, n, s) {
        (function(i, o, v, l, c, f, u, d, h) {
          var m = t("base64-js"), g = t("ieee754");
          function v(S, P, L) {
            if (!(this instanceof v)) return new v(S, P, L);
            var X, H, j, K, se = typeof S;
            if (P === "base64" && se == "string") for (S = (K = S).trim ? K.trim() : K.replace(/^\s+|\s+$/g, ""); S.length % 4 != 0; ) S += "=";
            if (se == "number") X = Z(S);
            else if (se == "string") X = v.byteLength(S, P);
            else {
              if (se != "object") throw new Error("First argument needs to be a number, array or string.");
              X = Z(S.length);
            }
            if (v._useTypedArrays ? H = v._augment(new Uint8Array(X)) : ((H = this).length = X, H._isBuffer = !0), v._useTypedArrays && typeof S.byteLength == "number") H._set(S);
            else if (ee(K = S) || v.isBuffer(K) || K && typeof K == "object" && typeof K.length == "number") for (j = 0; j < X; j++) v.isBuffer(S) ? H[j] = S.readUInt8(j) : H[j] = S[j];
            else if (se == "string") H.write(S, 0, P);
            else if (se == "number" && !v._useTypedArrays && !L) for (j = 0; j < X; j++) H[j] = 0;
            return H;
          }
          function p(S, P, L, X) {
            return v._charsWritten = we(function(H) {
              for (var j = [], K = 0; K < H.length; K++) j.push(255 & H.charCodeAt(K));
              return j;
            }(P), S, L, X);
          }
          function b(S, P, L, X) {
            return v._charsWritten = we(function(H) {
              for (var j, K, se = [], ie = 0; ie < H.length; ie++) K = H.charCodeAt(ie), j = K >> 8, K = K % 256, se.push(K), se.push(j);
              return se;
            }(P), S, L, X);
          }
          function _(S, P, L) {
            var X = "";
            L = Math.min(S.length, L);
            for (var H = P; H < L; H++) X += String.fromCharCode(S[H]);
            return X;
          }
          function M(S, P, L, j) {
            j || (z(typeof L == "boolean", "missing or invalid endian"), z(P != null, "missing offset"), z(P + 1 < S.length, "Trying to read beyond buffer length"));
            var H, j = S.length;
            if (!(j <= P)) return L ? (H = S[P], P + 1 < j && (H |= S[P + 1] << 8)) : (H = S[P] << 8, P + 1 < j && (H |= S[P + 1])), H;
          }
          function R(S, P, L, j) {
            j || (z(typeof L == "boolean", "missing or invalid endian"), z(P != null, "missing offset"), z(P + 3 < S.length, "Trying to read beyond buffer length"));
            var H, j = S.length;
            if (!(j <= P)) return L ? (P + 2 < j && (H = S[P + 2] << 16), P + 1 < j && (H |= S[P + 1] << 8), H |= S[P], P + 3 < j && (H += S[P + 3] << 24 >>> 0)) : (P + 1 < j && (H = S[P + 1] << 16), P + 2 < j && (H |= S[P + 2] << 8), P + 3 < j && (H |= S[P + 3]), H += S[P] << 24 >>> 0), H;
          }
          function w(S, P, L, X) {
            if (X || (z(typeof L == "boolean", "missing or invalid endian"), z(P != null, "missing offset"), z(P + 1 < S.length, "Trying to read beyond buffer length")), !(S.length <= P)) return X = M(S, P, L, !0), 32768 & X ? -1 * (65535 - X + 1) : X;
          }
          function E(S, P, L, X) {
            if (X || (z(typeof L == "boolean", "missing or invalid endian"), z(P != null, "missing offset"), z(P + 3 < S.length, "Trying to read beyond buffer length")), !(S.length <= P)) return X = R(S, P, L, !0), 2147483648 & X ? -1 * (4294967295 - X + 1) : X;
          }
          function x(S, P, L, X) {
            return X || (z(typeof L == "boolean", "missing or invalid endian"), z(P + 3 < S.length, "Trying to read beyond buffer length")), g.read(S, P, L, 23, 4);
          }
          function T(S, P, L, X) {
            return X || (z(typeof L == "boolean", "missing or invalid endian"), z(P + 7 < S.length, "Trying to read beyond buffer length")), g.read(S, P, L, 52, 8);
          }
          function y(S, P, L, X, H) {
            if (H || (z(P != null, "missing value"), z(typeof X == "boolean", "missing or invalid endian"), z(L != null, "missing offset"), z(L + 1 < S.length, "trying to write beyond buffer length"), B(P, 65535)), H = S.length, !(H <= L)) for (var j = 0, K = Math.min(H - L, 2); j < K; j++) S[L + j] = (P & 255 << 8 * (X ? j : 1 - j)) >>> 8 * (X ? j : 1 - j);
          }
          function A(S, P, L, X, H) {
            if (H || (z(P != null, "missing value"), z(typeof X == "boolean", "missing or invalid endian"), z(L != null, "missing offset"), z(L + 3 < S.length, "trying to write beyond buffer length"), B(P, 4294967295)), H = S.length, !(H <= L)) for (var j = 0, K = Math.min(H - L, 4); j < K; j++) S[L + j] = P >>> 8 * (X ? j : 3 - j) & 255;
          }
          function C(S, P, L, X, H) {
            H || (z(P != null, "missing value"), z(typeof X == "boolean", "missing or invalid endian"), z(L != null, "missing offset"), z(L + 1 < S.length, "Trying to write beyond buffer length"), D(P, 32767, -32768)), S.length <= L || y(S, 0 <= P ? P : 65535 + P + 1, L, X, H);
          }
          function N(S, P, L, X, H) {
            H || (z(P != null, "missing value"), z(typeof X == "boolean", "missing or invalid endian"), z(L != null, "missing offset"), z(L + 3 < S.length, "Trying to write beyond buffer length"), D(P, 2147483647, -2147483648)), S.length <= L || A(S, 0 <= P ? P : 4294967295 + P + 1, L, X, H);
          }
          function U(S, P, L, X, H) {
            H || (z(P != null, "missing value"), z(typeof X == "boolean", "missing or invalid endian"), z(L != null, "missing offset"), z(L + 3 < S.length, "Trying to write beyond buffer length"), O(P, 34028234663852886e22, -34028234663852886e22)), S.length <= L || g.write(S, P, L, X, 23, 4);
          }
          function Y(S, P, L, X, H) {
            H || (z(P != null, "missing value"), z(typeof X == "boolean", "missing or invalid endian"), z(L != null, "missing offset"), z(L + 7 < S.length, "Trying to write beyond buffer length"), O(P, 17976931348623157e292, -17976931348623157e292)), S.length <= L || g.write(S, P, L, X, 52, 8);
          }
          s.Buffer = v, s.SlowBuffer = v, s.INSPECT_MAX_BYTES = 50, v.poolSize = 8192, v._useTypedArrays = function() {
            try {
              var S = new ArrayBuffer(0), P = new Uint8Array(S);
              return P.foo = function() {
                return 42;
              }, P.foo() === 42 && typeof P.subarray == "function";
            } catch {
              return !1;
            }
          }(), v.isEncoding = function(S) {
            switch (String(S).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "binary":
              case "base64":
              case "raw":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return !0;
              default:
                return !1;
            }
          }, v.isBuffer = function(S) {
            return !(S == null || !S._isBuffer);
          }, v.byteLength = function(S, P) {
            var L;
            switch (S += "", P || "utf8") {
              case "hex":
                L = S.length / 2;
                break;
              case "utf8":
              case "utf-8":
                L = fe(S).length;
                break;
              case "ascii":
              case "binary":
              case "raw":
                L = S.length;
                break;
              case "base64":
                L = he(S).length;
                break;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                L = 2 * S.length;
                break;
              default:
                throw new Error("Unknown encoding");
            }
            return L;
          }, v.concat = function(S, P) {
            if (z(ee(S), `Usage: Buffer.concat(list, [totalLength])
list should be an Array.`), S.length === 0) return new v(0);
            if (S.length === 1) return S[0];
            if (typeof P != "number") for (H = P = 0; H < S.length; H++) P += S[H].length;
            for (var L = new v(P), X = 0, H = 0; H < S.length; H++) {
              var j = S[H];
              j.copy(L, X), X += j.length;
            }
            return L;
          }, v.prototype.write = function(S, P, L, X) {
            isFinite(P) ? isFinite(L) || (X = L, L = void 0) : (ie = X, X = P, P = L, L = ie), P = Number(P) || 0;
            var H, j, K, se, ie = this.length - P;
            switch ((!L || ie < (L = Number(L))) && (L = ie), X = String(X || "utf8").toLowerCase()) {
              case "hex":
                H = function(G, k, oe, ge) {
                  oe = Number(oe) || 0;
                  var Re = G.length - oe;
                  (!ge || Re < (ge = Number(ge))) && (ge = Re), z((Re = k.length) % 2 == 0, "Invalid hex string"), Re / 2 < ge && (ge = Re / 2);
                  for (var Ke = 0; Ke < ge; Ke++) {
                    var He = parseInt(k.substr(2 * Ke, 2), 16);
                    z(!isNaN(He), "Invalid hex string"), G[oe + Ke] = He;
                  }
                  return v._charsWritten = 2 * Ke, Ke;
                }(this, S, P, L);
                break;
              case "utf8":
              case "utf-8":
                j = this, K = P, se = L, H = v._charsWritten = we(fe(S), j, K, se);
                break;
              case "ascii":
              case "binary":
                H = p(this, S, P, L);
                break;
              case "base64":
                j = this, K = P, se = L, H = v._charsWritten = we(he(S), j, K, se);
                break;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                H = b(this, S, P, L);
                break;
              default:
                throw new Error("Unknown encoding");
            }
            return H;
          }, v.prototype.toString = function(S, P, L) {
            var X, H, j, K, se = this;
            if (S = String(S || "utf8").toLowerCase(), P = Number(P) || 0, (L = L !== void 0 ? Number(L) : se.length) === P) return "";
            switch (S) {
              case "hex":
                X = function(ie, G, k) {
                  var oe = ie.length;
                  (!G || G < 0) && (G = 0), (!k || k < 0 || oe < k) && (k = oe);
                  for (var ge = "", Re = G; Re < k; Re++) ge += te(ie[Re]);
                  return ge;
                }(se, P, L);
                break;
              case "utf8":
              case "utf-8":
                X = function(ie, G, k) {
                  var oe = "", ge = "";
                  k = Math.min(ie.length, k);
                  for (var Re = G; Re < k; Re++) ie[Re] <= 127 ? (oe += I(ge) + String.fromCharCode(ie[Re]), ge = "") : ge += "%" + ie[Re].toString(16);
                  return oe + I(ge);
                }(se, P, L);
                break;
              case "ascii":
              case "binary":
                X = _(se, P, L);
                break;
              case "base64":
                H = se, K = L, X = (j = P) === 0 && K === H.length ? m.fromByteArray(H) : m.fromByteArray(H.slice(j, K));
                break;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                X = function(ie, G, k) {
                  for (var oe = ie.slice(G, k), ge = "", Re = 0; Re < oe.length; Re += 2) ge += String.fromCharCode(oe[Re] + 256 * oe[Re + 1]);
                  return ge;
                }(se, P, L);
                break;
              default:
                throw new Error("Unknown encoding");
            }
            return X;
          }, v.prototype.toJSON = function() {
            return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
          }, v.prototype.copy = function(S, P, L, X) {
            if (P = P || 0, (X = X || X === 0 ? X : this.length) !== (L = L || 0) && S.length !== 0 && this.length !== 0) {
              z(L <= X, "sourceEnd < sourceStart"), z(0 <= P && P < S.length, "targetStart out of bounds"), z(0 <= L && L < this.length, "sourceStart out of bounds"), z(0 <= X && X <= this.length, "sourceEnd out of bounds"), X > this.length && (X = this.length);
              var H = (X = S.length - P < X - L ? S.length - P + L : X) - L;
              if (H < 100 || !v._useTypedArrays) for (var j = 0; j < H; j++) S[j + P] = this[j + L];
              else S._set(this.subarray(L, L + H), P);
            }
          }, v.prototype.slice = function(S, P) {
            var L = this.length;
            if (S = ne(S, L, 0), P = ne(P, L, L), v._useTypedArrays) return v._augment(this.subarray(S, P));
            for (var X = P - S, H = new v(X, void 0, !0), j = 0; j < X; j++) H[j] = this[j + S];
            return H;
          }, v.prototype.get = function(S) {
            return console.log(".get() is deprecated. Access using array indexes instead."), this.readUInt8(S);
          }, v.prototype.set = function(S, P) {
            return console.log(".set() is deprecated. Access using array indexes instead."), this.writeUInt8(S, P);
          }, v.prototype.readUInt8 = function(S, P) {
            if (P || (z(S != null, "missing offset"), z(S < this.length, "Trying to read beyond buffer length")), !(S >= this.length)) return this[S];
          }, v.prototype.readUInt16LE = function(S, P) {
            return M(this, S, !0, P);
          }, v.prototype.readUInt16BE = function(S, P) {
            return M(this, S, !1, P);
          }, v.prototype.readUInt32LE = function(S, P) {
            return R(this, S, !0, P);
          }, v.prototype.readUInt32BE = function(S, P) {
            return R(this, S, !1, P);
          }, v.prototype.readInt8 = function(S, P) {
            if (P || (z(S != null, "missing offset"), z(S < this.length, "Trying to read beyond buffer length")), !(S >= this.length)) return 128 & this[S] ? -1 * (255 - this[S] + 1) : this[S];
          }, v.prototype.readInt16LE = function(S, P) {
            return w(this, S, !0, P);
          }, v.prototype.readInt16BE = function(S, P) {
            return w(this, S, !1, P);
          }, v.prototype.readInt32LE = function(S, P) {
            return E(this, S, !0, P);
          }, v.prototype.readInt32BE = function(S, P) {
            return E(this, S, !1, P);
          }, v.prototype.readFloatLE = function(S, P) {
            return x(this, S, !0, P);
          }, v.prototype.readFloatBE = function(S, P) {
            return x(this, S, !1, P);
          }, v.prototype.readDoubleLE = function(S, P) {
            return T(this, S, !0, P);
          }, v.prototype.readDoubleBE = function(S, P) {
            return T(this, S, !1, P);
          }, v.prototype.writeUInt8 = function(S, P, L) {
            L || (z(S != null, "missing value"), z(P != null, "missing offset"), z(P < this.length, "trying to write beyond buffer length"), B(S, 255)), P >= this.length || (this[P] = S);
          }, v.prototype.writeUInt16LE = function(S, P, L) {
            y(this, S, P, !0, L);
          }, v.prototype.writeUInt16BE = function(S, P, L) {
            y(this, S, P, !1, L);
          }, v.prototype.writeUInt32LE = function(S, P, L) {
            A(this, S, P, !0, L);
          }, v.prototype.writeUInt32BE = function(S, P, L) {
            A(this, S, P, !1, L);
          }, v.prototype.writeInt8 = function(S, P, L) {
            L || (z(S != null, "missing value"), z(P != null, "missing offset"), z(P < this.length, "Trying to write beyond buffer length"), D(S, 127, -128)), P >= this.length || (0 <= S ? this.writeUInt8(S, P, L) : this.writeUInt8(255 + S + 1, P, L));
          }, v.prototype.writeInt16LE = function(S, P, L) {
            C(this, S, P, !0, L);
          }, v.prototype.writeInt16BE = function(S, P, L) {
            C(this, S, P, !1, L);
          }, v.prototype.writeInt32LE = function(S, P, L) {
            N(this, S, P, !0, L);
          }, v.prototype.writeInt32BE = function(S, P, L) {
            N(this, S, P, !1, L);
          }, v.prototype.writeFloatLE = function(S, P, L) {
            U(this, S, P, !0, L);
          }, v.prototype.writeFloatBE = function(S, P, L) {
            U(this, S, P, !1, L);
          }, v.prototype.writeDoubleLE = function(S, P, L) {
            Y(this, S, P, !0, L);
          }, v.prototype.writeDoubleBE = function(S, P, L) {
            Y(this, S, P, !1, L);
          }, v.prototype.fill = function(S, P, L) {
            if (P = P || 0, L = L || this.length, z(typeof (S = typeof (S = S || 0) == "string" ? S.charCodeAt(0) : S) == "number" && !isNaN(S), "value is not a number"), z(P <= L, "end < start"), L !== P && this.length !== 0) {
              z(0 <= P && P < this.length, "start out of bounds"), z(0 <= L && L <= this.length, "end out of bounds");
              for (var X = P; X < L; X++) this[X] = S;
            }
          }, v.prototype.inspect = function() {
            for (var S = [], P = this.length, L = 0; L < P; L++) if (S[L] = te(this[L]), L === s.INSPECT_MAX_BYTES) {
              S[L + 1] = "...";
              break;
            }
            return "<Buffer " + S.join(" ") + ">";
          }, v.prototype.toArrayBuffer = function() {
            if (typeof Uint8Array > "u") throw new Error("Buffer.toArrayBuffer not supported in this browser");
            if (v._useTypedArrays) return new v(this).buffer;
            for (var S = new Uint8Array(this.length), P = 0, L = S.length; P < L; P += 1) S[P] = this[P];
            return S.buffer;
          };
          var V = v.prototype;
          function ne(S, P, L) {
            return typeof S != "number" ? L : P <= (S = ~~S) ? P : 0 <= S || 0 <= (S += P) ? S : 0;
          }
          function Z(S) {
            return (S = ~~Math.ceil(+S)) < 0 ? 0 : S;
          }
          function ee(S) {
            return (Array.isArray || function(P) {
              return Object.prototype.toString.call(P) === "[object Array]";
            })(S);
          }
          function te(S) {
            return S < 16 ? "0" + S.toString(16) : S.toString(16);
          }
          function fe(S) {
            for (var P = [], L = 0; L < S.length; L++) {
              var X = S.charCodeAt(L);
              if (X <= 127) P.push(S.charCodeAt(L));
              else for (var H = L, j = (55296 <= X && X <= 57343 && L++, encodeURIComponent(S.slice(H, L + 1)).substr(1).split("%")), K = 0; K < j.length; K++) P.push(parseInt(j[K], 16));
            }
            return P;
          }
          function he(S) {
            return m.toByteArray(S);
          }
          function we(S, P, L, X) {
            for (var H = 0; H < X && !(H + L >= P.length || H >= S.length); H++) P[H + L] = S[H];
            return H;
          }
          function I(S) {
            try {
              return decodeURIComponent(S);
            } catch {
              return "�";
            }
          }
          function B(S, P) {
            z(typeof S == "number", "cannot write a non-number as a number"), z(0 <= S, "specified a negative value for writing an unsigned value"), z(S <= P, "value is larger than maximum value for type"), z(Math.floor(S) === S, "value has a fractional component");
          }
          function D(S, P, L) {
            z(typeof S == "number", "cannot write a non-number as a number"), z(S <= P, "value larger than maximum allowed value"), z(L <= S, "value smaller than minimum allowed value"), z(Math.floor(S) === S, "value has a fractional component");
          }
          function O(S, P, L) {
            z(typeof S == "number", "cannot write a non-number as a number"), z(S <= P, "value larger than maximum allowed value"), z(L <= S, "value smaller than minimum allowed value");
          }
          function z(S, P) {
            if (!S) throw new Error(P || "Failed assertion");
          }
          v._augment = function(S) {
            return S._isBuffer = !0, S._get = S.get, S._set = S.set, S.get = V.get, S.set = V.set, S.write = V.write, S.toString = V.toString, S.toLocaleString = V.toString, S.toJSON = V.toJSON, S.copy = V.copy, S.slice = V.slice, S.readUInt8 = V.readUInt8, S.readUInt16LE = V.readUInt16LE, S.readUInt16BE = V.readUInt16BE, S.readUInt32LE = V.readUInt32LE, S.readUInt32BE = V.readUInt32BE, S.readInt8 = V.readInt8, S.readInt16LE = V.readInt16LE, S.readInt16BE = V.readInt16BE, S.readInt32LE = V.readInt32LE, S.readInt32BE = V.readInt32BE, S.readFloatLE = V.readFloatLE, S.readFloatBE = V.readFloatBE, S.readDoubleLE = V.readDoubleLE, S.readDoubleBE = V.readDoubleBE, S.writeUInt8 = V.writeUInt8, S.writeUInt16LE = V.writeUInt16LE, S.writeUInt16BE = V.writeUInt16BE, S.writeUInt32LE = V.writeUInt32LE, S.writeUInt32BE = V.writeUInt32BE, S.writeInt8 = V.writeInt8, S.writeInt16LE = V.writeInt16LE, S.writeInt16BE = V.writeInt16BE, S.writeInt32LE = V.writeInt32LE, S.writeInt32BE = V.writeInt32BE, S.writeFloatLE = V.writeFloatLE, S.writeFloatBE = V.writeFloatBE, S.writeDoubleLE = V.writeDoubleLE, S.writeDoubleBE = V.writeDoubleBE, S.fill = V.fill, S.inspect = V.inspect, S.toArrayBuffer = V.toArrayBuffer, S;
          };
        }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/buffer/index.js", "/node_modules/gulp-browserify/node_modules/buffer");
      }, { "base64-js": 2, buffer: 3, ieee754: 10, lYpoI2: 11 }], 4: [function(t, n, s) {
        (function(i, o, m, l, c, f, u, d, h) {
          var m = t("buffer").Buffer, g = 4, v = new m(g);
          v.fill(0), n.exports = { hash: function(p, b, _, M) {
            for (var R = b(function(y, A) {
              y.length % g != 0 && (C = y.length + (g - y.length % g), y = m.concat([y, v], C));
              for (var C, N = [], U = A ? y.readInt32BE : y.readInt32LE, Y = 0; Y < y.length; Y += g) N.push(U.call(y, Y));
              return N;
            }(p = m.isBuffer(p) ? p : new m(p), M), 8 * p.length), b = M, w = new m(_), E = b ? w.writeInt32BE : w.writeInt32LE, x = 0; x < R.length; x++) E.call(w, R[x], 4 * x, !0);
            return w;
          } };
        }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { buffer: 3, lYpoI2: 11 }], 5: [function(t, n, s) {
        (function(i, o, m, l, c, f, u, d, h) {
          var m = t("buffer").Buffer, g = t("./sha"), v = t("./sha256"), p = t("./rng"), b = { sha1: g, sha256: v, md5: t("./md5") }, _ = 64, M = new m(_);
          function R(y, A) {
            var C = b[y = y || "sha1"], N = [];
            return C || w("algorithm:", y, "is not yet supported"), { update: function(U) {
              return m.isBuffer(U) || (U = new m(U)), N.push(U), U.length, this;
            }, digest: function(U) {
              var Y = m.concat(N), Y = A ? function(V, ne, Z) {
                m.isBuffer(ne) || (ne = new m(ne)), m.isBuffer(Z) || (Z = new m(Z)), ne.length > _ ? ne = V(ne) : ne.length < _ && (ne = m.concat([ne, M], _));
                for (var ee = new m(_), te = new m(_), fe = 0; fe < _; fe++) ee[fe] = 54 ^ ne[fe], te[fe] = 92 ^ ne[fe];
                return Z = V(m.concat([ee, Z])), V(m.concat([te, Z]));
              }(C, A, Y) : C(Y);
              return N = null, U ? Y.toString(U) : Y;
            } };
          }
          function w() {
            var y = [].slice.call(arguments).join(" ");
            throw new Error([y, "we accept pull requests", "http://github.com/dominictarr/crypto-browserify"].join(`
`));
          }
          M.fill(0), s.createHash = function(y) {
            return R(y);
          }, s.createHmac = R, s.randomBytes = function(y, A) {
            if (!A || !A.call) return new m(p(y));
            try {
              A.call(this, void 0, new m(p(y)));
            } catch (C) {
              A(C);
            }
          };
          var E, x = ["createCredentials", "createCipher", "createCipheriv", "createDecipher", "createDecipheriv", "createSign", "createVerify", "createDiffieHellman", "pbkdf2"], T = function(y) {
            s[y] = function() {
              w("sorry,", y, "is not implemented yet");
            };
          };
          for (E in x) T(x[E]);
        }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./md5": 6, "./rng": 7, "./sha": 8, "./sha256": 9, buffer: 3, lYpoI2: 11 }], 6: [function(t, n, s) {
        (function(i, o, a, l, c, f, u, d, h) {
          var m = t("./helpers");
          function g(w, E) {
            w[E >> 5] |= 128 << E % 32, w[14 + (E + 64 >>> 9 << 4)] = E;
            for (var x = 1732584193, T = -271733879, y = -1732584194, A = 271733878, C = 0; C < w.length; C += 16) {
              var N = x, U = T, Y = y, V = A, x = p(x, T, y, A, w[C + 0], 7, -680876936), A = p(A, x, T, y, w[C + 1], 12, -389564586), y = p(y, A, x, T, w[C + 2], 17, 606105819), T = p(T, y, A, x, w[C + 3], 22, -1044525330);
              x = p(x, T, y, A, w[C + 4], 7, -176418897), A = p(A, x, T, y, w[C + 5], 12, 1200080426), y = p(y, A, x, T, w[C + 6], 17, -1473231341), T = p(T, y, A, x, w[C + 7], 22, -45705983), x = p(x, T, y, A, w[C + 8], 7, 1770035416), A = p(A, x, T, y, w[C + 9], 12, -1958414417), y = p(y, A, x, T, w[C + 10], 17, -42063), T = p(T, y, A, x, w[C + 11], 22, -1990404162), x = p(x, T, y, A, w[C + 12], 7, 1804603682), A = p(A, x, T, y, w[C + 13], 12, -40341101), y = p(y, A, x, T, w[C + 14], 17, -1502002290), x = b(x, T = p(T, y, A, x, w[C + 15], 22, 1236535329), y, A, w[C + 1], 5, -165796510), A = b(A, x, T, y, w[C + 6], 9, -1069501632), y = b(y, A, x, T, w[C + 11], 14, 643717713), T = b(T, y, A, x, w[C + 0], 20, -373897302), x = b(x, T, y, A, w[C + 5], 5, -701558691), A = b(A, x, T, y, w[C + 10], 9, 38016083), y = b(y, A, x, T, w[C + 15], 14, -660478335), T = b(T, y, A, x, w[C + 4], 20, -405537848), x = b(x, T, y, A, w[C + 9], 5, 568446438), A = b(A, x, T, y, w[C + 14], 9, -1019803690), y = b(y, A, x, T, w[C + 3], 14, -187363961), T = b(T, y, A, x, w[C + 8], 20, 1163531501), x = b(x, T, y, A, w[C + 13], 5, -1444681467), A = b(A, x, T, y, w[C + 2], 9, -51403784), y = b(y, A, x, T, w[C + 7], 14, 1735328473), x = _(x, T = b(T, y, A, x, w[C + 12], 20, -1926607734), y, A, w[C + 5], 4, -378558), A = _(A, x, T, y, w[C + 8], 11, -2022574463), y = _(y, A, x, T, w[C + 11], 16, 1839030562), T = _(T, y, A, x, w[C + 14], 23, -35309556), x = _(x, T, y, A, w[C + 1], 4, -1530992060), A = _(A, x, T, y, w[C + 4], 11, 1272893353), y = _(y, A, x, T, w[C + 7], 16, -155497632), T = _(T, y, A, x, w[C + 10], 23, -1094730640), x = _(x, T, y, A, w[C + 13], 4, 681279174), A = _(A, x, T, y, w[C + 0], 11, -358537222), y = _(y, A, x, T, w[C + 3], 16, -722521979), T = _(T, y, A, x, w[C + 6], 23, 76029189), x = _(x, T, y, A, w[C + 9], 4, -640364487), A = _(A, x, T, y, w[C + 12], 11, -421815835), y = _(y, A, x, T, w[C + 15], 16, 530742520), x = M(x, T = _(T, y, A, x, w[C + 2], 23, -995338651), y, A, w[C + 0], 6, -198630844), A = M(A, x, T, y, w[C + 7], 10, 1126891415), y = M(y, A, x, T, w[C + 14], 15, -1416354905), T = M(T, y, A, x, w[C + 5], 21, -57434055), x = M(x, T, y, A, w[C + 12], 6, 1700485571), A = M(A, x, T, y, w[C + 3], 10, -1894986606), y = M(y, A, x, T, w[C + 10], 15, -1051523), T = M(T, y, A, x, w[C + 1], 21, -2054922799), x = M(x, T, y, A, w[C + 8], 6, 1873313359), A = M(A, x, T, y, w[C + 15], 10, -30611744), y = M(y, A, x, T, w[C + 6], 15, -1560198380), T = M(T, y, A, x, w[C + 13], 21, 1309151649), x = M(x, T, y, A, w[C + 4], 6, -145523070), A = M(A, x, T, y, w[C + 11], 10, -1120210379), y = M(y, A, x, T, w[C + 2], 15, 718787259), T = M(T, y, A, x, w[C + 9], 21, -343485551), x = R(x, N), T = R(T, U), y = R(y, Y), A = R(A, V);
            }
            return Array(x, T, y, A);
          }
          function v(w, E, x, T, y, A) {
            return R((E = R(R(E, w), R(T, A))) << y | E >>> 32 - y, x);
          }
          function p(w, E, x, T, y, A, C) {
            return v(E & x | ~E & T, w, E, y, A, C);
          }
          function b(w, E, x, T, y, A, C) {
            return v(E & T | x & ~T, w, E, y, A, C);
          }
          function _(w, E, x, T, y, A, C) {
            return v(E ^ x ^ T, w, E, y, A, C);
          }
          function M(w, E, x, T, y, A, C) {
            return v(x ^ (E | ~T), w, E, y, A, C);
          }
          function R(w, E) {
            var x = (65535 & w) + (65535 & E);
            return (w >> 16) + (E >> 16) + (x >> 16) << 16 | 65535 & x;
          }
          n.exports = function(w) {
            return m.hash(w, g, 16);
          };
        }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 7: [function(t, n, s) {
        (function(i, o, a, l, c, f, u, d, h) {
          n.exports = function(m) {
            for (var g, v = new Array(m), p = 0; p < m; p++) !(3 & p) && (g = 4294967296 * Math.random()), v[p] = g >>> ((3 & p) << 3) & 255;
            return v;
          };
        }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { buffer: 3, lYpoI2: 11 }], 8: [function(t, n, s) {
        (function(i, o, a, l, c, f, u, d, h) {
          var m = t("./helpers");
          function g(b, _) {
            b[_ >> 5] |= 128 << 24 - _ % 32, b[15 + (_ + 64 >> 9 << 4)] = _;
            for (var M, R, w, E = Array(80), x = 1732584193, T = -271733879, y = -1732584194, A = 271733878, C = -1009589776, N = 0; N < b.length; N += 16) {
              for (var U = x, Y = T, V = y, ne = A, Z = C, ee = 0; ee < 80; ee++) {
                E[ee] = ee < 16 ? b[N + ee] : p(E[ee - 3] ^ E[ee - 8] ^ E[ee - 14] ^ E[ee - 16], 1);
                var te = v(v(p(x, 5), (te = T, R = y, w = A, (M = ee) < 20 ? te & R | ~te & w : !(M < 40) && M < 60 ? te & R | te & w | R & w : te ^ R ^ w)), v(v(C, E[ee]), (M = ee) < 20 ? 1518500249 : M < 40 ? 1859775393 : M < 60 ? -1894007588 : -899497514)), C = A, A = y, y = p(T, 30), T = x, x = te;
              }
              x = v(x, U), T = v(T, Y), y = v(y, V), A = v(A, ne), C = v(C, Z);
            }
            return Array(x, T, y, A, C);
          }
          function v(b, _) {
            var M = (65535 & b) + (65535 & _);
            return (b >> 16) + (_ >> 16) + (M >> 16) << 16 | 65535 & M;
          }
          function p(b, _) {
            return b << _ | b >>> 32 - _;
          }
          n.exports = function(b) {
            return m.hash(b, g, 20, !0);
          };
        }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 9: [function(t, n, s) {
        (function(i, o, a, l, c, f, u, d, h) {
          function m(_, M) {
            var R = (65535 & _) + (65535 & M);
            return (_ >> 16) + (M >> 16) + (R >> 16) << 16 | 65535 & R;
          }
          function g(_, M) {
            var R, w = new Array(1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298), E = new Array(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225), x = new Array(64);
            _[M >> 5] |= 128 << 24 - M % 32, _[15 + (M + 64 >> 9 << 4)] = M;
            for (var T, y, A = 0; A < _.length; A += 16) {
              for (var C = E[0], N = E[1], U = E[2], Y = E[3], V = E[4], ne = E[5], Z = E[6], ee = E[7], te = 0; te < 64; te++) x[te] = te < 16 ? _[te + A] : m(m(m((y = x[te - 2], p(y, 17) ^ p(y, 19) ^ b(y, 10)), x[te - 7]), (y = x[te - 15], p(y, 7) ^ p(y, 18) ^ b(y, 3))), x[te - 16]), R = m(m(m(m(ee, p(y = V, 6) ^ p(y, 11) ^ p(y, 25)), V & ne ^ ~V & Z), w[te]), x[te]), T = m(p(T = C, 2) ^ p(T, 13) ^ p(T, 22), C & N ^ C & U ^ N & U), ee = Z, Z = ne, ne = V, V = m(Y, R), Y = U, U = N, N = C, C = m(R, T);
              E[0] = m(C, E[0]), E[1] = m(N, E[1]), E[2] = m(U, E[2]), E[3] = m(Y, E[3]), E[4] = m(V, E[4]), E[5] = m(ne, E[5]), E[6] = m(Z, E[6]), E[7] = m(ee, E[7]);
            }
            return E;
          }
          var v = t("./helpers"), p = function(_, M) {
            return _ >>> M | _ << 32 - M;
          }, b = function(_, M) {
            return _ >>> M;
          };
          n.exports = function(_) {
            return v.hash(_, g, 32, !0);
          };
        }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 10: [function(t, n, s) {
        (function(i, o, a, l, c, f, u, d, h) {
          s.read = function(m, g, v, p, A) {
            var _, M, R = 8 * A - p - 1, w = (1 << R) - 1, E = w >> 1, x = -7, T = v ? A - 1 : 0, y = v ? -1 : 1, A = m[g + T];
            for (T += y, _ = A & (1 << -x) - 1, A >>= -x, x += R; 0 < x; _ = 256 * _ + m[g + T], T += y, x -= 8) ;
            for (M = _ & (1 << -x) - 1, _ >>= -x, x += p; 0 < x; M = 256 * M + m[g + T], T += y, x -= 8) ;
            if (_ === 0) _ = 1 - E;
            else {
              if (_ === w) return M ? NaN : 1 / 0 * (A ? -1 : 1);
              M += Math.pow(2, p), _ -= E;
            }
            return (A ? -1 : 1) * M * Math.pow(2, _ - p);
          }, s.write = function(m, g, v, p, b, C) {
            var M, R, w = 8 * C - b - 1, E = (1 << w) - 1, x = E >> 1, T = b === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, y = p ? 0 : C - 1, A = p ? 1 : -1, C = g < 0 || g === 0 && 1 / g < 0 ? 1 : 0;
            for (g = Math.abs(g), isNaN(g) || g === 1 / 0 ? (R = isNaN(g) ? 1 : 0, M = E) : (M = Math.floor(Math.log(g) / Math.LN2), g * (p = Math.pow(2, -M)) < 1 && (M--, p *= 2), 2 <= (g += 1 <= M + x ? T / p : T * Math.pow(2, 1 - x)) * p && (M++, p /= 2), E <= M + x ? (R = 0, M = E) : 1 <= M + x ? (R = (g * p - 1) * Math.pow(2, b), M += x) : (R = g * Math.pow(2, x - 1) * Math.pow(2, b), M = 0)); 8 <= b; m[v + y] = 255 & R, y += A, R /= 256, b -= 8) ;
            for (M = M << b | R, w += b; 0 < w; m[v + y] = 255 & M, y += A, M /= 256, w -= 8) ;
            m[v + y - A] |= 128 * C;
          };
        }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/ieee754/index.js", "/node_modules/gulp-browserify/node_modules/ieee754");
      }, { buffer: 3, lYpoI2: 11 }], 11: [function(t, n, s) {
        (function(i, o, a, l, c, f, u, d, h) {
          var m, g, v;
          function p() {
          }
          (i = n.exports = {}).nextTick = (g = typeof window < "u" && window.setImmediate, v = typeof window < "u" && window.postMessage && window.addEventListener, g ? function(b) {
            return window.setImmediate(b);
          } : v ? (m = [], window.addEventListener("message", function(b) {
            var _ = b.source;
            _ !== window && _ !== null || b.data !== "process-tick" || (b.stopPropagation(), 0 < m.length && m.shift()());
          }, !0), function(b) {
            m.push(b), window.postMessage("process-tick", "*");
          }) : function(b) {
            setTimeout(b, 0);
          }), i.title = "browser", i.browser = !0, i.env = {}, i.argv = [], i.on = p, i.addListener = p, i.once = p, i.off = p, i.removeListener = p, i.removeAllListeners = p, i.emit = p, i.binding = function(b) {
            throw new Error("process.binding is not supported");
          }, i.cwd = function() {
            return "/";
          }, i.chdir = function(b) {
            throw new Error("process.chdir is not supported");
          };
        }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/process/browser.js", "/node_modules/gulp-browserify/node_modules/process");
      }, { buffer: 3, lYpoI2: 11 }] }, {}, [1])(1);
    });
  }(Xi)), Xi.exports;
}
var Gd = zd();
const Hd = /* @__PURE__ */ Ps(Gd);
var $i, Vr;
function vl() {
  return Vr || (Vr = 1, $i = [
    // current
    "precision",
    "highp",
    "mediump",
    "lowp",
    "attribute",
    "const",
    "uniform",
    "varying",
    "break",
    "continue",
    "do",
    "for",
    "while",
    "if",
    "else",
    "in",
    "out",
    "inout",
    "float",
    "int",
    "uint",
    "void",
    "bool",
    "true",
    "false",
    "discard",
    "return",
    "mat2",
    "mat3",
    "mat4",
    "vec2",
    "vec3",
    "vec4",
    "ivec2",
    "ivec3",
    "ivec4",
    "bvec2",
    "bvec3",
    "bvec4",
    "sampler1D",
    "sampler2D",
    "sampler3D",
    "samplerCube",
    "sampler1DShadow",
    "sampler2DShadow",
    "struct",
    "asm",
    "class",
    "union",
    "enum",
    "typedef",
    "template",
    "this",
    "packed",
    "goto",
    "switch",
    "default",
    "inline",
    "noinline",
    "volatile",
    "public",
    "static",
    "extern",
    "external",
    "interface",
    "long",
    "short",
    "double",
    "half",
    "fixed",
    "unsigned",
    "input",
    "output",
    "hvec2",
    "hvec3",
    "hvec4",
    "dvec2",
    "dvec3",
    "dvec4",
    "fvec2",
    "fvec3",
    "fvec4",
    "sampler2DRect",
    "sampler3DRect",
    "sampler2DRectShadow",
    "sizeof",
    "cast",
    "namespace",
    "using"
  ]), $i;
}
var Zi, Yr;
function jd() {
  return Yr || (Yr = 1, Zi = [
    "<<=",
    ">>=",
    "++",
    "--",
    "<<",
    ">>",
    "<=",
    ">=",
    "==",
    "!=",
    "&&",
    "||",
    "+=",
    "-=",
    "*=",
    "/=",
    "%=",
    "&=",
    "^^",
    "^=",
    "|=",
    "(",
    ")",
    "[",
    "]",
    ".",
    "!",
    "~",
    "*",
    "/",
    "%",
    "+",
    "-",
    "<",
    ">",
    "&",
    "^",
    "|",
    "?",
    ":",
    "=",
    ",",
    ";",
    "{",
    "}"
  ]), Zi;
}
var Ki, Wr;
function yl() {
  return Wr || (Wr = 1, Ki = [
    // Keep this list sorted
    "abs",
    "acos",
    "all",
    "any",
    "asin",
    "atan",
    "ceil",
    "clamp",
    "cos",
    "cross",
    "dFdx",
    "dFdy",
    "degrees",
    "distance",
    "dot",
    "equal",
    "exp",
    "exp2",
    "faceforward",
    "floor",
    "fract",
    "gl_BackColor",
    "gl_BackLightModelProduct",
    "gl_BackLightProduct",
    "gl_BackMaterial",
    "gl_BackSecondaryColor",
    "gl_ClipPlane",
    "gl_ClipVertex",
    "gl_Color",
    "gl_DepthRange",
    "gl_DepthRangeParameters",
    "gl_EyePlaneQ",
    "gl_EyePlaneR",
    "gl_EyePlaneS",
    "gl_EyePlaneT",
    "gl_Fog",
    "gl_FogCoord",
    "gl_FogFragCoord",
    "gl_FogParameters",
    "gl_FragColor",
    "gl_FragCoord",
    "gl_FragData",
    "gl_FragDepth",
    "gl_FragDepthEXT",
    "gl_FrontColor",
    "gl_FrontFacing",
    "gl_FrontLightModelProduct",
    "gl_FrontLightProduct",
    "gl_FrontMaterial",
    "gl_FrontSecondaryColor",
    "gl_LightModel",
    "gl_LightModelParameters",
    "gl_LightModelProducts",
    "gl_LightProducts",
    "gl_LightSource",
    "gl_LightSourceParameters",
    "gl_MaterialParameters",
    "gl_MaxClipPlanes",
    "gl_MaxCombinedTextureImageUnits",
    "gl_MaxDrawBuffers",
    "gl_MaxFragmentUniformComponents",
    "gl_MaxLights",
    "gl_MaxTextureCoords",
    "gl_MaxTextureImageUnits",
    "gl_MaxTextureUnits",
    "gl_MaxVaryingFloats",
    "gl_MaxVertexAttribs",
    "gl_MaxVertexTextureImageUnits",
    "gl_MaxVertexUniformComponents",
    "gl_ModelViewMatrix",
    "gl_ModelViewMatrixInverse",
    "gl_ModelViewMatrixInverseTranspose",
    "gl_ModelViewMatrixTranspose",
    "gl_ModelViewProjectionMatrix",
    "gl_ModelViewProjectionMatrixInverse",
    "gl_ModelViewProjectionMatrixInverseTranspose",
    "gl_ModelViewProjectionMatrixTranspose",
    "gl_MultiTexCoord0",
    "gl_MultiTexCoord1",
    "gl_MultiTexCoord2",
    "gl_MultiTexCoord3",
    "gl_MultiTexCoord4",
    "gl_MultiTexCoord5",
    "gl_MultiTexCoord6",
    "gl_MultiTexCoord7",
    "gl_Normal",
    "gl_NormalMatrix",
    "gl_NormalScale",
    "gl_ObjectPlaneQ",
    "gl_ObjectPlaneR",
    "gl_ObjectPlaneS",
    "gl_ObjectPlaneT",
    "gl_Point",
    "gl_PointCoord",
    "gl_PointParameters",
    "gl_PointSize",
    "gl_Position",
    "gl_ProjectionMatrix",
    "gl_ProjectionMatrixInverse",
    "gl_ProjectionMatrixInverseTranspose",
    "gl_ProjectionMatrixTranspose",
    "gl_SecondaryColor",
    "gl_TexCoord",
    "gl_TextureEnvColor",
    "gl_TextureMatrix",
    "gl_TextureMatrixInverse",
    "gl_TextureMatrixInverseTranspose",
    "gl_TextureMatrixTranspose",
    "gl_Vertex",
    "greaterThan",
    "greaterThanEqual",
    "inversesqrt",
    "length",
    "lessThan",
    "lessThanEqual",
    "log",
    "log2",
    "matrixCompMult",
    "max",
    "min",
    "mix",
    "mod",
    "normalize",
    "not",
    "notEqual",
    "pow",
    "radians",
    "reflect",
    "refract",
    "sign",
    "sin",
    "smoothstep",
    "sqrt",
    "step",
    "tan",
    "texture2D",
    "texture2DLod",
    "texture2DProj",
    "texture2DProjLod",
    "textureCube",
    "textureCubeLod",
    "texture2DLodEXT",
    "texture2DProjLodEXT",
    "textureCubeLodEXT",
    "texture2DGradEXT",
    "texture2DProjGradEXT",
    "textureCubeGradEXT"
  ]), Ki;
}
var qi, Xr;
function Vd() {
  if (Xr) return qi;
  Xr = 1;
  var r = vl();
  return qi = r.slice().concat([
    "layout",
    "centroid",
    "smooth",
    "case",
    "mat2x2",
    "mat2x3",
    "mat2x4",
    "mat3x2",
    "mat3x3",
    "mat3x4",
    "mat4x2",
    "mat4x3",
    "mat4x4",
    "uvec2",
    "uvec3",
    "uvec4",
    "samplerCubeShadow",
    "sampler2DArray",
    "sampler2DArrayShadow",
    "isampler2D",
    "isampler3D",
    "isamplerCube",
    "isampler2DArray",
    "usampler2D",
    "usampler3D",
    "usamplerCube",
    "usampler2DArray",
    "coherent",
    "restrict",
    "readonly",
    "writeonly",
    "resource",
    "atomic_uint",
    "noperspective",
    "patch",
    "sample",
    "subroutine",
    "common",
    "partition",
    "active",
    "filter",
    "image1D",
    "image2D",
    "image3D",
    "imageCube",
    "iimage1D",
    "iimage2D",
    "iimage3D",
    "iimageCube",
    "uimage1D",
    "uimage2D",
    "uimage3D",
    "uimageCube",
    "image1DArray",
    "image2DArray",
    "iimage1DArray",
    "iimage2DArray",
    "uimage1DArray",
    "uimage2DArray",
    "image1DShadow",
    "image2DShadow",
    "image1DArrayShadow",
    "image2DArrayShadow",
    "imageBuffer",
    "iimageBuffer",
    "uimageBuffer",
    "sampler1DArray",
    "sampler1DArrayShadow",
    "isampler1D",
    "isampler1DArray",
    "usampler1D",
    "usampler1DArray",
    "isampler2DRect",
    "usampler2DRect",
    "samplerBuffer",
    "isamplerBuffer",
    "usamplerBuffer",
    "sampler2DMS",
    "isampler2DMS",
    "usampler2DMS",
    "sampler2DMSArray",
    "isampler2DMSArray",
    "usampler2DMSArray"
  ]), qi;
}
var Qi, $r;
function Yd() {
  if ($r) return Qi;
  $r = 1;
  var r = yl();
  return r = r.slice().filter(function(e) {
    return !/^(gl\_|texture)/.test(e);
  }), Qi = r.concat([
    // the updated gl_ constants
    "gl_VertexID",
    "gl_InstanceID",
    "gl_Position",
    "gl_PointSize",
    "gl_FragCoord",
    "gl_FrontFacing",
    "gl_FragDepth",
    "gl_PointCoord",
    "gl_MaxVertexAttribs",
    "gl_MaxVertexUniformVectors",
    "gl_MaxVertexOutputVectors",
    "gl_MaxFragmentInputVectors",
    "gl_MaxVertexTextureImageUnits",
    "gl_MaxCombinedTextureImageUnits",
    "gl_MaxTextureImageUnits",
    "gl_MaxFragmentUniformVectors",
    "gl_MaxDrawBuffers",
    "gl_MinProgramTexelOffset",
    "gl_MaxProgramTexelOffset",
    "gl_DepthRangeParameters",
    "gl_DepthRange",
    "trunc",
    "round",
    "roundEven",
    "isnan",
    "isinf",
    "floatBitsToInt",
    "floatBitsToUint",
    "intBitsToFloat",
    "uintBitsToFloat",
    "packSnorm2x16",
    "unpackSnorm2x16",
    "packUnorm2x16",
    "unpackUnorm2x16",
    "packHalf2x16",
    "unpackHalf2x16",
    "outerProduct",
    "transpose",
    "determinant",
    "inverse",
    "texture",
    "textureSize",
    "textureProj",
    "textureLod",
    "textureOffset",
    "texelFetch",
    "texelFetchOffset",
    "textureProjOffset",
    "textureLodOffset",
    "textureProjLod",
    "textureProjLodOffset",
    "textureGrad",
    "textureGradOffset",
    "textureProjGrad",
    "textureProjGradOffset"
  ]), Qi;
}
var Ji, Zr;
function Wd() {
  if (Zr) return Ji;
  Zr = 1, Ji = M;
  var r = vl(), e = jd(), t = yl(), n = Vd(), s = Yd(), i = 999, o = 9999, a = 0, l = 1, c = 2, f = 3, u = 4, d = 5, h = 6, m = 7, g = 8, v = 9, p = 10, b = 11, _ = [
    "block-comment",
    "line-comment",
    "preprocessor",
    "operator",
    "integer",
    "float",
    "ident",
    "builtin",
    "keyword",
    "whitespace",
    "eof",
    "integer"
  ];
  function M(R) {
    var w = 0, E = 0, x = i, T, y, A = [], C = [], N = 1, U = 0, Y = 0, V = !1, ne = !1, Z = "", ee;
    R = R || {};
    var te = t, fe = r;
    R.version === "300 es" && (te = s, fe = n);
    for (var he = {}, we = {}, w = 0; w < te.length; w++)
      he[te[w]] = !0;
    for (var w = 0; w < fe.length; w++)
      we[fe[w]] = !0;
    return function(G) {
      return C = [], G !== null ? B(G) : D();
    };
    function I(G) {
      G.length && C.push({
        type: _[x],
        data: G,
        position: Y,
        line: N,
        column: U
      });
    }
    function B(G) {
      w = 0, G.toString && (G = G.toString()), Z += G.replace(/\r\n/g, `
`), ee = Z.length;
      for (var k; T = Z[w], w < ee; ) {
        switch (k = w, x) {
          case a:
            w = L();
            break;
          case l:
            w = P();
            break;
          case c:
            w = S();
            break;
          case f:
            w = X();
            break;
          case u:
            w = K();
            break;
          case b:
            w = j();
            break;
          case d:
            w = se();
            break;
          case o:
            w = ie();
            break;
          case v:
            w = z();
            break;
          case i:
            w = O();
            break;
        }
        if (k !== w)
          switch (Z[k]) {
            case `
`:
              U = 0, ++N;
              break;
            default:
              ++U;
              break;
          }
      }
      return E += w, Z = Z.slice(w), C;
    }
    function D(G) {
      return A.length && I(A.join("")), x = p, I("(eof)"), C;
    }
    function O() {
      return A = A.length ? [] : A, y === "/" && T === "*" ? (Y = E + w - 1, x = a, y = T, w + 1) : y === "/" && T === "/" ? (Y = E + w - 1, x = l, y = T, w + 1) : T === "#" ? (x = c, Y = E + w, w) : /\s/.test(T) ? (x = v, Y = E + w, w) : (V = /\d/.test(T), ne = /[^\w_]/.test(T), Y = E + w, x = V ? u : ne ? f : o, w);
    }
    function z() {
      return /[^\s]/g.test(T) ? (I(A.join("")), x = i, w) : (A.push(T), y = T, w + 1);
    }
    function S() {
      return (T === "\r" || T === `
`) && y !== "\\" ? (I(A.join("")), x = i, w) : (A.push(T), y = T, w + 1);
    }
    function P() {
      return S();
    }
    function L() {
      return T === "/" && y === "*" ? (A.push(T), I(A.join("")), x = i, w + 1) : (A.push(T), y = T, w + 1);
    }
    function X() {
      if (y === "." && /\d/.test(T))
        return x = d, w;
      if (y === "/" && T === "*")
        return x = a, w;
      if (y === "/" && T === "/")
        return x = l, w;
      if (T === "." && A.length) {
        for (; H(A); ) ;
        return x = d, w;
      }
      if (T === ";" || T === ")" || T === "(") {
        if (A.length) for (; H(A); ) ;
        return I(T), x = i, w + 1;
      }
      var G = A.length === 2 && T !== "=";
      if (/[\w_\d\s]/.test(T) || G) {
        for (; H(A); ) ;
        return x = i, w;
      }
      return A.push(T), y = T, w + 1;
    }
    function H(G) {
      var k = 0, oe, ge;
      do {
        if (oe = e.indexOf(G.slice(0, G.length + k).join("")), ge = e[oe], oe === -1) {
          if (k-- + G.length > 0) continue;
          ge = G.slice(0, 1).join("");
        }
        return I(ge), Y += ge.length, A = A.slice(ge.length), A.length;
      } while (!0);
    }
    function j() {
      return /[^a-fA-F0-9]/.test(T) ? (I(A.join("")), x = i, w) : (A.push(T), y = T, w + 1);
    }
    function K() {
      return T === "." || /[eE]/.test(T) ? (A.push(T), x = d, y = T, w + 1) : T === "x" && A.length === 1 && A[0] === "0" ? (x = b, A.push(T), y = T, w + 1) : /[^\d]/.test(T) ? (I(A.join("")), x = i, w) : (A.push(T), y = T, w + 1);
    }
    function se() {
      return T === "f" && (A.push(T), y = T, w += 1), /[eE]/.test(T) || (T === "-" || T === "+") && /[eE]/.test(y) ? (A.push(T), y = T, w + 1) : /[^\d]/.test(T) ? (I(A.join("")), x = i, w) : (A.push(T), y = T, w + 1);
    }
    function ie() {
      if (/[^\d\w_]/.test(T)) {
        var G = A.join("");
        return we[G] ? x = g : he[G] ? x = m : x = h, I(A.join("")), x = i, w;
      }
      return A.push(T), y = T, w + 1;
    }
  }
  return Ji;
}
var eo, Kr;
function Xd() {
  if (Kr) return eo;
  Kr = 1;
  var r = Wd();
  eo = e;
  function e(t, n) {
    var s = r(n), i = [];
    return i = i.concat(s(t)), i = i.concat(s(null)), i;
  }
  return eo;
}
var $d = Xd();
const Zd = /* @__PURE__ */ Ps($d);
var to, qr;
function Kd() {
  if (qr) return to;
  qr = 1, to = r;
  function r(e) {
    for (var t = [], n = 0; n < e.length; n++)
      e[n].type !== "eof" && t.push(e[n].data);
    return t.join("");
  }
  return to;
}
var qd = Kd();
const Qr = /* @__PURE__ */ Ps(qd);
var no, Jr;
function Qd() {
  if (Jr) return no;
  Jr = 1, no = r;
  function r(n) {
    var s = null, i = null, o = 0, a = 0, l = 0, c = 0, f = 0, u = [], d, h, m;
    for (d = 0, h; d < n.length; d++)
      if (m = n[d], m.data === "{") {
        if (o && o++ || (h = v(d, e(")"), e()), h < 0) || (c = h, h = v(h, e("("), e(")")), h < 0) || (f = h, h = v(h, t), h < 0) || n[h].type !== "ident" || (i = n[h].data, h = v(h, t), h < 0)) continue;
        o = 1, a = d, s = n[h].data, l = h;
        var g = v(h, t);
        switch (n[g] && n[g].data) {
          case "lowp":
          case "highp":
          case "mediump":
            l = g;
        }
      } else if (o && m.data === "}") {
        if (--o) continue;
        u.push({
          name: i,
          type: s,
          body: [a + 1, d],
          args: [f, c + 1],
          outer: [l, d + 1]
        });
      }
    for (d = 0; d < n.length; d++)
      if (m = n[d], m.data === ";") {
        if (h = v(d, e(")"), e()), h < 0 || (c = h, h = v(h, e("("), e(")")), h < 0) || (f = h, h = v(h, t), h < 0) || n[h].type !== "ident" || (i = n[h].data, h = v(h, t), h < 0) || n[h].type === "operator" || n[h].data === "return") continue;
        s = n[h].data, u.push({
          name: i,
          type: s,
          body: !1,
          args: [f, c + 1],
          outer: [h, d + 1]
        });
      }
    return u.sort(function(p, b) {
      return p.outer[0] - b.outer[0];
    });
    function v(p, b, _) {
      for (var M = p - 1; M >= 0; M--) {
        if (b(n[M])) return M;
        if (_ && _(n[M])) return -1;
      }
      return -1;
    }
  }
  function e(n) {
    return function(s) {
      return s.type === "operator" && (!n || s.data === n);
    };
  }
  function t(n) {
    return n.type !== "whitespace";
  }
  return no;
}
var Jd = Qd();
const ep = /* @__PURE__ */ Ps(Jd);
function tp(r, e) {
  if (typeof r != "object" || r === null) return r;
  var t = r[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(r, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
function _l(r) {
  var e = tp(r, "string");
  return typeof e == "symbol" ? e : String(e);
}
function Ge(r, e, t) {
  return e = _l(e), e in r ? Object.defineProperty(r, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : r[e] = t, r;
}
function ea(r, e) {
  var t = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(r);
    e && (n = n.filter(function(s) {
      return Object.getOwnPropertyDescriptor(r, s).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function Xn(r) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ea(Object(t), !0).forEach(function(n) {
      Ge(r, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(t)) : ea(Object(t)).forEach(function(n) {
      Object.defineProperty(r, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return r;
}
function np(r, e) {
  if (r == null) return {};
  var t = {}, n = Object.keys(r), s, i;
  for (i = 0; i < n.length; i++)
    s = n[i], !(e.indexOf(s) >= 0) && (t[s] = r[s]);
  return t;
}
function sp(r, e) {
  if (r == null) return {};
  var t = np(r, e), n, s;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(r);
    for (s = 0; s < i.length; s++)
      n = i[s], !(e.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(r, n) && (t[n] = r[n]);
  }
  return t;
}
function ip(r, e) {
  if (!(r instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function op(r, e) {
  for (var t = 0; t < e.length; t++) {
    var n = e[t];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(r, _l(n.key), n);
  }
}
function rp(r, e, t) {
  return e && op(r.prototype, e), Object.defineProperty(r, "prototype", {
    writable: !1
  }), r;
}
function xl(r) {
  if (r === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return r;
}
function To(r, e) {
  return To = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, s) {
    return n.__proto__ = s, n;
  }, To(r, e);
}
function ap(r, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  r.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: r,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(r, "prototype", {
    writable: !1
  }), e && To(r, e);
}
function ri(r) {
  return ri = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, ri(r);
}
function lp() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
  if (typeof Proxy == "function") return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function cp(r, e) {
  if (e && (typeof e == "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return xl(r);
}
function up(r) {
  var e = lp();
  return function() {
    var n = ri(r), s;
    if (e) {
      var i = ri(this).constructor;
      s = Reflect.construct(n, arguments, i);
    } else
      s = n.apply(this, arguments);
    return cp(this, s);
  };
}
var Me = {
  position: "csm_Position",
  positionRaw: "csm_PositionRaw",
  pointSize: "csm_PointSize",
  fragColor: "csm_FragColor",
  // PBR
  diffuseColor: "csm_DiffuseColor",
  // Color + alpha
  normal: "csm_Normal",
  // Normal
  roughness: "csm_Roughness",
  // Roughness
  metalness: "csm_Metalness",
  // Metalness
  emissive: "csm_Emissive",
  // Emissive
  ao: "csm_AO",
  // AO
  bump: "csm_Bump",
  // Bump
  depthAlpha: "csm_DepthAlpha"
  // Depth
}, dt, $n, hp = (dt = {}, Ge(dt, "".concat(Me.normal), {
  "#include <beginnormal_vertex>": `
    vec3 objectNormal = `.concat(Me.normal, `;
    #ifdef USE_TANGENT
	    vec3 objectTangent = vec3( tangent.xyz );
    #endif
    `)
}), Ge(dt, "".concat(Me.position), {
  "#include <begin_vertex>": `
    vec3 transformed = `.concat(Me.position, `;
  `)
}), Ge(dt, "".concat(Me.positionRaw), {
  "#include <begin_vertex>": `
    vec4 csm_internal_positionUnprojected = `.concat(Me.positionRaw, `;
    mat4x4 csm_internal_unprojectMatrix = projectionMatrix * modelViewMatrix;
    #ifdef USE_INSTANCING
      csm_internal_unprojectMatrix = csm_internal_unprojectMatrix * instanceMatrix;
    #endif
    csm_internal_positionUnprojected = inverse(csm_internal_unprojectMatrix) * csm_internal_positionUnprojected;
    vec3 transformed = csm_internal_positionUnprojected.xyz;
  `)
}), Ge(dt, "".concat(Me.pointSize), {
  "gl_PointSize = size;": `
    gl_PointSize = `.concat(Me.pointSize, `;
    `)
}), Ge(dt, "".concat(Me.diffuseColor), {
  "#include <color_fragment>": `
    #include <color_fragment>
    diffuseColor = `.concat(Me.diffuseColor, `;
  `)
}), Ge(dt, "".concat(Me.fragColor), {
  "#include <dithering_fragment>": `
    #include <dithering_fragment>
    gl_FragColor  = `.concat(Me.fragColor, `;
  `)
}), Ge(dt, "".concat(Me.emissive), {
  "vec3 totalEmissiveRadiance = emissive;": `
    vec3 totalEmissiveRadiance = `.concat(Me.emissive, `;
    `)
}), Ge(dt, "".concat(Me.roughness), {
  "#include <roughnessmap_fragment>": `
    #include <roughnessmap_fragment>
    roughnessFactor = `.concat(Me.roughness, `;
    `)
}), Ge(dt, "".concat(Me.metalness), {
  "#include <metalnessmap_fragment>": `
    #include <metalnessmap_fragment>
    metalnessFactor = `.concat(Me.metalness, `;
    `)
}), Ge(dt, "".concat(Me.ao), {
  "#include <aomap_fragment>": `
    #include <aomap_fragment>
    reflectedLight.indirectDiffuse *= 1. - `.concat(Me.ao, `;
    `)
}), Ge(dt, "".concat(Me.bump), {
  "#include <normal_fragment_maps>": `
    #include <normal_fragment_maps>

    vec3 csm_internal_orthogonal = `.concat(Me.bump, " - (dot(").concat(Me.bump, `, normal) * normal);
    vec3 csm_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_internal_orthogonal;
    normal = normalize(normal - csm_internal_projectedbump);
    `)
}), Ge(dt, "".concat(Me.depthAlpha), {
  "gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );": `
      gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity * `.concat(Me.depthAlpha, ` );
    `),
  "gl_FragColor = packDepthToRGBA( fragCoordZ );": `
      gl_FragColor = packDepthToRGBA( fragCoordZ );
      gl_FragColor.a *= `.concat(Me.depthAlpha, `;
    `)
}), dt), fp = ($n = {}, Ge($n, "".concat(Me.position), {
  "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );": `
    gl_Position = projectionMatrix * modelViewMatrix * vec4( `.concat(Me.position, `, 1.0 );
  `)
}), Ge($n, "".concat(Me.positionRaw), {
  "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );": `
    gl_Position = `.concat(Me.position, `;
  `)
}), Ge($n, "".concat(Me.diffuseColor), {
  "gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );": `
    gl_FragColor = `.concat(Me.diffuseColor, `;
  `)
}), Ge($n, "".concat(Me.fragColor), {
  "gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );": `
    gl_FragColor = `.concat(Me.fragColor, `;
  `)
}), $n), dp = (
  /* glsl */
  `

#ifdef IS_VERTEX
    // csm_Position & csm_PositionRaw
    #ifdef IS_UNKNOWN
        vec3 csm_Position = vec3(0.0);
        vec4 csm_PositionRaw = vec4(0.0);
        vec3 csm_Normal = vec3(0.0);
    #else
        vec3 csm_Position = position;
        vec4 csm_PositionRaw = projectionMatrix * modelViewMatrix * vec4(position, 1.);
        vec3 csm_Normal = normal;
    #endif

    // csm_PointSize
    #ifdef IS_POINTSMATERIAL
        float csm_PointSize = size;
    #endif
#else
    // csm_DiffuseColor & csm_FragColor
    #if defined IS_UNKNOWN || defined IS_SHADERMATERIAL || defined IS_MESHDEPTHMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_SHADOWMATERIAL
        vec4 csm_DiffuseColor = vec4(1.0, 0.0, 1.0, 1.0);
        vec4 csm_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    #else
        #ifdef USE_MAP
            vec4 _csm_sampledDiffuseColor = texture2D(map, vMapUv);

            #ifdef DECODE_VIDEO_TEXTURE
            // inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)
            _csm_sampledDiffuseColor = vec4(mix(pow(_csm_sampledDiffuseColor.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), _csm_sampledDiffuseColor.rgb * 0.0773993808, vec3(lessThanEqual(_csm_sampledDiffuseColor.rgb, vec3(0.04045)))), _csm_sampledDiffuseColor.w);
            #endif

            vec4 csm_DiffuseColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;
            vec4 csm_FragColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;
        #else
            vec4 csm_DiffuseColor = vec4(diffuse, opacity);
            vec4 csm_FragColor = vec4(diffuse, opacity);
        #endif
    #endif

    // csm_Emissive, csm_Roughness, csm_Metalness
    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL
        vec3 csm_Emissive = emissive;
        float csm_Roughness = roughness;
        float csm_Metalness = metalness;
    #endif

    // csm_AO
    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL
        float csm_AO = 0.0;
    #endif

    // csm_Bump
    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL 
        vec3 csm_Bump = vec3(0.0);
    #endif

    float csm_DepthAlpha = 1.0;
#endif
`
), pp = (
  /* glsl */
  `
    varying mat4 csm_internal_vModelViewMatrix;
`
), mp = (
  /* glsl */
  `
    csm_internal_vModelViewMatrix = modelViewMatrix;
`
), gp = (
  /* glsl */
  `
    varying mat4 csm_internal_vModelViewMatrix;
`
), vp = (
  /* glsl */
  `
    
`
), pt, yp = (pt = {}, Ge(pt, "".concat(Me.position), "*"), Ge(pt, "".concat(Me.positionRaw), "*"), Ge(pt, "".concat(Me.normal), "*"), Ge(pt, "".concat(Me.pointSize), ["PointsMaterial"]), Ge(pt, "".concat(Me.diffuseColor), "*"), Ge(pt, "".concat(Me.fragColor), "*"), Ge(pt, "".concat(Me.emissive), ["MeshStandardMaterial", "MeshPhysicalMaterial"]), Ge(pt, "".concat(Me.roughness), ["MeshStandardMaterial", "MeshPhysicalMaterial"]), Ge(pt, "".concat(Me.metalness), ["MeshStandardMaterial", "MeshPhysicalMaterial"]), Ge(pt, "".concat(Me.ao), ["MeshStandardMaterial", "MeshPhysicalMaterial", "MeshBasicMaterial", "MeshLambertMaterial", "MeshPhongMaterial", "MeshToonMaterial"]), Ge(pt, "".concat(Me.bump), ["MeshLambertMaterial", "MeshMatcapMaterial", "MeshNormalMaterial", "MeshPhongMaterial", "MeshPhysicalMaterial", "MeshStandardMaterial", "MeshToonMaterial", "ShadowMaterial"]), Ge(pt, "".concat(Me.depthAlpha), "*"), pt), _p = ["baseMaterial", "fragmentShader", "vertexShader", "uniforms", "patchMap", "cacheKey", "silent"], xp = function(e, t, n) {
  return e.split(t).join(n);
}, wp = function(e) {
  return e.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}, Tp = function(e, t) {
  return new RegExp("\\b".concat(wp(t), "\\b")).test(e);
};
function bp(r) {
  try {
    new r();
  } catch (e) {
    if (e.message.indexOf("is not a constructor") >= 0)
      return !1;
  }
  return !0;
}
function Ep(r, e) {
  var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  Object.assign(r, e);
  var n = Object.getPrototypeOf(e);
  Object.entries(Object.getOwnPropertyDescriptors(n)).filter(function(s) {
    var i = typeof s[1].get == "function", o = typeof s[1].set == "function", a = typeof s[1].value == "function", l = s[0] === "constructor";
    return (i || o || a) && !l;
  }).forEach(function(s) {
    if (typeof r[s[0]] == "function") {
      t || console.warn("Function ".concat(s[0], " already exists on CSM, renaming to base_").concat(s[0]));
      var i = "base_".concat(s[0]);
      r[i] = s[1].value.bind(r);
      return;
    }
    Object.defineProperty(r, s[0], s[1]);
  });
}
function Mp(r) {
  var e = r.toString().trim(), t = e.substring(e.indexOf("{") + 1, e.lastIndexOf("}"));
  return t.trim().length === 0;
}
function ta(r) {
  return r.replace(/\s/g, "");
}
function Sp(r, e, t) {
  var n = r.lastIndexOf(e);
  return n === -1 ? r : r.substring(0, n) + t + r.substring(n + e.length);
}
var Ap = /* @__PURE__ */ function(r) {
  ap(t, r);
  var e = up(t);
  function t(n) {
    var s, i = n.baseMaterial, o = n.fragmentShader, a = n.vertexShader, l = n.uniforms, c = n.patchMap, f = n.cacheKey, u = n.silent, d = sp(n, _p);
    ip(this, t);
    var h;
    if (bp(i) ? h = new i(d) : (h = i, Object.assign(h, d)), h.type === "RawShaderMaterial")
      throw new Error("CustomShaderMaterial does not support RawShaderMaterial");
    s = e.call(this), Ep(xl(s), h, u), s.__csm = {
      patchMap: c || {},
      fragmentShader: o || "",
      vertexShader: a || "",
      cacheKey: f,
      baseMaterial: i,
      instanceID: Jn.MathUtils.generateUUID(),
      type: h.type,
      isAlreadyExtended: !Mp(h.onBeforeCompile),
      cacheHash: "",
      silent: u
    }, s.uniforms = Xn(Xn({}, s.uniforms || {}), l || {});
    {
      var m = s.__csm, g = m.fragmentShader, v = m.vertexShader, p = s.uniforms;
      s.__csm.cacheHash = s.getCacheHash(), s.generateMaterial(g, v, p);
    }
    return s;
  }
  return rp(t, [{
    key: "update",
    value: function() {
      var s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.uniforms = s.uniforms || this.uniforms, Object.assign(this.__csm, s);
      var i = this.__csm, o = i.fragmentShader, a = i.vertexShader, l = this.uniforms, c = this.getCacheHash();
      this.__csm.cacheHash = c, this.generateMaterial(o, a, l);
    }
    /**
     * Returns a new instance of this material with the same options.
     *
     * @returns A clone of this material.
     */
  }, {
    key: "clone",
    value: function() {
      var s = {
        baseMaterial: this.__csm.baseMaterial,
        fragmentShader: this.__csm.fragmentShader,
        vertexShader: this.__csm.vertexShader,
        uniforms: this.uniforms,
        silent: this.__csm.silent,
        patchMap: this.__csm.patchMap,
        cacheKey: this.__csm.cacheKey
      }, i = new this.constructor(s);
      return Object.assign(this, i), i;
    }
    /**
     * Internally calculates the cache key for this instance of CSM.
     * If no specific CSM inputs are provided, the cache key is the same as the default
     * cache key, i.e. `baseMaterial.onBeforeCompile.toString()`. Not meant to be called directly.
     *
     * This method is quite expensive owing to the hashing function and string manip.
     *
     * TODO:
     * - Optimize string manip.
     * - Find faster hash function
     *
     * @returns {string} A cache key for this instance of CSM.
     */
  }, {
    key: "getCacheHash",
    value: function() {
      var s = this.__csm, i = s.fragmentShader, o = s.vertexShader, a = this.uniforms, l = Object.values(a).reduce(function(f, u) {
        var d = u.value;
        return f + JSON.stringify(d);
      }, ""), c = ta(i) + ta(o) + l;
      return c.trim().length > 0 ? Hd(c) : this.customProgramCacheKey();
    }
    /**
     * Does the internal shader generation. Not meant to be called directly.
     *
     * @param fragmentShader
     * @param vertexShader
     * @param uniforms
     */
  }, {
    key: "generateMaterial",
    value: function(s, i, o) {
      var a = this, l = this.parseShader(s), c = this.parseShader(i);
      this.uniforms = o || {}, this.customProgramCacheKey = function() {
        return a.__csm.cacheHash;
      };
      var f = function(h) {
        try {
          if (l) {
            var m = a.patchShader(l, h.fragmentShader, !0);
            h.fragmentShader = a.getMaterialDefine() + m;
          }
          if (c) {
            var g = a.patchShader(c, h.vertexShader);
            h.vertexShader = `#define IS_VERTEX;
` + g, h.vertexShader = a.getMaterialDefine() + h.vertexShader;
          }
          h.uniforms = Xn(Xn({}, h.uniforms), a.uniforms), a.uniforms = h.uniforms;
        } catch (v) {
          console.error(v);
        }
      };
      if (this.__csm.isAlreadyExtended) {
        var u = this.onBeforeCompile;
        this.onBeforeCompile = function(d, h) {
          u(d, h), f(d);
        };
      } else
        this.onBeforeCompile = f;
      this.needsUpdate = !0;
    }
    /**
     * Patches input shader with custom shader. Not meant to be called directly.
     * @param customShader
     * @param shader
     * @param isFrag
     * @returns
     */
  }, {
    key: "patchShader",
    value: function(s, i, o) {
      var a = this, l = i, c = Xn(Xn({}, this.getPatchMapForMaterial()), this.__csm.patchMap);
      Object.keys(c).forEach(function(d) {
        Object.keys(c[d]).forEach(function(h) {
          var m = yp[d], g = a.__csm.type;
          if (d === "*" || Tp(s.main, d))
            if (!m || Array.isArray(m) && m.includes(g) || m === "*")
              l = xp(l, h, c[d][h]);
            else
              throw new Error("CSM: ".concat(d, " is not available in ").concat(g, ". Shader cannot compile."));
        });
      }), l = l.replace("void main() {", `
        #ifndef CSM_IS_HEAD_DEFAULTS_DEFINED
          `.concat(o ? gp : pp, `
          #define CSM_IS_HEAD_DEFAULTS_DEFINED 1
        #endif

        `).concat(s.header, `
        
        void main() {
          #ifndef CSM_IS_DEFAULTS_DEFINED
            `).concat(dp, `
            #define CSM_IS_DEFAULTS_DEFINED 1
          #endif
          
          #ifndef CSM_IS_MAIN_DEFAULTS_DEFINED
            `).concat(o ? vp : mp, `
            #define CSM_IS_MAIN_DEFAULTS_DEFINED 1
          #endif

          // CSM_START
      `));
      var f = this.__csm.isAlreadyExtended, u = l.includes("// CSM_END");
      return f && u ? l = Sp(l, "// CSM_END", `
          // CSM_END
          `.concat(s.main, `
          // CSM_END
        `)) : l = l.replace("// CSM_START", `
        // CSM_START
        `.concat(s.main, `
        // CSM_END
          `)), l = s.defines + l, l;
    }
    /**
     * This method is expensive owing to the tokenization and parsing of the shader.
     *
     * TODO:
     * - Replace tokenization with regex
     *
     * @param shader
     * @returns
     */
  }, {
    key: "parseShader",
    value: function(s) {
      if (s) {
        var i = s.replace(/\/\*\*(.*?)\*\/|\/\/(.*?)\n/gm, ""), o = Zd(i), a = ep(o), l = a.map(function(u) {
          return u.name;
        }).indexOf("main"), c = Qr(o.slice(0, l >= 0 ? a[l].outer[0] : void 0)), f = l >= 0 ? this.getShaderFromIndex(o, a[l].body) : "";
        return {
          defines: "",
          header: c,
          main: f
        };
      }
    }
    /**
     * Gets the material type as a string. Not meant to be called directly.
     * @returns
     */
  }, {
    key: "getMaterialDefine",
    value: function() {
      var s = this.__csm.type;
      return s ? "#define IS_".concat(s.toUpperCase(), `;
`) : `#define IS_UNKNOWN;
`;
    }
    /**
     * Gets the right patch map for the material. Not meant to be called directly.
     * @returns
     */
  }, {
    key: "getPatchMapForMaterial",
    value: function() {
      switch (this.__csm.type) {
        case "ShaderMaterial":
          return fp;
        default:
          return hp;
      }
    }
    /**
     * Gets the shader from the tokens. Not meant to be called directly.
     * @param tokens
     * @param index
     * @returns
     */
  }, {
    key: "getShaderFromIndex",
    value: function(s, i) {
      return Qr(s.slice(i[0], i[1]));
    }
  }]), t;
}(Jn.Material);
const Pp = ["args"], mv = /* @__PURE__ */ ue({
  __name: "index",
  props: {
    baseMaterial: { type: Function },
    vertexShader: {},
    fragmentShader: {},
    silent: { type: Boolean },
    uniforms: {}
  },
  setup(r, { expose: e }) {
    const t = r, n = re(null), { extend: s, invalidate: i } = xe();
    return s({ CustomShaderMaterial: Ap }), J(t, () => i()), e({ instance: n }), (o, a) => (ae(), ce("TresCustomShaderMaterial", {
      ref_key: "customShaderMaterialClass",
      ref: n,
      args: [t]
    }, null, 8, Pp));
  }
});
class na extends bt {
  /**
   * Create a HolographicMaterial.
   *
   * @param {object} parameters - The parameters to configure the material.
   * @param {number} [parameters.time] - The time uniform representing animation time.
   * @param {number} [parameters.fresnelOpacity] - The opacity for the fresnel effect.
   * @param {number} [parameters.fresnelAmount] - The strength of the fresnel effect.
   * @param {number} [parameters.scanlineSize] - The size of the scanline effect.
   * @param {number} [parameters.hologramBrightness] - The brightness of the hologram.
   * @param {number} [parameters.signalSpeed] - The speed of the signal effect.
   * @param {Color} [parameters.hologramColor] - The color of the hologram.
   * @param {boolean} [parameters.enableBlinking] - Enable/disable blinking effect.
   * @param {boolean} [parameters.blinkFresnelOnly] - Enable blinking only on the fresnel effect.
   * @param {number} [parameters.hologramOpacity] - The opacity of the hologram.
   * @param {number} [parameters.blendMode] - The blending mode. Use `THREE.NormalBlending` or `THREE.AdditiveBlending`.
   * @param {number} [parameters.side] - The rendering side. Use `THREE.FrontSide`,
   *  `THREE.BackSide`, or `THREE.DoubleSide`.
   * @param {boolean} [parameters.depthTest] - Enable or disable depthTest.
   */
  constructor(t = {}) {
    super();
    pe(this, "clock");
    this.vertexShader = `
      #define STANDARD
      varying vec3 vViewPosition;
      #ifdef USE_TRANSMISSION
      varying vec3 vWorldPosition;
      #endif
    
      varying vec2 vUv;
      varying vec4 vPos;
      varying vec3 vNormalW;
      varying vec3 vPositionW;

      #include <common>
      #include <uv_pars_vertex>
      #include <envmap_pars_vertex>
      #include <color_pars_vertex>
      #include <fog_pars_vertex>
      #include <morphtarget_pars_vertex>
      #include <skinning_pars_vertex>
      #include <logdepthbuf_pars_vertex>
      #include <clipping_planes_pars_vertex>

      void main() {
        
        #include <uv_vertex>
        #include <color_vertex>
        #include <morphcolor_vertex>
      
        #if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
      
          #include <beginnormal_vertex>
          #include <morphnormal_vertex>
          #include <skinbase_vertex>
          #include <skinnormal_vertex>
          #include <defaultnormal_vertex>
      
        #endif
      
        #include <begin_vertex>
        #include <morphtarget_vertex>
        #include <skinning_vertex>
        #include <project_vertex>
        #include <logdepthbuf_vertex>
        #include <clipping_planes_vertex>
      
        #include <worldpos_vertex>
        #include <envmap_vertex>
        #include <fog_vertex>

        mat4 modelViewProjectionMatrix = projectionMatrix * modelViewMatrix;

        vUv = uv;
        vPos = projectionMatrix * modelViewMatrix * vec4( transformed, 1.0 );
        vPositionW = vec3( vec4( transformed, 1.0 ) * modelMatrix);
        vNormalW = normalize( vec3( vec4( normal, 0.0 ) * modelMatrix ) );
        
        gl_Position = modelViewProjectionMatrix * vec4( transformed, 1.0 );

      }`, this.fragmentShader = ` 
      varying vec2 vUv;
      varying vec3 vPositionW;
      varying vec4 vPos;
      varying vec3 vNormalW;
      
      uniform float time;
      uniform float fresnelOpacity;
      uniform float scanlineSize;
      uniform float fresnelAmount;
      uniform float signalSpeed;
      uniform float hologramBrightness;
      uniform float hologramOpacity;
      uniform bool blinkFresnelOnly;
      uniform bool enableBlinking;
      uniform vec3 hologramColor;

      float flicker( float amt, float time ) {return clamp( fract( cos( time ) * 43758.5453123 ), amt, 1.0 );}
      float random(in float a, in float b) { return fract((cos(dot(vec2(a,b) ,vec2(12.9898,78.233))) * 43758.5453)); }

      void main() {
        vec2 vCoords = vPos.xy;
        vCoords /= vPos.w;
        vCoords = vCoords * 0.5 + 0.5;
        vec2 myUV = fract( vCoords );

        // Defines hologram main color
        vec4 hologramColor = vec4(hologramColor, mix(hologramBrightness, vUv.y, 0.5));

        // Add scanlines
        float scanlines = 10.;
        scanlines += 20. * sin(time *signalSpeed * 20.8 - myUV.y * 60. * scanlineSize);
        scanlines *= smoothstep(1.3 * cos(time *signalSpeed + myUV.y * scanlineSize), 0.78, 0.9);
        scanlines *= max(0.25, sin(time *signalSpeed) * 1.0);

        // Scanlines offsets
        float r = random(vUv.x, vUv.y);
        float g = random(vUv.y * 20.2, vUv.y * .2);
        float b = random(vUv.y * .9, vUv.y * .2);

        // Scanline composition
        hologramColor += vec4(r*scanlines, b*scanlines, r, 1.0) / 84.;
        vec4 scanlineMix = mix(vec4(0.0), hologramColor, hologramColor.a);

        // Calculates fresnel
        vec3 viewDirectionW = normalize(cameraPosition - vPositionW);
        float fresnelEffect = dot(viewDirectionW, vNormalW) * (1.6 - fresnelOpacity/2.);
        fresnelEffect = clamp(fresnelAmount - fresnelEffect, 0., fresnelOpacity);

        // Blinkin effect
        //Suggested by Octano - https://x.com/OtanoDesign?s=20
        float blinkValue = enableBlinking ? 0.6 - signalSpeed : 1.0;
        float blink = flicker(blinkValue, time * signalSpeed * .02);

        // Final shader composition
        vec3 finalColor;

        if(blinkFresnelOnly){
          finalColor = scanlineMix.rgb + fresnelEffect * blink;
        }else{
          finalColor = scanlineMix.rgb * blink + fresnelEffect;
        }

        gl_FragColor = vec4( finalColor, hologramOpacity);

      }`, this.uniforms = {
      /**
       * The time uniform representing animation time.
       * @type {Uniform<number>}
       * @default 0.0
       */
      time: new Se(0),
      /**
       * The opacity for the fresnel effect.
       * @type {Uniform<number>}
       * @default 1.0
       */
      fresnelOpacity: new Se(t.fresnelOpacity !== void 0 ? t.fresnelOpacity : 1),
      /**
       * The strength of the fresnel effect.
       * @type {Uniform<number>}
       * @default 1.0
       */
      fresnelAmount: new Se(t.fresnelAmount !== void 0 ? t.fresnelAmount : 0.45),
      /**
       * The size of the scanline effect.
       * @type {Uniform<number>}
       * @default 1.0
       */
      scanlineSize: new Se(t.scanlineSize !== void 0 ? t.scanlineSize : 8),
      /**
       * The brightness of the hologram.
       * @type {Uniform<number>}
       * @default 1.0
       */
      hologramBrightness: new Se(t.hologramBrightness !== void 0 ? t.hologramBrightness : 1),
      /**
       * The speed of the signal effect.
       * @type {Uniform<number>}
       * @default 1.0
       */
      signalSpeed: new Se(t.signalSpeed !== void 0 ? t.signalSpeed : 1),
      /**
       * The color of the hologram.
       * @type {Uniform<Color>}
       * @default new Color(0xFFFFFF)
       */
      hologramColor: new Se(t.hologramColor !== void 0 ? new be(t.hologramColor) : new be("#00d5ff")),
      /**
       * Enable/disable blinking effect.
       * @type {Uniform<boolean>}
       * @default true
       */
      enableBlinking: new Se(t.enableBlinking !== void 0 ? t.enableBlinking : !0),
      /**
       * Enable blinking only on the fresnel effect.
       * @type {Uniform<boolean>}
       * @default false
       */
      blinkFresnelOnly: new Se(t.blinkFresnelOnly !== void 0 ? t.blinkFresnelOnly : !0),
      /**
       * The opacity of the hologram.
       * @type {Uniform<number>}
       * @default 1.0
       */
      hologramOpacity: new Se(t.hologramOpacity !== void 0 ? t.hologramOpacity : 1)
    }, this.clock = new ic(), this.setValues(t), this.depthTest = t.depthTest !== void 0 ? t.depthTest : !1, this.blending = t.blendMode !== void 0 ? t.blendMode : So, this.transparent = !0, this.side = t.side !== void 0 ? t.side : ss;
  }
  update() {
    this.uniforms.time.value = this.clock.getElapsedTime();
  }
}
const Rp = ["uniforms-fresnelAmount-value", "uniforms-enableBlinking-value", "uniforms-fresnelOpacity-value", "uniforms-hologramBrightness-value", "uniforms-scanlineSize-value", "uniforms-signalSpeed-value", "uniforms-hologramColor-value", "uniforms-hologramOpacity-value", "uniforms-blinkFresnelOnly-value", "enableAdditive", "side"], gv = /* @__PURE__ */ ue({
  __name: "index",
  props: {
    fresnelAmount: { default: 0.45 },
    fresnelOpacity: { default: 1 },
    blinkFresnelOnly: { type: Boolean, default: !0 },
    enableBlinking: { type: Boolean, default: !0 },
    enableAdditive: { type: Boolean, default: !0 },
    hologramBrightness: { default: 0.7 },
    scanlineSize: { default: 8 },
    signalSpeed: { default: 0.45 },
    hologramOpacity: { default: 1 },
    hologramColor: { default: "#00d5ff" },
    side: { default: ss }
  },
  setup(r, { expose: e }) {
    const t = r, n = re(), { extend: s } = xe();
    s({ HolographicMaterial: na }), e({ root: n, constructor: na });
    const { onBeforeRender: i } = Ve();
    return i(({ invalidate: o }) => {
      var a;
      (a = n.value) == null || a.update(), o();
    }), (o, a) => (ae(), ce("TresHolographicMaterial", {
      ref_key: "MeshHolographicMaterialClass",
      ref: n,
      "uniforms-fresnelAmount-value": t.fresnelAmount,
      "uniforms-enableBlinking-value": t.enableBlinking,
      "uniforms-fresnelOpacity-value": t.fresnelOpacity,
      "uniforms-hologramBrightness-value": t.hologramBrightness,
      "uniforms-scanlineSize-value": t.scanlineSize,
      "uniforms-signalSpeed-value": t.signalSpeed,
      "uniforms-hologramColor-value": t.hologramColor,
      "uniforms-hologramOpacity-value": t.hologramOpacity,
      "uniforms-blinkFresnelOnly-value": t.blinkFresnelOnly,
      enableAdditive: t.enableAdditive,
      side: t.side
    }, null, 8, Rp));
  }
});
class Cp extends bt {
  constructor() {
    super(), this.vertexShader = "void main() { }", this.fragmentShader = "void main() { gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0); discard;}";
  }
}
const vv = /* @__PURE__ */ ue({
  __name: "index",
  setup(r, { expose: e }) {
    const t = re(), { extend: n } = xe();
    return n({ MeshDiscardMaterial: Cp }), e({ instance: t }), (s, i) => (ae(), ce("TresMeshDiscardMaterial", {
      ref_key: "meshDiscardMaterialRef",
      ref: t
    }, null, 512));
  }
});
class Ip extends Es {
  constructor(t = {}) {
    super();
    pe(this, "isMeshPhysicalMaterial");
    pe(this, "clearcoatMap");
    pe(this, "clearcoatRoughness");
    pe(this, "clearcoatRoughnessMap");
    pe(this, "clearcoatNormalScale");
    pe(this, "clearcoatNormalMap");
    pe(this, "ior");
    pe(this, "transmissionMap");
    pe(this, "thickness");
    pe(this, "thicknessMap");
    pe(this, "attenuationDistance");
    pe(this, "attenuationColor");
    pe(this, "specularIntensity");
    pe(this, "specularIntensityMap");
    pe(this, "specularColor");
    pe(this, "specularColorMap");
    pe(this, "_clearcoat");
    pe(this, "_transmission");
    this.isMeshPhysicalMaterial = !0, this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new ve(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
      get() {
        return Ye.clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set(n) {
        this.ior = (1 + 0.4 * n) / (1 - 0.4 * n);
      }
    }), this.roughness = 0, this.transmissionMap = null, this.thickness = 0.5, this.thicknessMap = null, this.attenuationDistance = Number.POSITIVE_INFINITY, this.attenuationColor = new be(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new be(1, 1, 1), this.specularColorMap = null, this._clearcoat = 0.5, this._transmission = 1, this.setValues(t);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(t) {
    this._clearcoat > 0 != t > 0 && this.version++, this._clearcoat = t;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(t) {
    this._transmission > 0 != t > 0 && this.version++, this._transmission = t;
  }
  copy(t) {
    return super.copy(t), this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.ior = t.ior, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationColor.copy(t.attenuationColor), this.specularIntensity = t.specularIntensity, this.specularIntensityMap = t.specularIntensityMap, this.specularColor.copy(t.specularColor), this.specularColorMap = t.specularColorMap, this;
  }
}
const yv = /* @__PURE__ */ ue({
  __name: "index",
  setup(r, { expose: e }) {
    const t = re(), { extend: n } = xe();
    return n({ MeshGlassMaterial: Ip }), e({ instance: t }), (s, i) => (ae(), ce("TresMeshGlassMaterial", {
      ref_key: "MeshGlassMaterialClass",
      ref: t
    }, null, 512));
  }
}), Op = () => Number.parseInt(Ts.replace(/\D+/g, "")), Dp = /* @__PURE__ */ Op();
class Lp extends bt {
  constructor(t = new ve()) {
    super({
      uniforms: {
        inputBuffer: new Se(null),
        depthBuffer: new Se(null),
        resolution: new Se(new ve()),
        texelSize: new Se(new ve()),
        halfTexelSize: new Se(new ve()),
        kernel: new Se(0),
        scale: new Se(1),
        cameraNear: new Se(0),
        cameraFar: new Se(1),
        depthEdge0: new Se(0),
        depthEdge1: new Se(1),
        depthScale: new Se(0),
        depthBias: new Se(0.25)
      },
      fragmentShader: `#include <common>
        #include <dithering_pars_fragment>      
        uniform sampler2D inputBuffer;
        uniform sampler2D depthBuffer;
        uniform float cameraNear;
        uniform float cameraFar;
        uniform float depthEdge0;
        uniform float depthEdge1;
        uniform float depthScale;
        uniform float depthBias;
        varying vec2 vUv;
        varying vec2 vUv0;
        varying vec2 vUv1;
        varying vec2 vUv2;
        varying vec2 vUv3;

        void main() {
          float depthFactor = 0.0;
          
          #ifdef USE_DEPTH
            vec4 depth = texture2D(depthBuffer, vUv);
            depthFactor = smoothstep(
              1.0 - depthEdge1, 1.0 - depthEdge0,
              1.0 - (depth.r * depth.a) + depthBias
            );
            depthFactor = clamp(depthScale * depthFactor + 0.25, 0.0, 1.0);
          #endif

          gl_FragColor = 0.25 * (
            texture2D(inputBuffer, mix(vUv0, vUv, depthFactor))
            + texture2D(inputBuffer, mix(vUv1, vUv, depthFactor))
            + texture2D(inputBuffer, mix(vUv2, vUv, depthFactor))
            + texture2D(inputBuffer, mix(vUv3, vUv, depthFactor))
          );
          
          #include <dithering_fragment>
          #include <tonemapping_fragment>
          #include <${Dp >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
        }`,
      vertexShader: `uniform vec2 texelSize;
        uniform vec2 halfTexelSize;
        uniform float kernel;
        uniform float scale;
        varying vec2 vUv;
        varying vec2 vUv0;
        varying vec2 vUv1;
        varying vec2 vUv2;
        varying vec2 vUv3;

        void main() {
          vec2 uv = position.xy * 0.5 + 0.5;
          vUv = uv;

          vec2 dUv = (texelSize * vec2(kernel) + halfTexelSize) * scale;
          vUv0 = vec2(uv.x - dUv.x, uv.y + dUv.y);
          vUv1 = vec2(uv.x + dUv.x, uv.y + dUv.y);
          vUv2 = vec2(uv.x + dUv.x, uv.y - dUv.y);
          vUv3 = vec2(uv.x - dUv.x, uv.y - dUv.y);

          gl_Position = vec4(position.xy, 1.0, 1.0);
        }`,
      blending: oc,
      depthWrite: !1,
      depthTest: !1
    });
    pe(this, "kernel");
    this.toneMapped = !1, this.setTexelSize(t.x, t.y), this.kernel = new Float32Array([0, 1, 2, 2, 3]);
  }
  setTexelSize(t, n) {
    this.uniforms.texelSize.value.set(t, n), this.uniforms.halfTexelSize.value.set(t, n).multiplyScalar(0.5);
  }
  setResolution(t) {
    this.uniforms.resolution.value.copy(t);
  }
}
class kp {
  constructor({
    resolution: e,
    width: t = 500,
    height: n = 500,
    depthEdge0: s = 0,
    depthEdge1: i = 1,
    depthScale: o = 0,
    depthBias: a = 0.25
  }) {
    pe(this, "renderTargetA");
    pe(this, "renderTargetB");
    pe(this, "convolutionMaterial");
    pe(this, "scene");
    pe(this, "camera");
    pe(this, "screen");
    pe(this, "renderToScreen", !1);
    this.renderTargetA = new Xt(e, e, {
      minFilter: wt,
      magFilter: wt,
      stencilBuffer: !1,
      depthBuffer: !1,
      type: Lt
    }), this.renderTargetB = this.renderTargetA.clone(), this.convolutionMaterial = new Lp(), this.convolutionMaterial.setTexelSize(1 / t, 1 / n), this.convolutionMaterial.setResolution(new ve(t, n)), this.scene = new xs(), this.camera = new rc(), this.convolutionMaterial.uniforms.depthEdge0.value = s, this.convolutionMaterial.uniforms.depthEdge1.value = i, this.convolutionMaterial.uniforms.depthScale.value = o, this.convolutionMaterial.uniforms.depthBias.value = a, this.convolutionMaterial.defines.USE_DEPTH = o > 0;
    const l = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]), c = new Float32Array([0, 0, 2, 0, 0, 2]), f = new ht();
    f.setAttribute("position", new ut(l, 3)), f.setAttribute("uv", new ut(c, 2)), this.screen = new de(f, this.convolutionMaterial), this.screen.frustumCulled = !1, this.scene.add(this.screen);
  }
  render(e, t, n) {
    const s = this.scene, i = this.camera, o = this.renderTargetA, a = this.renderTargetB, l = this.convolutionMaterial, c = l.uniforms;
    c.depthBuffer.value = t.depthTexture;
    const f = l.kernel;
    let u = t, d, h, m;
    for (h = 0, m = f.length - 1; h < m; ++h)
      d = h & 1 ? a : o, c.kernel.value = f[h], c.inputBuffer.value = u.texture, e.setRenderTarget(d), e.render(s, i), u = d;
    c.kernel.value = f[h], c.inputBuffer.value = u.texture, e.setRenderTarget(this.renderToScreen ? null : n), e.render(s, i);
  }
  dispose() {
    this.screen.material.dispose(), this.screen.geometry.dispose(), this.renderTargetA.dispose(), this.renderTargetB.dispose(), this.convolutionMaterial.dispose();
  }
}
class Np extends Es {
  constructor(t = {}) {
    super(t);
    pe(this, "_tDepth", { value: null });
    pe(this, "_distortionMap", { value: null });
    pe(this, "_tSharp", { value: null });
    pe(this, "_tBlur", { value: null });
    pe(this, "_textureMatrix", { value: null });
    pe(this, "_mix", { value: 0.5 });
    pe(this, "_sharpMix", { value: 0 });
    pe(this, "_blurMixSmooth", { value: 0 });
    pe(this, "_blurMixRough", { value: 0 });
    pe(this, "_sharpDepthEdgeMin", { value: 0.9 });
    pe(this, "_sharpDepthEdgeMax", { value: 1 });
    pe(this, "_sharpDepthScale", { value: 0 });
    pe(this, "_sharpDepthBias", { value: 0 });
    pe(this, "_distortion", { value: 1 });
    this.setValues(t);
  }
  onBeforeCompile(t) {
    var n;
    (n = t.defines) != null && n.USE_UV || (t.defines.USE_UV = "");
    for (const s of Object.keys(t.defines))
      t.defines[s.toUpperCase()] = t.defines[s];
    t.uniforms.tSharp = this._tSharp, t.uniforms.tDepth = this._tDepth, t.uniforms.tBlur = this._tBlur, t.uniforms.distortionMap = this._distortionMap, t.uniforms.textureMatrix = this._textureMatrix, t.uniforms.mixMain = this._mix, t.uniforms.sharpMix = this._sharpMix, t.uniforms.sharpDepthScale = this._sharpDepthScale, t.uniforms.sharpDepthEdgeMin = this._sharpDepthEdgeMin, t.uniforms.sharpDepthEdgeMax = this._sharpDepthEdgeMax, t.uniforms.sharpDepthBias = this._sharpDepthBias, t.uniforms.blurMixSmooth = this._blurMixSmooth, t.uniforms.blurMixRough = this._blurMixRough, t.uniforms.distortion = this._distortion, t.vertexShader = `
        uniform mat4 textureMatrix;
        varying vec4 my_vUv;
      ${t.vertexShader}`, t.vertexShader = t.vertexShader.replace(
      "#include <project_vertex>",
      `#include <project_vertex>
        my_vUv = textureMatrix * vec4( position, 1.0 );
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );`
    ), t.fragmentShader = `
        uniform sampler2D tSharp;
        uniform sampler2D tBlur;
        uniform sampler2D tDepth;
        uniform sampler2D distortionMap;
        uniform float distortion;
        uniform float cameraNear;
        uniform float cameraFar;
        uniform float mixMain;
        uniform float sharpMix;
        uniform float blurMixSmooth;
        uniform float blurMixRough;
        uniform float sharpDepthScale;
        uniform float sharpDepthBias;
        uniform float sharpDepthEdgeMin;
        uniform float sharpDepthEdgeMax;
        varying vec4 my_vUv;
        ${t.fragmentShader}`, t.fragmentShader = t.fragmentShader.replace(
      "#include <emissivemap_fragment>",
      `#include <emissivemap_fragment>

      vec4 new_vUv = my_vUv;

      #ifdef USE_DISTORTION
        float distortionFactor = (texture(distortionMap, vUv).r - 0.5) * distortion;
        new_vUv.x += distortionFactor;
        new_vUv.y += distortionFactor;
      #endif

      #ifdef USE_NORMALMAP

        vec4 normalColor = texture(normalMap, vUv * normalScale);
        vec3 my_normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );
        vec3 coord = new_vUv.xyz / new_vUv.w;
        vec2 normal_uv = coord.xy + coord.z * my_normal.xz * 0.05;

        vec4 sharp = texture(tSharp, normal_uv);

        #ifdef USE_BLUR
          vec4 blur = texture(tBlur, normal_uv);
        #endif

        #ifdef USE_DEPTH
          vec4 depth = texture(tDepth, normal_uv);
        #endif

      #else

        vec4 sharp = textureProj(tSharp, new_vUv);

        #ifdef USE_BLUR
          vec4 blur = textureProj(tBlur, new_vUv);
        #endif

        #ifdef USE_DEPTH
          vec4 depth = textureProj(tDepth, new_vUv);
        #endif

      #endif

      #ifdef USE_DEPTH
        float depthFactor = smoothstep(
          1.0 - sharpDepthEdgeMax, 1.0 - sharpDepthEdgeMin,
          1.0 - (depth.r * depth.a) + sharpDepthBias
        );
        depthFactor = clamp(sharpDepthScale * depthFactor, 0.0, 1.0);

        sharp *= depthFactor;
      #endif

      sharp *= (1.0 - roughnessFactor);
      `
    ), t.fragmentShader = t.fragmentShader.replace(
      "#include <opaque_fragment>",
      `

      #ifdef USE_BLUR
        outgoingLight += mixMain * (
          vec3(sharp) * sharpMix
          + vec3(blur) * (blurMixSmooth * (1.0 - roughnessFactor) + blurMixRough * roughnessFactor)
        );
      #else
        outgoingLight += mixMain * vec3(sharp) * sharpMix;
      #endif

      #include <opaque_fragment>
      `
    );
  }
  get tSharp() {
    return this._tSharp.value;
  }
  set tSharp(t) {
    this._tSharp.value = t;
  }
  get tDepth() {
    return this._tDepth.value;
  }
  set tDepth(t) {
    this._tDepth.value = t;
  }
  get distortionMap() {
    return this._distortionMap.value;
  }
  set distortionMap(t) {
    this._distortionMap.value = t;
  }
  get tBlur() {
    return this._tBlur.value;
  }
  set tBlur(t) {
    this._tBlur.value = t;
  }
  get textureMatrix() {
    return this._textureMatrix.value;
  }
  set textureMatrix(t) {
    this._textureMatrix.value = t;
  }
  get sharpMix() {
    return this._sharpMix.value;
  }
  set sharpMix(t) {
    this._sharpMix.value = t;
  }
  get blurMixSmooth() {
    return this._blurMixSmooth.value;
  }
  set blurMixSmooth(t) {
    this._blurMixSmooth.value = t;
  }
  get blurMixRough() {
    return this._blurMixRough.value;
  }
  set blurMixRough(t) {
    this._blurMixRough.value = t;
  }
  get mix() {
    return this._mix.value;
  }
  set mix(t) {
    this._mix.value = t;
  }
  get sharpDepthScale() {
    return this._sharpDepthScale.value;
  }
  set sharpDepthScale(t) {
    this._sharpDepthScale.value = t;
  }
  get sharpDepthBias() {
    return this._sharpDepthBias.value;
  }
  set sharpDepthBias(t) {
    this._sharpDepthBias.value = t;
  }
  get sharpDepthEdgeMin() {
    return this._sharpDepthEdgeMin.value;
  }
  set sharpDepthEdgeMin(t) {
    this._sharpDepthEdgeMin.value = t;
  }
  get sharpDepthEdgeMax() {
    return this._sharpDepthEdgeMax.value;
  }
  set sharpDepthEdgeMax(t) {
    this._sharpDepthEdgeMax.value = t;
  }
  get distortion() {
    return this._distortion.value;
  }
  set distortion(t) {
    this._distortion.value = t;
  }
}
const Bp = ["texture-matrix", "t-sharp", "t-depth", "t-blur", "defines-USE_BLUR", "defines-USE_DEPTH", "defines-USE_DISTORTION"], _v = /* @__PURE__ */ ue({
  __name: "index",
  props: {
    resolution: { default: 256 },
    mix: { default: 1 },
    sharpMix: { default: 1 },
    sharpDepthScale: { default: 1 },
    sharpDepthBias: { default: 0 },
    sharpDepthEdgeMin: { default: 0 },
    sharpDepthEdgeMax: { default: 0.2 },
    blurMixSmooth: { default: 1 },
    blurMixRough: { default: 1 },
    blurDepthScale: { default: 1 },
    blurDepthBias: { default: 0 },
    blurDepthEdgeMin: { default: 0 },
    blurDepthEdgeMax: { default: 0.2 },
    blurSize: { default: () => [0, 0] },
    distortionMap: {},
    distortion: { default: 0 },
    reflectorOffset: { default: 0 },
    color: { default: () => new be(3355443) },
    roughness: { default: 1 },
    metalness: { default: 0 },
    map: {},
    lightMap: {},
    lightMapIntensity: { default: 1 },
    aoMap: {},
    aoMapIntensity: { default: 1 },
    emissive: { default: () => new be(0) },
    emissiveIntensity: { default: 1 },
    emissiveMap: {},
    bumpMap: {},
    bumpScale: { default: 1 },
    normalMap: {},
    normalMapType: { default: ac },
    normalScale: { default: () => new ve(1, 1) },
    displacementMap: {},
    displacementScale: { default: 1 },
    displacementBias: { default: 0 },
    roughnessMap: { default: null },
    metalnessMap: {},
    alphaMap: {},
    envMap: {},
    envMapRotation: { default: () => new vt() },
    envMapIntensity: { default: 1 },
    wireframe: { type: Boolean, default: !1 },
    wireframeLinewidth: { default: 1 },
    wireframeLinecap: { default: "round" },
    wireframeLinejoin: { default: "round" },
    flatShading: { type: Boolean, default: !1 },
    fog: { type: Boolean, default: !0 }
  },
  setup(r, { expose: e }) {
    const t = r, { extend: n, invalidate: s } = xe();
    n({ MeshReflectionMaterial: Np });
    const i = Pe(() => 500 - (Array.isArray(t.blurSize) ? t.blurSize[0] : t.blurSize)), o = Pe(() => 500 - (Array.isArray(t.blurSize) ? t.blurSize[1] : t.blurSize)), a = Pe(() => i.value > 0 || o.value > 0), l = Pe(() => t.sharpDepthScale > 0 || t.blurDepthScale > 0), c = Pe(() => !!t.distortionMap), f = Pe(() => !!t.roughnessMap), u = re();
    let d;
    const h = {
      reflectorPlane: new bs(),
      normal: new $(),
      reflectorWorldPosition: new $(),
      cameraWorldPosition: new $(),
      rotationMatrix: new Ie(),
      lookAtPosition: new $(0, 0, -1),
      clipPlane: new at(),
      view: new $(),
      target: new $(),
      q: new at(),
      virtualCamera: new kt(),
      textureMatrix: new Ie()
    }, m = new Xt(
      t.resolution,
      t.resolution,
      {
        minFilter: wt,
        magFilter: wt,
        type: Lt,
        depthBuffer: !0,
        depthTexture: new Sa(
          t.resolution,
          t.resolution
        )
      }
    ), g = new Xt(
      t.resolution,
      t.resolution,
      {
        minFilter: wt,
        magFilter: wt,
        type: Lt
      }
    );
    function v(p, b, _, M) {
      s();
      const R = p.xr.enabled, w = p.shadowMap.autoUpdate;
      if (h.reflectorWorldPosition.setFromMatrixPosition(M.matrixWorld), h.cameraWorldPosition.setFromMatrixPosition(_.matrixWorld), h.rotationMatrix.extractRotation(M.matrixWorld), h.normal.set(0, 0, 1), h.normal.applyMatrix4(h.rotationMatrix), h.reflectorWorldPosition.addScaledVector(h.normal, t.reflectorOffset), h.view.subVectors(h.reflectorWorldPosition, h.cameraWorldPosition), h.view.dot(h.normal) > 0)
        return;
      M.visible = !1, h.view.reflect(h.normal).negate(), h.view.add(h.reflectorWorldPosition), h.rotationMatrix.extractRotation(_.matrixWorld), h.lookAtPosition.set(0, 0, -1), h.lookAtPosition.applyMatrix4(h.rotationMatrix), h.lookAtPosition.add(h.cameraWorldPosition), h.target.subVectors(h.reflectorWorldPosition, h.lookAtPosition), h.target.reflect(h.normal).negate(), h.target.add(h.reflectorWorldPosition), h.virtualCamera.position.copy(h.view), h.virtualCamera.up.set(0, 1, 0), h.virtualCamera.up.applyMatrix4(h.rotationMatrix), h.virtualCamera.up.reflect(h.normal), h.virtualCamera.lookAt(h.target), h.virtualCamera.far = _.far, h.virtualCamera.updateMatrixWorld(), h.virtualCamera.projectionMatrix.copy(_.projectionMatrix), h.textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), h.textureMatrix.multiply(h.virtualCamera.projectionMatrix), h.textureMatrix.multiply(h.virtualCamera.matrixWorldInverse), h.textureMatrix.multiply(M.matrixWorld), h.reflectorPlane.setFromNormalAndCoplanarPoint(h.normal, h.reflectorWorldPosition), h.reflectorPlane.applyMatrix4(h.virtualCamera.matrixWorldInverse), h.clipPlane.set(
        h.reflectorPlane.normal.x,
        h.reflectorPlane.normal.y,
        h.reflectorPlane.normal.z,
        h.reflectorPlane.constant
      );
      const E = h.virtualCamera.projectionMatrix;
      h.q.x = (Math.sign(h.clipPlane.x) + E.elements[8]) / E.elements[0], h.q.y = (Math.sign(h.clipPlane.y) + E.elements[9]) / E.elements[5], h.q.z = -1, h.q.w = (1 + E.elements[10]) / E.elements[14], h.clipPlane.multiplyScalar(2 / h.clipPlane.dot(h.q)), E.elements[2] = h.clipPlane.x, E.elements[6] = h.clipPlane.y, E.elements[10] = h.clipPlane.z + 1, E.elements[14] = h.clipPlane.w, p.shadowMap.autoUpdate = !1, p.setRenderTarget(m), p.autoClear || p.clear(), p.render(b, h.virtualCamera), d.render(p, m, g), p.xr.enabled = R, p.shadowMap.autoUpdate = w, M.visible = !0, p.setRenderTarget(null);
    }
    return J(
      () => [t.resolution],
      () => {
        m.setSize(t.resolution, t.resolution), g.setSize(t.resolution, t.resolution);
      }
    ), J(() => [
      t.resolution,
      i.value,
      o.value,
      t.blurDepthEdgeMin,
      t.blurDepthEdgeMax,
      t.blurDepthScale,
      t.blurDepthBias
    ], () => {
      d == null || d.dispose(), d = new kp({
        resolution: t.resolution,
        width: i.value,
        height: o.value,
        depthEdge0: t.blurDepthEdgeMin,
        depthEdge1: t.blurDepthEdgeMax,
        depthScale: t.blurDepthScale,
        depthBias: t.blurDepthBias
      });
    }, { immediate: !0 }), J(() => [a.value], () => {
      xt().logWarning(
        "MeshReflectionMaterial: Setting blurMixRough or blurMixSmooth to 0, then non-zero triggers a recompile.The TresJS core cannot currently handle recompiled materials."
      );
    }), J(l, () => {
      xt().logWarning(
        "MeshReflectionMaterial: Setting depthScale to 0, then non-zero triggers a recompile.The TresJS core cannot currently handle recompiled materials."
      );
    }), J(c, () => {
      xt().logWarning(
        "MeshReflectionMaterial: Toggling distortionMap triggers a recompile.The TresJS core cannot currently handle recompiled materials."
      );
    }), J(f, () => {
      xt().logWarning(
        "MeshReflectionMaterial: Toggling roughnessMap triggers a recompile.The TresJS core cannot currently handle recompiled materials."
      );
    }), J(() => [t.normalMap], () => {
      xt().logWarning(
        "MeshReflectionMaterial: Toggling normalMap triggers a recompile.The TresJS core cannot currently handle recompiled materials."
      );
    }), Co(() => {
      m.dispose(), g.dispose(), d.dispose();
    }), Ve().onBeforeRender(({ renderer: p, scene: b, camera: _, invalidate: M }) => {
      var w, E;
      const R = (E = (w = u.value) == null ? void 0 : w.__tres) == null ? void 0 : E.parent;
      R && (v(p, b, _, R), M());
    }), e({ instance: u }), (p, b) => {
      var _, M, R;
      return ae(), ce("TresMeshReflectionMaterial", $e({
        key: `key${a.value ? "0" : "1"}${l.value ? "0" : "1"}${c.value ? "0" : "1"}${f.value ? "0" : "1"}`,
        ref_key: "materialRef",
        ref: u
      }, t, {
        "texture-matrix": h.textureMatrix,
        "t-sharp": (_ = F(m)) == null ? void 0 : _.texture,
        "t-depth": (M = F(m)) == null ? void 0 : M.depthTexture,
        "t-blur": (R = F(g)) == null ? void 0 : R.texture,
        "defines-USE_BLUR": a.value ? "" : void 0,
        "defines-USE_DEPTH": l.value ? "" : void 0,
        "defines-USE_DISTORTION": c.value ? "" : void 0
      }), null, 16, Bp);
    };
  }
});
class Up extends Es {
  constructor(t = {}) {
    super(t);
    pe(this, "_time");
    pe(this, "_factor");
    this.setValues(t), this._time = { value: 0 }, this._factor = { value: 1 };
  }
  onBeforeCompile(t) {
    t.uniforms || (t.uniforms = {}), t.uniforms.time = this._time, t.uniforms.factor = this._factor, t.vertexShader = `
        uniform float time;
        uniform float factor;
        ${t.vertexShader}
      `, t.vertexShader = t.vertexShader.replace(
      "#include <begin_vertex>",
      `float theta = sin( time + position.y ) / 2.0 * factor;
          float c = cos( theta );
          float s = sin( theta );
          mat3 m = mat3( c, 0, s, 0, 1, 0, -s, 0, c );
          vec3 transformed = vec3( position ) * m;
          vNormal = vNormal * m;`
    );
  }
  get time() {
    return this._time.value;
  }
  set time(t) {
    this._time.value = t;
  }
  get factor() {
    return this._factor.value;
  }
  set factor(t) {
    this._factor.value = t;
  }
}
const Fp = ["factor"], xv = /* @__PURE__ */ ue({
  __name: "index",
  props: {
    speed: { default: 1 },
    factor: { default: 1 }
  },
  setup(r, { expose: e }) {
    const t = r, n = re(), { extend: s, invalidate: i } = xe();
    s({ MeshWobbleMaterial: Up }), J(t, () => i());
    const { onBeforeRender: o } = Ve();
    return o(({ elapsed: a, invalidate: l }) => {
      n.value && (n.value.time = a * (t == null ? void 0 : t.speed), l());
    }), e({ instance: n }), (a, l) => (ae(), ce("TresMeshWobbleMaterial", $e({
      ref_key: "materialRef",
      ref: n,
      factor: a.factor
    }, a.$attrs), null, 16, Fp));
  }
}), wv = ue({
  name: "BakeShadows",
  setup() {
    const { renderer: r } = xe();
    et(() => {
      r.value.shadowMap.autoUpdate = !1, r.value.shadowMap.needsUpdate = !0;
    });
  }
});
var zp = `void main() {
  gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
}`, Gp = `#include <common>

void main() {
  vec2 center = vec2(0., 1.);
  float rotation = 0.0;

  
  
  float size = 0.03;

  vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
  vec2 scale;
  scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
  scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

  bool isPerspective = isPerspectiveMatrix( projectionMatrix );
  if ( isPerspective ) scale *= - mvPosition.z;

  vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
  vec2 rotatedPosition;
  rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
  rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
  mvPosition.xy += rotatedPosition;

  gl_Position = projectionMatrix * mvPosition;
}`;
const Rs = new $(0, 0, 0), Vo = new $(0, 0, 0), Hp = new $(0, 0, 0);
function sa(r, e, t) {
  const n = Rs.setFromMatrixPosition(r.matrixWorld);
  n.project(e);
  const s = t.width / 2, i = t.height / 2;
  return [
    (Number.isNaN(n.x) ? 0 : n.x) * s + s,
    -(n.y * i) + i,
    n.z
  ];
}
function jp(r, e) {
  const t = Rs.setFromMatrixPosition(r.matrixWorld), n = Vo.setFromMatrixPosition(e.matrixWorld), s = t.sub(n), i = e.getWorldDirection(Hp);
  return s.angleTo(i) > Math.PI / 2;
}
function Vp(r, e, t, n) {
  const s = Rs.setFromMatrixPosition(r.matrixWorld), i = s.clone();
  i.project(e), t.setFromCamera(new ve(i.x, i.y), e);
  const o = t.intersectObjects(n, !0);
  if (o.length > 0) {
    const a = o[0].distance;
    return s.distanceTo(t.ray.origin) < a;
  }
  return !0;
}
function Yp(r, e) {
  if (e instanceof _n)
    return e.zoom;
  if (e instanceof kt) {
    const t = Rs.setFromMatrixPosition(r.matrixWorld), n = Vo.setFromMatrixPosition(e.matrixWorld), s = e.fov * Math.PI / 180, i = t.distanceTo(n);
    return 1 / (2 * Math.tan(s / 2) * i);
  } else
    return 1;
}
function Wp(r, e, t) {
  if (e instanceof kt || e instanceof _n) {
    const n = Rs.setFromMatrixPosition(r.matrixWorld), s = Vo.setFromMatrixPosition(e.matrixWorld), i = n.distanceTo(s), o = (t[1] - t[0]) / (e.far - e.near), a = t[1] - o * e.far;
    return Math.round(o * i + a);
  }
}
const bo = (r) => Math.abs(r) < 1e-10 ? 0 : r;
function wl(r, e, t = "") {
  let n = "matrix3d(";
  for (let s = 0; s !== 16; s++)
    n += bo(e[s] * r.elements[s]) + (s !== 15 ? "," : ")");
  return t + n;
}
const Xp = /* @__PURE__ */ ((r) => (e) => wl(e, r))([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]), $p = /* @__PURE__ */ ((r) => (e, t) => wl(e, r(t), "translate(-50%,-50%)"))((r) => [1 / r, 1 / r, 1 / r, 1, -1 / r, -1 / r, -1 / r, -1, 1 / r, 1 / r, 1 / r, 1, 1, 1, 1, 1]), Zp = ["geometry", "material"], Tv = /* @__PURE__ */ ue({
  __name: "HTML",
  props: {
    geometry: { default: new jt() },
    material: {},
    as: { default: "div" },
    transform: { type: Boolean, default: !1 },
    portal: {},
    wrapperClass: {},
    eps: { default: 1e-4 },
    distanceFactor: {},
    fullscreen: { type: Boolean },
    center: { type: Boolean },
    pointerEvents: { default: "auto" },
    sprite: { type: Boolean, default: !1 },
    zIndexRange: { default: () => [16777271, 0] },
    occlude: { type: [Object, null, Array, Boolean, String] }
  },
  emits: ["onOcclude"],
  setup(r, { expose: e, emit: t }) {
    const n = r, s = t, i = Io(), o = mc(), a = me(), l = me(), {
      geometry: c,
      material: f,
      as: u,
      transform: d,
      portal: h,
      wrapperClass: m,
      eps: g,
      distanceFactor: v,
      fullscreen: p,
      center: b,
      pointerEvents: _,
      sprite: M,
      occlude: R,
      zIndexRange: w
    } = Le(n), { renderer: E, scene: x, camera: T, raycaster: y, sizes: A } = xe(), C = Pe(() => document.createElement(u.value)), N = me([0, 0, 0]), U = me(0), Y = me(), V = Pe(() => d.value ? {
      position: "absolute",
      top: 0,
      left: 0,
      width: `${A.width.value}px`,
      height: `${A.height.value}px`,
      transformStyle: "preserve-3d",
      pointerEvents: "none",
      zIndex: 2
    } : {
      position: "absolute",
      transform: b.value ? "translate3d(-50%,-50%,0)" : "none",
      ...p.value && {
        top: -A.height.value / 2,
        left: -A.width.value / 2,
        width: `${A.width.value}px`,
        height: `${A.height.value}px`
      },
      zIndex: 2,
      ...Object.assign({}, o.style)
    }), ne = Pe(() => ({
      position: "absolute",
      pointerEvents: _.value
    })), Z = me(null), ee = me(!1), te = Pe(
      () => (R == null ? void 0 : R.value) && (R == null ? void 0 : R.value) !== "blending" || Array.isArray(R == null ? void 0 : R.value) && (R == null ? void 0 : R.value.length) && ii(R.value[0])
    );
    J(
      () => R,
      ({ value: B }) => {
        B === "blending" ? (C.value.style.zIndex = `${Math.floor(w.value[0] / 2)}`, C.value.style.position = "absolute", C.value.style.pointerEvents = "none") : (C.value.style.zIndex = null, C.value.style.position = null, C.value.style.pointerEvents = null);
      }
    ), J(
      () => {
        var B;
        return [a.value, E.value, A.width.value, A.height.value, (B = i.default) == null ? void 0 : B.call(i)];
      },
      ([B, D]) => {
        var O, z, S, P, L, X;
        if (B && D) {
          const H = (h == null ? void 0 : h.value) || D.domElement;
          if ((O = x.value) == null || O.updateMatrixWorld(), d.value)
            C.value.style.cssText = "position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";
          else {
            const j = sa(B, T.value, {
              width: A.width.value,
              height: A.height.value
            });
            C.value.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${j[0]}px,${j[1]}px,0);transform-origin:0 0;`;
          }
          H && !C.value.parentNode && ((z = H.parentNode) == null || z.appendChild(C.value)), d.value ? Y.value = ms("div", { id: "outer", style: V.value }, [
            ms("div", { id: "inner", style: ne.value }, [
              ms("div", {
                key: (S = l.value) == null ? void 0 : S.uuid,
                id: x == null ? void 0 : x.value.uuid,
                class: o.class,
                style: o.style
              }, (P = i.default) == null ? void 0 : P.call(i))
            ])
          ]) : Y.value = ms("div", {
            key: (L = l.value) == null ? void 0 : L.uuid,
            id: x == null ? void 0 : x.value.uuid,
            style: V.value
          }, (X = i.default) == null ? void 0 : X.call(i)), gc(Y.value, C.value);
        }
      }
    ), et(() => {
      m != null && m.value && (C.value.className = m.value);
    });
    const fe = me(!0), { onBeforeRender: he } = Ve();
    he(({ invalidate: B }) => {
      var D, O, z, S, P, L, X;
      if (B(), a.value && T.value && E.value) {
        (D = T.value) == null || D.updateMatrixWorld(), a.value.updateWorldMatrix(!0, !1);
        const H = d.value ? N.value : sa(a.value, T.value, {
          width: A.width.value || 0,
          height: A.height.value || 0
        });
        if (d.value || Math.abs(U.value - T.value.zoom) > g.value || Math.abs(N.value[0] - H[0]) > g.value || Math.abs(N.value[1] - H[1]) > g.value || Math.abs(N.value[2] - H[2]) > g.value) {
          const j = jp(a.value, T.value);
          let K = !1;
          te.value && (Array.isArray(R == null ? void 0 : R.value) ? K = R == null ? void 0 : R.value : (R == null ? void 0 : R.value) !== "blending" && (K = [x.value]));
          const se = fe.value;
          if (K) {
            const k = Vp(
              a.value,
              T.value,
              y.value,
              K
            );
            fe.value = k && !j;
          } else
            fe.value = !j;
          se !== fe.value && (s("onOcclude", !fe.value), C.value.style.display = fe.value ? "block" : "none");
          const ie = Math.floor(w.value[0] / 2), G = R != null && R.value ? te.value ? [w.value[0], ie] : [ie - 1, 0] : w.value;
          if (C.value.style.zIndex = `${Wp(a.value, T.value, G)}`, d.value) {
            const [k, oe] = [
              A.width.value / 2,
              A.height.value / 2
            ], ge = T.value.projectionMatrix.elements[5] * oe, { isOrthographicCamera: Re, top: Ke, left: He, bottom: Et, right: un } = T.value, En = Xp(T.value.matrixWorldInverse), Nt = Re ? `scale(${ge})translate(${bo(-(un + He) / 2)}px,${bo((Ke + Et) / 2)}px)` : `translateZ(${ge}px)`;
            let yt = a.value.matrixWorld;
            if (M.value && (yt = T.value.matrixWorldInverse.clone().transpose().copyPosition(yt).scale(a.value.scale), yt.elements[3] = yt.elements[7] = yt.elements[11] = 0, yt.elements[15] = 1), C.value.style.width = `${A.width.value}px`, C.value.style.height = `${A.height.value}px`, C.value.style.perspective = Re ? "" : `${ge}px`, (O = Y.value) != null && O.el && ((z = Y.value) != null && z.children) && Array.isArray(Y.value.children)) {
              Y.value.el.style.transform = `${Nt}${En}translate(${k}px,${oe}px)`;
              const Bt = Y.value.children[0];
              Bt && Bt.el && (Bt.el.style.transform = $p(
                yt,
                1 / (((v == null ? void 0 : v.value) || 10) / 400)
              ));
            }
          } else {
            const k = (v == null ? void 0 : v.value) === void 0 ? 1 : Yp(a.value, T.value) * (v == null ? void 0 : v.value);
            C.value.style.transform = `translate3d(${H[0]}px,${H[1]}px,0) scale(${k})`;
          }
        }
        N.value = H, U.value = T.value.zoom;
      }
      if (!te.value && l.value && !ee.value)
        if (d.value) {
          if ((S = Y.value) != null && S.el && ((P = Y.value) != null && P.children)) {
            const H = ((L = Y.value) == null ? void 0 : L.children)[0];
            if (H != null && H.clientWidth && (H != null && H.clientHeight)) {
              const { isOrthographicCamera: j } = T.value;
              if (j || c)
                o.scale && (Array.isArray(o.scale) ? o.scale instanceof $ ? l.value.scale.copy(o.scale.clone().divideScalar(1)) : l.value.scale.set(1 / o.scale[0], 1 / o.scale[1], 1 / o.scale[2]) : l.value.scale.setScalar(1 / o.scale));
              else {
                const K = ((v == null ? void 0 : v.value) || 10) / 400, se = H.clientWidth * K, ie = H.clientHeight * K;
                l.value.scale.set(se, ie, 1);
              }
              ee.value = !0;
            }
          }
        } else {
          const H = C.value.children[0];
          if (H != null && H.clientWidth && (H != null && H.clientHeight)) {
            const K = H.clientWidth * 1, se = H.clientHeight * 1;
            l.value.scale.set(K, se, 1), ee.value = !0;
          }
          Z.value.lookAt((X = T.value) == null ? void 0 : X.position);
        }
    });
    const we = Pe(() => ({
      vertexShader: d.value ? void 0 : Gp,
      fragmentShader: zp
    })), I = Pe(() => {
      const B = we.value;
      return f.value || new bt({
        vertexShader: B.vertexShader,
        fragmentShader: B.fragmentShader,
        side: on
      });
    });
    return tt(() => {
      I.value && I.value.dispose(), C.value.remove();
    }), e({ instance: a }), (B, D) => (ae(), ce("TresGroup", {
      ref_key: "groupRef",
      ref: a
    }, [
      F(R) && !te.value ? (ae(), ce("TresMesh", {
        key: 0,
        ref_key: "meshRef",
        ref: l,
        geometry: F(c),
        material: I.value
      }, null, 8, Zp)) : an("", !0)
    ], 512));
  }
});
var Js = { exports: {} }, Kp = Js.exports, ia;
function qp() {
  return ia || (ia = 1, function(r, e) {
    (function(t, n) {
      r.exports = n();
    })(Kp, function() {
      var t = function() {
        function n(h) {
          return o.appendChild(h.dom), h;
        }
        function s(h) {
          for (var m = 0; m < o.children.length; m++) o.children[m].style.display = m === h ? "block" : "none";
          i = h;
        }
        var i = 0, o = document.createElement("div");
        o.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", o.addEventListener("click", function(h) {
          h.preventDefault(), s(++i % o.children.length);
        }, !1);
        var a = (performance || Date).now(), l = a, c = 0, f = n(new t.Panel("FPS", "#0ff", "#002")), u = n(new t.Panel("MS", "#0f0", "#020"));
        if (self.performance && self.performance.memory) var d = n(new t.Panel("MB", "#f08", "#201"));
        return s(0), { REVISION: 16, dom: o, addPanel: n, showPanel: s, begin: function() {
          a = (performance || Date).now();
        }, end: function() {
          c++;
          var h = (performance || Date).now();
          if (u.update(h - a, 200), h > l + 1e3 && (f.update(1e3 * c / (h - l), 100), l = h, c = 0, d)) {
            var m = performance.memory;
            d.update(m.usedJSHeapSize / 1048576, m.jsHeapSizeLimit / 1048576);
          }
          return h;
        }, update: function() {
          a = this.end();
        }, domElement: o, setMode: s };
      };
      return t.Panel = function(n, s, i) {
        var o = 1 / 0, a = 0, l = Math.round, c = l(window.devicePixelRatio || 1), f = 80 * c, u = 48 * c, d = 3 * c, h = 2 * c, m = 3 * c, g = 15 * c, v = 74 * c, p = 30 * c, b = document.createElement("canvas");
        b.width = f, b.height = u, b.style.cssText = "width:80px;height:48px";
        var _ = b.getContext("2d");
        return _.font = "bold " + 9 * c + "px Helvetica,Arial,sans-serif", _.textBaseline = "top", _.fillStyle = i, _.fillRect(0, 0, f, u), _.fillStyle = s, _.fillText(n, d, h), _.fillRect(m, g, v, p), _.fillStyle = i, _.globalAlpha = 0.9, _.fillRect(m, g, v, p), { dom: b, update: function(M, R) {
          o = Math.min(o, M), a = Math.max(a, M), _.fillStyle = i, _.globalAlpha = 1, _.fillRect(0, 0, f, g), _.fillStyle = s, _.fillText(l(M) + " " + n + " (" + l(o) + "-" + l(a) + ")", d, h), _.drawImage(b, m + c, g, v - c, p, m, g, v - c, p), _.fillRect(m + v - c, g, c, p), _.fillStyle = i, _.globalAlpha = 0.9, _.fillRect(m + v - c, g, c, l((1 - M / R) * p));
        } };
      }, t;
    });
  }(Js)), Js.exports;
}
var Qp = qp();
const Jp = /* @__PURE__ */ Ps(Qp), bv = ue({
  name: "Stats",
  props: {
    showPanel: {
      type: Number,
      default: 0
    }
  },
  setup(r, { expose: e }) {
    const t = new Jp();
    e({ instance: t });
    const n = document.body;
    t.showPanel(r.showPanel || 0), n == null || n.appendChild(t.dom);
    const { onBeforeRender: s, onAfterRender: i } = Ve();
    s(() => t.begin(), Number.NEGATIVE_INFINITY), i(() => t.end(), Number.POSITIVE_INFINITY), tt(() => {
      n == null || n.removeChild(t.dom);
    });
  }
});
class em {
  constructor(e, t, n) {
    this.name = e, this.fg = t, this.bg = n, this.gradient = null, this.PR = Math.round(window.devicePixelRatio || 1), this.WIDTH = 90 * this.PR, this.HEIGHT = 48 * this.PR, this.TEXT_X = 3 * this.PR, this.TEXT_Y = 2 * this.PR, this.GRAPH_X = 3 * this.PR, this.GRAPH_Y = 15 * this.PR, this.GRAPH_WIDTH = 84 * this.PR, this.GRAPH_HEIGHT = 30 * this.PR, this.canvas = document.createElement("canvas"), this.canvas.width = this.WIDTH, this.canvas.height = this.HEIGHT, this.canvas.style.width = "90px", this.canvas.style.height = "48px", this.canvas.style.position = "absolute", this.canvas.style.cssText = "width:90px;height:48px", this.context = this.canvas.getContext("2d"), this.initializeCanvas();
  }
  createGradient() {
    if (!this.context)
      throw new Error("No context");
    const e = this.context.createLinearGradient(
      0,
      this.GRAPH_Y,
      0,
      this.GRAPH_Y + this.GRAPH_HEIGHT
    );
    let t;
    const n = this.fg;
    switch (this.fg.toLowerCase()) {
      case "#0ff":
        t = "#006666";
        break;
      case "#0f0":
        t = "#006600";
        break;
      case "#ff0":
        t = "#666600";
        break;
      case "#e1e1e1":
        t = "#666666";
        break;
      default:
        t = this.bg;
        break;
    }
    return e.addColorStop(0, t), e.addColorStop(1, n), e;
  }
  initializeCanvas() {
    this.context && (this.context.font = "bold " + 9 * this.PR + "px Helvetica,Arial,sans-serif", this.context.textBaseline = "top", this.gradient = this.createGradient(), this.context.fillStyle = this.bg, this.context.fillRect(0, 0, this.WIDTH, this.HEIGHT), this.context.fillStyle = this.fg, this.context.fillText(this.name, this.TEXT_X, this.TEXT_Y), this.context.fillStyle = this.fg, this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT), this.context.fillStyle = this.bg, this.context.globalAlpha = 0.9, this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT));
  }
  update(e, t, n, s, i = 0) {
    if (!this.context || !this.gradient)
      return;
    const o = Math.min(1 / 0, e), a = Math.max(n, e);
    s = Math.max(s, t), this.context.globalAlpha = 1, this.context.fillStyle = this.bg, this.context.fillRect(0, 0, this.WIDTH, this.GRAPH_Y), this.context.fillStyle = this.fg, this.context.fillText(
      `${e.toFixed(i)} ${this.name} (${o.toFixed(i)}-${parseFloat(
        a.toFixed(i)
      )})`,
      this.TEXT_X,
      this.TEXT_Y
    ), this.context.drawImage(
      this.canvas,
      this.GRAPH_X + this.PR,
      this.GRAPH_Y,
      this.GRAPH_WIDTH - this.PR,
      this.GRAPH_HEIGHT,
      this.GRAPH_X,
      this.GRAPH_Y,
      this.GRAPH_WIDTH - this.PR,
      this.GRAPH_HEIGHT
    );
    const l = this.GRAPH_HEIGHT - (1 - t / s) * this.GRAPH_HEIGHT;
    l > 0 && (this.context.globalAlpha = 1, this.context.fillStyle = this.gradient, this.context.fillRect(
      this.GRAPH_X + this.GRAPH_WIDTH - this.PR,
      this.GRAPH_Y + this.GRAPH_HEIGHT - l,
      this.PR,
      l
    ));
  }
}
const Tl = class Zn {
  constructor({
    trackGPU: e = !1,
    logsPerSecond: t = 30,
    samplesLog: n = 60,
    samplesGraph: s = 10,
    precision: i = 2,
    minimal: o = !1,
    horizontal: a = !0,
    mode: l = 0
  } = {}) {
    this.gl = null, this.ext = null, this.activeQuery = null, this.gpuQueries = [], this.threeRendererPatched = !1, this.frames = 0, this.renderCount = 0, this.isRunningCPUProfiling = !1, this.totalCpuDuration = 0, this.totalGpuDuration = 0, this.totalGpuDurationCompute = 0, this.totalFps = 0, this.gpuPanel = null, this.gpuPanelCompute = null, this.averageFps = { logs: [], graph: [] }, this.averageCpu = { logs: [], graph: [] }, this.averageGpu = { logs: [], graph: [] }, this.averageGpuCompute = { logs: [], graph: [] }, this.handleClick = (c) => {
      c.preventDefault(), this.showPanel(++this.mode % this.dom.children.length);
    }, this.handleResize = () => {
      this.resizePanel(this.fpsPanel, 0), this.resizePanel(this.msPanel, 1), this.gpuPanel && this.resizePanel(this.gpuPanel, 2), this.gpuPanelCompute && this.resizePanel(this.gpuPanelCompute, 3);
    }, this.mode = l, this.horizontal = a, this.minimal = o, this.trackGPU = e, this.samplesLog = n, this.samplesGraph = s, this.precision = i, this.logsPerSecond = t, this.dom = document.createElement("div"), this.initializeDOM(), this.beginTime = performance.now(), this.prevTime = this.beginTime, this.prevCpuTime = this.beginTime, this.fpsPanel = this.addPanel(new Zn.Panel("FPS", "#0ff", "#002"), 0), this.msPanel = this.addPanel(new Zn.Panel("CPU", "#0f0", "#020"), 1), this.setupEventListeners();
  }
  initializeDOM() {
    this.dom.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      opacity: 0.9;
      z-index: 10000;
      ${this.minimal ? "cursor: pointer;" : ""}
    `;
  }
  setupEventListeners() {
    this.minimal ? (this.dom.addEventListener("click", this.handleClick), this.showPanel(this.mode)) : window.addEventListener("resize", this.handleResize);
  }
  async init(e) {
    if (!e) {
      console.error('Stats: The "canvas" parameter is undefined.');
      return;
    }
    this.handleThreeRenderer(e) || await this.handleWebGPURenderer(e) || this.initializeWebGL(e);
  }
  handleThreeRenderer(e) {
    return e.isWebGLRenderer && !this.threeRendererPatched ? (this.patchThreeRenderer(e), this.gl = e.getContext(), this.trackGPU && this.initializeGPUTracking(), !0) : !1;
  }
  async handleWebGPURenderer(e) {
    return e.isWebGPURenderer ? (this.trackGPU && (e.backend.trackTimestamp = !0, await e.hasFeatureAsync("timestamp-query") && this.initializeWebGPUPanels()), this.info = e.info, !0) : !1;
  }
  initializeWebGPUPanels() {
    this.gpuPanel = this.addPanel(new Zn.Panel("GPU", "#ff0", "#220"), 2), this.gpuPanelCompute = this.addPanel(
      new Zn.Panel("CPT", "#e1e1e1", "#212121"),
      3
    );
  }
  initializeWebGL(e) {
    if (e instanceof WebGL2RenderingContext)
      this.gl = e;
    else if (e instanceof HTMLCanvasElement || e instanceof OffscreenCanvas) {
      if (this.gl = e.getContext("webgl2"), !this.gl)
        return console.error("Stats: Unable to obtain WebGL2 context."), !1;
    } else
      return console.error(
        "Stats: Invalid input type. Expected WebGL2RenderingContext, HTMLCanvasElement, or OffscreenCanvas."
      ), !1;
    return !0;
  }
  initializeGPUTracking() {
    this.gl && (this.ext = this.gl.getExtension("EXT_disjoint_timer_query_webgl2"), this.ext && (this.gpuPanel = this.addPanel(new Zn.Panel("GPU", "#ff0", "#220"), 2)));
  }
  begin() {
    this.isRunningCPUProfiling || this.beginProfiling("cpu-started"), !(!this.gl || !this.ext) && (this.activeQuery && this.gl.endQuery(this.ext.TIME_ELAPSED_EXT), this.activeQuery = this.gl.createQuery(), this.activeQuery && this.gl.beginQuery(this.ext.TIME_ELAPSED_EXT, this.activeQuery));
  }
  end() {
    this.renderCount++, this.gl && this.ext && this.activeQuery && (this.gl.endQuery(this.ext.TIME_ELAPSED_EXT), this.gpuQueries.push({ query: this.activeQuery }), this.activeQuery = null);
  }
  update() {
    this.info ? this.processWebGPUTimestamps() : this.processGpuQueries(), this.endProfiling("cpu-started", "cpu-finished", "cpu-duration"), this.updateAverages(), this.resetCounters();
  }
  processWebGPUTimestamps() {
    this.totalGpuDuration = this.info.render.timestamp, this.totalGpuDurationCompute = this.info.compute.timestamp, this.addToAverage(this.totalGpuDurationCompute, this.averageGpuCompute);
  }
  updateAverages() {
    this.addToAverage(this.totalCpuDuration, this.averageCpu), this.addToAverage(this.totalGpuDuration, this.averageGpu);
  }
  resetCounters() {
    this.renderCount = 0, this.totalCpuDuration === 0 && this.beginProfiling("cpu-started"), this.totalCpuDuration = 0, this.totalFps = 0, this.beginTime = this.endInternal();
  }
  resizePanel(e, t) {
    e.canvas.style.position = "absolute", this.minimal ? e.canvas.style.display = "none" : (e.canvas.style.display = "block", this.horizontal ? (e.canvas.style.top = "0px", e.canvas.style.left = t * e.WIDTH / e.PR + "px") : (e.canvas.style.left = "0px", e.canvas.style.top = t * e.HEIGHT / e.PR + "px"));
  }
  addPanel(e, t) {
    return e.canvas && (this.dom.appendChild(e.canvas), this.resizePanel(e, t)), e;
  }
  showPanel(e) {
    for (let t = 0; t < this.dom.children.length; t++) {
      const n = this.dom.children[t];
      n.style.display = t === e ? "block" : "none";
    }
    this.mode = e;
  }
  processGpuQueries() {
    !this.gl || !this.ext || (this.totalGpuDuration = 0, this.gpuQueries.forEach((e, t) => {
      if (this.gl) {
        const n = this.gl.getQueryParameter(e.query, this.gl.QUERY_RESULT_AVAILABLE), s = this.gl.getParameter(this.ext.GPU_DISJOINT_EXT);
        if (n && !s) {
          const o = this.gl.getQueryParameter(e.query, this.gl.QUERY_RESULT) * 1e-6;
          this.totalGpuDuration += o, this.gl.deleteQuery(e.query), this.gpuQueries.splice(t, 1);
        }
      }
    }));
  }
  endInternal() {
    this.frames++;
    const e = (performance || Date).now(), t = e - this.prevTime;
    if (e >= this.prevCpuTime + 1e3 / this.logsPerSecond) {
      const n = Math.round(this.frames * 1e3 / t);
      this.addToAverage(n, this.averageFps), this.updatePanel(this.fpsPanel, this.averageFps, 0), this.updatePanel(this.msPanel, this.averageCpu, this.precision), this.updatePanel(this.gpuPanel, this.averageGpu, this.precision), this.gpuPanelCompute && this.updatePanel(this.gpuPanelCompute, this.averageGpuCompute), this.frames = 0, this.prevCpuTime = e, this.prevTime = e;
    }
    return e;
  }
  addToAverage(e, t) {
    t.logs.push(e), t.logs.length > this.samplesLog && t.logs.shift(), t.graph.push(e), t.graph.length > this.samplesGraph && t.graph.shift();
  }
  beginProfiling(e) {
    window.performance && (window.performance.mark(e), this.isRunningCPUProfiling = !0);
  }
  endProfiling(e, t, n) {
    if (window.performance && t && this.isRunningCPUProfiling) {
      window.performance.mark(t);
      const s = performance.measure(n, e, t);
      this.totalCpuDuration += s.duration, this.isRunningCPUProfiling = !1;
    }
  }
  updatePanel(e, t, n = 2) {
    if (t.logs.length > 0) {
      let s = 0, i = 0.01;
      for (let l = 0; l < t.logs.length; l++)
        s += t.logs[l], t.logs[l] > i && (i = t.logs[l]);
      let o = 0, a = 0.01;
      for (let l = 0; l < t.graph.length; l++)
        o += t.graph[l], t.graph[l] > a && (a = t.graph[l]);
      e && e.update(s / Math.min(t.logs.length, this.samplesLog), o / Math.min(t.graph.length, this.samplesGraph), i, a, n);
    }
  }
  get domElement() {
    return this.dom;
  }
  patchThreeRenderer(e) {
    const t = e.render, n = this;
    e.render = function(s, i) {
      n.begin(), t.call(this, s, i), n.end();
    }, this.threeRendererPatched = !0;
  }
};
Tl.Panel = em;
let tm = Tl;
const Ev = ue({
  name: "StatsGl",
  props: [
    "logsPerSecond",
    "samplesLog",
    "samplesGraph",
    "precision",
    "horizontal",
    "minimal",
    "mode"
  ],
  setup(r, { expose: e }) {
    const t = new tm({
      logsPerSecond: r.logsPerSecond,
      samplesLog: r.samplesLog,
      samplesGraph: r.samplesGraph,
      precision: r.precision,
      horizontal: r.horizontal,
      minimal: r.minimal,
      mode: r.mode
    });
    e({ instance: t });
    const n = document.body, s = t.dom || t.container;
    n == null || n.appendChild(s);
    const { renderer: i } = xe(), { onAfterRender: o } = Ve();
    t.init(i.value), o(() => t.update(), Number.POSITIVE_INFINITY), tt(() => {
      n == null || n.removeChild(s);
    });
  }
}), { logError: nm } = xt();
async function Mv(r, e) {
  const t = new Uo(), n = (e == null ? void 0 : e.fileName) || "scene";
  t.parse(
    r,
    (s) => {
      if (s instanceof ArrayBuffer)
        im(s, `${n}.glb`);
      else {
        const i = JSON.stringify(s, null, 2);
        sm(i, `${n}.gltf`);
      }
    },
    (s) => {
      nm("An error happened while exporting the GLTF", s);
    },
    e
  );
}
function sm(r, e) {
  bl(new Blob([r], { type: "text/plain" }), e);
}
function im(r, e) {
  bl(new Blob([r], { type: "application/octet-stream" }), e);
}
function bl(r, e) {
  const t = document.createElement("a");
  t.style.display = "none", document.body.appendChild(t), t.href = URL.createObjectURL(r), t.download = e, t.click(), t.remove();
}
const om = ["args"], rm = ["color"], Sv = /* @__PURE__ */ ue({
  __name: "Box",
  props: {
    args: { default: () => [1, 1, 1] },
    color: { default: "#ffffff" }
  },
  setup(r, { expose: e }) {
    const t = r, { invalidate: n } = xe(), { args: s, color: i } = Le(t);
    J(s, () => n());
    const o = re();
    return e({
      instance: o
    }), (a, l) => (ae(), ce("TresMesh", $e({
      ref_key: "boxRef",
      ref: o
    }, a.$attrs), [
      ye("TresBoxGeometry", { args: F(s) }, null, 8, om),
      Ne(a.$slots, "default", {}, () => [
        ye("TresMeshBasicMaterial", { color: F(i) }, null, 8, rm)
      ])
    ], 16));
  }
}), am = ["object"], lm = /* @__PURE__ */ ue({
  __name: "Line2",
  props: {
    points: {},
    vertexColors: { default: null },
    color: { default: "white" },
    lineWidth: { default: 1 },
    worldUnits: { type: Boolean, default: !1 },
    alphaToCoverage: { type: Boolean, default: !1 },
    dashed: { type: Boolean, default: !1 },
    dashSize: { default: 1 },
    gapSize: { default: 1 },
    dashScale: { default: 1 },
    dashOffset: { default: 0 }
  },
  setup(r, { expose: e }) {
    const t = r;
    function n(h, m) {
      if (!h || h.length === 0)
        return Array.from({ length: m }).fill(tn(t.color));
      if (h.length === 1)
        return Array.from({ length: m }).fill(tn(h[0]));
      if (h.length === m)
        return h.map(tn);
      const g = m - 1, v = h.map(tn);
      closed && v.push(v[0].clone());
      const p = [v[0]], b = g / (v.length - 1);
      for (let _ = 1; _ < g; _++) {
        const M = _ % b / b, R = Math.floor(_ / b);
        p.push(v[R].clone().lerp(v[R + 1], M));
      }
      return p.push(v[v.length - 1]), p;
    }
    const s = new Ho(), i = new al(), o = new kf(i, s), { sizes: a, invalidate: l } = xe(), c = Pe(() => Array.isArray(t.vertexColors));
    function f(h, m) {
      h.color = tn(m.color), h.linewidth = m.lineWidth, h.alphaToCoverage = m.alphaToCoverage, h.worldUnits = m.worldUnits, h.vertexColors = Array.isArray(m.vertexColors), h.dashed = m.dashed, h.dashScale = m.dashScale, h.dashSize = m.dashSize, h.dashOffset = m.dashOffset, h.gapSize = m.gapSize, h.needsUpdate = !0;
    }
    function u(h, m, g) {
      const v = m.map((b) => b instanceof $ ? [b.x, b.y, b.z] : b instanceof ve ? [b.x, b.y, 0] : Array.isArray(b) && b.length === 2 ? [b[0], b[1], 0] : b).flat();
      h.setPositions(v.flat());
      const p = n(g, m.length).map((b) => b.toArray()).flat();
      h.setColors(p), o.computeLineDistances();
    }
    f(s, t), u(i, t.points, t.vertexColors), o.computeLineDistances(), J(() => [
      t.color,
      t.lineWidth,
      t.alphaToCoverage,
      t.worldUnits,
      c,
      t.dashed,
      t.dashScale,
      t.dashSize,
      t.dashOffset
    ], () => {
      f(s, t), l();
    }), J(() => [t.points, t.vertexColors], () => {
      u(i, t.points, t.vertexColors), l();
    }), J(() => [a.height, a.width], () => {
      s.resolution = new ve(a.width.value, a.height.value), l();
    }), tt(() => {
      i.dispose(), s.dispose();
    });
    const d = re();
    return e({ instance: d }), (h, m) => (ae(), ce("primitive", {
      ref: d.value,
      object: F(o)
    }, null, 8, am));
  }
}), Av = /* @__PURE__ */ ue({
  __name: "CatmullRomCurve3",
  props: {
    segments: { default: 20 },
    closed: { type: Boolean, default: !1 },
    curveType: { default: "centripetal" },
    tension: { default: 0.5 },
    points: {},
    vertexColors: {},
    color: {},
    lineWidth: {},
    alphaToCoverage: { type: Boolean },
    dashed: { type: Boolean },
    dashSize: {},
    dashScale: {},
    dashOffset: {},
    gapSize: {},
    worldUnits: { type: Boolean }
  },
  setup(r, { expose: e }) {
    const t = r;
    function n(l, c, f, u) {
      const d = l.map(
        (h) => h instanceof $ ? h : new $(...h)
      );
      return new lc(d, c, f, u);
    }
    function s(l, c) {
      return l.getPoints(c);
    }
    const i = Pe(() => n(t.points, t.closed, t.curveType, t.tension)), o = Pe(() => s(i.value, t.segments)), a = re();
    return e({ instance: a }), (l, c) => (ae(), Oo(lm, {
      ref: a.value,
      points: o.value,
      "vertex-colors": t.vertexColors,
      color: t.color,
      "line-width": t.lineWidth,
      "alpha-to-coverage": t.alphaToCoverage,
      dashed: t.dashed,
      "dash-size": t.dashSize,
      "dash-scale": t.dashScale,
      "dash-offset": t.dashOffset,
      "gap-size": t.gapSize,
      "world-units": t.worldUnits
    }, null, 8, ["points", "vertex-colors", "color", "line-width", "alpha-to-coverage", "dashed", "dash-size", "dash-scale", "dash-offset", "gap-size", "world-units"]));
  }
}), cm = ["args"], um = ["color"], Pv = /* @__PURE__ */ ue({
  __name: "Circle",
  props: {
    args: { default: () => [1, 32, 0, Math.PI * 2] },
    color: { default: "#ffffff" }
  },
  setup(r, { expose: e }) {
    const t = r, { args: n, color: s } = Le(t), { invalidate: i } = xe();
    J(n, () => i());
    const o = re();
    return e({
      instance: o
    }), (a, l) => (ae(), ce("TresMesh", $e({
      ref_key: "circleRef",
      ref: o
    }, a.$attrs), [
      ye("TresCircleGeometry", { args: F(n) }, null, 8, cm),
      Ne(a.$slots, "default", {}, () => [
        ye("TresMeshBasicMaterial", { color: F(s) }, null, 8, um)
      ])
    ], 16));
  }
}), hm = ["args"], fm = ["color"], Rv = /* @__PURE__ */ ue({
  __name: "Cone",
  props: {
    args: { default: () => [1, 1, 12, 12, !1, 0, Math.PI * 2] },
    color: { default: "#ffffff" }
  },
  setup(r, { expose: e }) {
    const t = r, { args: n, color: s } = Le(t), { invalidate: i } = xe();
    J(n, () => i());
    const o = re();
    return e({
      instance: o
    }), (a, l) => (ae(), ce("TresMesh", $e({
      ref_key: "coneRef",
      ref: o
    }, a.$attrs), [
      ye("TresConeGeometry", { args: F(n) }, null, 8, hm),
      Ne(a.$slots, "default", {}, () => [
        ye("TresMeshBasicMaterial", { color: F(s) }, null, 8, fm)
      ])
    ], 16));
  }
}), dm = ["args"], pm = ["color"], Cv = /* @__PURE__ */ ue({
  __name: "Cylinder",
  props: {
    args: { default: () => [1, 1, 1, 32, 1, !1, 0, Math.PI * 2] },
    color: { default: "#ffffff" }
  },
  setup(r, { expose: e }) {
    const t = r, { args: n, color: s } = Le(t), { invalidate: i } = xe();
    J(n, () => i());
    const o = re();
    return e({
      instance: o
    }), (a, l) => (ae(), ce("TresMesh", $e({
      ref_key: "cylinderRef",
      ref: o
    }, a.$attrs), [
      ye("TresCylinderGeometry", { args: F(n) }, null, 8, dm),
      Ne(a.$slots, "default", {}, () => [
        ye("TresMeshBasicMaterial", { color: F(s) }, null, 8, pm)
      ])
    ], 16));
  }
}), mm = ["args"], gm = ["color"], Iv = /* @__PURE__ */ ue({
  __name: "Dodecahedron",
  props: {
    args: { default: () => [1, 0] },
    color: { default: "#ffffff" }
  },
  setup(r, { expose: e }) {
    const t = r, { args: n, color: s } = Le(t), i = re(), { invalidate: o } = xe();
    return J(n, () => o()), e({
      instance: i
    }), (a, l) => (ae(), ce("TresMesh", $e({
      ref_key: "dodecahedronRef",
      ref: i
    }, a.$attrs), [
      ye("TresDodecahedronGeometry", { args: F(n) }, null, 8, mm),
      Ne(a.$slots, "default", {}, () => [
        ye("TresMeshBasicMaterial", { color: F(s) }, null, 8, gm)
      ])
    ], 16));
  }
}), vm = ["args"], ym = ["color"], Ov = /* @__PURE__ */ ue({
  __name: "Icosahedron",
  props: {
    args: { default: () => [1, 0] },
    color: { default: "#ffffff" }
  },
  setup(r, { expose: e }) {
    const t = r, { args: n, color: s } = Le(t), { invalidate: i } = xe();
    J(n, () => i());
    const o = re();
    return e({
      instance: o
    }), (a, l) => (ae(), ce("TresMesh", $e({
      ref_key: "icosahedronRef",
      ref: o
    }, a.$attrs), [
      ye("TresIcosahedronGeometry", { args: F(n) }, null, 8, vm),
      Ne(a.$slots, "default", {}, () => [
        ye("TresMeshBasicMaterial", { color: F(s) }, null, 8, ym)
      ])
    ], 16));
  }
}), _m = ["args"], xm = ["color"], Dv = /* @__PURE__ */ ue({
  __name: "Octahedron",
  props: {
    args: { default: () => [1, 0] },
    color: { default: "#ffffff" }
  },
  setup(r, { expose: e }) {
    const t = r, { args: n, color: s } = Le(t), { invalidate: i } = xe();
    J(n, () => i());
    const o = re();
    return e({
      instance: o
    }), (a, l) => (ae(), ce("TresMesh", $e({
      ref_key: "octahedronRef",
      ref: o
    }, a.$attrs), [
      ye("TresOctahedronGeometry", { args: F(n) }, null, 8, _m),
      Ne(a.$slots, "default", {}, () => [
        ye("TresMeshBasicMaterial", { color: F(s) }, null, 8, xm)
      ])
    ], 16));
  }
}), wm = ["rotation"], Tm = ["args"], bm = ["color"], Lv = /* @__PURE__ */ ue({
  __name: "Plane",
  props: {
    args: { default: () => [1, 1] },
    color: { default: "#ffffff" }
  },
  setup(r, { expose: e }) {
    const t = r, { args: n, color: s } = Le(t), { invalidate: i } = xe();
    J(n, () => i());
    const o = re();
    return e({
      instance: o
    }), (a, l) => (ae(), ce("TresMesh", $e({
      ref_key: "planeRef",
      ref: o,
      rotation: [-Math.PI / 2, 0, 0]
    }, a.$attrs), [
      ye("TresPlaneGeometry", { args: F(n) }, null, 8, Tm),
      Ne(a.$slots, "default", {}, () => [
        ye("TresMeshBasicMaterial", { color: F(s) }, null, 8, bm)
      ])
    ], 16, wm));
  }
}), Em = ["args"], Mm = ["color"], kv = /* @__PURE__ */ ue({
  __name: "Ring",
  props: {
    args: { default: () => [0.5, 1, 32] },
    color: { default: "#ffffff" }
  },
  setup(r, { expose: e }) {
    const t = r, { args: n, color: s } = Le(t), { invalidate: i } = xe();
    J(n, () => i());
    const o = re();
    return e({
      instance: o
    }), (a, l) => (ae(), ce("TresMesh", $e({
      ref_key: "ringRef",
      ref: o
    }, a.$attrs), [
      ye("TresRingGeometry", { args: F(n) }, null, 8, Em),
      Ne(a.$slots, "default", {}, () => [
        ye("TresMeshBasicMaterial", { color: F(s) }, null, 8, Mm)
      ])
    ], 16));
  }
}), Sm = ["args"], Am = ["color"], Nv = /* @__PURE__ */ ue({
  __name: "RoundedBox",
  props: {
    args: { default: () => [1, 1, 1, 2, 0.1] },
    color: { default: "#ffffff" }
  },
  setup(r, { expose: e }) {
    const t = r, { args: n, color: s } = Le(t), { invalidate: i, extend: o } = xe();
    o({ RoundedBoxGeometry: tf }), J(n, () => i());
    const a = re();
    return e({ instance: a }), (l, c) => (ae(), ce("TresMesh", {
      ref_key: "roundedBoxRef",
      ref: a
    }, [
      ye("TresRoundedBoxGeometry", { args: F(n) }, null, 8, Sm),
      Ne(l.$slots, "default", {}, () => [
        ye("TresMeshBasicMaterial", { color: F(s) }, null, 8, Am)
      ])
    ], 512));
  }
}), Pm = ["args"], Rm = ["color"], Bv = /* @__PURE__ */ ue({
  __name: "Sphere",
  props: {
    args: { default: () => [2, 32, 16] },
    color: { default: "#ffffff" }
  },
  setup(r, { expose: e }) {
    const t = r, { args: n, color: s } = Le(t), { invalidate: i } = xe();
    J(n, () => i());
    const o = re();
    return e({
      instance: o
    }), (a, l) => (ae(), ce("TresMesh", $e({
      ref_key: "sphereRef",
      ref: o
    }, a.$attrs), [
      ye("TresSphereGeometry", { args: F(n) }, null, 8, Pm),
      Ne(a.$slots, "default", {}, () => [
        ye("TresMeshBasicMaterial", { color: F(s) }, null, 8, Rm)
      ])
    ], 16));
  }
}), Cm = ["geometry"], Im = ["color"], Uv = /* @__PURE__ */ ue({
  __name: "Superformula",
  props: {
    widthSegments: { default: 32 },
    heightSegments: { default: 32 },
    numArmsA: { default: 4 },
    expA: { default: () => [40, 1.3, 0.9] },
    numArmsB: { default: 4 },
    expB: { default: () => [40, 1.3, 0.9] },
    color: { default: "white" }
  },
  setup(r, { expose: e }) {
    const t = r, { invalidate: n } = xe(), { cos: s, sin: i, abs: o } = Math, a = re(), l = re(t.color);
    function c(h, m) {
      const g = new ht(), v = h * m, p = new Float32Array(Array.from({ length: 3 * v }).fill(0)), b = new Float32Array(Array.from({ length: 3 * v }).fill(0)), _ = [];
      for (let M = 0; M < m - 1; M++) {
        for (let T = 0; T < h - 1; T++) {
          const y = M * h + T, A = y + 1, C = y + h, N = A + h;
          _.push(y, C, A), _.push(C, N, A);
        }
        const R = M * h + h - 1, w = M * h, E = R + h, x = w + h;
        _.push(R, E, w), _.push(E, x, w);
      }
      return g.setIndex(_), g.setAttribute("position", new ut(p, 3)), g.setAttribute("normal", new ut(b, 3)), g;
    }
    function f(h, m, g, v, p) {
      return (o(s(m * h * 0.25)) ** v + o(i(m * h * 0.25)) ** p) ** (-1 / g);
    }
    function u(h, m, g, v, p, b, _, M, R, w, E) {
      const x = 2 * Math.PI / w, T = -Math.PI, y = Math.PI / (E - 1), A = -0.5 * Math.PI, C = h.getAttribute("position");
      let N = 0, U = 0, Y = A;
      for (let V = 0; V < E; V++) {
        U = T;
        for (let ne = 0; ne < w; ne++) {
          const Z = f(U, m, g, v, p), ee = f(Y, b, _, M, R);
          C.setXYZ(
            N,
            Z * s(U) * ee * s(Y),
            ee * i(Y),
            Z * i(U) * ee * s(Y)
          ), N++, U += x;
        }
        Y += y;
      }
      C.needsUpdate = !0, h.computeVertexNormals();
    }
    J(() => t.color, () => l.value = t.color), J(() => [t.widthSegments, t.heightSegments], () => {
      a.value && a.value.dispose(), a.value = c(t.widthSegments, t.heightSegments), n();
    }, { immediate: !0 }), J(() => [
      t.numArmsA,
      t.expA[0],
      t.expA[1],
      t.expA[2],
      t.numArmsB,
      t.expB[0],
      t.expB[1],
      t.expB[2]
    ], () => {
      u(a.value, t.numArmsA, t.expA[0], t.expA[1], t.expA[2], t.numArmsB, t.expB[0], t.expB[1], t.expB[2], t.widthSegments, t.heightSegments), n();
    }, { immediate: !0 }), tt(() => {
      a.value && a.value.dispose();
    });
    const d = re();
    return e({
      instance: d
    }), (h, m) => (ae(), ce("TresMesh", $e({
      ref_key: "superformulaRef",
      ref: d
    }, h.$attrs, { geometry: a.value }), [
      Ne(h.$slots, "default", {}, () => [
        ye("TresMeshBasicMaterial", { color: l.value }, null, 8, Im)
      ])
    ], 16, Cm));
  }
}), Om = ["rotation"], Dm = ["args"], Lm = ["color"], Fv = /* @__PURE__ */ ue({
  __name: "Tetrahedron",
  props: {
    args: { default: () => [1, 0] },
    color: { default: "#ffffff" }
  },
  setup(r, { expose: e }) {
    const t = r, { args: n, color: s } = Le(t), i = re();
    return e({
      instance: i
    }), (o, a) => (ae(), ce("TresMesh", $e({
      ref_key: "tetrahedronRef",
      ref: i,
      rotation: [-Math.PI / 2, 0, 0]
    }, o.$attrs), [
      ye("TresTetrahedronGeometry", { args: F(n) }, null, 8, Dm),
      Ne(o.$slots, "default", {}, () => [
        ye("TresMeshBasicMaterial", { color: F(s) }, null, 8, Lm)
      ])
    ], 16, Om));
  }
}), km = ["args"], Nm = ["color"], zv = /* @__PURE__ */ ue({
  __name: "Torus",
  props: {
    args: { default: () => [1, 1, 16, 80] },
    color: { default: "#ffffff" }
  },
  setup(r, { expose: e }) {
    const t = r, { args: n, color: s } = Le(t), { invalidate: i } = xe();
    J(n, () => i());
    const o = re();
    return e({
      instance: o
    }), (a, l) => (ae(), ce("TresMesh", $e({
      ref_key: "torusRef",
      ref: o
    }, a.$attrs), [
      ye("TresTorusGeometry", { args: F(n) }, null, 8, km),
      Ne(a.$slots, "default", {}, () => [
        ye("TresMeshBasicMaterial", { color: F(s) }, null, 8, Nm)
      ])
    ], 16));
  }
}), Bm = ["args"], Um = ["color"], Gv = /* @__PURE__ */ ue({
  __name: "TorusKnot",
  props: {
    args: { default: () => [1, 0.4, 64, 8] },
    color: { default: "#ffffff" }
  },
  setup(r, { expose: e }) {
    const t = r, { args: n, color: s } = Le(t), { invalidate: i } = xe();
    J(n, () => i());
    const o = re();
    return e({
      instance: o
    }), (a, l) => (ae(), ce("TresMesh", $e({
      ref_key: "torusKnotRef",
      ref: o
    }, a.$attrs), [
      ye("TresTorusKnotGeometry", { args: F(n) }, null, 8, Bm),
      Ne(a.$slots, "default", {}, () => [
        ye("TresMeshBasicMaterial", { color: F(s) }, null, 8, Um)
      ])
    ], 16));
  }
}), Fm = ["args"], zm = ["color"], Hv = /* @__PURE__ */ ue({
  __name: "Tube",
  props: {
    args: { default: () => [
      new cc(new $(-1, 0, 0), new $(0, 1, 0), new $(1, 0, 0)),
      20,
      0.2,
      8,
      !1
    ] },
    color: { default: "#ffffff" }
  },
  setup(r, { expose: e }) {
    const t = r, { args: n, color: s } = Le(t), { invalidate: i } = xe();
    J(n, () => i());
    const o = re();
    return e({
      instance: o
    }), (a, l) => (ae(), ce("TresMesh", $e({
      ref_key: "tubeRef",
      ref: o
    }, a.$attrs), [
      ye("TresTubeGeometry", { args: F(n) }, null, 8, Fm),
      Ne(a.$slots, "default", {}, () => [
        ye("TresMeshBasicMaterial", { color: F(s) }, null, 8, zm)
      ])
    ], 16));
  }
}), jv = /* @__PURE__ */ ue({
  __name: "Align",
  props: {
    top: { type: Boolean },
    right: { type: Boolean },
    bottom: { type: Boolean },
    left: { type: Boolean },
    front: { type: Boolean },
    back: { type: Boolean },
    disable: { type: Boolean },
    disableX: { type: Boolean },
    disableY: { type: Boolean },
    disableZ: { type: Boolean },
    precise: { type: Boolean, default: !0 },
    onAlign: {},
    cacheKey: { default: void 0 }
  },
  setup(r, { expose: e }) {
    const t = r, n = re(), s = re(), i = re(), o = new _t(), a = new $(), l = new Ms();
    function c() {
      if (!s.value || !i.value || !n.value)
        return;
      s.value.matrixWorld.identity(), o.setFromObject(i.value, t.precise);
      const h = o.max.x - o.min.x, m = o.max.y - o.min.y, g = o.max.z - o.min.z;
      o.getCenter(a), o.getBoundingSphere(l);
      const v = t.top ? m / 2 : t.bottom ? -m / 2 : 0, p = t.left ? -h / 2 : t.right ? h / 2 : 0, b = t.front ? g / 2 : t.back ? -g / 2 : 0;
      s.value.position.set(
        t.disable || t.disableX ? 0 : -a.x + p,
        t.disable || t.disableY ? 0 : -a.y + v,
        t.disable || t.disableZ ? 0 : -a.z + b
      ), typeof t.onAlign < "u" && t.onAlign({
        parent: n.value.parent,
        container: n.value,
        width: h,
        height: m,
        depth: g,
        boundingBox: o,
        boundingSphere: l,
        center: a,
        verticalAlignment: v,
        horizontalAlignment: p,
        depthAlignment: b
      });
    }
    let f = null, u = null;
    const d = Ve();
    return et(() => {
      f == null || f(), f = null;
      const h = ze(t.cacheKey);
      h === u && u !== null && u !== void 0 || (u = h, t.cacheKey === null || t.cacheKey === void 0 ? f = d.onBeforeRender(() => {
        c();
      }).off : c());
    }), e({ instance: n, update: c }), (h, m) => (ae(), ce("TresGroup", {
      ref_key: "ref",
      ref: n
    }, [
      ye("TresGroup", {
        ref_key: "outer",
        ref: s
      }, [
        ye("TresGroup", {
          ref_key: "inner",
          ref: i
        }, [
          Ne(h.$slots, "default")
        ], 512)
      ], 512)
    ], 512));
  }
}), Gm = ["receive-shadow", "rotation"], Hm = ["args"], Vv = /* @__PURE__ */ ue({
  __name: "Backdrop",
  props: {
    floor: { default: 0.25 },
    segments: { default: 20 },
    receiveShadow: { type: Boolean, default: !1 }
  },
  setup(r, { expose: e }) {
    const t = r, n = (c) => c === 0 ? 0 : 2 ** (10 * c - 10), { floor: s, segments: i, receiveShadow: o } = Le(t), a = me(null);
    J(
      [i, s, a],
      ([c, f, u]) => {
        if (!u || c === null)
          return;
        let d = 0;
        const h = c / c / 2, m = u.attributes.position;
        for (let g = 0; g < c + 1; g++)
          for (let v = 0; v < c + 1; v++)
            m.setXYZ(
              d++,
              g / c - h + (g === 0 ? -f : 0),
              v / c - h,
              n(g / c)
            );
        m.needsUpdate = !0, u.computeVertexNormals();
      }
    );
    const l = re();
    return e({ instance: l }), (c, f) => (ae(), ce("TresGroup", $e({
      ref_key: "backdropRef",
      ref: l
    }, c.$attrs), [
      ye("TresMesh", {
        "receive-shadow": F(o),
        rotation: [-Math.PI / 2, 0, Math.PI / 2]
      }, [
        ye("TresPlaneGeometry", {
          ref_key: "planeRef",
          ref: a,
          args: [1, 1, F(i), F(i)]
        }, null, 8, Hm),
        Ne(c.$slots, "default", {}, () => [
          f[0] || (f[0] = ye("TresMeshStandardMaterial", {
            color: 8421504,
            side: 2
          }, null, -1))
        ])
      ], 8, Gm)
    ], 16));
  }
}), jm = ["object"], Yv = /* @__PURE__ */ ue({
  __name: "ContactShadows",
  props: {
    opacity: { default: 1 },
    blur: { default: 1 },
    color: { default: "#000000" },
    tint: { default: void 0 },
    scale: { default: 10 },
    width: { default: 1 },
    height: { default: 1 },
    far: { default: 10 },
    smooth: { type: Boolean, default: !0 },
    resolution: { default: 512 },
    frames: { default: Number.POSITIVE_INFINITY },
    depthWrite: { type: Boolean, default: !1 }
  },
  setup(r, { expose: e }) {
    const t = r;
    function n(h, m, g) {
      g.blurPlane.visible = !0, g.blurPlane.material = g.horizontalBlurMaterial, g.horizontalBlurMaterial.uniforms.tDiffuse.value = g.renderTarget.texture, g.horizontalBlurMaterial.uniforms.h.value = h / 256, m.setRenderTarget(g.renderTargetBlur), m.render(g.blurPlane, g.shadowCamera), g.blurPlane.material = g.verticalBlurMaterial, g.verticalBlurMaterial.uniforms.tDiffuse.value = g.renderTargetBlur.texture, g.verticalBlurMaterial.uniforms.v.value = h / 256, m.setRenderTarget(g.renderTarget), m.render(g.blurPlane, g.shadowCamera), g.blurPlane.visible = !1;
    }
    function s(h, m, g, v) {
      const {
        renderTarget: p,
        shadowCamera: b,
        depthMaterial: _
      } = v, M = m.background;
      m.background = null, m.overrideMaterial = _;
      const R = g.getClearAlpha();
      g.setClearAlpha(0), g.setRenderTarget(p), g.render(m, b), m.overrideMaterial = null, n(h.blur, g, v), h.smooth && n(h.blur * 0.4, g, v), g.setRenderTarget(null), g.setClearAlpha(R), m.background = M;
    }
    function i(h) {
      const m = new Zt(), g = new Xt(h.resolution, h.resolution);
      g.texture.generateMipmaps = !1;
      const v = new Xt(h.resolution, h.resolution);
      v.texture.generateMipmaps = !1;
      const p = new jt(h.width, h.height).rotateX(Math.PI / 2), b = new $t({
        map: g.texture,
        opacity: h.opacity,
        transparent: !0,
        depthWrite: h.depthWrite,
        color: new be(h.color ?? "black")
      }), _ = new de(p, b);
      m.add(_), _.scale.y = -1;
      const M = new de(p);
      M.visible = !1, m.add(M);
      const R = new _n(-h.width / 2, h.width / 2, h.height / 2, -h.height / 2, 0, 0.3);
      R.rotation.x = Math.PI / 2, m.add(R);
      const w = new Ko(), E = new bt(nf);
      E.depthTest = !1;
      const x = new bt(sf);
      return x.depthTest = !1, {
        renderTarget: g,
        renderTargetBlur: v,
        shadowCamera: R,
        depthMaterial: w,
        horizontalBlurMaterial: E,
        verticalBlurMaterial: x,
        shadowGroup: m,
        plane: _,
        blurPlane: M
      };
    }
    function o(h, m) {
      const g = m.shadowCamera;
      g.left = -h.width / 2, g.right = h.width / 2, g.top = h.height / 2, g.bottom = -h.height / 2, g.far = h.far;
      const v = h.width * (Array.isArray(h.scale) ? h.scale[0] : h.scale || 1), p = h.height * (Array.isArray(h.scale) ? h.scale[1] : h.scale || 1);
      m.shadowGroup.scale.set(v, h.far, p);
    }
    function a(h, m) {
      m.renderTarget.dispose(), m.renderTargetBlur.dispose(), m.renderTarget = new Xt(h, h), m.renderTarget.texture.generateMipmaps = !1, m.renderTargetBlur = new Xt(h, h), m.renderTargetBlur.texture.generateMipmaps = !1, m.plane.material.map = m.renderTarget.texture;
    }
    function l(h, m) {
      m.plane.material.color = new be(h.color ?? "black"), m.depthMaterial.dispose(), m.depthMaterial = new Ko(), m.depthMaterial.onBeforeCompile = function(g) {
        const v = h.tint ? new be(h.tint) : new be("white"), { r: p, g: b, b: _ } = v, M = g.fragmentShader.replace(
          "gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );",
          `gl_FragColor = vec4( ${p}, ${b}, ${_}, ( 1.0 - fragCoordZ ) * opacity);`
        );
        g.fragmentShader = M;
      };
    }
    const { onBeforeRender: c } = Ve(), f = i(t);
    let u = 0;
    const d = () => u = u >= t.frames ? t.frames - 1 : u;
    return c(
      ({ renderer: h, scene: m, invalidate: g }) => {
        u < t.frames && (u++, s(t, m, h, f), g());
      }
    ), J(() => [t.opacity, t.depthWrite, t.blur, t.smooth], () => {
      f.plane.material.opacity = t.opacity ?? 1, f.plane.material.depthWrite = t.depthWrite ?? !1, d();
    }, { immediate: !0 }), J(() => [t.color, t.tint], () => {
      l(t, f), d();
    }, { immediate: !0 }), J(() => [t.resolution], () => {
      a(t.resolution, f), d();
    }), J(() => [t.width, t.height, t.scale, t.far], () => {
      o(t, f), d();
    }, { immediate: !0 }), tt(() => {
      for (const h of Object.values(f))
        h && "dispose" in h && typeof h.dispose == "function" && h.dispose();
    }), e({ instance: f.shadowGroup }), (h, m) => (ae(), ce("primitive", {
      object: F(f).shadowGroup
    }, null, 8, jm));
  }
}), Wv = /* @__PURE__ */ ue({
  __name: "Fit",
  props: {
    into: { default: () => new _t(new $(-0.5, -0.5, -0.5), new $(0.5, 0.5, 0.5)) },
    precise: { type: Boolean, default: !1 }
  },
  setup(r, { expose: e }) {
    const t = r, { invalidate: n } = xe(), s = re(new Zt()), i = re(new Zt());
    function o(c, f) {
      if (s.value.position.set(0, 0, 0), s.value.updateMatrixWorld(), i.value.scale.set(1, 1, 1), i.value.updateMatrixWorld(), !i.value.children.length || c === null)
        return;
      const { box3: u, use: d } = a(c, f), h = new _t();
      i.value.children.forEach((b) => h.expandByObject(b, f));
      const m = h.getSize(new $()), g = u.getSize(new $()), v = Math.min(
        g.x / m.x,
        g.y / m.y,
        g.z / m.z
      );
      i.value.scale.setScalar(v === Number.POSITIVE_INFINITY ? 1 : v), i.value.updateMatrixWorld();
      const p = s.value.worldToLocal(h.getCenter(new $()));
      if (d.position) {
        const b = s.value.worldToLocal(u.getCenter(new $()));
        s.value.position.copy(b.sub(p.multiplyScalar(v)));
      } else
        s.value.position.copy(p.sub(p.multiplyScalar(v)));
      n();
    }
    function a(c, f) {
      return typeof c == "number" ? c = new $(c, c, c) : Array.isArray(c) && (c = new $(...c)), c && "isVector3" in c && c.isVector3 ? { box3: new _t(new $(0, 0, 0), c), use: { position: !1 } } : c && "isBox3" in c && c.isBox3 ? { box3: c, use: { position: !0 } } : c && "isObject3D" in c && c.isObject3D ? { box3: new _t().setFromObject(c, f ?? !1), use: { position: !0 } } : {
        box3: new _t(new $(-0.5, -0.5, -0.5), new $(0.5, 0.5, 0.5)),
        use: { position: !0 }
      };
    }
    J(() => [t.into, t.precise], () => o(t.into, t.precise)), bn(() => {
      o(t.into, t.precise), Ro().then(() => {
        o(t.into, t.precise);
      });
    });
    const l = re();
    return e({
      instance: l,
      fit: (c = new _t(new $(-0.5, -0.5, -0.5), new $(0.5, 0.5, 0.5)), f = !1) => {
        o(c, f);
      },
      update: () => o(t.into, t.precise)
    }), (c, f) => (ae(), ce("TresGroup", {
      ref_key: "outer",
      ref: l
    }, [
      ye("TresGroup", {
        ref_key: "middle",
        ref: s
      }, [
        ye("TresGroup", {
          ref_key: "inner",
          ref: i
        }, [
          Ne(c.$slots, "default")
        ], 512)
      ], 512)
    ], 512));
  }
}), Vm = ["side", "cell-size", "section-size", "cell-color", "section-color", "cell-thickness", "section-thickness", "fade-distance", "fade-strength", "fade-from", "infinite-grid", "follow-camera"], Ym = ["args"], Xv = /* @__PURE__ */ ue({
  __name: "Grid",
  props: {
    cellSize: { default: 0.5 },
    cellThickness: { default: 0.5 },
    cellColor: { default: "#000000" },
    sectionSize: { default: 1 },
    sectionThickness: { default: 1 },
    sectionColor: { default: "#0000ff" },
    followCamera: { type: Boolean, default: !1 },
    infiniteGrid: { type: Boolean, default: !1 },
    fadeDistance: { default: 100 },
    fadeStrength: { default: 1 },
    fadeFrom: { default: 1 },
    side: { default: li },
    args: {}
  },
  setup(r) {
    const e = r, t = No(
      {
        cellSize: 0.5,
        sectionSize: 1,
        fadeDistance: 100,
        fadeStrength: 1,
        fadeFrom: 1,
        cellThickness: 0.5,
        sectionThickness: 1,
        cellColor: new be(),
        sectionColor: new be(),
        infiniteGrid: !1,
        followCamera: !1,
        worldCamProjPosition: new $(),
        worldPlanePosition: new $()
      },
      /* glsl */
      `
    varying vec3 localPosition;
    varying vec4 worldPosition;

    uniform vec3 worldCamProjPosition;
    uniform vec3 worldPlanePosition;
    uniform float fadeDistance;
    uniform bool infiniteGrid;
    uniform bool followCamera;

    void main() {
      localPosition = position.xzy;
      if (infiniteGrid) localPosition *= 1.0 + fadeDistance;
      
      worldPosition = modelMatrix * vec4(localPosition, 1.0);
      if (followCamera) {
        worldPosition.xyz += (worldCamProjPosition - worldPlanePosition);
        localPosition = (inverse(modelMatrix) * worldPosition).xyz;
      }

      gl_Position = projectionMatrix * viewMatrix * worldPosition;
    }
  `,
      /* glsl */
      `
    varying vec3 localPosition;
    varying vec4 worldPosition;

    uniform vec3 worldCamProjPosition;
    uniform float cellSize;
    uniform float sectionSize;
    uniform vec3 cellColor;
    uniform vec3 sectionColor;
    uniform float fadeDistance;
    uniform float fadeStrength;
    uniform float fadeFrom;
    uniform float cellThickness;
    uniform float sectionThickness;

    float getGrid(float size, float thickness) {
      vec2 r = localPosition.xz / size;
      vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);
      float line = min(grid.x, grid.y) + 1.0 - thickness;
      return 1.0 - min(line, 1.0);
    }

    void main() {
      float g1 = getGrid(cellSize, cellThickness);
      float g2 = getGrid(sectionSize, sectionThickness);

      vec3 from = worldCamProjPosition*vec3(fadeFrom);
      float dist = distance(from, worldPosition.xyz);
      float d = 1.0 - min(dist / fadeDistance, 1.0);
      vec3 color = mix(cellColor, sectionColor, min(1.0, sectionThickness * g2));

      gl_FragColor = vec4(color, (g1 + g2) * pow(d, fadeStrength));
      gl_FragColor.a = mix(0.75 * gl_FragColor.a, gl_FragColor.a, g2);
      if (gl_FragColor.a <= 0.0) discard;

      #include <tonemapping_fragment>
      #include <colorspace_fragment>
    }
  `
    );
    Oa({ GridMaterial: t });
    const n = re(new de()), s = new bs(), i = new $(0, 1, 0), o = new $(0, 0, 0);
    return Ve().onBeforeRender((a) => {
      s.setFromNormalAndCoplanarPoint(i, o).applyMatrix4(n.value.matrixWorld);
      const l = n.value.material, c = l.uniforms.worldCamProjPosition, f = l.uniforms.worldPlanePosition;
      s.projectPoint(a.camera.position, c.value), f.value.set(0, 0, 0).applyMatrix4(n.value.matrixWorld);
    }), (a, l) => (ae(), ce("TresMesh", {
      ref_key: "ref",
      ref: n,
      "frustum-culled": !1
    }, [
      ye("TresGridMaterial", {
        transparent: !0,
        "extensions-derivatives": !0,
        side: e.side,
        "cell-size": e.cellSize,
        "section-size": e.sectionSize,
        "cell-color": e.cellColor,
        "section-color": e.sectionColor,
        "cell-thickness": e.cellThickness,
        "section-thickness": e.sectionThickness,
        "fade-distance": e.fadeDistance,
        "fade-strength": e.fadeStrength,
        "fade-from": e.fadeFrom,
        "infinite-grid": e.infiniteGrid,
        "follow-camera": e.followCamera
      }, null, 8, Vm),
      ye("TresPlaneGeometry", {
        args: e.args
      }, null, 8, Ym)
    ], 512));
  }
}), Wm = ["rotation-x", "args"], $v = /* @__PURE__ */ ue({
  __name: "Ocean",
  props: {
    textureWidth: { default: 512 },
    textureHeight: { default: 512 },
    waterNormals: { default: "https://raw.githubusercontent.com/Tresjs/assets/main/textures/water-normals/Water_1_M_Normal.jpg" },
    sunDirection: { default: () => new $() },
    sunColor: { default: 16777215 },
    waterColor: { default: 7695 },
    distortionScale: { default: 3.7 },
    size: { default: 1 },
    clipBias: { default: 0 },
    alpha: { default: 1 },
    side: { default: ss }
  },
  async setup(r, { expose: e }) {
    let t, n;
    const s = r, { textureWidth: i, textureHeight: o, waterNormals: a, sunDirection: l, sunColor: c, waterColor: f, distortionScale: u, size: d, clipBias: h, alpha: m, side: g } = Le(s), { extend: v, scene: p } = xe();
    v({ Water: th });
    const b = re(), _ = re(), M = p.value.fog !== void 0;
    e({
      instance: b
    }), p.value.traverse((E) => {
      Object.prototype.hasOwnProperty.call(E, "isSky") && (_.value = E);
    }), bn(async () => {
      if (await Ro(), _.value) {
        const E = _.value.material.uniforms.sunPosition.value;
        b.value.material.uniforms.sunDirection.value.copy(E);
      }
    });
    const { normalMap: R } = ([t, n] = Tn(() => Bn({ normalMap: a.value })), t = await t, n(), t);
    R.wrapS = R.wrapT = Ln;
    const { onBeforeRender: w } = Ve();
    return w(({ delta: E, invalidate: x }) => {
      b.value.material.uniforms.time.value += E, x();
    }), (E, x) => (ae(), ce("TresWater", {
      ref_key: "waterRef",
      ref: b,
      "rotation-x": -Math.PI / 2,
      args: [void 0, {
        textureWidth: F(i),
        textureHeight: F(o),
        waterNormals: F(R),
        sunDirection: F(l),
        sunColor: F(c),
        waterColor: F(f),
        distortionScale: F(u),
        fog: M,
        size: F(d),
        clipBias: F(h),
        alpha: F(m),
        side: F(g)
      }]
    }, [
      Ne(E.$slots, "default", {}, () => [
        x[0] || (x[0] = ye("TresPlaneGeometry", { args: [1e4, 1e4] }, null, -1))
      ])
    ], 8, Wm));
  }
}), Xm = ["size", "color", "alpha-map", "map", "opacity", "alpha-test", "depth-write", "transparent", "size-attenuation"], $m = ["position", "velocity"], Zv = /* @__PURE__ */ ue({
  __name: "Precipitation",
  props: {
    size: { default: 0.1 },
    area: { default: () => [10, 10, 20] },
    color: { default: 16777215 },
    map: {},
    alphaMap: {},
    alphaTest: { default: 0.01 },
    opacity: { default: 0.8 },
    count: { default: 5e3 },
    speed: { default: 0.1 },
    randomness: { default: 0.5 },
    depthWrite: { type: Boolean, default: !1 },
    transparent: { type: Boolean, default: !0 },
    sizeAttenuation: { type: Boolean, default: !0 }
  },
  setup(r, { expose: e }) {
    const t = r, {
      size: n,
      area: s,
      color: i,
      alphaMap: o,
      map: a,
      opacity: l,
      alphaTest: c,
      depthWrite: f,
      transparent: u,
      sizeAttenuation: d,
      count: h,
      speed: m,
      randomness: g
    } = Le(t), v = re();
    let p = [], b = [];
    const _ = () => {
      p = new Float32Array(h.value * 3);
      for (let T = 0; T < h.value; T++) {
        const y = T * 3;
        p[y] = (Math.random() - 0.5) * s.value[0], p[y + 1] = (Math.random() - 0.5) * s.value[1], p[y + 2] = (Math.random() - 0.5) * s.value[2];
      }
    }, M = () => {
      b = new Float32Array(h.value * 2);
      for (let T = 0; T < h.value * 2; T += 2)
        b[T] = (Math.random() - 0.5) / 5 * m.value * g.value, b[T + 1] = Math.random() / 5 * m.value;
    };
    M(), _(), et(() => {
      M(), _();
    });
    const R = re(null), w = re(null);
    et(async () => {
      et(async () => {
        if (typeof o.value == "string") {
          const T = await Bn({ alphaMap: o.value });
          R.value = T.alphaMap;
        } else
          R.value = o.value ?? null;
        if (typeof a.value == "string") {
          const T = await Bn({ map: a.value });
          w.value = T.map;
        } else
          w.value = a.value ?? null;
      });
    });
    const { onBeforeRender: E } = Ve();
    E(({ invalidate: T }) => {
      var y, A;
      if ((y = v.value) != null && y.attributes.position.array && ((A = v.value) != null && A.attributes.position.count)) {
        const C = v.value.attributes.position.array;
        for (let N = 0; N < v.value.attributes.position.count; N++) {
          const U = b[N * 2], Y = b[N * 2 + 1];
          C[N * 3] += U, C[N * 3 + 1] -= Y, (C[N * 3] <= -s.value[0] / 2 || C[N * 3] >= s.value[0] / 2) && (C[N * 3] = C[N * 3] * -1), (C[N * 3 + 1] <= -s.value[1] / 2 || C[N * 3 + 1] >= s.value[1] / 2) && (C[N * 3 + 1] = C[N * 3 + 1] * -1);
        }
        v.value.attributes.position.needsUpdate = !0, T();
      }
    });
    const x = re();
    return e({ instance: x }), (T, y) => (ae(), ce("TresPoints", {
      ref_key: "pointsRef",
      ref: x
    }, [
      ye("TresPointsMaterial", {
        size: F(n),
        color: F(i),
        "alpha-map": R.value,
        map: w.value,
        opacity: F(l),
        "alpha-test": F(c),
        "depth-write": F(f),
        transparent: F(u),
        "size-attenuation": F(d)
      }, null, 8, Xm),
      ye("TresBufferGeometry", {
        ref_key: "geometryRef",
        ref: v,
        position: [F(p), 3],
        velocity: [F(b)]
      }, null, 8, $m)
    ], 512));
  }
}), Zm = ["object", "material-uniforms-turbidity-value", "material-uniforms-rayleigh-value", "material-uniforms-mieCoefficient-value", "material-uniforms-mieDirectionalG-value", "material-uniforms-sunPosition-value", "scale"], Kv = /* @__PURE__ */ ue({
  __name: "Sky",
  props: {
    turbidity: { default: 3.4 },
    rayleigh: { default: 3 },
    mieCoefficient: { default: 5e-3 },
    mieDirectionalG: { default: 0.7 },
    elevation: { default: 0.6 },
    azimuth: { default: 180 },
    distance: { default: 45e4 }
  },
  setup(r, { expose: e }) {
    const t = r, { invalidate: n } = xe();
    J(t, () => n());
    const s = re(), i = new Fo(), o = Pe(
      () => a(t.azimuth, t.elevation)
    );
    function a(l, c) {
      const f = Ye.degToRad(90 - c), u = Ye.degToRad(l);
      return new $().setFromSphericalCoords(1, f, u);
    }
    return e({
      instance: s,
      sunPosition: o.value
    }), (l, c) => (ae(), ce("primitive", {
      ref_key: "skyRef",
      ref: s,
      object: F(i),
      "material-uniforms-turbidity-value": t.turbidity,
      "material-uniforms-rayleigh-value": t.rayleigh,
      "material-uniforms-mieCoefficient-value": t.mieCoefficient,
      "material-uniforms-mieDirectionalG-value": t.mieDirectionalG,
      "material-uniforms-sunPosition-value": o.value,
      scale: t.distance
    }, null, 8, Zm));
  }
}), Km = ["position"], qm = ["position"], Qm = ["scale"], Jm = ["map", "depth-test", "color-space", "color", "opacity"], qv = /* @__PURE__ */ ue({
  __name: "Smoke",
  props: {
    color: { default: "#ffffff" },
    opacity: { default: 0.5 },
    speed: { default: 0.4 },
    width: { default: 10 },
    depth: { default: 1.5 },
    segments: { default: 20 },
    texture: { default: "https://raw.githubusercontent.com/Tresjs/assets/main/textures/clouds/defaultCloud.png" },
    depthTest: { type: Boolean, default: !0 }
  },
  async setup(r, { expose: e }) {
    let t, n;
    const s = r, { width: i, depth: o, segments: a, texture: l, color: c, depthTest: f, opacity: u, speed: d } = Le(s), h = re(), m = re();
    e({
      instance: h
    });
    const g = [a].map((w, E) => ({
      x: i.value / 2 - Math.random() * i.value,
      y: i.value / 2 - Math.random() * i.value,
      scale: 0.4 + Math.sin((E + 1) / a.value * Math.PI) * ((0.2 + Math.random()) * 10),
      density: Math.max(0.2, Math.random()),
      rotation: Math.max(2e-3, 5e-3 * Math.random()) * d.value
    })), v = (w, E) => w / 6 * E * u.value, { map: p } = ([t, n] = Tn(() => Bn({ map: l.value })), t = await t, n(), t), { renderer: b, camera: _ } = xe(), M = Pe(() => {
      var w;
      return (w = b.value) == null ? void 0 : w.outputColorSpace;
    }), { onBeforeRender: R } = Ve();
    return R(({ invalidate: w }) => {
      var E, x;
      h.value && _.value && m.value && ((E = m.value) == null || E.children.forEach((T, y) => {
        T.rotation.z += g[y].rotation;
      }), h.value.lookAt((x = _.value) == null ? void 0 : x.position), w());
    }), (w, E) => (ae(), ce("TresGroup", $e({
      ref_key: "smokeRef",
      ref: h
    }, w.$attrs), [
      ye("TresGroup", {
        ref_key: "groupRef",
        ref: m,
        position: [0, 0, F(a) / 2 * F(o)]
      }, [
        (ae(!0), ce(Ra, null, Ca(F(g), ({ scale: x, x: T, y, density: A }, C) => (ae(), ce("TresMesh", {
          key: `${C}`,
          position: [T, y, -C * F(o)]
        }, [
          ye("TresPlaneGeometry", {
            scale: [x, x, x],
            rotation: [0, 0, 0]
          }, null, 8, Qm),
          ye("TresMeshStandardMaterial", {
            map: F(p),
            "depth-test": F(f),
            "color-space": M.value,
            color: F(c),
            "depth-write": !1,
            transparent: "",
            opacity: v(x, A)
          }, null, 8, Jm)
        ], 8, qm))), 128))
      ], 8, Km)
    ], 16));
  }
}), eg = `
return PCSS( shadowMap, shadowCoord );
`, Qv = /* @__PURE__ */ ue({
  __name: "SoftShadows",
  props: {
    size: { default: 25 },
    samples: { default: 10 },
    focus: { default: 0 }
  },
  setup(r) {
    const e = r, t = ({ focus: c = 0, size: f = 25, samples: u = 10 } = {}) => `
#define PENUMBRA_FILTER_SIZE float(${f})
#define RGB_NOISE_FUNCTION(uv) (randRGB(uv))
vec3 randRGB(vec2 uv) {
  return vec3(
    fract(sin(dot(uv, vec2(12.75613, 38.12123))) * 13234.76575),
    fract(sin(dot(uv, vec2(19.45531, 58.46547))) * 43678.23431),
    fract(sin(dot(uv, vec2(23.67817, 78.23121))) * 93567.23423)
  );
}

vec3 lowPassRandRGB(vec2 uv) {
  // 3x3 convolution (average)
  // can be implemented as separable with an extra buffer for a total of 6 samples instead of 9
  vec3 result = vec3(0);
  result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, -1.0));
  result += RGB_NOISE_FUNCTION(uv + vec2(-1.0,  0.0));
  result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, +1.0));
  result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, -1.0));
  result += RGB_NOISE_FUNCTION(uv + vec2( 0.0,  0.0));
  result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, +1.0));
  result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, -1.0));
  result += RGB_NOISE_FUNCTION(uv + vec2(+1.0,  0.0));
  result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, +1.0));
  result *= 0.111111111; // 1.0 / 9.0
  return result;
}
vec3 highPassRandRGB(vec2 uv) {
  // by subtracting the low-pass signal from the original signal, we're being left with the high-pass signal
  // hp(x) = x - lp(x)
  return RGB_NOISE_FUNCTION(uv) - lowPassRandRGB(uv) + 0.5;
}


vec2 vogelDiskSample(int sampleIndex, int sampleCount, float angle) {
  const float goldenAngle = 2.399963f; // radians
  float r = sqrt(float(sampleIndex) + 0.5f) / sqrt(float(sampleCount));
  float theta = float(sampleIndex) * goldenAngle + angle;
  float sine = sin(theta);
  float cosine = cos(theta);
  return vec2(cosine, sine) * r;
}
float penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation
  return (zReceiver - zBlocker) / zBlocker;
}
float findBlocker(sampler2D shadowMap, vec2 uv, float compare, float angle) {
  float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);
  float blockerDepthSum = float(${c});
  float blockers = 0.0;

  int j = 0;
  vec2 offset = vec2(0.);
  float depth = 0.;

  #pragma unroll_loop_start
  for(int i = 0; i < ${u}; i ++) {
    offset = (vogelDiskSample(j, ${u}, angle) * texelSize) * 2.0 * PENUMBRA_FILTER_SIZE;
    depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset));
    if (depth < compare) {
      blockerDepthSum += depth;
      blockers++;
    }
    j++;
  }
  #pragma unroll_loop_end

  if (blockers > 0.0) {
    return blockerDepthSum / blockers;
  }
  return -1.0;
}

        
float vogelFilter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius, float angle) {
  float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);
  float shadow = 0.0f;
  int j = 0;
  vec2 vogelSample = vec2(0.0);
  vec2 offset = vec2(0.0);
  #pragma unroll_loop_start
  for (int i = 0; i < ${u}; i++) {
    vogelSample = vogelDiskSample(j, ${u}, angle) * texelSize;
    offset = vogelSample * (1.0 + filterRadius * float(${f}));
    shadow += step( zReceiver, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );
    j++;
  }
  #pragma unroll_loop_end
  return shadow * 1.0 / ${u}.0;
}

float PCSS (sampler2D shadowMap, vec4 coords) {
  vec2 uv = coords.xy;
  float zReceiver = coords.z; // Assumed to be eye-space z in this code
  float angle = highPassRandRGB(gl_FragCoord.xy).r * PI2;
  float avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver, angle);
  if (avgBlockerDepth == -1.0) {
    return 1.0;
  }
  float penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);
  return vogelFilter(shadowMap, uv, zReceiver, 1.25 * penumbraRatio, angle);
}`, n = Ti.shadowmap_pars_fragment, { renderer: s, scene: i, camera: o } = xn();
    function a(c, f) {
      let u = n;
      u = u.replace(
        "#ifdef USE_SHADOWMAP",
        `#ifdef USE_SHADOWMAP
    ${t(f)}`
      ), u = u.replace(
        "#if defined( SHADOWMAP_TYPE_PCF )",
        `${eg} 
    #if defined( SHADOWMAP_TYPE_PCF )`
      ), Ti.shadowmap_pars_fragment = u, c.shadowMap.enabled = !0;
    }
    function l(c, f, u) {
      f.traverse((d) => {
        var h, m;
        "material" in d && d.material && (c.properties.remove(d.material), typeof d.material == "object" && "dispose" in d.material && typeof d.material.dispose == "function" && ((m = (h = d.material).dispose) == null || m.call(h)));
      }), c.info.programs && (c.info.programs.length = 0), c.compile(f, u);
    }
    return tt(() => {
      o.value && (Ti.shadowmap_pars_fragment = n, l(s.value, i.value, o.value));
    }), J(e, () => {
      o.value && (a(s.value, e), l(s.value, i.value, o.value));
    }, { immediate: !0 }), (c, f) => (ae(), ce("TresGroup"));
  }
});
function tg(r) {
  return Yo(r, {
    normalizeValue: (e) => tn(e),
    getDefaultValue: () => new be(0, 0, 0),
    isSingleValue: (e) => !Array.isArray(e),
    isMultipleValues: (e) => Array.isArray(e) && (e.length === 0 || !Array.isArray(e[0])),
    isMultipleValuesWithStops: (e) => Array.isArray(e) && e.length > 0 && Array.isArray(e[0]),
    isEmpty: (e) => Array.isArray(e) && e.length === 0
  });
}
function so(r) {
  return "isVector3" in r || Array.isArray(r) && r.length > 0 && r.every((e) => typeof e == "number");
}
function ng(r) {
  return Yo(r, {
    normalizeValue: (e) => Ia(e),
    getDefaultValue: () => [0, 0, 0],
    isSingleValue: (e) => so(e),
    isMultipleValues: (e) => Array.isArray(e) && e.length > 0 && so(e[0]),
    isMultipleValuesWithStops: (e) => Array.isArray(e) && e.length > 0 && Array.isArray(e[0]) && e[0].length === 2 && so(e[0][1]),
    isEmpty: (e) => Array.isArray(e) && e.length === 0
  });
}
function sg(r) {
  return Yo(r, {
    normalizeValue: (e) => e,
    getDefaultValue: () => 1,
    isSingleValue: (e) => !Array.isArray(e) && typeof e < "u",
    isMultipleValues: (e) => Array.isArray(e) && (e.length === 0 || !Array.isArray(e[0])),
    isMultipleValuesWithStops: (e) => Array.isArray(e) && e.length > 0 && Array.isArray(e[0]),
    isEmpty: (e) => Array.isArray(e) && e.length === 0
  });
}
function Yo(r, e) {
  const { normalizeValue: t, getDefaultValue: n, isEmpty: s } = e, i = (l) => e.isSingleValue(l), o = (l) => e.isMultipleValues(l), a = (l) => e.isMultipleValuesWithStops(l);
  if (s(r))
    return [[0, n()]];
  if (i(r))
    return [[0, t(r)]];
  if (o(r)) {
    const l = r.length > 1 ? 1 / (r.length - 1) : 1;
    return r.map((c, f) => [l * f, t(c)]);
  } else if (a(r))
    return r.map(([l, c], f) => [l, t(c)]);
  return [[0, n()]];
}
class ig {
  constructor(e, t) {
    pe(this, "entries");
    pe(this, "resolution");
    this.entries = e, this.resolution = t;
  }
  useTexture() {
    return new ag(this.entries, this.resolution).use();
  }
}
class Wo {
  constructor(e, t, n, s, i, o) {
    pe(this, "data");
    pe(this, "ref");
    pe(this, "name");
    pe(this, "valueMin");
    pe(this, "valueMax");
    pe(this, "suffix");
    pe(this, "renderToCanvasGradient");
    this.data = ii(e) ? e.value : e, this.ref = ii(e) ? e : null, this.name = t, this.valueMin = n, this.valueMax = s, this.suffix = i, this.renderToCanvasGradient = o;
  }
}
class og extends Wo {
  constructor(e, t = "color", n = 0, s = 1, i = "rgba", o = lg) {
    super(e, t, n, s, i, o);
  }
}
class oa extends Wo {
  constructor(e, t = "scalar", n = 0, s = 1, i = "x", o = cg) {
    super(e, t, n, s, i, o);
  }
}
class rg extends Wo {
  constructor(e, t = "scalar3", n = 0, s = 1, i = "xyz", o = ug) {
    super(e, t, n, s, i, o);
  }
}
class ag {
  constructor(e, t) {
    pe(this, "entries");
    pe(this, "size");
    pe(this, "dirty", re(0));
    pe(this, "context");
    this.entries = e, this.size = Math.max(t, e.length);
    const n = document.createElement("canvas");
    n.height = this.size, n.width = this.size, this.context = n.getContext("2d");
  }
  use() {
    const e = this.build(), t = re(e);
    for (const n of this.entries)
      n.ref && J(n.ref, () => {
        var s;
        n.data = (s = n.ref) == null ? void 0 : s.value, vc(this.dirty);
      });
    return Xc(
      this.dirty,
      () => {
        this.build(e), t.value = e;
      },
      { throttle: 1e3 / 60 }
    ), {
      texture: t,
      dispose: () => e.dispose(),
      yFor: this.entries.reduce((n, s, i) => (n[s.name] = (i + 0.5) / this.size, n), {})
    };
  }
  build(e) {
    this.entries.forEach((n, s) => {
      const i = this.context.createLinearGradient(0, s, this.size, s);
      n.renderToCanvasGradient(i, n), this.context.fillStyle = i, this.context.fillRect(0, s, this.size, 1);
    }), e && (e.source.data = this.context.getImageData(
      0,
      0,
      this.size,
      this.size
    ));
    const t = e ?? new ti(
      this.context.getImageData(0, 0, this.size, this.size).data,
      this.size,
      this.size,
      ei,
      uc,
      hc,
      Wt,
      Wt
    );
    return t.needsUpdate = !0, t;
  }
}
function El(r, e, t, n, s) {
  return Ye.mapLinear(Ye.clamp(r, e, t), e, t, n, s);
}
function lg(r, e) {
  return tg(e.data).forEach(
    ([t, n]) => r.addColorStop(
      t,
      `rgb(${n.r * 255}, ${n.g * 255}, ${n.b * 255})`
    )
  );
}
function cg(r, e) {
  return sg(e.data).forEach(([t, n]) => {
    r.addColorStop(
      t,
      `rgb(${El(
        n,
        e.valueMin,
        e.valueMax,
        0,
        255
      )}, 0, 0)`
    );
  });
}
function ug(r, e) {
  return ng(e.data).forEach(
    ([t, n]) => r.addColorStop(
      t,
      `rgb(${n.map(
        (s) => El(s, e.valueMin, e.valueMax, 0, 255)
      )})`
    )
  );
}
class hg {
  constructor(e = 256) {
    pe(this, "entries");
    pe(this, "resolution");
    this.resolution = e, this.entries = [];
  }
  withResolution(e) {
    return this.resolution = e, this;
  }
  get add() {
    return new dg(
      (e) => this.onAdd(e)
    );
  }
  build() {
    return new ig(this.entries, this.resolution);
  }
  onAdd(e) {
    return this.entries.push(e), new fg(e, this);
  }
}
class fg {
  constructor(e, t) {
    pe(this, "entry");
    pe(this, "parent");
    this.entry = e, this.parent = t;
  }
  id(e) {
    return this.entry.name = e, this;
  }
  range(e, t) {
    return this.entry.valueMin = e, this.entry.valueMax = t, this;
  }
  suffix(e) {
    return this.entry.suffix = e, this;
  }
  canvasGradientRenderer(e) {
    return this.entry.renderToCanvasGradient = e, this;
  }
  /**
   * Add another entry to the ShaderDataBuilder
   */
  get add() {
    return this.parent.add;
  }
  /**
   * Finalize the ShaderDataBuilder
   * @returns ShaderData
   */
  build() {
    return this.parent.build();
  }
}
class dg {
  constructor(e) {
    pe(this, "onAdd");
    this.onAdd = e;
  }
  GradientTresColor(e) {
    return this.onAdd(new og(e));
  }
  Gradient01(e) {
    return this.onAdd(new oa(e, "zeroOne", 0, 1));
  }
  GradientScalar(e, t, n) {
    return this.onAdd(
      new oa(e, "scalar", t, n)
    );
  }
  GradientXyz(e, t, n) {
    return this.onAdd(
      new rg(e, "position", t, n)
    );
  }
}
let io = null;
function pg() {
  return io === null && (io = new ti(new Uint8Array([0, 0, 0, 0]), 1, 1)), io;
}
const mg = ["object"], Jv = /* @__PURE__ */ ue({
  __name: "component",
  props: {
    map: { default: "https://raw.githubusercontent.com/Tresjs/assets/e41a93c56ec7cb5ac2d241f309e23582a5fe1fc6/textures/sparkles/particle.png" },
    geometry: { default: void 0 },
    directionalLight: { default: void 0 },
    lifetimeSec: { default: 0.4 },
    cooldownSec: { default: 2 },
    normalThreshold: { default: 0.7 },
    noiseScale: { default: 3 },
    scaleNoise: { default: 1 },
    offsetNoise: { default: 0.1 },
    lifetimeNoise: { default: 0 },
    size: { default: 1 },
    alpha: { default: 1 },
    offset: { default: 1 },
    surfaceDistance: { default: 1 },
    sequenceColor: { default: () => [[0.7, "#82dbc5"], [0.8, "#fbb03b"]] },
    sequenceAlpha: { default: () => [[0, 0], [0.1, 1], [0.5, 1], [0.9, 0]] },
    sequenceOffset: { default: () => [0, 0, 0] },
    sequenceNoise: { default: () => [0.1, 0.1, 0.1] },
    sequenceSize: { default: () => [0, 1] },
    sequenceSurfaceDistance: { default: () => [0.05, 0.08, 0.1] },
    mixColor: { default: 0.5 },
    mixAlpha: { default: 1 },
    mixOffset: { default: 1 },
    mixSize: { default: 0 },
    mixSurfaceDistance: { default: 1 },
    mixNoise: { default: 1 },
    blending: { default: So },
    transparent: { type: Boolean, default: !0 },
    depthWrite: { type: Boolean, default: !1 }
  },
  setup(r, { expose: e }) {
    const t = r, n = Number.parseInt(Ts.replace(/\D+/g, "")), s = Le(t), i = typeof t.map == "string" ? pg() : t.map, { texture: o, yFor: a } = new hg(256).add.GradientTresColor(s.sequenceColor).id("sequenceColor").add.Gradient01(s.sequenceAlpha).id("sequenceAlpha").add.Gradient01(s.sequenceSurfaceDistance).id("sequenceSurfaceDistance").add.Gradient01(s.sequenceSize).id("sequenceSize").add.GradientXyz(s.sequenceOffset, -1, 1).id("sequenceOffset").add.GradientXyz(s.sequenceNoise, 0, 1).id("sequenceNoise").build().useTexture(), l = {
      blending: t.blending,
      transparent: t.transparent,
      depthWrite: t.depthWrite,
      uniforms: {
        uMap: new Se(i),
        uPixelRatio: new Se(1),
        uNormal: new Se(Rt.DEFAULT_UP),
        uNormalThreshold: new Se(t.normalThreshold),
        uTime: new Se(0),
        uCooldownRatio: new Se(1),
        uSize: new Se(t.size),
        uAlpha: new Se(t.alpha),
        uOffset: new Se(t.offset),
        uSurfaceDistance: new Se(t.surfaceDistance),
        uNoiseScale: new Se(t.noiseScale),
        uScaleNoise: new Se(t.scaleNoise),
        uOffsetNoise: new Se(t.offsetNoise),
        uLifetimeNoise: new Se(t.lifetimeNoise),
        uMixColor: new Se(t.mixColor),
        uMixAlpha: new Se(t.mixAlpha),
        uMixOffset: new Se(t.mixOffset),
        uMixSize: new Se(t.mixSize),
        uMixSurfaceDistance: new Se(t.mixSurfaceDistance),
        uMixNoise: new Se(t.mixNoise),
        uInfoTexture: new Se(o.value)
      },
      vertexShader: `
    uniform float uPixelRatio;
    uniform vec3 uNormal;
    uniform float uNormalThreshold;
    uniform float uTime;
    uniform float uCooldownRatio;
    uniform float uSize;
    uniform float uAlpha;
    uniform float uOffset;
    uniform float uSurfaceDistance;
    uniform float uNoiseScale;
    uniform float uScaleNoise;
    uniform float uOffsetNoise;
    uniform float uLifetimeNoise;
    uniform float uMixColor;
    uniform float uMixAlpha;
    uniform float uMixOffset;
    uniform float uMixSize;
    uniform float uMixSurfaceDistance;
    uniform float uMixNoise;
    uniform sampler2D uInfoTexture;

    varying vec4 vColor;

    void main() {
      float dotNormal = dot(normal, uNormal) * 0.5 + 0.5;
      float normalP = smoothstep(uNormalThreshold, 1., dotNormal);
      float lifetimeNoise = uLifetimeNoise * mix(normalP, 1.0, uMixNoise);

      float t = uTime + position.x * 1. * uNoiseScale + position.y * 10. * uNoiseScale + 
      position.z * 7.3 * uNoiseScale + sin(lifetimeNoise * (position.x + 13. * position.y)) * lifetimeNoise;

      float lifetimeP = max(-0.0001, mix(-uCooldownRatio, 1. + cos(t) * lifetimeNoise, fract(t)));
      float surfaceDistance = texture2D(uInfoTexture, vec2(
        mix(normalP, lifetimeP, uMixSurfaceDistance),
        ${a.sequenceSurfaceDistance})).x * uSurfaceDistance;

      vec4 modelPosition = modelMatrix * (vec4(position, 1.0) + vec4(normal * surfaceDistance, 0.0));
      vec3 noise = texture2D(uInfoTexture, vec2(
        mix(normalP, lifetimeP, uMixNoise),
        ${a.sequenceNoise})).xyz;
      vec3 offset = uOffset * (texture2D(uInfoTexture, vec2(
        mix(normalP, lifetimeP, uMixOffset),
        ${a.sequenceOffset})).xyz * 2.0 - vec3(1.0, 1.0, 1.0));
      modelPosition.x += cos(t * uNoiseScale * 10.0) * 0.2 * uOffsetNoise * noise.x + offset.x;
      modelPosition.y += sin(t * uNoiseScale * 10.0) * 0.2 * uOffsetNoise * noise.y + offset.y;
      modelPosition.z += cos(t * uNoiseScale * 10.0) * 0.2 * uOffsetNoise * noise.z + offset.z;

      vec4 viewPosition = viewMatrix * modelPosition;
      vec4 projectionPostion = projectionMatrix * viewPosition;
      gl_Position = projectionPostion;

      gl_PointSize = 2.
      * texture2D(uInfoTexture, vec2(mix(normalP, lifetimeP, uMixSize), ${a.sequenceSize})).x
      * mix(1., abs(sin(t * uNoiseScale + position.x * 13.9 + position.y * 73.1)), uScaleNoise)
      * uSize * (100.0 / -viewPosition.z) * uPixelRatio;

      if (gl_PointSize < 0.6 || lifetimeP < 0.0) { gl_Position = vec4(2, 2, 2, 1); }

      vColor = texture2D(uInfoTexture, vec2(mix(normalP, lifetimeP, uMixColor), ${a.sequenceColor}))
      * texture2D(uInfoTexture, vec2(mix(normalP, lifetimeP, uMixAlpha), ${a.sequenceAlpha})).x * uAlpha;
    }`,
      fragmentShader: `
    varying vec4 vColor;

    uniform sampler2D uMap;
    uniform sampler2D uInfoTexture;

    void main() {
      gl_FragColor = vColor * texture2D(uMap, gl_PointCoord);
      #include <tonemapping_fragment>
      #include <${n >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
    }`
    }, c = new bt(l), f = new ba(void 0, c), u = c.uniforms, d = { immediate: !0 };
    [
      [u.uPixelRatio, xe().sizes.aspectRatio],
      [u.uSize, s.size],
      [u.uNormalThreshold, s.normalThreshold],
      [u.uAlpha, s.alpha],
      [u.uOffset, s.offset],
      [u.uOffsetNoise, s.offsetNoise],
      [u.uMixColor, s.mixColor],
      [u.uMixAlpha, s.mixAlpha],
      [u.uMixOffset, s.mixOffset],
      [u.uMixSize, s.mixSize],
      [u.uMixSurfaceDistance, s.mixSurfaceDistance],
      [u.uMixNoise, s.mixNoise],
      [u.uInfoTexture, o]
    ].forEach(
      ([_, M]) => J(
        M,
        () => {
          _.value = M.value;
        },
        d
      )
    ), J([s.noiseScale, s.lifetimeSec], () => {
      u.uNoiseScale.value = s.noiseScale.value * s.lifetimeSec.value;
    }, d), J([s.lifetimeSec, s.cooldownSec], () => {
      u.uCooldownRatio.value = s.cooldownSec.value / s.lifetimeSec.value;
    }, d), J(s.map, () => {
      typeof s.map.value == "string" ? Bn([s.map.value]).then((_) => c.uniforms.uMap.value = _) : c.uniforms.uMap.value = s.map.value;
    });
    const m = new je(), g = new $();
    Ve().onBeforeRender(({ elapsed: _, invalidate: M }) => {
      f.getWorldQuaternion(m), g.copy(t.directionalLight ? t.directionalLight.position : Rt.DEFAULT_UP).normalize(), g.applyQuaternion(m.invert()), c.uniforms.uNormal.value = g, c.uniforms.uTime.value = _ / (t.cooldownSec + t.lifetimeSec), M();
    });
    function v(_) {
      return _ && "isObject3D" in _;
    }
    function p(_) {
      return _ && "isBufferGeometry" in _;
    }
    bn(() => {
      t.geometry ? p(t.geometry) ? f.geometry.copy(t.geometry) : v(t.geometry) && "geometry" in t.geometry && p(t.geometry.geometry) && f.geometry.copy(t.geometry.geometry) : v(f.parent) && "geometry" in f.parent && p(f.parent.geometry) ? f.geometry.copy(f.parent.geometry) : f.geometry = new fc(1, 16), typeof t.map == "string" && Bn([t.map]).then((_) => c.uniforms.uMap.value = _);
    }), tt(() => {
      var _;
      (_ = c.uniforms.uMap.value) == null || _.dispose(), o.value.dispose(), c.dispose();
    });
    const b = re();
    return e({ instance: f }), (_, M) => (ae(), ce("primitive", {
      ref_key: "sparkleRef",
      ref: b,
      object: F(f)
    }, null, 8, mg));
  }
}), gg = ["position", "a-scale"], vg = ["size", "size-attenuation", "transparent", "alpha-test", "alpha-map"], e0 = /* @__PURE__ */ ue({
  __name: "Stars",
  props: {
    size: { default: 0.1 },
    sizeAttenuation: { type: Boolean, default: !0 },
    transparent: { type: Boolean, default: !0 },
    alphaTest: { default: 0.01 },
    count: { default: 5e3 },
    depth: { default: 50 },
    radius: { default: 100 },
    alphaMap: { default: null }
  },
  setup(r, { expose: e }) {
    const t = r, n = me(), s = me(), { radius: i, depth: o, count: a, size: l, sizeAttenuation: c, transparent: f, alphaMap: u, alphaTest: d } = Le(t), { invalidate: h } = xe();
    J(t, () => {
      h();
    });
    const m = () => {
      let v = i.value + o.value;
      const p = Pe(() => o.value / a.value), b = [], _ = Array.from(
        { length: a.value },
        () => (0.5 + 0.5 * Math.random()) * 4
      ), M = (R) => new $().setFromSpherical(new si(R, Math.acos(1 - Math.random() * 2), Math.random() * 2 * Math.PI)).toArray();
      for (let R = 0; R < a.value; R++)
        v -= p.value * Math.random(), b.push(...M(v));
      n.value = new Float32Array(b), s.value = new Float32Array(_);
    };
    et(() => {
      m();
    });
    const g = re();
    return e({
      instance: g
    }), (v, p) => (ae(), ce("TresPoints", {
      ref_key: "starsRef",
      ref: g
    }, [
      ye("TresBufferGeometry", {
        position: [n.value, 3],
        "a-scale": [s.value, 1]
      }, null, 8, gg),
      ye("TresPointsMaterial", {
        size: F(l),
        "size-attenuation": F(c),
        transparent: F(f),
        "alpha-test": F(d),
        "alpha-map": F(u)
      }, null, 8, vg)
    ], 512));
  }
});
class ra extends Rt {
  constructor() {
    super();
    pe(this, "virtualScene", null);
    this.virtualScene = new xs();
  }
  add(...t) {
    return this.virtualScene.add(...t), this;
  }
  dispose() {
    this.virtualScene.traverse((t) => {
      t instanceof de && (t.geometry.dispose(), t.material.dispose(), t.material.map && t.material.map.dispose(), this.virtualScene.remove(t));
    }), this.virtualScene = null;
  }
}
const t0 = /* @__PURE__ */ ue({
  __name: "component",
  props: {
    background: { type: [Boolean, String], default: !1 },
    blur: { default: 0 },
    files: { default: () => [] },
    path: { default: "" },
    preset: { default: void 0 },
    resolution: { default: 256 },
    near: { default: 1 },
    far: { default: 1e3 },
    frames: { default: Number.POSITIVE_INFINITY },
    backgroundIntensity: { default: 1 },
    backgroundRotation: {},
    environmentIntensity: { default: 1 },
    environmentRotation: {},
    syncMaterials: { type: Boolean }
  },
  async setup(r, { expose: e }) {
    let t, n;
    const s = r, i = me(null);
    e({ texture: i });
    const { extend: o, renderer: a, scene: l } = xe();
    o({ EnvironmentScene: ra });
    let c = null;
    const f = me(null);
    let u = null;
    const d = me(null), h = ([t, n] = Tn(() => vd(s, f)), t = await t, n(), t), { onBeforeRender: m } = Ve();
    let g = 1;
    m(() => {
      if (u && d.value && f.value && (s.frames === Number.POSITIVE_INFINITY || g < s.frames)) {
        const p = a.value.autoClear;
        a.value.autoClear = !0;
        const b = qo(d.value).virtualScene;
        u.update(a.value, b), a.value.autoClear = p, g++;
      }
    }, -1), J([h, d], ([p, b]) => {
      if (p && (b != null && b.virtualScene)) {
        const _ = qo(b).virtualScene;
        let M = _.children.find(
          (R) => R instanceof de && R.userData.isEnvironment
        );
        M || (M = new de(
          new Ht(1, 1, 1),
          new $t({ side: li })
        ), M.userData.isEnvironment = !0, _.add(M)), _.background = p, _.backgroundBlurriness = s.blur;
      }
    }, { immediate: !0 });
    const v = (p) => {
      p && (c != null && c.length) ? (l.value.environment = p.texture, s.background && (l.value.background = p.texture)) : h.value && (l.value.environment = h.value, s.background && (l.value.background = h.value));
    };
    return J(h, () => {
      f.value && v(f.value);
    }, { immediate: !0, deep: !0 }), J(() => Io().default, (p) => {
      var b;
      if (p && (c = p(), Array.isArray(c) && c.length > 0)) {
        o({ EnvironmentScene: ra }), f.value = new aa(s.resolution), f.value.texture.type = Lt, u = new la(s.near, s.far, f.value), v(f.value);
        return;
      }
      (b = f.value) == null || b.dispose(), f.value = null, v();
    }, { immediate: !0, deep: !0 }), i.value = h.value, tt(() => {
      var p, b;
      (p = d.value) == null || p.dispose(), (b = f.value) == null || b.dispose();
    }), (p, b) => f.value ? (ae(), ce("TresEnvironmentScene", {
      key: 0,
      ref_key: "environmentScene",
      ref: d
    }, [
      Ne(p.$slots, "default")
    ], 512)) : an("", !0);
  }
}), yg = {
  key: 0,
  args: [0, 1, 64]
}, _g = {
  key: 1,
  args: [0.5, 1, 64]
}, xg = { key: 2 }, wg = ["tone-mapped", "map", "side", "color"], n0 = /* @__PURE__ */ ue({
  __name: "index",
  props: {
    args: { default: null },
    form: { default: "rect" },
    toneMapped: { type: Boolean, default: !1 },
    map: { default: null },
    intensity: { default: 1 },
    color: { default: new be(16777215) }
  },
  setup(r, { expose: e }) {
    const t = r, n = me(), s = me();
    return et(() => {
      n.value && (n.value.color.copy(new be(t.color)), n.value.color.multiplyScalar(t.intensity), n.value.needsUpdate = !0);
    }), e({ mesh: s }), (i, o) => (ae(), ce("TresMesh", {
      ref_key: "mesh",
      ref: s
    }, [
      i.form === "circle" ? (ae(), ce("TresRingGeometry", yg)) : i.form === "ring" ? (ae(), ce("TresRingGeometry", _g)) : i.form === "rect" ? (ae(), ce("TresPlaneGeometry", xg)) : (ae(), Oo(t.form, {
        key: 3,
        args: i.args
      }, null, 8, ["args"])),
      ye("TresMeshBasicMaterial", {
        ref_key: "material",
        ref: n,
        "tone-mapped": i.toneMapped,
        map: i.map,
        side: F(on),
        color: i.color
      }, null, 8, wg)
    ], 512));
  }
});
function s0(r, e) {
  const t = {};
  for (const n of e)
    Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);
  return t;
}
function i0(r, e) {
  const t = `set${e[0].toUpperCase()}${e.slice(1)}`;
  return r[t] !== void 0;
}
function o0(r) {
  var t, n;
  let e = r.value;
  return r.value && ((n = (t = r.value) == null ? void 0 : t.value) != null && n.isMesh) && (e = r.value.value.position), Array.isArray(r.value) && (e = new $(...e)), e;
}
export {
  jv as Align,
  Ag as AnimatedSprite,
  Vv as Backdrop,
  wv as BakeShadows,
  lt as BaseCameraControls,
  Rg as Billboard,
  Sv as Box,
  iv as CameraControls,
  Av as CatmullRomCurve3,
  Pv as Circle,
  Rv as Cone,
  Yv as ContactShadows,
  Pg as CubeCamera,
  mv as CustomShaderMaterial,
  Cv as Cylinder,
  Iv as Dodecahedron,
  sv as Edges,
  t0 as Environment,
  hv as FBXModel,
  ev as Fbo,
  Wv as Fit,
  fv as GLTFModel,
  Cg as GlobalAudio,
  Ig as GradientTexture,
  Xv as Grid,
  gv as HolographicMaterial,
  Tv as Html,
  Ov as Icosahedron,
  Og as Image,
  ov as KeyboardControls,
  jg as Lensflare,
  Vg as Levioso,
  n0 as Lightformer,
  lm as Line2,
  rv as MapControls,
  Yg as Mask,
  vv as MeshDiscardMaterial,
  yv as MeshGlassMaterial,
  _v as MeshReflectionMaterial,
  xv as MeshWobbleMaterial,
  Wg as MouseParallax,
  $v as Ocean,
  Dv as Octahedron,
  av as OrbitControls,
  Xg as Outline,
  Lv as Plane,
  Md as PointerLockControls,
  $g as PositionalAudio,
  Zv as Precipitation,
  Zg as Reflector,
  kv as Ring,
  Nv as RoundedBox,
  uv as SVG,
  tv as Sampler,
  nv as ScreenSizer,
  Kg as ScreenSpace,
  lv as ScrollControls,
  Kv as Sky,
  qv as Smoke,
  Qv as SoftShadows,
  Jv as Sparkles,
  Bv as Sphere,
  e0 as Stars,
  bv as Stats,
  Ev as StatsGl,
  Uv as Superformula,
  Fv as Tetrahedron,
  qg as Text3D,
  zv as Torus,
  Gv as TorusKnot,
  cv as TransformControls,
  Hv as Tube,
  o0 as extractBindingPosition,
  i0 as hasSetter,
  s0 as pick,
  Qg as useAnimations,
  vd as useEnvironment,
  ad as useFBO,
  Cd as useFBX,
  kd as useGLTF,
  Mv as useGLTFExporter,
  Jg as useMask,
  dv as useProgress,
  ld as useSurfaceSampler,
  pv as useVideoTexture
};
