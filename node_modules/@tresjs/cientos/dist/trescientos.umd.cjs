/**
 * name: @tresjs/cientos
 * version: v4.3.1
 * (c) 2025
 * description: Collection of useful helpers and fully functional, ready-made abstractions for Tres
 * author: Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)
 */
(function(ne,l){typeof exports=="object"&&typeof module<"u"?l(exports,require("three"),require("vue"),require("@tresjs/core")):typeof define=="function"&&define.amd?define(["exports","three","vue","@tresjs/core"],l):(ne=typeof globalThis<"u"?globalThis:ne||self,l(ne.trescientos={},ne.Three,ne.Vue,ne.TresjsCore))})(this,function(ne,l,u,H){"use strict";var yp=Object.defineProperty;var _p=(ne,l,u)=>l in ne?yp(ne,l,{enumerable:!0,configurable:!0,writable:!0,value:u}):ne[l]=u;var ue=(ne,l,u)=>_p(ne,typeof l!="symbol"?l+"":l,u);function $s(i){const e=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(i){for(const t in i)if(t!=="default"){const n=Object.getOwnPropertyDescriptor(i,t);Object.defineProperty(e,t,n.get?n:{enumerable:!0,get:()=>i[t]})}}return e.default=i,Object.freeze(e)}const Ot=$s(l);function ei(i){const e=ti(i),t=[];for(const{startFrame:n,endFrame:o,duration:r}of e)if(!(r<=0))if(o<0||n===o){for(let s=0;s<r;s++)t.push(n);continue}else{const s=Math.sign(o-n);for(let a=n;a!==o+s;a+=s)for(let c=0;c<r;c++)t.push(a)}return t}function ti(i){let e="START_FRAME_IN";const t=[];for(const{name:n,value:o,startI:r}of ni(i))e==="START_FRAME_IN"?n==="NUMBER"?(t.push({startFrame:o,endFrame:o,duration:1}),e="START_FRAME_OUT"):Mt("number",n,i,r):e==="START_FRAME_OUT"?n==="COMMA"?e="START_FRAME_IN":n==="HYPHEN"?e="END_FRAME_IN":n==="OPEN_PAREN"?e="DURATION_IN":Mt('",", "-", "("',n,i,r):e==="END_FRAME_IN"?n==="NUMBER"?(t[t.length-1].endFrame=o,e="END_FRAME_OUT"):Mt("number",n,i,r):e==="END_FRAME_OUT"?n==="COMMA"?e="START_FRAME_IN":n==="OPEN_PAREN"?e="DURATION_IN":Mt("',' or '('",n,i,r):e==="DURATION_IN"?n==="NUMBER"?(t[t.length-1].duration=o,e="DURATION_OUT"):Mt("number",n,i,r):e==="DURATION_OUT"?n==="CLOSE_PAREN"?e="NEXT_OR_DONE":Mt('"("',n,i,r):e==="NEXT_OR_DONE"&&(n==="COMMA"?e="START_FRAME_IN":Mt('","',n,i,r));return t}function ni(i){const e=[];for(let t=0;t<i.length;t++){const n=i[t];if("0123456789".includes(n))e.length&&e[e.length-1].name==="NUMBER"?(e[e.length-1].value*=10,e[e.length-1].value+=Number.parseInt(n)):e.push({name:"NUMBER",value:Number.parseInt(n),startI:t});else{if(n===" ")continue;n===","?e.push({name:"COMMA",value:-1,startI:t}):n==="("?e.push({name:"OPEN_PAREN",value:-1,startI:t}):n===")"?e.push({name:"CLOSE_PAREN",value:-1,startI:t}):n==="-"?e.push({name:"HYPHEN",value:-1,startI:t}):oi("0123456789,-()",n,i,t)}}return e}function oi(i,e,t,n){H.useLogger().logError(`Cientos AnimationDefinitionParser: Unexpected character while processing animation definition: expected ${i}, got ${e}.
${t}
${Array.from({length:n+1}).join(" ")}^`)}function Mt(i,e,t,n){H.useLogger().logError(`Cientos AnimationDefinitionParser: Syntax error while processing animation definition: expected ${i}, got ${e}.
${t}
${Array.from({length:n+1}).join(" ")}^`)}const ri=/\d*$/,si=/_*\d*$/;function ii(i){return i.replace(si,"")}function ai(i){const e=i.match(ri);return e?Number.parseInt(e[e.length-1]):null}async function li(i,e){const t=H.useLoader(l.TextureLoader,i),n=typeof e!="string"?new Promise(o=>o(e)):fetch(e).then(o=>o.json()).catch(o=>H.useLogger().logError(`Cientos Atlas - ${o}`));return Promise.all([t,n]).then(([o,r])=>{const s=ci(r,o.image.width,o.image.height);return[o,s]})}function ci(i,e,t){const n=typeof i=="number"||Array.isArray(i)?di(i,e,t):ui(i,e,t);return{frames:n,animations:Xo(n)}}function Yt(i,e,t){let n;return typeof e=="string"?n=mi(i,e):typeof e=="number"?n=Yo(i,e,e):n=Yo(i,e[0],e[1]),t?n.toReversed():n}function Nn(){return{name:"null",width:0,height:0,offsetX:0,offsetY:0,repeatX:0,repeatY:0}}function ui(i,e,t){return Array.isArray(i.frames)?hi(i,e,t):fi(i,e,t)}function hi(i,e,t){const n=1/e,o=1/t;return i.frames.map(r=>({name:r.filename,offsetX:r.frame.x*n,offsetY:1-(r.frame.y+r.frame.h)*o,repeatX:r.frame.w*n,repeatY:r.frame.h*o,width:r.frame.w,height:r.frame.h}))}function fi(i,e,t){const n=1/e,o=1/t;return Object.entries(i.frames).map(([r,s])=>({name:r,offsetX:s.frame.x*n,offsetY:1-(s.frame.y+s.frame.h)*o,repeatX:s.frame.w*n,repeatY:s.frame.h*o,width:s.frame.w,height:s.frame.h}))}function di(i,e,t,n="default"){const[o,r]=Array.isArray(i)?i:[i,1],s=e/o,a=t/r,c=(o*r).toString().length,h=1/o,p=1/r,f=[];let m=0;for(let d=r-1;d>=0;d--)for(let y=0;y<o;y++)m++,f.push({name:n+String(m).padStart(c,"0"),offsetX:y*h,offsetY:d*p,repeatX:h,repeatY:p,width:s,height:a});return f}function pi(i,e={}){const t=Xo(i.frames);for(const[n,o]of Object.entries(e)){const r=Yt(i,n,!1),s=ei(o);for(const a of s)(a<0||r.length<=a)&&H.useLogger().logError(`Cientos Atlas: Attempting to access frame index ${a} in animation ${n}, but it does not exist.`);t[n]=s.map(a=>r[a])}i.animations=t}function mi(i,e){if(!(e in i.animations)){const t=Object.keys(i.animations).map(n=>`* ${n}
`).join("");return H.useLogger().logError(`Cientos Atlas: getAtlasFramesByAnimationName
The animation name "${e}" does not exist in this atlas.
Available names:
${t}`),[Nn()]}return i.animations[e]}function Yo(i,e,t){if(e<0||i.frames.length<=e||t<0||i.frames.length<=t)return H.useLogger().logError(`Cientos Atlas: getFramesByIndex â€“ [${e}, ${t}] is out of bounds.`),[Nn()];const n=[],o=Math.sign(t-e);if(o===0)return[i.frames[e]];for(let r=e;r!==t+o;r+=o)n.push(i.frames[r]);return n}function Xo(i){const e={};for(const t of i)if(ai(t.name)!==null){const n=ii(t.name);Object.prototype.hasOwnProperty.call(e,n)?e[n].push(t):e[n]=[t]}for(const t of Object.values(e))t.sort((n,o)=>n.name.localeCompare(o.name));return e}const gi=["scale","position"],yi=["map","alphaTest"],_i=["scale","position"],vi=["side","map","alphaTest","depthWrite","depthTest"],un=.01,xi=u.defineComponent({__name:"component",props:{image:{},atlas:{},definitions:{},fps:{default:30},loop:{type:Boolean,default:!0},animation:{default:0},paused:{type:Boolean,default:!1},reversed:{type:Boolean,default:!1},flipX:{type:Boolean,default:!1},resetOnEnd:{type:Boolean,default:!1},asSprite:{type:Boolean,default:!0},center:{default:()=>[.5,.5]},alphaTest:{default:0},depthTest:{type:Boolean,default:!0},depthWrite:{type:Boolean,default:!0}},emits:["frame","end","loop"],async setup(i,{expose:e,emit:t}){let n,o;const r=i,s=t,{invalidate:a}=H.useTresContext();u.watch(r,()=>{a()});const c=u.ref(0),h=u.ref(0),p=u.ref(0),f=u.ref(0),m=u.shallowRef();e({instance:m});const[d,y]=([n,o]=u.withAsyncContext(()=>li(r.image,r.atlas)),n=await n,o(),n);d.matrixAutoUpdate=!1;let _=Yt(y,r.animation,r.reversed),v=.5,g=.5,A=1,w=Nn(),C=null,L=0,M=!1,P=!0;H.useLoop().onBeforeRender(({delta:S})=>{for(!r.paused&&!M&&(A-=S*r.fps);A<=0;)A++,L++,r.loop?(L>=_.length&&s("loop",_[_.length-1].name),L%=_.length):L>=_.length&&(M=!0,L=r.resetOnEnd?0:_.length-1,s("end",_[_.length-1].name));_[L]!==w&&(w=_[L],C=w.name,b()),P&&(P=!1,d.offset.x=w.offsetX+(r.flipX?w.repeatX:0),d.offset.y=w.offsetY,d.repeat.x=w.repeatX*(r.flipX?-1:1),d.repeat.y=w.repeatY,d.updateMatrix(),p.value=w.width*un,f.value=w.height*un,c.value=(.5-v)*w.width*un,h.value=(.5-g)*w.height*un),C&&(s("frame",C),C=null)});function b(){P=!0}return u.watch(()=>r.animation,(S,x)=>{JSON.stringify(S)!==JSON.stringify(x)&&(_=Yt(y,r.animation,r.reversed),L=0,A=1,M=!1,b())},{immediate:!0}),u.watch(()=>r.reversed,()=>{L=(_.length-L-1)%_.length,_=Yt(y,r.animation,r.reversed),M&&(L=r.resetOnEnd?0:_.length-1),b()}),u.watch(()=>r.paused,()=>{M=!1}),u.watch(()=>r.loop,()=>{M&&r.loop&&(M=!1)}),u.watch(()=>r.resetOnEnd,()=>{M&&(L=r.resetOnEnd?0:_.length-1,b())}),u.watch(()=>r.flipX,b),u.watch(()=>[r.center],()=>{[v,g]=H.normalizeVectorFlexibleParam(r.center),b()},{immediate:!0}),u.watch(()=>[r.definitions],()=>{pi(y,r.definitions),_=Yt(y,r.animation,r.reversed),A=1,L=0,b()},{immediate:!0}),u.onUnmounted(()=>{d.dispose()}),(S,x)=>(u.openBlock(),u.createElementBlock("TresGroup",{ref_key:"groupRef",ref:m},[r.asSprite?(u.openBlock(),u.createElementBlock("TresSprite",{key:0,scale:[p.value,f.value,1],position:[c.value,h.value,0]},[u.createElementVNode("TresSpriteMaterial",{toneMapped:!1,map:u.unref(d),transparent:!0,alphaTest:r.alphaTest},null,8,yi)],8,gi)):(u.openBlock(),u.createElementBlock("TresMesh",{key:1,scale:[p.value,f.value,1],position:[c.value,h.value,0]},[x[0]||(x[0]=u.createElementVNode("TresPlaneGeometry",{args:[1,1]},null,-1)),u.createElementVNode("TresMeshBasicMaterial",{toneMapped:!1,side:u.unref(l.DoubleSide),map:u.unref(d),transparent:!0,alphaTest:r.alphaTest,depthWrite:r.depthWrite,depthTest:r.depthTest},null,8,vi)],8,_i)),u.renderSlot(S.$slots,"default")],512))}});function hn(i){return u.getCurrentScope()?(u.onScopeDispose(i),!0):!1}function Ge(i){return typeof i=="function"?i():u.unref(i)}const wi=typeof window<"u"&&typeof document<"u";typeof WorkerGlobalScope<"u"&&globalThis instanceof WorkerGlobalScope;const bi=Object.prototype.toString,Mi=i=>bi.call(i)==="[object Object]",pt=()=>{};function Fn(i,e){function t(...n){return new Promise((o,r)=>{Promise.resolve(i(()=>e.apply(this,n),{fn:e,thisArg:this,args:n})).then(o).catch(r)})}return t}const Si=i=>i();function Ai(i,e={}){let t,n,o=pt;const r=a=>{clearTimeout(a),o(),o=pt};return a=>{const c=Ge(i),h=Ge(e.maxWait);return t&&r(t),c<=0||h!==void 0&&h<=0?(n&&(r(n),n=null),Promise.resolve(a())):new Promise((p,f)=>{o=e.rejectOnCancel?f:p,h&&!n&&(n=setTimeout(()=>{t&&r(t),n=null,p(a())},h)),t=setTimeout(()=>{n&&r(n),n=null,p(a())},c)})}}function Eo(...i){let e=0,t,n=!0,o=pt,r,s,a,c,h;!u.isRef(i[0])&&typeof i[0]=="object"?{delay:s,trailing:a=!0,leading:c=!0,rejectOnCancel:h=!1}=i[0]:[s,a=!0,c=!0,h=!1]=i;const p=()=>{t&&(clearTimeout(t),t=void 0,o(),o=pt)};return m=>{const d=Ge(s),y=Date.now()-e,_=()=>r=m();return p(),d<=0?(e=Date.now(),_()):(y>d&&(c||!n)?(e=Date.now(),_()):a&&(r=new Promise((v,g)=>{o=h?g:v,t=setTimeout(()=>{e=Date.now(),n=!0,v(_()),p()},Math.max(0,d-y))})),!c&&!t&&(t=setTimeout(()=>n=!0,d)),n=!1,r)}}function Pi(i){return u.getCurrentInstance()}function Ci(i,e=200,t={}){return Fn(Ai(e,t),i)}function Ti(i,e=200,t=!1,n=!0,o=!1){return Fn(Eo(e,t,n,o),i)}function Ii(i,e,t={}){const{eventFilter:n=Si,...o}=t;return u.watch(i,Fn(n,e),o)}function zn(i,e=!0,t){Pi()?u.onMounted(i,t):e?i():u.nextTick(i)}function Oi(i,e,t={}){const{throttle:n=0,trailing:o=!0,leading:r=!0,...s}=t;return Ii(i,e,{...s,eventFilter:Eo(n,o,r)})}const at=wi?window:void 0;function mt(i){var e;const t=Ge(i);return(e=t==null?void 0:t.$el)!=null?e:t}function Ce(...i){let e,t,n,o;if(typeof i[0]=="string"||Array.isArray(i[0])?([t,n,o]=i,e=at):[e,t,n,o]=i,!e)return pt;Array.isArray(t)||(t=[t]),Array.isArray(n)||(n=[n]);const r=[],s=()=>{r.forEach(p=>p()),r.length=0},a=(p,f,m,d)=>(p.addEventListener(f,m,d),()=>p.removeEventListener(f,m,d)),c=u.watch(()=>[mt(e),Ge(o)],([p,f])=>{if(s(),!p)return;const m=Mi(f)?{...f}:f;r.push(...t.flatMap(d=>n.map(y=>a(p,d,y,m))))},{immediate:!0,flush:"post"}),h=()=>{c(),s()};return hn(h),h}function Li(){const i=u.ref(!1),e=u.getCurrentInstance();return e&&u.onMounted(()=>{i.value=!0},e),i}function Zo(i){const e=Li();return u.computed(()=>(e.value,!!i()))}function Di(i,e={}){const{window:t=at}=e,n=Zo(()=>t&&"matchMedia"in t&&typeof t.matchMedia=="function");let o;const r=u.ref(!1),s=h=>{r.value=h.matches},a=()=>{o&&("removeEventListener"in o?o.removeEventListener("change",s):o.removeListener(s))},c=u.watchEffect(()=>{n.value&&(a(),o=t.matchMedia(Ge(i)),"addEventListener"in o?o.addEventListener("change",s):o.addListener(s),r.value=o.matches)});return hn(()=>{c(),a(),o=void 0}),r}function ki(i,e,t={}){const{window:n=at,...o}=t;let r;const s=Zo(()=>n&&"ResizeObserver"in n),a=()=>{r&&(r.disconnect(),r=void 0)},c=u.computed(()=>{const f=Ge(i);return Array.isArray(f)?f.map(m=>mt(m)):[mt(f)]}),h=u.watch(c,f=>{if(a(),s.value&&n){r=new ResizeObserver(e);for(const m of f)m&&r.observe(m,o)}},{immediate:!0,flush:"post"}),p=()=>{a(),h()};return hn(p),{isSupported:s,stop:p}}function Bi(i,e={width:0,height:0},t={}){const{window:n=at,box:o="content-box"}=t,r=u.computed(()=>{var f,m;return(m=(f=mt(i))==null?void 0:f.namespaceURI)==null?void 0:m.includes("svg")}),s=u.ref(e.width),a=u.ref(e.height),{stop:c}=ki(i,([f])=>{const m=o==="border-box"?f.borderBoxSize:o==="content-box"?f.contentBoxSize:f.devicePixelContentBoxSize;if(n&&r.value){const d=mt(i);if(d){const y=d.getBoundingClientRect();s.value=y.width,a.value=y.height}}else if(m){const d=Array.isArray(m)?m:[m];s.value=d.reduce((y,{inlineSize:_})=>y+_,0),a.value=d.reduce((y,{blockSize:_})=>y+_,0)}else s.value=f.contentRect.width,a.value=f.contentRect.height},t);zn(()=>{const f=mt(i);f&&(s.value="offsetWidth"in f?f.offsetWidth:e.width,a.value="offsetHeight"in f?f.offsetHeight:e.height)});const h=u.watch(()=>mt(i),f=>{s.value=f?e.width:0,a.value=f?e.height:0});function p(){c(),h()}return{width:s,height:a,stop:p}}const Ko=1;function Ui(i,e={}){const{throttle:t=0,idle:n=200,onStop:o=pt,onScroll:r=pt,offset:s={left:0,right:0,top:0,bottom:0},eventListenerOptions:a={capture:!1,passive:!0},behavior:c="auto",window:h=at,onError:p=P=>{console.error(P)}}=e,f=u.ref(0),m=u.ref(0),d=u.computed({get(){return f.value},set(P){_(P,void 0)}}),y=u.computed({get(){return m.value},set(P){_(void 0,P)}});function _(P,b){var S,x,I,D;if(!h)return;const z=Ge(i);if(!z)return;(I=z instanceof Document?h.document.body:z)==null||I.scrollTo({top:(S=Ge(b))!=null?S:y.value,left:(x=Ge(P))!=null?x:d.value,behavior:Ge(c)});const G=((D=z==null?void 0:z.document)==null?void 0:D.documentElement)||(z==null?void 0:z.documentElement)||z;d!=null&&(f.value=G.scrollLeft),y!=null&&(m.value=G.scrollTop)}const v=u.ref(!1),g=u.reactive({left:!0,right:!1,top:!0,bottom:!1}),A=u.reactive({left:!1,right:!1,top:!1,bottom:!1}),w=P=>{v.value&&(v.value=!1,A.left=!1,A.right=!1,A.top=!1,A.bottom=!1,o(P))},C=Ci(w,t+n),L=P=>{var b;if(!h)return;const S=((b=P==null?void 0:P.document)==null?void 0:b.documentElement)||(P==null?void 0:P.documentElement)||mt(P),{display:x,flexDirection:I}=getComputedStyle(S),D=S.scrollLeft;A.left=D<f.value,A.right=D>f.value;const z=Math.abs(D)<=(s.left||0),G=Math.abs(D)+S.clientWidth>=S.scrollWidth-(s.right||0)-Ko;x==="flex"&&I==="row-reverse"?(g.left=G,g.right=z):(g.left=z,g.right=G),f.value=D;let E=S.scrollTop;P===h.document&&!E&&(E=h.document.body.scrollTop),A.top=E<m.value,A.bottom=E>m.value;const X=Math.abs(E)<=(s.top||0),oe=Math.abs(E)+S.clientHeight>=S.scrollHeight-(s.bottom||0)-Ko;x==="flex"&&I==="column-reverse"?(g.top=oe,g.bottom=X):(g.top=X,g.bottom=oe),m.value=E},M=P=>{var b;if(!h)return;const S=(b=P.target.documentElement)!=null?b:P.target;L(S),v.value=!0,C(P),r(P)};return Ce(i,"scroll",t?Ti(M,t,!0,!1):M,a),zn(()=>{try{const P=Ge(i);if(!P)return;L(P)}catch(P){p(P)}}),Ce(i,"scrollend",w,a),{x:d,y,isScrolling:v,arrivedState:g,directions:A,measure(){const P=Ge(i);h&&P&&L(P)}}}const Ni={ctrl:"control",command:"meta",cmd:"meta",option:"alt",up:"arrowup",down:"arrowdown",left:"arrowleft",right:"arrowright"};function Fi(i={}){const{reactive:e=!1,target:t=at,aliasMap:n=Ni,passive:o=!0,onEventFired:r=pt}=i,s=u.reactive(new Set),a={toJSON(){return{}},current:s},c=e?u.reactive(a):a,h=new Set,p=new Set;function f(_,v){_ in c&&(e?c[_]=v:c[_].value=v)}function m(){s.clear();for(const _ of p)f(_,!1)}function d(_,v){var g,A;const w=(g=_.key)==null?void 0:g.toLowerCase(),L=[(A=_.code)==null?void 0:A.toLowerCase(),w].filter(Boolean);w&&(v?s.add(w):s.delete(w));for(const M of L)p.add(M),f(M,v);w==="meta"&&!v?(h.forEach(M=>{s.delete(M),f(M,!1)}),h.clear()):typeof _.getModifierState=="function"&&_.getModifierState("Meta")&&v&&[...s,...L].forEach(M=>h.add(M))}Ce(t,"keydown",_=>(d(_,!0),r(_)),{passive:o}),Ce(t,"keyup",_=>(d(_,!1),r(_)),{passive:o}),Ce("blur",m,{passive:!0}),Ce("focus",m,{passive:!0});const y=new Proxy(c,{get(_,v,g){if(typeof v!="string")return Reflect.get(_,v,g);if(v=v.toLowerCase(),v in n&&(v=n[v]),!(v in c))if(/[+_-]/.test(v)){const w=v.split(/[+_-]/g).map(C=>C.trim());c[v]=u.computed(()=>w.every(C=>Ge(y[C])))}else c[v]=u.ref(!1);const A=Reflect.get(_,v,g);return e?Ge(A):A}});return y}const zi={page:i=>[i.pageX,i.pageY],client:i=>[i.clientX,i.clientY],screen:i=>[i.screenX,i.screenY],movement:i=>i instanceof Touch?null:[i.movementX,i.movementY]};function Vi(i={}){const{type:e="page",touch:t=!0,resetOnTouchEnds:n=!1,initialValue:o={x:0,y:0},window:r=at,target:s=r,scroll:a=!0,eventFilter:c}=i;let h=null,p=0,f=0;const m=u.ref(o.x),d=u.ref(o.y),y=u.ref(null),_=typeof e=="function"?e:zi[e],v=P=>{const b=_(P);h=P,b&&([m.value,d.value]=b,y.value="mouse"),r&&(p=r.scrollX,f=r.scrollY)},g=P=>{if(P.touches.length>0){const b=_(P.touches[0]);b&&([m.value,d.value]=b,y.value="touch")}},A=()=>{if(!h||!r)return;const P=_(h);h instanceof MouseEvent&&P&&(m.value=P[0]+r.scrollX-p,d.value=P[1]+r.scrollY-f)},w=()=>{m.value=o.x,d.value=o.y},C=c?P=>c(()=>v(P),{}):P=>v(P),L=c?P=>c(()=>g(P),{}):P=>g(P),M=c?()=>c(()=>A(),{}):()=>A();if(s){const P={passive:!0};Ce(s,["mousemove","dragover"],C,P),t&&e!=="movement"&&(Ce(s,["touchstart","touchmove"],L,P),n&&Ce(s,"touchend",w,P)),a&&e==="page"&&Ce(r,"scroll",M,{passive:!0})}return{x:m,y:d,sourceType:y}}function Gi(i={}){const{window:e=at,behavior:t="auto"}=i;if(!e)return{x:u.ref(0),y:u.ref(0)};const n=u.ref(e.scrollX),o=u.ref(e.scrollY),r=u.computed({get(){return n.value},set(a){scrollTo({left:a,behavior:t})}}),s=u.computed({get(){return o.value},set(a){scrollTo({top:a,behavior:t})}});return Ce(e,"scroll",()=>{n.value=e.scrollX,o.value=e.scrollY},{capture:!1,passive:!0}),{x:r,y:s}}function qo(i={}){const{window:e=at,initialWidth:t=Number.POSITIVE_INFINITY,initialHeight:n=Number.POSITIVE_INFINITY,listenOrientation:o=!0,includeScrollbar:r=!0,type:s="inner"}=i,a=u.ref(t),c=u.ref(n),h=()=>{e&&(s==="outer"?(a.value=e.outerWidth,c.value=e.outerHeight):r?(a.value=e.innerWidth,c.value=e.innerHeight):(a.value=e.document.documentElement.clientWidth,c.value=e.document.documentElement.clientHeight))};if(h(),zn(h),Ce("resize",h,{passive:!0}),o){const p=Di("(orientation: portrait)");u.watch(p,()=>h())}return{width:a,height:c}}function Ri(i){let{resolution:e,renderer:t,scene:n,envMap:o,fog:r,near:s,far:a}=i;t=t??H.useTres().renderer,n=n??H.useTres().scene;const c=()=>{e=u.toValue(i.resolution)??255,s=u.toValue(i.near)??.1,a=u.toValue(i.far)??1e3,o=u.toValue(i.envMap)??void 0,r=u.toValue(i.fog)??void 0,t=u.toValue(i.renderer)??t,n=u.toValue(i.scene)??n};u.watchEffect(c);const h=u.computed(()=>new l.WebGLCubeRenderTarget(u.toValue(e)));h.value.texture.type=l.HalfFloatType,hn(()=>{h.value.dispose()});const p=u.computed(()=>new l.CubeCamera(u.toValue(s),u.toValue(a),u.toValue(h))),f=()=>{const m=u.toValue(n),d=m.fog,y=m.background;m.background=u.toValue(o)||y,m.fog=u.toValue(r)||d,p.value.update(u.toValue(t),m),m.fog=d,m.background=y};return u.watchEffect(f),{fbo:h,camera:p,update:f}}const ji=["object"],Wi=u.defineComponent({__name:"component",props:{frames:{default:1/0},resolution:{},near:{},far:{},envMap:{},fog:{},renderer:{},scene:{}},setup(i,{expose:e}){const t=i,n=u.shallowRef(),{fbo:o,camera:r,update:s}=Ri(t);let a=0;return H.useLoop().onBeforeRender(()=>{n.value&&(t.frames===1/0||a<u.toValue(t.frames))&&(n.value.visible=!1,s(),n.value.visible=!0,n.value&&n.value.traverse(c=>{"material"in c&&typeof c.material=="object"&&c.material&&"envMap"in c.material&&(c.material.envMap=o.value.texture)}),a++)}),e({instance:n,fbo:o,camera:r,update:s}),(c,h)=>(u.openBlock(),u.createElementBlock("TresGroup",{ref_key:"groupRef",ref:n},[u.createElementVNode("primitive",{object:u.unref(r)},null,8,ji),u.renderSlot(c.$slots,"default")],512))}}),Yi=u.defineComponent({__name:"Billboard",props:{autoUpdate:{type:Boolean,default:!0},lockX:{type:Boolean,default:!1},lockY:{type:Boolean,default:!1},lockZ:{type:Boolean,default:!1}},setup(i,{expose:e}){const t=i,n=u.shallowRef(new l.Group),o=u.shallowRef(new l.Group),r=new l.Quaternion,s=new l.Euler;function a(c){n.value&&(!c&&(c=H.useTres().camera.value,!c)||(o.value.rotation.copy(s),n.value.updateMatrix(),n.value.updateWorldMatrix(!1,!1),n.value.getWorldQuaternion(r),c.getWorldQuaternion(o.value.quaternion).premultiply(r.invert()),t.lockX&&(o.value.rotation.x=s.x),t.lockY&&(o.value.rotation.y=s.y),t.lockZ&&(o.value.rotation.z=s.z)))}return H.useLoop().onBeforeRender(({camera:c})=>{t.autoUpdate&&a(c)}),e({instance:n,update:a}),(c,h)=>(u.openBlock(),u.createElementBlock("TresGroup",{ref_key:"outerRef",ref:n},[u.createElementVNode("TresGroup",{ref_key:"innerRef",ref:o},[u.renderSlot(c.$slots,"default")],512)],512))}}),Xi=u.defineComponent({name:"GlobalAudio",props:["src","loop","volume","playbackRate","playTrigger","stopTrigger"],async setup(i,{expose:e,emit:t}){var f;const{camera:n,renderer:o}=H.useTresContext(),r=new l.AudioListener;(f=n.value)==null||f.add(r);const s=new l.Audio(r),a=new l.AudioLoader;e({instance:s}),u.onUnmounted(()=>{s&&s.disconnect()}),u.watch(()=>[i.playbackRate],()=>s.setPlaybackRate(i.playbackRate??1),{immediate:!0}),u.watch(()=>[i.volume],()=>s.setVolume(i.volume??.5),{immediate:!0}),u.watch(()=>[i.loop],()=>s.setLoop(i.loop??!1),{immediate:!0}),u.watch(()=>[i.src],async()=>{const m=await a.loadAsync(i.src);s.setBuffer(m)},{immediate:!0});const h=document.getElementById(i.playTrigger??"")||o.value.domElement;Ce(h,"click",()=>{s.isPlaying?s.pause():s.play(),t("isPlaying",s.isPlaying)});const p=document.getElementById(i.stopTrigger??"");return p&&Ce(p,"click",()=>{s.stop(),t("isPlaying",s.isPlaying)}),null}}),Ei=["color-space","args","attach"],Zi=u.defineComponent({__name:"GradientTexture",props:{stops:{},colors:{},attach:{default:"map"},height:{default:1024},width:{default:16},type:{default:"linear"},innerCircleRadius:{default:0},outerCircleRadius:{default:"auto"}},setup(i,{expose:e}){const t=i,n=u.shallowRef(),o=document.createElement("canvas");function r(a){const c=a.getContext("2d");a.width=t.width,a.height=t.height;let h;if(t.type==="linear")h=c.createLinearGradient(0,0,0,t.height);else{const m=a.width/2,d=a.height/2,y=t.outerCircleRadius!=="auto"?Math.abs(Number(t.outerCircleRadius)):Math.sqrt(m**2+d**2);h=c.createRadialGradient(m,d,Math.abs(t.innerCircleRadius),m,d,y)}const p=new Ot.Color;let f=t.stops.length;for(;f--;)h.addColorStop(t.stops[f],p.set(t.colors[f]).getStyle());c.save(),c.fillStyle=h,c.fillRect(0,0,t.width,t.height),c.restore(),n.value&&(n.value.needsUpdate=!0)}const s=H.useTres().renderer;return u.watch(()=>[t.colors,t.stops,t.height,t.width,t.type,t.innerCircleRadius,t.outerCircleRadius],()=>{r(o)},{immediate:!0}),u.isReactive(t.colors)&&u.watch(t.colors,()=>r(o)),u.isReactive(t.stops)&&u.watch(t.stops,()=>r(o)),e({instance:n}),(a,c)=>(u.openBlock(),u.createElementBlock("TresCanvasTexture",{ref_key:"textureRef",ref:n,"color-space":u.unref(s).outputColorSpace,args:[u.unref(o)],attach:t.attach},null,8,Ei))}});function Vn(i,e,t,n){const o=class extends l.ShaderMaterial{constructor(s={}){const a=Object.entries(i);super({uniforms:a.reduce((c,[h,p])=>{const f=l.UniformsUtils.clone({[h]:{value:p}});return{...c,...f}},{}),vertexShader:e,fragmentShader:t});ue(this,"key","");a.forEach(([c])=>Object.defineProperty(this,c,{get:()=>this.uniforms[c].value,set:h=>this.uniforms[c].value=h})),Object.assign(this,s)}};return o.key=l.MathUtils.generateUUID(),o}const Ki=Vn({color:new l.Color("white"),scale:new l.Vector2(1,1),imageBounds:new l.Vector2(1,1),resolution:1024,map:null,zoom:1,radius:0,grayscale:0,opacity:1},`
    varying vec2 vUv;
    varying vec2 vPos;
    void main() {
      gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);
      vUv = uv;
      vPos = position.xy;
    }
  `,`
    // mostly from https://gist.github.com/statico/df64c5d167362ecf7b34fca0b1459a44
    varying vec2 vUv;
    varying vec2 vPos;
    uniform vec2 scale;
    uniform vec2 imageBounds;
    uniform float resolution;
    uniform vec3 color;
    uniform sampler2D map;
    uniform float radius;
    uniform float zoom;
    uniform float grayscale;
    uniform float opacity;
    const vec3 luma = vec3(.299, 0.587, 0.114);
    vec4 toGrayscale(vec4 color, float intensity) {
      return vec4(mix(color.rgb, vec3(dot(color.rgb, luma)), intensity), color.a);
    }
    vec2 aspect(vec2 size) {
      return size / min(size.x, size.y);
    }
    
    const float PI = 3.14159265;
      
    // from https://iquilezles.org/articles/distfunctions
    float udRoundBox( vec2 p, vec2 b, float r ) {
      return length(max(abs(p)-b+r,0.0))-r;
    }
  
    void main() {
      vec2 s = aspect(scale);
      vec2 i = aspect(imageBounds);
      float rs = s.x / s.y;
      float ri = i.x / i.y;
      vec2 new = rs < ri ? vec2(i.x * s.y / i.y, s.y) : vec2(s.x, i.y * s.x / i.x);
      vec2 offset = (rs < ri ? vec2((new.x - s.x) / 2.0, 0.0) : vec2(0.0, (new.y - s.y) / 2.0)) / new;
      vec2 uv = vUv * s / new + offset;
      vec2 zUv = (uv - vec2(0.5, 0.5)) / zoom + vec2(0.5, 0.5);
  
      vec2 res = vec2(scale * resolution);
      vec2 halfRes = 0.5 * res;
      float b = udRoundBox(vUv.xy * res - halfRes, halfRes, resolution * radius);    
        vec3 a = mix(vec3(1.0,0.0,0.0), vec3(0.0,0.0,0.0), smoothstep(0.0, 1.0, b));
      gl_FragColor = toGrayscale(texture2D(map, zUv) * vec4(color, opacity * a), grayscale);
      
      #include <tonemapping_fragment>
      #include <colorspace_fragment>
    }
  `),qi=u.defineComponent({__name:"ImageMaterial",setup(i,{expose:e}){H.extend({ImageMaterial:Ki});const t=u.shallowRef();return e({instance:t}),(n,o)=>(u.openBlock(),u.createElementBlock("TresImageMaterial",{ref_key:"materialRef",ref:t},null,512))}}),Qi=["scale"],Ji=["args"],Hi=u.defineComponent({__name:"component",props:{segments:{default:1},scale:{default:1},color:{default:()=>new l.Color("white")},zoom:{default:1},radius:{default:0},grayscale:{default:0},toneMapped:{type:Boolean,default:!0},transparent:{type:Boolean,default:!1},opacity:{default:1},side:{default:l.FrontSide},texture:{},url:{}},setup(i,{expose:e}){const t=i,n=u.shallowRef(),o=u.shallowRef(t.texture??null),r=H.useTres().sizes,s=u.computed(()=>Array.isArray(t.scale)?[t.scale[0],t.scale[1]]:[t.scale,t.scale]),a=u.computed(()=>{var p,f;return[((p=o.value)==null?void 0:p.image.width)??0,((f=o.value)==null?void 0:f.image.height)??0]}),c=u.computed(()=>Math.max(r.width.value,r.height.value));u.watchEffect(()=>{t.texture?o.value=t.texture:H.useTexture([t.url]).then(p=>o.value=p)});const h=u.computed(()=>Array.isArray(t.scale)?[...t.scale,1]:t.scale);return e({instance:n}),(p,f)=>(u.openBlock(),u.createElementBlock("TresMesh",{ref_key:"imageRef",ref:n,scale:h.value},[u.renderSlot(p.$slots,"default",{},()=>[u.createElementVNode("TresPlaneGeometry",{args:[1,1,t.segments,t.segments]},null,8,Ji)]),u.createVNode(qi,{color:t.color,map:o.value,zoom:t.zoom,grayscale:t.grayscale,opacity:t.opacity,scale:s.value,imageBounds:a.value,resolution:c.value,radius:p.radius,toneMapped:p.toneMapped,transparent:p.transparent,side:p.side},null,8,["color","map","zoom","grayscale","opacity","scale","imageBounds","resolution","radius","toneMapped","transparent","side"])],8,Qi))}}),Xt=parseInt(l.REVISION.replace(/\D+/g,"")),Gn=Xt>=125?"uv1":"uv2";function Qo(i,e){if(e===l.TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),i;if(e===l.TriangleFanDrawMode||e===l.TriangleStripDrawMode){let t=i.getIndex();if(t===null){const s=[],a=i.getAttribute("position");if(a!==void 0){for(let c=0;c<a.count;c++)s.push(c);i.setIndex(s),t=i.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),i}const n=t.count-2,o=[];if(t)if(e===l.TriangleFanDrawMode)for(let s=1;s<=n;s++)o.push(t.getX(0)),o.push(t.getX(s)),o.push(t.getX(s+1));else for(let s=0;s<n;s++)s%2===0?(o.push(t.getX(s)),o.push(t.getX(s+1)),o.push(t.getX(s+2))):(o.push(t.getX(s+2)),o.push(t.getX(s+1)),o.push(t.getX(s)));o.length/3!==n&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const r=i.clone();return r.setIndex(o),r.clearGroups(),r}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),i}function $i(i,e=Math.PI/3){const t=Math.cos(e),n=(1+1e-10)*100,o=[new l.Vector3,new l.Vector3,new l.Vector3],r=new l.Vector3,s=new l.Vector3,a=new l.Vector3,c=new l.Vector3;function h(_){const v=~~(_.x*n),g=~~(_.y*n),A=~~(_.z*n);return`${v},${g},${A}`}const p=i.index?i.toNonIndexed():i,f=p.attributes.position,m={};for(let _=0,v=f.count/3;_<v;_++){const g=3*_,A=o[0].fromBufferAttribute(f,g+0),w=o[1].fromBufferAttribute(f,g+1),C=o[2].fromBufferAttribute(f,g+2);r.subVectors(C,w),s.subVectors(A,w);const L=new l.Vector3().crossVectors(r,s).normalize();for(let M=0;M<3;M++){const P=o[M],b=h(P);b in m||(m[b]=[]),m[b].push(L)}}const d=new Float32Array(f.count*3),y=new l.BufferAttribute(d,3,!1);for(let _=0,v=f.count/3;_<v;_++){const g=3*_,A=o[0].fromBufferAttribute(f,g+0),w=o[1].fromBufferAttribute(f,g+1),C=o[2].fromBufferAttribute(f,g+2);r.subVectors(C,w),s.subVectors(A,w),a.crossVectors(r,s).normalize();for(let L=0;L<3;L++){const M=o[L],P=h(M),b=m[P];c.set(0,0,0);for(let S=0,x=b.length;S<x;S++){const I=b[S];a.dot(I)>t&&c.add(I)}c.normalize(),y.setXYZ(g+L,c.x,c.y,c.z)}}return p.setAttribute("normal",y),p}var ea=Object.defineProperty,ta=(i,e,t)=>e in i?ea(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,na=(i,e,t)=>(ta(i,e+"",t),t);async function Jo(i){const e=await i.arrayBuffer(),t=btoa(String.fromCharCode(...new Uint8Array(e)));return`data:${i.type||""};base64,${t}`}let fn,Rn,Lt,dn;function jn(i,e=1/0,t=null){Rn||(Rn=new l.PlaneGeometry(2,2,1,1)),Lt||(Lt=new l.ShaderMaterial({uniforms:{blitTexture:new l.Uniform(i)},vertexShader:`
        varying vec2 vUv;
        void main(){
            vUv = uv;
            gl_Position = vec4(position.xy * 1.0,0.,.999999);
        }
      `,fragmentShader:`
          uniform sampler2D blitTexture; 
          varying vec2 vUv;

          void main(){ 
              gl_FragColor = vec4(vUv.xy, 0, 1);
              
              #ifdef IS_SRGB
              gl_FragColor = LinearTosRGB( texture2D( blitTexture, vUv) );
              #else
              gl_FragColor = texture2D( blitTexture, vUv);
              #endif
          }
      `})),Lt.uniforms.blitTexture.value=i,Lt.defines.IS_SRGB="colorSpace"in i?i.colorSpace==="srgb":i.encoding===3001,Lt.needsUpdate=!0,dn||(dn=new l.Mesh(Rn,Lt),dn.frustrumCulled=!1);const n=new l.PerspectiveCamera,o=new l.Scene;o.add(dn),t||(t=fn=new l.WebGLRenderer({antialias:!1})),t.setSize(Math.min(i.image.width,e),Math.min(i.image.height,e)),t.clear(),t.render(o,n);const r=new l.Texture(t.domElement);return r.minFilter=i.minFilter,r.magFilter=i.magFilter,r.wrapS=i.wrapS,r.wrapT=i.wrapT,r.name=i.name,fn&&(fn.dispose(),fn=null),r}const Ho={POSITION:["byte","byte normalized","unsigned byte","unsigned byte normalized","short","short normalized","unsigned short","unsigned short normalized"],NORMAL:["byte normalized","short normalized"],TANGENT:["byte normalized","short normalized"],TEXCOORD:["byte","byte normalized","unsigned byte","short","short normalized","unsigned short"]};class Wn{constructor(){this.pluginCallbacks=[],this.register(function(e){return new fa(e)}),this.register(function(e){return new da(e)}),this.register(function(e){return new ga(e)}),this.register(function(e){return new ya(e)}),this.register(function(e){return new _a(e)}),this.register(function(e){return new va(e)}),this.register(function(e){return new pa(e)}),this.register(function(e){return new ma(e)}),this.register(function(e){return new xa(e)}),this.register(function(e){return new wa(e)}),this.register(function(e){return new ba(e)})}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,n,o){const r=new ha,s=[];for(let a=0,c=this.pluginCallbacks.length;a<c;a++)s.push(this.pluginCallbacks[a](r));r.setPlugins(s),r.write(e,t,o).catch(n)}parseAsync(e,t){const n=this;return new Promise(function(o,r){n.parse(e,o,r,t)})}}na(Wn,"Utils",{insertKeyframe:function(i,e){const n=i.getValueSize(),o=new i.TimeBufferType(i.times.length+1),r=new i.ValueBufferType(i.values.length+n),s=i.createInterpolant(new i.ValueBufferType(n));let a;if(i.times.length===0){o[0]=e;for(let c=0;c<n;c++)r[c]=0;a=0}else if(e<i.times[0]){if(Math.abs(i.times[0]-e)<.001)return 0;o[0]=e,o.set(i.times,1),r.set(s.evaluate(e),0),r.set(i.values,n),a=0}else if(e>i.times[i.times.length-1]){if(Math.abs(i.times[i.times.length-1]-e)<.001)return i.times.length-1;o[o.length-1]=e,o.set(i.times,0),r.set(i.values,0),r.set(s.evaluate(e),i.values.length),a=o.length-1}else for(let c=0;c<i.times.length;c++){if(Math.abs(i.times[c]-e)<.001)return c;if(i.times[c]<e&&i.times[c+1]>e){o.set(i.times.slice(0,c+1),0),o[c+1]=e,o.set(i.times.slice(c+1),c+2),r.set(i.values.slice(0,(c+1)*n),0),r.set(s.evaluate(e),(c+1)*n),r.set(i.values.slice((c+1)*n),(c+2)*n),a=c+1;break}}return i.times=o,i.values=r,a},mergeMorphTargetTracks:function(i,e){const t=[],n={},o=i.tracks;for(let r=0;r<o.length;++r){let s=o[r];const a=l.PropertyBinding.parseTrackName(s.name),c=l.PropertyBinding.findNode(e,a.nodeName);if(a.propertyName!=="morphTargetInfluences"||a.propertyIndex===void 0){t.push(s);continue}if(s.createInterpolant!==s.InterpolantFactoryMethodDiscrete&&s.createInterpolant!==s.InterpolantFactoryMethodLinear){if(s.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."),s=s.clone(),s.setInterpolation(l.InterpolateLinear)}const h=c.morphTargetInfluences.length,p=c.morphTargetDictionary[a.propertyIndex];if(p===void 0)throw new Error("THREE.GLTFExporter: Morph target name not found: "+a.propertyIndex);let f;if(n[c.uuid]===void 0){f=s.clone();const d=new f.ValueBufferType(h*f.times.length);for(let y=0;y<f.times.length;y++)d[y*h+p]=f.values[y];f.name=(a.nodeName||"")+".morphTargetInfluences",f.values=d,n[c.uuid]=f,t.push(f);continue}const m=s.createInterpolant(new s.ValueBufferType(1));f=n[c.uuid];for(let d=0;d<f.times.length;d++)f.values[d*h+p]=m.evaluate(f.times[d]);for(let d=0;d<s.times.length;d++){const y=this.insertKeyframe(f,s.times[d]);f.values[y*h+p]=s.values[d]}}return i.tracks=t,i}});const we={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,BYTE:5120,UNSIGNED_BYTE:5121,SHORT:5122,UNSIGNED_SHORT:5123,INT:5124,UNSIGNED_INT:5125,FLOAT:5126,ARRAY_BUFFER:34962,ELEMENT_ARRAY_BUFFER:34963,NEAREST:9728,LINEAR:9729,NEAREST_MIPMAP_NEAREST:9984,LINEAR_MIPMAP_NEAREST:9985,NEAREST_MIPMAP_LINEAR:9986,LINEAR_MIPMAP_LINEAR:9987,CLAMP_TO_EDGE:33071,MIRRORED_REPEAT:33648,REPEAT:10497},Yn="KHR_mesh_quantization",Xe={};Xe[l.NearestFilter]=we.NEAREST,Xe[l.NearestMipmapNearestFilter]=we.NEAREST_MIPMAP_NEAREST,Xe[l.NearestMipmapLinearFilter]=we.NEAREST_MIPMAP_LINEAR,Xe[l.LinearFilter]=we.LINEAR,Xe[l.LinearMipmapNearestFilter]=we.LINEAR_MIPMAP_NEAREST,Xe[l.LinearMipmapLinearFilter]=we.LINEAR_MIPMAP_LINEAR,Xe[l.ClampToEdgeWrapping]=we.CLAMP_TO_EDGE,Xe[l.RepeatWrapping]=we.REPEAT,Xe[l.MirroredRepeatWrapping]=we.MIRRORED_REPEAT;const $o={scale:"scale",position:"translation",quaternion:"rotation",morphTargetInfluences:"weights"},oa=new l.Color,er=12,ra=1179937895,sa=2,tr=8,ia=1313821514,aa=5130562;function Et(i,e){return i.length===e.length&&i.every(function(t,n){return t===e[n]})}function la(i){return new TextEncoder().encode(i).buffer}function ca(i){return Et(i.elements,[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}function ua(i,e,t){const n={min:new Array(i.itemSize).fill(Number.POSITIVE_INFINITY),max:new Array(i.itemSize).fill(Number.NEGATIVE_INFINITY)};for(let o=e;o<e+t;o++)for(let r=0;r<i.itemSize;r++){let s;i.itemSize>4?s=i.array[o*i.itemSize+r]:(r===0?s=i.getX(o):r===1?s=i.getY(o):r===2?s=i.getZ(o):r===3&&(s=i.getW(o)),i.normalized===!0&&(s=l.MathUtils.normalize(s,i.array))),n.min[r]=Math.min(n.min[r],s),n.max[r]=Math.max(n.max[r],s)}return n}function nr(i){return Math.ceil(i/4)*4}function Xn(i,e=0){const t=nr(i.byteLength);if(t!==i.byteLength){const n=new Uint8Array(t);if(n.set(new Uint8Array(i)),e!==0)for(let o=i.byteLength;o<t;o++)n[o]=e;return n.buffer}return i}function or(){return typeof document>"u"&&typeof OffscreenCanvas<"u"?new OffscreenCanvas(1,1):document.createElement("canvas")}function rr(i,e){if(i.toBlob!==void 0)return new Promise(n=>i.toBlob(n,e));let t;return e==="image/jpeg"?t=.92:e==="image/webp"&&(t=.8),i.convertToBlob({type:e,quality:t})}class ha{constructor(){this.plugins=[],this.options={},this.pending=[],this.buffers=[],this.byteOffset=0,this.buffers=[],this.nodeMap=new Map,this.skins=[],this.extensionsUsed={},this.extensionsRequired={},this.uids=new Map,this.uid=0,this.json={asset:{version:"2.0",generator:"THREE.GLTFExporter"}},this.cache={meshes:new Map,attributes:new Map,attributesNormalized:new Map,materials:new Map,textures:new Map,images:new Map}}setPlugins(e){this.plugins=e}async write(e,t,n={}){this.options=Object.assign({binary:!1,trs:!1,onlyVisible:!0,maxTextureSize:1/0,animations:[],includeCustomExtensions:!1},n),this.options.animations.length>0&&(this.options.trs=!0),this.processInput(e),await Promise.all(this.pending);const o=this,r=o.buffers,s=o.json;n=o.options;const a=o.extensionsUsed,c=o.extensionsRequired,h=new Blob(r,{type:"application/octet-stream"}),p=Object.keys(a),f=Object.keys(c);p.length>0&&(s.extensionsUsed=p),f.length>0&&(s.extensionsRequired=f),s.buffers&&s.buffers.length>0&&(s.buffers[0].byteLength=h.size),n.binary===!0?h.arrayBuffer().then(m=>{const d=Xn(m),y=new DataView(new ArrayBuffer(tr));y.setUint32(0,d.byteLength,!0),y.setUint32(4,aa,!0);const _=Xn(la(JSON.stringify(s)),32),v=new DataView(new ArrayBuffer(tr));v.setUint32(0,_.byteLength,!0),v.setUint32(4,ia,!0);const g=new ArrayBuffer(er),A=new DataView(g);A.setUint32(0,ra,!0),A.setUint32(4,sa,!0);const w=er+v.byteLength+_.byteLength+y.byteLength+d.byteLength;A.setUint32(8,w,!0),new Blob([g,v,_,y,d],{type:"application/octet-stream"}).arrayBuffer().then(t)}):s.buffers&&s.buffers.length>0?Jo(h).then(m=>{s.buffers[0].uri=m,t(s)}):t(s)}serializeUserData(e,t){if(Object.keys(e.userData).length===0)return;const n=this.options,o=this.extensionsUsed;try{const r=JSON.parse(JSON.stringify(e.userData));if(n.includeCustomExtensions&&r.gltfExtensions){t.extensions===void 0&&(t.extensions={});for(const s in r.gltfExtensions)t.extensions[s]=r.gltfExtensions[s],o[s]=!0;delete r.gltfExtensions}Object.keys(r).length>0&&(t.extras=r)}catch(r){console.warn("THREE.GLTFExporter: userData of '"+e.name+"' won't be serialized because of JSON.stringify error - "+r.message)}}getUID(e,t=!1){if(this.uids.has(e)===!1){const o=new Map;o.set(!0,this.uid++),o.set(!1,this.uid++),this.uids.set(e,o)}return this.uids.get(e).get(t)}isNormalizedNormalAttribute(e){if(this.cache.attributesNormalized.has(e))return!1;const n=new l.Vector3;for(let o=0,r=e.count;o<r;o++)if(Math.abs(n.fromBufferAttribute(e,o).length()-1)>5e-4)return!1;return!0}createNormalizedNormalAttribute(e){const t=this.cache;if(t.attributesNormalized.has(e))return t.attributesNormalized.get(e);const n=e.clone(),o=new l.Vector3;for(let r=0,s=n.count;r<s;r++)o.fromBufferAttribute(n,r),o.x===0&&o.y===0&&o.z===0?o.setX(1):o.normalize(),n.setXYZ(r,o.x,o.y,o.z);return t.attributesNormalized.set(e,n),n}applyTextureTransform(e,t){let n=!1;const o={};(t.offset.x!==0||t.offset.y!==0)&&(o.offset=t.offset.toArray(),n=!0),t.rotation!==0&&(o.rotation=t.rotation,n=!0),(t.repeat.x!==1||t.repeat.y!==1)&&(o.scale=t.repeat.toArray(),n=!0),n&&(e.extensions=e.extensions||{},e.extensions.KHR_texture_transform=o,this.extensionsUsed.KHR_texture_transform=!0)}buildMetalRoughTexture(e,t){if(e===t)return e;function n(d){return("colorSpace"in d?d.colorSpace==="srgb":d.encoding===3001)?function(_){return _<.04045?_*.0773993808:Math.pow(_*.9478672986+.0521327014,2.4)}:function(_){return _}}console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures."),e instanceof l.CompressedTexture&&(e=jn(e)),t instanceof l.CompressedTexture&&(t=jn(t));const o=e?e.image:null,r=t?t.image:null,s=Math.max(o?o.width:0,r?r.width:0),a=Math.max(o?o.height:0,r?r.height:0),c=or();c.width=s,c.height=a;const h=c.getContext("2d");h.fillStyle="#00ffff",h.fillRect(0,0,s,a);const p=h.getImageData(0,0,s,a);if(o){h.drawImage(o,0,0,s,a);const d=n(e),y=h.getImageData(0,0,s,a).data;for(let _=2;_<y.length;_+=4)p.data[_]=d(y[_]/256)*256}if(r){h.drawImage(r,0,0,s,a);const d=n(t),y=h.getImageData(0,0,s,a).data;for(let _=1;_<y.length;_+=4)p.data[_]=d(y[_]/256)*256}h.putImageData(p,0,0);const m=(e||t).clone();return m.source=new l.Texture(c).source,"colorSpace"in m?m.colorSpace="":m.encoding=3e3,m.channel=(e||t).channel,e&&t&&e.channel!==t.channel&&console.warn("THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match."),m}processBuffer(e){const t=this.json,n=this.buffers;return t.buffers||(t.buffers=[{byteLength:0}]),n.push(e),0}processBufferView(e,t,n,o,r){const s=this.json;s.bufferViews||(s.bufferViews=[]);let a;switch(t){case we.BYTE:case we.UNSIGNED_BYTE:a=1;break;case we.SHORT:case we.UNSIGNED_SHORT:a=2;break;default:a=4}const c=nr(o*e.itemSize*a),h=new DataView(new ArrayBuffer(c));let p=0;for(let d=n;d<n+o;d++)for(let y=0;y<e.itemSize;y++){let _;e.itemSize>4?_=e.array[d*e.itemSize+y]:(y===0?_=e.getX(d):y===1?_=e.getY(d):y===2?_=e.getZ(d):y===3&&(_=e.getW(d)),e.normalized===!0&&(_=l.MathUtils.normalize(_,e.array))),t===we.FLOAT?h.setFloat32(p,_,!0):t===we.INT?h.setInt32(p,_,!0):t===we.UNSIGNED_INT?h.setUint32(p,_,!0):t===we.SHORT?h.setInt16(p,_,!0):t===we.UNSIGNED_SHORT?h.setUint16(p,_,!0):t===we.BYTE?h.setInt8(p,_):t===we.UNSIGNED_BYTE&&h.setUint8(p,_),p+=a}const f={buffer:this.processBuffer(h.buffer),byteOffset:this.byteOffset,byteLength:c};return r!==void 0&&(f.target=r),r===we.ARRAY_BUFFER&&(f.byteStride=e.itemSize*a),this.byteOffset+=c,s.bufferViews.push(f),{id:s.bufferViews.length-1,byteLength:0}}processBufferViewImage(e){const t=this,n=t.json;return n.bufferViews||(n.bufferViews=[]),e.arrayBuffer().then(o=>{const r=Xn(o),s={buffer:t.processBuffer(r),byteOffset:t.byteOffset,byteLength:r.byteLength};return t.byteOffset+=r.byteLength,n.bufferViews.push(s)-1})}processAccessor(e,t,n,o){const r=this.json,s={1:"SCALAR",2:"VEC2",3:"VEC3",4:"VEC4",9:"MAT3",16:"MAT4"};let a;if(e.array.constructor===Float32Array)a=we.FLOAT;else if(e.array.constructor===Int32Array)a=we.INT;else if(e.array.constructor===Uint32Array)a=we.UNSIGNED_INT;else if(e.array.constructor===Int16Array)a=we.SHORT;else if(e.array.constructor===Uint16Array)a=we.UNSIGNED_SHORT;else if(e.array.constructor===Int8Array)a=we.BYTE;else if(e.array.constructor===Uint8Array)a=we.UNSIGNED_BYTE;else throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type: "+e.array.constructor.name);if(n===void 0&&(n=0),o===void 0&&(o=e.count),o===0)return null;const c=ua(e,n,o);let h;t!==void 0&&(h=e===t.index?we.ELEMENT_ARRAY_BUFFER:we.ARRAY_BUFFER);const p=this.processBufferView(e,a,n,o,h),f={bufferView:p.id,byteOffset:p.byteOffset,componentType:a,count:o,max:c.max,min:c.min,type:s[e.itemSize]};return e.normalized===!0&&(f.normalized=!0),r.accessors||(r.accessors=[]),r.accessors.push(f)-1}processImage(e,t,n,o="image/png"){if(e!==null){const r=this,s=r.cache,a=r.json,c=r.options,h=r.pending;s.images.has(e)||s.images.set(e,{});const p=s.images.get(e),f=o+":flipY/"+n.toString();if(p[f]!==void 0)return p[f];a.images||(a.images=[]);const m={mimeType:o},d=or();d.width=Math.min(e.width,c.maxTextureSize),d.height=Math.min(e.height,c.maxTextureSize);const y=d.getContext("2d");if(n===!0&&(y.translate(0,d.height),y.scale(1,-1)),e.data!==void 0){t!==l.RGBAFormat&&console.error("GLTFExporter: Only RGBAFormat is supported.",t),(e.width>c.maxTextureSize||e.height>c.maxTextureSize)&&console.warn("GLTFExporter: Image size is bigger than maxTextureSize",e);const v=new Uint8ClampedArray(e.height*e.width*4);for(let g=0;g<v.length;g+=4)v[g+0]=e.data[g+0],v[g+1]=e.data[g+1],v[g+2]=e.data[g+2],v[g+3]=e.data[g+3];y.putImageData(new ImageData(v,e.width,e.height),0,0)}else y.drawImage(e,0,0,d.width,d.height);c.binary===!0?h.push(rr(d,o).then(v=>r.processBufferViewImage(v)).then(v=>{m.bufferView=v})):d.toDataURL!==void 0?m.uri=d.toDataURL(o):h.push(rr(d,o).then(Jo).then(v=>{m.uri=v}));const _=a.images.push(m)-1;return p[f]=_,_}else throw new Error("THREE.GLTFExporter: No valid image data found. Unable to process texture.")}processSampler(e){const t=this.json;t.samplers||(t.samplers=[]);const n={magFilter:Xe[e.magFilter],minFilter:Xe[e.minFilter],wrapS:Xe[e.wrapS],wrapT:Xe[e.wrapT]};return t.samplers.push(n)-1}processTexture(e){const n=this.options,o=this.cache,r=this.json;if(o.textures.has(e))return o.textures.get(e);r.textures||(r.textures=[]),e instanceof l.CompressedTexture&&(e=jn(e,n.maxTextureSize));let s=e.userData.mimeType;s==="image/webp"&&(s="image/png");const a={sampler:this.processSampler(e),source:this.processImage(e.image,e.format,e.flipY,s)};e.name&&(a.name=e.name),this._invokeAll(function(h){h.writeTexture&&h.writeTexture(e,a)});const c=r.textures.push(a)-1;return o.textures.set(e,c),c}processMaterial(e){const t=this.cache,n=this.json;if(t.materials.has(e))return t.materials.get(e);if(e.isShaderMaterial)return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."),null;n.materials||(n.materials=[]);const o={pbrMetallicRoughness:{}};e.isMeshStandardMaterial!==!0&&e.isMeshBasicMaterial!==!0&&console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");const r=e.color.toArray().concat([e.opacity]);if(Et(r,[1,1,1,1])||(o.pbrMetallicRoughness.baseColorFactor=r),e.isMeshStandardMaterial?(o.pbrMetallicRoughness.metallicFactor=e.metalness,o.pbrMetallicRoughness.roughnessFactor=e.roughness):(o.pbrMetallicRoughness.metallicFactor=.5,o.pbrMetallicRoughness.roughnessFactor=.5),e.metalnessMap||e.roughnessMap){const a=this.buildMetalRoughTexture(e.metalnessMap,e.roughnessMap),c={index:this.processTexture(a),channel:a.channel};this.applyTextureTransform(c,a),o.pbrMetallicRoughness.metallicRoughnessTexture=c}if(e.map){const a={index:this.processTexture(e.map),texCoord:e.map.channel};this.applyTextureTransform(a,e.map),o.pbrMetallicRoughness.baseColorTexture=a}if(e.emissive){const a=e.emissive;if(Math.max(a.r,a.g,a.b)>0&&(o.emissiveFactor=e.emissive.toArray()),e.emissiveMap){const h={index:this.processTexture(e.emissiveMap),texCoord:e.emissiveMap.channel};this.applyTextureTransform(h,e.emissiveMap),o.emissiveTexture=h}}if(e.normalMap){const a={index:this.processTexture(e.normalMap),texCoord:e.normalMap.channel};e.normalScale&&e.normalScale.x!==1&&(a.scale=e.normalScale.x),this.applyTextureTransform(a,e.normalMap),o.normalTexture=a}if(e.aoMap){const a={index:this.processTexture(e.aoMap),texCoord:e.aoMap.channel};e.aoMapIntensity!==1&&(a.strength=e.aoMapIntensity),this.applyTextureTransform(a,e.aoMap),o.occlusionTexture=a}e.transparent?o.alphaMode="BLEND":e.alphaTest>0&&(o.alphaMode="MASK",o.alphaCutoff=e.alphaTest),e.side===l.DoubleSide&&(o.doubleSided=!0),e.name!==""&&(o.name=e.name),this.serializeUserData(e,o),this._invokeAll(function(a){a.writeMaterial&&a.writeMaterial(e,o)});const s=n.materials.push(o)-1;return t.materials.set(e,s),s}processMesh(e){const t=this.cache,n=this.json,o=[e.geometry.uuid];if(Array.isArray(e.material))for(let w=0,C=e.material.length;w<C;w++)o.push(e.material[w].uuid);else o.push(e.material.uuid);const r=o.join(":");if(t.meshes.has(r))return t.meshes.get(r);const s=e.geometry;let a;e.isLineSegments?a=we.LINES:e.isLineLoop?a=we.LINE_LOOP:e.isLine?a=we.LINE_STRIP:e.isPoints?a=we.POINTS:a=e.material.wireframe?we.LINES:we.TRIANGLES;const c={},h={},p=[],f=[],m={...Xt>=152?{uv:"TEXCOORD_0",uv1:"TEXCOORD_1",uv2:"TEXCOORD_2",uv3:"TEXCOORD_3"}:{uv:"TEXCOORD_0",uv2:"TEXCOORD_1"},color:"COLOR_0",skinWeight:"WEIGHTS_0",skinIndex:"JOINTS_0"},d=s.getAttribute("normal");d!==void 0&&!this.isNormalizedNormalAttribute(d)&&(console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."),s.setAttribute("normal",this.createNormalizedNormalAttribute(d)));let y=null;for(let w in s.attributes){if(w.slice(0,5)==="morph")continue;const C=s.attributes[w];if(w=m[w]||w.toUpperCase(),/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(w)||(w="_"+w),t.attributes.has(this.getUID(C))){h[w]=t.attributes.get(this.getUID(C));continue}y=null;const M=C.array;w==="JOINTS_0"&&!(M instanceof Uint16Array)&&!(M instanceof Uint8Array)&&(console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'),y=new l.BufferAttribute(new Uint16Array(M),C.itemSize,C.normalized));const P=this.processAccessor(y||C,s);P!==null&&(w.startsWith("_")||this.detectMeshQuantization(w,C),h[w]=P,t.attributes.set(this.getUID(C),P))}if(d!==void 0&&s.setAttribute("normal",d),Object.keys(h).length===0)return null;if(e.morphTargetInfluences!==void 0&&e.morphTargetInfluences.length>0){const w=[],C=[],L={};if(e.morphTargetDictionary!==void 0)for(const M in e.morphTargetDictionary)L[e.morphTargetDictionary[M]]=M;for(let M=0;M<e.morphTargetInfluences.length;++M){const P={};let b=!1;for(const S in s.morphAttributes){if(S!=="position"&&S!=="normal"){b||(console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."),b=!0);continue}const x=s.morphAttributes[S][M],I=S.toUpperCase(),D=s.attributes[S];if(t.attributes.has(this.getUID(x,!0))){P[I]=t.attributes.get(this.getUID(x,!0));continue}const z=x.clone();if(!s.morphTargetsRelative)for(let G=0,E=x.count;G<E;G++)for(let X=0;X<x.itemSize;X++)X===0&&z.setX(G,x.getX(G)-D.getX(G)),X===1&&z.setY(G,x.getY(G)-D.getY(G)),X===2&&z.setZ(G,x.getZ(G)-D.getZ(G)),X===3&&z.setW(G,x.getW(G)-D.getW(G));P[I]=this.processAccessor(z,s),t.attributes.set(this.getUID(D,!0),P[I])}f.push(P),w.push(e.morphTargetInfluences[M]),e.morphTargetDictionary!==void 0&&C.push(L[M])}c.weights=w,C.length>0&&(c.extras={},c.extras.targetNames=C)}const _=Array.isArray(e.material);if(_&&s.groups.length===0)return null;const v=_?e.material:[e.material],g=_?s.groups:[{materialIndex:0,start:void 0,count:void 0}];for(let w=0,C=g.length;w<C;w++){const L={mode:a,attributes:h};if(this.serializeUserData(s,L),f.length>0&&(L.targets=f),s.index!==null){let P=this.getUID(s.index);(g[w].start!==void 0||g[w].count!==void 0)&&(P+=":"+g[w].start+":"+g[w].count),t.attributes.has(P)?L.indices=t.attributes.get(P):(L.indices=this.processAccessor(s.index,s,g[w].start,g[w].count),t.attributes.set(P,L.indices)),L.indices===null&&delete L.indices}const M=this.processMaterial(v[g[w].materialIndex]);M!==null&&(L.material=M),p.push(L)}c.primitives=p,n.meshes||(n.meshes=[]),this._invokeAll(function(w){w.writeMesh&&w.writeMesh(e,c)});const A=n.meshes.push(c)-1;return t.meshes.set(r,A),A}detectMeshQuantization(e,t){if(this.extensionsUsed[Yn])return;let n;switch(t.array.constructor){case Int8Array:n="byte";break;case Uint8Array:n="unsigned byte";break;case Int16Array:n="short";break;case Uint16Array:n="unsigned short";break;default:return}t.normalized&&(n+=" normalized");const o=e.split("_",1)[0];Ho[o]&&Ho[o].includes(n)&&(this.extensionsUsed[Yn]=!0,this.extensionsRequired[Yn]=!0)}processCamera(e){const t=this.json;t.cameras||(t.cameras=[]);const n=e.isOrthographicCamera,o={type:n?"orthographic":"perspective"};return n?o.orthographic={xmag:e.right*2,ymag:e.top*2,zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near}:o.perspective={aspectRatio:e.aspect,yfov:l.MathUtils.degToRad(e.fov),zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near},e.name!==""&&(o.name=e.type),t.cameras.push(o)-1}processAnimation(e,t){const n=this.json,o=this.nodeMap;n.animations||(n.animations=[]),e=Wn.Utils.mergeMorphTargetTracks(e.clone(),t);const r=e.tracks,s=[],a=[];for(let c=0;c<r.length;++c){const h=r[c],p=l.PropertyBinding.parseTrackName(h.name);let f=l.PropertyBinding.findNode(t,p.nodeName);const m=$o[p.propertyName];if(p.objectName==="bones"&&(f.isSkinnedMesh===!0?f=f.skeleton.getBoneByName(p.objectIndex):f=void 0),!f||!m)return console.warn('THREE.GLTFExporter: Could not export animation track "%s".',h.name),null;const d=1;let y=h.values.length/h.times.length;m===$o.morphTargetInfluences&&(y/=f.morphTargetInfluences.length);let _;h.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline===!0?(_="CUBICSPLINE",y/=3):h.getInterpolation()===l.InterpolateDiscrete?_="STEP":_="LINEAR",a.push({input:this.processAccessor(new l.BufferAttribute(h.times,d)),output:this.processAccessor(new l.BufferAttribute(h.values,y)),interpolation:_}),s.push({sampler:a.length-1,target:{node:o.get(f),path:m}})}return n.animations.push({name:e.name||"clip_"+n.animations.length,samplers:a,channels:s}),n.animations.length-1}processSkin(e){const t=this.json,n=this.nodeMap,o=t.nodes[n.get(e)],r=e.skeleton;if(r===void 0)return null;const s=e.skeleton.bones[0];if(s===void 0)return null;const a=[],c=new Float32Array(r.bones.length*16),h=new l.Matrix4;for(let f=0;f<r.bones.length;++f)a.push(n.get(r.bones[f])),h.copy(r.boneInverses[f]),h.multiply(e.bindMatrix).toArray(c,f*16);return t.skins===void 0&&(t.skins=[]),t.skins.push({inverseBindMatrices:this.processAccessor(new l.BufferAttribute(c,16)),joints:a,skeleton:n.get(s)}),o.skin=t.skins.length-1}processNode(e){const t=this.json,n=this.options,o=this.nodeMap;t.nodes||(t.nodes=[]);const r={};if(n.trs){const a=e.quaternion.toArray(),c=e.position.toArray(),h=e.scale.toArray();Et(a,[0,0,0,1])||(r.rotation=a),Et(c,[0,0,0])||(r.translation=c),Et(h,[1,1,1])||(r.scale=h)}else e.matrixAutoUpdate&&e.updateMatrix(),ca(e.matrix)===!1&&(r.matrix=e.matrix.elements);if(e.name!==""&&(r.name=String(e.name)),this.serializeUserData(e,r),e.isMesh||e.isLine||e.isPoints){const a=this.processMesh(e);a!==null&&(r.mesh=a)}else e.isCamera&&(r.camera=this.processCamera(e));if(e.isSkinnedMesh&&this.skins.push(e),e.children.length>0){const a=[];for(let c=0,h=e.children.length;c<h;c++){const p=e.children[c];if(p.visible||n.onlyVisible===!1){const f=this.processNode(p);f!==null&&a.push(f)}}a.length>0&&(r.children=a)}this._invokeAll(function(a){a.writeNode&&a.writeNode(e,r)});const s=t.nodes.push(r)-1;return o.set(e,s),s}processScene(e){const t=this.json,n=this.options;t.scenes||(t.scenes=[],t.scene=0);const o={};e.name!==""&&(o.name=e.name),t.scenes.push(o);const r=[];for(let s=0,a=e.children.length;s<a;s++){const c=e.children[s];if(c.visible||n.onlyVisible===!1){const h=this.processNode(c);h!==null&&r.push(h)}}r.length>0&&(o.nodes=r),this.serializeUserData(e,o)}processObjects(e){const t=new l.Scene;t.name="AuxScene";for(let n=0;n<e.length;n++)t.children.push(e[n]);this.processScene(t)}processInput(e){const t=this.options;e=e instanceof Array?e:[e],this._invokeAll(function(o){o.beforeParse&&o.beforeParse(e)});const n=[];for(let o=0;o<e.length;o++)e[o]instanceof l.Scene?this.processScene(e[o]):n.push(e[o]);n.length>0&&this.processObjects(n);for(let o=0;o<this.skins.length;++o)this.processSkin(this.skins[o]);for(let o=0;o<t.animations.length;++o)this.processAnimation(t.animations[o],e[0]);this._invokeAll(function(o){o.afterParse&&o.afterParse(e)})}_invokeAll(e){for(let t=0,n=this.plugins.length;t<n;t++)e(this.plugins[t])}}class fa{constructor(e){this.writer=e,this.name="KHR_lights_punctual"}writeNode(e,t){if(!e.isLight)return;if(!e.isDirectionalLight&&!e.isPointLight&&!e.isSpotLight){console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.",e);return}const n=this.writer,o=n.json,r=n.extensionsUsed,s={};e.name&&(s.name=e.name),s.color=e.color.toArray(),s.intensity=e.intensity,e.isDirectionalLight?s.type="directional":e.isPointLight?(s.type="point",e.distance>0&&(s.range=e.distance)):e.isSpotLight&&(s.type="spot",e.distance>0&&(s.range=e.distance),s.spot={},s.spot.innerConeAngle=(e.penumbra-1)*e.angle*-1,s.spot.outerConeAngle=e.angle),e.decay!==void 0&&e.decay!==2&&console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."),e.target&&(e.target.parent!==e||e.target.position.x!==0||e.target.position.y!==0||e.target.position.z!==-1)&&console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."),r[this.name]||(o.extensions=o.extensions||{},o.extensions[this.name]={lights:[]},r[this.name]=!0);const a=o.extensions[this.name].lights;a.push(s),t.extensions=t.extensions||{},t.extensions[this.name]={light:a.length-1}}}let da=class{constructor(e){this.writer=e,this.name="KHR_materials_unlit"}writeMaterial(e,t){if(!e.isMeshBasicMaterial)return;const o=this.writer.extensionsUsed;t.extensions=t.extensions||{},t.extensions[this.name]={},o[this.name]=!0,t.pbrMetallicRoughness.metallicFactor=0,t.pbrMetallicRoughness.roughnessFactor=.9}},pa=class{constructor(e){this.writer=e,this.name="KHR_materials_clearcoat"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||e.clearcoat===0)return;const n=this.writer,o=n.extensionsUsed,r={};if(r.clearcoatFactor=e.clearcoat,e.clearcoatMap){const s={index:n.processTexture(e.clearcoatMap),texCoord:e.clearcoatMap.channel};n.applyTextureTransform(s,e.clearcoatMap),r.clearcoatTexture=s}if(r.clearcoatRoughnessFactor=e.clearcoatRoughness,e.clearcoatRoughnessMap){const s={index:n.processTexture(e.clearcoatRoughnessMap),texCoord:e.clearcoatRoughnessMap.channel};n.applyTextureTransform(s,e.clearcoatRoughnessMap),r.clearcoatRoughnessTexture=s}if(e.clearcoatNormalMap){const s={index:n.processTexture(e.clearcoatNormalMap),texCoord:e.clearcoatNormalMap.channel};n.applyTextureTransform(s,e.clearcoatNormalMap),r.clearcoatNormalTexture=s}t.extensions=t.extensions||{},t.extensions[this.name]=r,o[this.name]=!0}},ma=class{constructor(e){this.writer=e,this.name="KHR_materials_iridescence"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||e.iridescence===0)return;const n=this.writer,o=n.extensionsUsed,r={};if(r.iridescenceFactor=e.iridescence,e.iridescenceMap){const s={index:n.processTexture(e.iridescenceMap),texCoord:e.iridescenceMap.channel};n.applyTextureTransform(s,e.iridescenceMap),r.iridescenceTexture=s}if(r.iridescenceIor=e.iridescenceIOR,r.iridescenceThicknessMinimum=e.iridescenceThicknessRange[0],r.iridescenceThicknessMaximum=e.iridescenceThicknessRange[1],e.iridescenceThicknessMap){const s={index:n.processTexture(e.iridescenceThicknessMap),texCoord:e.iridescenceThicknessMap.channel};n.applyTextureTransform(s,e.iridescenceThicknessMap),r.iridescenceThicknessTexture=s}t.extensions=t.extensions||{},t.extensions[this.name]=r,o[this.name]=!0}},ga=class{constructor(e){this.writer=e,this.name="KHR_materials_transmission"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||e.transmission===0)return;const n=this.writer,o=n.extensionsUsed,r={};if(r.transmissionFactor=e.transmission,e.transmissionMap){const s={index:n.processTexture(e.transmissionMap),texCoord:e.transmissionMap.channel};n.applyTextureTransform(s,e.transmissionMap),r.transmissionTexture=s}t.extensions=t.extensions||{},t.extensions[this.name]=r,o[this.name]=!0}},ya=class{constructor(e){this.writer=e,this.name="KHR_materials_volume"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||e.transmission===0)return;const n=this.writer,o=n.extensionsUsed,r={};if(r.thicknessFactor=e.thickness,e.thicknessMap){const s={index:n.processTexture(e.thicknessMap),texCoord:e.thicknessMap.channel};n.applyTextureTransform(s,e.thicknessMap),r.thicknessTexture=s}r.attenuationDistance=e.attenuationDistance,r.attenuationColor=e.attenuationColor.toArray(),t.extensions=t.extensions||{},t.extensions[this.name]=r,o[this.name]=!0}},_a=class{constructor(e){this.writer=e,this.name="KHR_materials_ior"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||e.ior===1.5)return;const o=this.writer.extensionsUsed,r={};r.ior=e.ior,t.extensions=t.extensions||{},t.extensions[this.name]=r,o[this.name]=!0}},va=class{constructor(e){this.writer=e,this.name="KHR_materials_specular"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||e.specularIntensity===1&&e.specularColor.equals(oa)&&!e.specularIntensityMap&&!e.specularColorTexture)return;const n=this.writer,o=n.extensionsUsed,r={};if(e.specularIntensityMap){const s={index:n.processTexture(e.specularIntensityMap),texCoord:e.specularIntensityMap.channel};n.applyTextureTransform(s,e.specularIntensityMap),r.specularTexture=s}if(e.specularColorMap){const s={index:n.processTexture(e.specularColorMap),texCoord:e.specularColorMap.channel};n.applyTextureTransform(s,e.specularColorMap),r.specularColorTexture=s}r.specularFactor=e.specularIntensity,r.specularColorFactor=e.specularColor.toArray(),t.extensions=t.extensions||{},t.extensions[this.name]=r,o[this.name]=!0}},xa=class{constructor(e){this.writer=e,this.name="KHR_materials_sheen"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||e.sheen==0)return;const n=this.writer,o=n.extensionsUsed,r={};if(e.sheenRoughnessMap){const s={index:n.processTexture(e.sheenRoughnessMap),texCoord:e.sheenRoughnessMap.channel};n.applyTextureTransform(s,e.sheenRoughnessMap),r.sheenRoughnessTexture=s}if(e.sheenColorMap){const s={index:n.processTexture(e.sheenColorMap),texCoord:e.sheenColorMap.channel};n.applyTextureTransform(s,e.sheenColorMap),r.sheenColorTexture=s}r.sheenRoughnessFactor=e.sheenRoughness,r.sheenColorFactor=e.sheenColor.toArray(),t.extensions=t.extensions||{},t.extensions[this.name]=r,o[this.name]=!0}},wa=class{constructor(e){this.writer=e,this.name="KHR_materials_anisotropy"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||e.anisotropy==0)return;const n=this.writer,o=n.extensionsUsed,r={};if(e.anisotropyMap){const s={index:n.processTexture(e.anisotropyMap)};n.applyTextureTransform(s,e.anisotropyMap),r.anisotropyTexture=s}r.anisotropyStrength=e.anisotropy,r.anisotropyRotation=e.anisotropyRotation,t.extensions=t.extensions||{},t.extensions[this.name]=r,o[this.name]=!0}},ba=class{constructor(e){this.writer=e,this.name="KHR_materials_emissive_strength"}writeMaterial(e,t){if(!e.isMeshStandardMaterial||e.emissiveIntensity===1)return;const o=this.writer.extensionsUsed,r={};r.emissiveStrength=e.emissiveIntensity,t.extensions=t.extensions||{},t.extensions[this.name]=r,o[this.name]=!0}};var Ze=Uint8Array,gt=Uint16Array,En=Uint32Array,sr=new Ze([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),ir=new Ze([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Ma=new Ze([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),ar=function(i,e){for(var t=new gt(31),n=0;n<31;++n)t[n]=e+=1<<i[n-1];for(var o=new En(t[30]),n=1;n<30;++n)for(var r=t[n];r<t[n+1];++r)o[r]=r-t[n]<<5|n;return[t,o]},lr=ar(sr,2),cr=lr[0],Sa=lr[1];cr[28]=258,Sa[258]=28;for(var Aa=ar(ir,0),Pa=Aa[0],Zn=new gt(32768),Ie=0;Ie<32768;++Ie){var yt=(Ie&43690)>>>1|(Ie&21845)<<1;yt=(yt&52428)>>>2|(yt&13107)<<2,yt=(yt&61680)>>>4|(yt&3855)<<4,Zn[Ie]=((yt&65280)>>>8|(yt&255)<<8)>>>1}for(var Zt=function(i,e,t){for(var n=i.length,o=0,r=new gt(e);o<n;++o)++r[i[o]-1];var s=new gt(e);for(o=0;o<e;++o)s[o]=s[o-1]+r[o-1]<<1;var a;if(t){a=new gt(1<<e);var c=15-e;for(o=0;o<n;++o)if(i[o])for(var h=o<<4|i[o],p=e-i[o],f=s[i[o]-1]++<<p,m=f|(1<<p)-1;f<=m;++f)a[Zn[f]>>>c]=h}else for(a=new gt(n),o=0;o<n;++o)i[o]&&(a[o]=Zn[s[i[o]-1]++]>>>15-i[o]);return a},Kt=new Ze(288),Ie=0;Ie<144;++Ie)Kt[Ie]=8;for(var Ie=144;Ie<256;++Ie)Kt[Ie]=9;for(var Ie=256;Ie<280;++Ie)Kt[Ie]=7;for(var Ie=280;Ie<288;++Ie)Kt[Ie]=8;for(var ur=new Ze(32),Ie=0;Ie<32;++Ie)ur[Ie]=5;var Ca=Zt(Kt,9,1),Ta=Zt(ur,5,1),Kn=function(i){for(var e=i[0],t=1;t<i.length;++t)i[t]>e&&(e=i[t]);return e},He=function(i,e,t){var n=e/8|0;return(i[n]|i[n+1]<<8)>>(e&7)&t},qn=function(i,e){var t=e/8|0;return(i[t]|i[t+1]<<8|i[t+2]<<16)>>(e&7)},Ia=function(i){return(i/8|0)+(i&7&&1)},Oa=function(i,e,t){(t==null||t>i.length)&&(t=i.length);var n=new(i instanceof gt?gt:i instanceof En?En:Ze)(t-e);return n.set(i.subarray(e,t)),n},La=function(i,e,t){var n=i.length;if(!n||t&&!t.l&&n<5)return e||new Ze(0);var o=!e||t,r=!t||t.i;t||(t={}),e||(e=new Ze(n*3));var s=function(U){var B=e.length;if(U>B){var R=new Ze(Math.max(B*2,U));R.set(e),e=R}},a=t.f||0,c=t.p||0,h=t.b||0,p=t.l,f=t.d,m=t.m,d=t.n,y=n*8;do{if(!p){t.f=a=He(i,c,1);var _=He(i,c+1,3);if(c+=3,_)if(_==1)p=Ca,f=Ta,m=9,d=5;else if(_==2){var w=He(i,c,31)+257,C=He(i,c+10,15)+4,L=w+He(i,c+5,31)+1;c+=14;for(var M=new Ze(L),P=new Ze(19),b=0;b<C;++b)P[Ma[b]]=He(i,c+b*3,7);c+=C*3;for(var S=Kn(P),x=(1<<S)-1,I=Zt(P,S,1),b=0;b<L;){var D=I[He(i,c,x)];c+=D&15;var v=D>>>4;if(v<16)M[b++]=v;else{var z=0,G=0;for(v==16?(G=3+He(i,c,3),c+=2,z=M[b-1]):v==17?(G=3+He(i,c,7),c+=3):v==18&&(G=11+He(i,c,127),c+=7);G--;)M[b++]=z}}var E=M.subarray(0,w),X=M.subarray(w);m=Kn(E),d=Kn(X),p=Zt(E,m,1),f=Zt(X,d,1)}else throw"invalid block type";else{var v=Ia(c)+4,g=i[v-4]|i[v-3]<<8,A=v+g;if(A>n){if(r)throw"unexpected EOF";break}o&&s(h+g),e.set(i.subarray(v,A),h),t.b=h+=g,t.p=c=A*8;continue}if(c>y){if(r)throw"unexpected EOF";break}}o&&s(h+131072);for(var oe=(1<<m)-1,q=(1<<d)-1,ee=c;;ee=c){var z=p[qn(i,c)&oe],te=z>>>4;if(c+=z&15,c>y){if(r)throw"unexpected EOF";break}if(!z)throw"invalid length/literal";if(te<256)e[h++]=te;else if(te==256){ee=c,p=null;break}else{var ce=te-254;if(te>264){var b=te-257,le=sr[b];ce=He(i,c,(1<<le)-1)+cr[b],c+=le}var de=f[qn(i,c)&q],k=de>>>4;if(!de)throw"invalid distance";c+=de&15;var X=Pa[k];if(k>3){var le=ir[k];X+=qn(i,c)&(1<<le)-1,c+=le}if(c>y){if(r)throw"unexpected EOF";break}o&&s(h+131072);for(var V=h+ce;h<V;h+=4)e[h]=e[h-X],e[h+1]=e[h+1-X],e[h+2]=e[h+2-X],e[h+3]=e[h+3-X];h=V}}t.l=p,t.p=ee,t.b=h,p&&(a=1,t.m=m,t.d=f,t.n=d)}while(!a);return h==e.length?e:Oa(e,0,h)},Da=new Ze(0),ka=function(i){if((i[0]&15)!=8||i[0]>>>4>7||(i[0]<<8|i[1])%31)throw"invalid zlib data";if(i[1]&32)throw"invalid zlib data: preset dictionaries not supported"};function Ba(i,e){return La((ka(i),i.subarray(2,-4)),e)}var Ua=typeof TextDecoder<"u"&&new TextDecoder,Na=0;try{Ua.decode(Da,{stream:!0}),Na=1}catch{}var Fa=Object.defineProperty,za=(i,e,t)=>e in i?Fa(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Va=(i,e,t)=>(za(i,e+"",t),t);const hr=class extends l.Mesh{constructor(i,e={}){super(i),this.isReflector=!0,this.type="Reflector",this.camera=new l.PerspectiveCamera;const t=this,n=e.color!==void 0?new l.Color(e.color):new l.Color(8355711),o=e.textureWidth||512,r=e.textureHeight||512,s=e.clipBias||0,a=e.shader||hr.ReflectorShader,c=e.multisample!==void 0?e.multisample:4,h=new l.Plane,p=new l.Vector3,f=new l.Vector3,m=new l.Vector3,d=new l.Matrix4,y=new l.Vector3(0,0,-1),_=new l.Vector4,v=new l.Vector3,g=new l.Vector3,A=new l.Vector4,w=new l.Matrix4,C=this.camera,L=new l.WebGLRenderTarget(o,r,{samples:c,type:l.HalfFloatType}),M=new l.ShaderMaterial({uniforms:l.UniformsUtils.clone(a.uniforms),fragmentShader:a.fragmentShader,vertexShader:a.vertexShader});M.uniforms.tDiffuse.value=L.texture,M.uniforms.color.value=n,M.uniforms.textureMatrix.value=w,this.material=M,this.onBeforeRender=function(P,b,S){if(f.setFromMatrixPosition(t.matrixWorld),m.setFromMatrixPosition(S.matrixWorld),d.extractRotation(t.matrixWorld),p.set(0,0,1),p.applyMatrix4(d),v.subVectors(f,m),v.dot(p)>0)return;v.reflect(p).negate(),v.add(f),d.extractRotation(S.matrixWorld),y.set(0,0,-1),y.applyMatrix4(d),y.add(m),g.subVectors(f,y),g.reflect(p).negate(),g.add(f),C.position.copy(v),C.up.set(0,1,0),C.up.applyMatrix4(d),C.up.reflect(p),C.lookAt(g),C.far=S.far,C.updateMatrixWorld(),C.projectionMatrix.copy(S.projectionMatrix),w.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),w.multiply(C.projectionMatrix),w.multiply(C.matrixWorldInverse),w.multiply(t.matrixWorld),h.setFromNormalAndCoplanarPoint(p,f),h.applyMatrix4(C.matrixWorldInverse),_.set(h.normal.x,h.normal.y,h.normal.z,h.constant);const x=C.projectionMatrix;A.x=(Math.sign(_.x)+x.elements[8])/x.elements[0],A.y=(Math.sign(_.y)+x.elements[9])/x.elements[5],A.z=-1,A.w=(1+x.elements[10])/x.elements[14],_.multiplyScalar(2/_.dot(A)),x.elements[2]=_.x,x.elements[6]=_.y,x.elements[10]=_.z+1-s,x.elements[14]=_.w,t.visible=!1;const I=P.getRenderTarget(),D=P.xr.enabled,z=P.shadowMap.autoUpdate,G=P.toneMapping;let E=!1;"outputColorSpace"in P?E=P.outputColorSpace==="srgb":E=P.outputEncoding===3001,P.xr.enabled=!1,P.shadowMap.autoUpdate=!1,"outputColorSpace"in P?P.outputColorSpace="srgb-linear":P.outputEncoding=3e3,P.toneMapping=l.NoToneMapping,P.setRenderTarget(L),P.state.buffers.depth.setMask(!0),P.autoClear===!1&&P.clear(),P.render(b,C),P.xr.enabled=D,P.shadowMap.autoUpdate=z,P.toneMapping=G,"outputColorSpace"in P?P.outputColorSpace=E?"srgb":"srgb-linear":P.outputEncoding=E?3001:3e3,P.setRenderTarget(I);const X=S.viewport;X!==void 0&&P.state.viewport(X),t.visible=!0},this.getRenderTarget=function(){return L},this.dispose=function(){L.dispose(),t.material.dispose()}}};let Qn=hr;Va(Qn,"ReflectorShader",{uniforms:{color:{value:null},tDiffuse:{value:null},textureMatrix:{value:null}},vertexShader:`
		uniform mat4 textureMatrix;
		varying vec4 vUv;

		#include <common>
		#include <logdepthbuf_pars_vertex>

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			#include <logdepthbuf_vertex>

		}`,fragmentShader:`
		uniform vec3 color;
		uniform sampler2D tDiffuse;
		varying vec4 vUv;

		#include <logdepthbuf_pars_fragment>

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			#include <logdepthbuf_fragment>

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

			#include <tonemapping_fragment>
			#include <${Xt>=154?"colorspace_fragment":"encodings_fragment"}>

		}`});var Ga=Object.defineProperty,Ra=(i,e,t)=>e in i?Ga(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,fr=(i,e,t)=>(Ra(i,typeof e!="symbol"?e+"":e,t),t);const pn=new l.BufferGeometry,ja=new Float32Array([-1,-1,0,0,0,1,-1,0,1,0,1,1,0,1,1,-1,1,0,0,1]),dr=new l.InterleavedBuffer(ja,5);pn.setIndex([0,1,2,0,2,3]),pn.setAttribute("position",new l.InterleavedBufferAttribute(dr,3,0,!1)),pn.setAttribute("uv",new l.InterleavedBufferAttribute(dr,2,3,!1));const Jn=class extends l.Mesh{constructor(){super(Jn.Geometry,new l.MeshBasicMaterial({opacity:0,transparent:!0})),this.isLensflare=!0,this.type="Lensflare",this.frustumCulled=!1,this.renderOrder=1/0;const i=new l.Vector3,e=new l.Vector3,t=new l.DataTexture(new Uint8Array(16*16*3),16,16,l.RGBAFormat);t.minFilter=l.NearestFilter,t.magFilter=l.NearestFilter,t.wrapS=l.ClampToEdgeWrapping,t.wrapT=l.ClampToEdgeWrapping;const n=new l.DataTexture(new Uint8Array(16*16*3),16,16,l.RGBAFormat);n.minFilter=l.NearestFilter,n.magFilter=l.NearestFilter,n.wrapS=l.ClampToEdgeWrapping,n.wrapT=l.ClampToEdgeWrapping;const o=Jn.Geometry,r=new l.RawShaderMaterial({uniforms:{scale:{value:null},screenPosition:{value:null}},vertexShader:`

				precision highp float;

				uniform vec3 screenPosition;
				uniform vec2 scale;

				attribute vec3 position;

				void main() {

					gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );

				}`,fragmentShader:`

				precision highp float;

				void main() {

					gl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );

				}`,depthTest:!0,depthWrite:!1,transparent:!1}),s=new l.RawShaderMaterial({uniforms:{map:{value:t},scale:{value:null},screenPosition:{value:null}},vertexShader:`

				precision highp float;

				uniform vec3 screenPosition;
				uniform vec2 scale;

				attribute vec3 position;
				attribute vec2 uv;

				varying vec2 vUV;

				void main() {

					vUV = uv;

					gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );

				}`,fragmentShader:`

				precision highp float;

				uniform sampler2D map;

				varying vec2 vUV;

				void main() {

					gl_FragColor = texture2D( map, vUV );

				}`,depthTest:!1,depthWrite:!1,transparent:!1}),a=new l.Mesh(o,r),c=[],h=mr.Shader,p=new l.RawShaderMaterial({uniforms:{map:{value:null},occlusionMap:{value:n},color:{value:new l.Color(16777215)},scale:{value:new l.Vector2},screenPosition:{value:new l.Vector3}},vertexShader:h.vertexShader,fragmentShader:h.fragmentShader,blending:l.AdditiveBlending,transparent:!0,depthWrite:!1}),f=new l.Mesh(o,p);this.addElement=function(v){c.push(v)};const m=new l.Vector2,d=new l.Vector2,y=new l.Box2,_=new l.Vector4;this.onBeforeRender=function(v,g,A){v.getCurrentViewport(_);const w=_.w/_.z,C=_.z/2,L=_.w/2;let M=16/_.w;if(m.set(M*w,M),y.min.set(_.x,_.y),y.max.set(_.x+(_.z-16),_.y+(_.w-16)),e.setFromMatrixPosition(this.matrixWorld),e.applyMatrix4(A.matrixWorldInverse),!(e.z>0)&&(i.copy(e).applyMatrix4(A.projectionMatrix),d.x=_.x+i.x*C+C-8,d.y=_.y+i.y*L+L-8,y.containsPoint(d))){v.copyFramebufferToTexture(d,t);let P=r.uniforms;P.scale.value=m,P.screenPosition.value=i,v.renderBufferDirect(A,null,o,r,a,null),v.copyFramebufferToTexture(d,n),P=s.uniforms,P.scale.value=m,P.screenPosition.value=i,v.renderBufferDirect(A,null,o,s,a,null);const b=-i.x*2,S=-i.y*2;for(let x=0,I=c.length;x<I;x++){const D=c[x],z=p.uniforms;z.color.value.copy(D.color),z.map.value=D.texture,z.screenPosition.value.x=i.x+b*D.distance,z.screenPosition.value.y=i.y+S*D.distance,M=D.size/_.w;const G=_.w/_.z;z.scale.value.set(M*G,M),p.uniformsNeedUpdate=!0,v.renderBufferDirect(A,null,o,p,f,null)}}},this.dispose=function(){r.dispose(),s.dispose(),p.dispose(),t.dispose(),n.dispose();for(let v=0,g=c.length;v<g;v++)c[v].texture.dispose()}}};let pr=Jn;fr(pr,"Geometry",pn);class mr{constructor(e,t=1,n=0,o=new l.Color(16777215)){this.texture=e,this.size=t,this.distance=n,this.color=o}}fr(mr,"Shader",{uniforms:{map:{value:null},occlusionMap:{value:null},color:{value:null},scale:{value:null},screenPosition:{value:null}},vertexShader:`

		precision highp float;

		uniform vec3 screenPosition;
		uniform vec2 scale;

		uniform sampler2D occlusionMap;

		attribute vec3 position;
		attribute vec2 uv;

		varying vec2 vUV;
		varying float vVisibility;

		void main() {

			vUV = uv;

			vec2 pos = position.xy;

			vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );
			visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );
			visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );
			visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );
			visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );
			visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );
			visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );
			visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );
			visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );

			vVisibility =        visibility.r / 9.0;
			vVisibility *= 1.0 - visibility.g / 9.0;
			vVisibility *=       visibility.b / 9.0;

			gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );

		}`,fragmentShader:`

		precision highp float;

		uniform sampler2D map;
		uniform vec3 color;

		varying vec2 vUV;
		varying float vVisibility;

		void main() {

			vec4 texture = texture2D( map, vUV );
			texture.a *= vVisibility;
			gl_FragColor = texture;
			gl_FragColor.rgb *= color;

		}`});class Wa extends l.Mesh{constructor(e,t={}){super(e),this.isWater=!0;const n=this,o=t.textureWidth!==void 0?t.textureWidth:512,r=t.textureHeight!==void 0?t.textureHeight:512,s=t.clipBias!==void 0?t.clipBias:0,a=t.alpha!==void 0?t.alpha:1,c=t.time!==void 0?t.time:0,h=t.waterNormals!==void 0?t.waterNormals:null,p=t.sunDirection!==void 0?t.sunDirection:new l.Vector3(.70707,.70707,0),f=new l.Color(t.sunColor!==void 0?t.sunColor:16777215),m=new l.Color(t.waterColor!==void 0?t.waterColor:8355711),d=t.eye!==void 0?t.eye:new l.Vector3(0,0,0),y=t.distortionScale!==void 0?t.distortionScale:20,_=t.side!==void 0?t.side:l.FrontSide,v=t.fog!==void 0?t.fog:!1,g=new l.Plane,A=new l.Vector3,w=new l.Vector3,C=new l.Vector3,L=new l.Matrix4,M=new l.Vector3(0,0,-1),P=new l.Vector4,b=new l.Vector3,S=new l.Vector3,x=new l.Vector4,I=new l.Matrix4,D=new l.PerspectiveCamera,z=new l.WebGLRenderTarget(o,r),G={uniforms:l.UniformsUtils.merge([l.UniformsLib.fog,l.UniformsLib.lights,{normalSampler:{value:null},mirrorSampler:{value:null},alpha:{value:1},time:{value:0},size:{value:1},distortionScale:{value:20},textureMatrix:{value:new l.Matrix4},sunColor:{value:new l.Color(8355711)},sunDirection:{value:new l.Vector3(.70707,.70707,0)},eye:{value:new l.Vector3},waterColor:{value:new l.Color(5592405)}}]),vertexShader:`
				uniform mat4 textureMatrix;
				uniform float time;

				varying vec4 mirrorCoord;
				varying vec4 worldPosition;

				#include <common>
				#include <fog_pars_vertex>
				#include <shadowmap_pars_vertex>
				#include <logdepthbuf_pars_vertex>

				void main() {
					mirrorCoord = modelMatrix * vec4( position, 1.0 );
					worldPosition = mirrorCoord.xyzw;
					mirrorCoord = textureMatrix * mirrorCoord;
					vec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );
					gl_Position = projectionMatrix * mvPosition;

				#include <beginnormal_vertex>
				#include <defaultnormal_vertex>
				#include <logdepthbuf_vertex>
				#include <fog_vertex>
				#include <shadowmap_vertex>
			}`,fragmentShader:`
				uniform sampler2D mirrorSampler;
				uniform float alpha;
				uniform float time;
				uniform float size;
				uniform float distortionScale;
				uniform sampler2D normalSampler;
				uniform vec3 sunColor;
				uniform vec3 sunDirection;
				uniform vec3 eye;
				uniform vec3 waterColor;

				varying vec4 mirrorCoord;
				varying vec4 worldPosition;

				vec4 getNoise( vec2 uv ) {
					vec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);
					vec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );
					vec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );
					vec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );
					vec4 noise = texture2D( normalSampler, uv0 ) +
						texture2D( normalSampler, uv1 ) +
						texture2D( normalSampler, uv2 ) +
						texture2D( normalSampler, uv3 );
					return noise * 0.5 - 1.0;
				}

				void sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {
					vec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );
					float direction = max( 0.0, dot( eyeDirection, reflection ) );
					specularColor += pow( direction, shiny ) * sunColor * spec;
					diffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;
				}

				#include <common>
				#include <packing>
				#include <bsdfs>
				#include <fog_pars_fragment>
				#include <logdepthbuf_pars_fragment>
				#include <lights_pars_begin>
				#include <shadowmap_pars_fragment>
				#include <shadowmask_pars_fragment>

				void main() {

					#include <logdepthbuf_fragment>
					vec4 noise = getNoise( worldPosition.xz * size );
					vec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );

					vec3 diffuseLight = vec3(0.0);
					vec3 specularLight = vec3(0.0);

					vec3 worldToEye = eye-worldPosition.xyz;
					vec3 eyeDirection = normalize( worldToEye );
					sunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );

					float distance = length(worldToEye);

					vec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;
					vec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );

					float theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );
					float rf0 = 0.3;
					float reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );
					vec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;
					vec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);
					vec3 outgoingLight = albedo;
					gl_FragColor = vec4( outgoingLight, alpha );

					#include <tonemapping_fragment>
					#include <${parseInt(l.REVISION.replace(/\D+/g,""))>=154?"colorspace_fragment":"encodings_fragment"}>
					#include <fog_fragment>	
				}`},E=new l.ShaderMaterial({fragmentShader:G.fragmentShader,vertexShader:G.vertexShader,uniforms:l.UniformsUtils.clone(G.uniforms),lights:!0,side:_,fog:v});E.uniforms.mirrorSampler.value=z.texture,E.uniforms.textureMatrix.value=I,E.uniforms.alpha.value=a,E.uniforms.time.value=c,E.uniforms.normalSampler.value=h,E.uniforms.sunColor.value=f,E.uniforms.waterColor.value=m,E.uniforms.sunDirection.value=p,E.uniforms.distortionScale.value=y,E.uniforms.eye.value=d,n.material=E,n.onBeforeRender=function(X,oe,q){if(w.setFromMatrixPosition(n.matrixWorld),C.setFromMatrixPosition(q.matrixWorld),L.extractRotation(n.matrixWorld),A.set(0,0,1),A.applyMatrix4(L),b.subVectors(w,C),b.dot(A)>0)return;b.reflect(A).negate(),b.add(w),L.extractRotation(q.matrixWorld),M.set(0,0,-1),M.applyMatrix4(L),M.add(C),S.subVectors(w,M),S.reflect(A).negate(),S.add(w),D.position.copy(b),D.up.set(0,1,0),D.up.applyMatrix4(L),D.up.reflect(A),D.lookAt(S),D.far=q.far,D.updateMatrixWorld(),D.projectionMatrix.copy(q.projectionMatrix),I.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),I.multiply(D.projectionMatrix),I.multiply(D.matrixWorldInverse),g.setFromNormalAndCoplanarPoint(A,w),g.applyMatrix4(D.matrixWorldInverse),P.set(g.normal.x,g.normal.y,g.normal.z,g.constant);const ee=D.projectionMatrix;x.x=(Math.sign(P.x)+ee.elements[8])/ee.elements[0],x.y=(Math.sign(P.y)+ee.elements[9])/ee.elements[5],x.z=-1,x.w=(1+ee.elements[10])/ee.elements[14],P.multiplyScalar(2/P.dot(x)),ee.elements[2]=P.x,ee.elements[6]=P.y,ee.elements[10]=P.z+1-s,ee.elements[14]=P.w,d.setFromMatrixPosition(q.matrixWorld);const te=X.getRenderTarget(),ce=X.xr.enabled,le=X.shadowMap.autoUpdate;n.visible=!1,X.xr.enabled=!1,X.shadowMap.autoUpdate=!1,X.setRenderTarget(z),X.state.buffers.depth.setMask(!0),X.autoClear===!1&&X.clear(),X.render(oe,D),n.visible=!0,X.xr.enabled=ce,X.shadowMap.autoUpdate=le,X.setRenderTarget(te);const de=q.viewport;de!==void 0&&X.state.viewport(de)}}}var Ya=Object.defineProperty,Xa=(i,e,t)=>e in i?Ya(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,gr=(i,e,t)=>(Xa(i,typeof e!="symbol"?e+"":e,t),t);const mn={uniforms:{turbidity:{value:2},rayleigh:{value:1},mieCoefficient:{value:.005},mieDirectionalG:{value:.8},sunPosition:{value:new l.Vector3},up:{value:new l.Vector3(0,1,0)}},vertexShader:`
      uniform vec3 sunPosition;
      uniform float rayleigh;
      uniform float turbidity;
      uniform float mieCoefficient;
      uniform vec3 up;

      varying vec3 vWorldPosition;
      varying vec3 vSunDirection;
      varying float vSunfade;
      varying vec3 vBetaR;
      varying vec3 vBetaM;
      varying float vSunE;

      // constants for atmospheric scattering
      const float e = 2.71828182845904523536028747135266249775724709369995957;
      const float pi = 3.141592653589793238462643383279502884197169;

      // wavelength of used primaries, according to preetham
      const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );
      // this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:
      // (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
      const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );

      // mie stuff
      // K coefficient for the primaries
      const float v = 4.0;
      const vec3 K = vec3( 0.686, 0.678, 0.666 );
      // MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
      const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );

      // earth shadow hack
      // cutoffAngle = pi / 1.95;
      const float cutoffAngle = 1.6110731556870734;
      const float steepness = 1.5;
      const float EE = 1000.0;

      float sunIntensity( float zenithAngleCos ) {
        zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );
        return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );
      }

      vec3 totalMie( float T ) {
        float c = ( 0.2 * T ) * 10E-18;
        return 0.434 * c * MieConst;
      }

      void main() {

        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
        vWorldPosition = worldPosition.xyz;

        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        gl_Position.z = gl_Position.w; // set z to camera.far

        vSunDirection = normalize( sunPosition );

        vSunE = sunIntensity( dot( vSunDirection, up ) );

        vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );

        float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );

      // extinction (absorbtion + out scattering)
      // rayleigh coefficients
        vBetaR = totalRayleigh * rayleighCoefficient;

      // mie coefficients
        vBetaM = totalMie( turbidity ) * mieCoefficient;

      }
    `,fragmentShader:`
      varying vec3 vWorldPosition;
      varying vec3 vSunDirection;
      varying float vSunfade;
      varying vec3 vBetaR;
      varying vec3 vBetaM;
      varying float vSunE;

      uniform float mieDirectionalG;
      uniform vec3 up;

      const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );

      // constants for atmospheric scattering
      const float pi = 3.141592653589793238462643383279502884197169;

      const float n = 1.0003; // refractive index of air
      const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)

      // optical length at zenith for molecules
      const float rayleighZenithLength = 8.4E3;
      const float mieZenithLength = 1.25E3;
      // 66 arc seconds -> degrees, and the cosine of that
      const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;

      // 3.0 / ( 16.0 * pi )
      const float THREE_OVER_SIXTEENPI = 0.05968310365946075;
      // 1.0 / ( 4.0 * pi )
      const float ONE_OVER_FOURPI = 0.07957747154594767;

      float rayleighPhase( float cosTheta ) {
        return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );
      }

      float hgPhase( float cosTheta, float g ) {
        float g2 = pow( g, 2.0 );
        float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );
        return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );
      }

      void main() {

        vec3 direction = normalize( vWorldPosition - cameraPos );

      // optical length
      // cutoff angle at 90 to avoid singularity in next formula.
        float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );
        float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );
        float sR = rayleighZenithLength * inverse;
        float sM = mieZenithLength * inverse;

      // combined extinction factor
        vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );

      // in scattering
        float cosTheta = dot( direction, vSunDirection );

        float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );
        vec3 betaRTheta = vBetaR * rPhase;

        float mPhase = hgPhase( cosTheta, mieDirectionalG );
        vec3 betaMTheta = vBetaM * mPhase;

        vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );
        Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );

      // nightsky
        float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]
        float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]
        vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );
        vec3 L0 = vec3( 0.1 ) * Fex;

      // composition + solar disc
        float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );
        L0 += ( vSunE * 19000.0 * Fex ) * sundisk;

        vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );

        vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );

        gl_FragColor = vec4( retColor, 1.0 );

      #include <tonemapping_fragment>
      #include <${Xt>=154?"colorspace_fragment":"encodings_fragment"}>

      }
    `},yr=new l.ShaderMaterial({name:"SkyShader",fragmentShader:mn.fragmentShader,vertexShader:mn.vertexShader,uniforms:l.UniformsUtils.clone(mn.uniforms),side:l.BackSide,depthWrite:!1});class Hn extends l.Mesh{constructor(){super(new l.BoxGeometry(1,1,1),yr)}}gr(Hn,"SkyShader",mn),gr(Hn,"material",yr);const Ue=new l.Triangle,gn=new l.Vector3;class Ea{constructor(e){let t=e.geometry;t.index&&(console.warn("THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry."),t=t.toNonIndexed()),this.geometry=t,this.randomFunction=Math.random,this.positionAttribute=this.geometry.getAttribute("position"),this.colorAttribute=this.geometry.getAttribute("color"),this.weightAttribute=null,this.distribution=null}setWeightAttribute(e){return this.weightAttribute=e?this.geometry.getAttribute(e):null,this}build(){const e=this.positionAttribute,t=this.weightAttribute,n=new Float32Array(e.count/3);for(let r=0;r<e.count;r+=3){let s=1;t&&(s=t.getX(r)+t.getX(r+1)+t.getX(r+2)),Ue.a.fromBufferAttribute(e,r),Ue.b.fromBufferAttribute(e,r+1),Ue.c.fromBufferAttribute(e,r+2),s*=Ue.getArea(),n[r/3]=s}this.distribution=new Float32Array(e.count/3);let o=0;for(let r=0;r<n.length;r++)o+=n[r],this.distribution[r]=o;return this}setRandomGenerator(e){return this.randomFunction=e,this}sample(e,t,n){const o=this.sampleFaceIndex();return this.sampleFace(o,e,t,n)}sampleFaceIndex(){const e=this.distribution[this.distribution.length-1];return this.binarySearch(this.randomFunction()*e)}binarySearch(e){const t=this.distribution;let n=0,o=t.length-1,r=-1;for(;n<=o;){const s=Math.ceil((n+o)/2);if(s===0||t[s-1]<=e&&t[s]>e){r=s;break}else e<t[s]?o=s-1:n=s+1}return r}sampleFace(e,t,n,o){let r=this.randomFunction(),s=this.randomFunction();return r+s>1&&(r=1-r,s=1-s),Ue.a.fromBufferAttribute(this.positionAttribute,e*3),Ue.b.fromBufferAttribute(this.positionAttribute,e*3+1),Ue.c.fromBufferAttribute(this.positionAttribute,e*3+2),t.set(0,0,0).addScaledVector(Ue.a,r).addScaledVector(Ue.b,s).addScaledVector(Ue.c,1-(r+s)),n!==void 0&&Ue.getNormal(n),o!==void 0&&this.colorAttribute!==void 0&&(Ue.a.fromBufferAttribute(this.colorAttribute,e*3),Ue.b.fromBufferAttribute(this.colorAttribute,e*3+1),Ue.c.fromBufferAttribute(this.colorAttribute,e*3+2),gn.set(0,0,0).addScaledVector(Ue.a,r).addScaledVector(Ue.b,s).addScaledVector(Ue.c,1-(r+s)),o.r=gn.x,o.g=gn.y,o.b=gn.z),this}}var Za=Object.defineProperty,Ka=(i,e,t)=>e in i?Za(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,J=(i,e,t)=>(Ka(i,typeof e!="symbol"?e+"":e,t),t);class qa extends l.Object3D{constructor(e,t){super(),J(this,"isTransformControls",!0),J(this,"visible",!1),J(this,"domElement"),J(this,"raycaster",new l.Raycaster),J(this,"gizmo"),J(this,"plane"),J(this,"tempVector",new l.Vector3),J(this,"tempVector2",new l.Vector3),J(this,"tempQuaternion",new l.Quaternion),J(this,"unit",{X:new l.Vector3(1,0,0),Y:new l.Vector3(0,1,0),Z:new l.Vector3(0,0,1)}),J(this,"pointStart",new l.Vector3),J(this,"pointEnd",new l.Vector3),J(this,"offset",new l.Vector3),J(this,"rotationAxis",new l.Vector3),J(this,"startNorm",new l.Vector3),J(this,"endNorm",new l.Vector3),J(this,"rotationAngle",0),J(this,"cameraPosition",new l.Vector3),J(this,"cameraQuaternion",new l.Quaternion),J(this,"cameraScale",new l.Vector3),J(this,"parentPosition",new l.Vector3),J(this,"parentQuaternion",new l.Quaternion),J(this,"parentQuaternionInv",new l.Quaternion),J(this,"parentScale",new l.Vector3),J(this,"worldPositionStart",new l.Vector3),J(this,"worldQuaternionStart",new l.Quaternion),J(this,"worldScaleStart",new l.Vector3),J(this,"worldPosition",new l.Vector3),J(this,"worldQuaternion",new l.Quaternion),J(this,"worldQuaternionInv",new l.Quaternion),J(this,"worldScale",new l.Vector3),J(this,"eye",new l.Vector3),J(this,"positionStart",new l.Vector3),J(this,"quaternionStart",new l.Quaternion),J(this,"scaleStart",new l.Vector3),J(this,"camera"),J(this,"object"),J(this,"enabled",!0),J(this,"axis",null),J(this,"mode","translate"),J(this,"translationSnap",null),J(this,"rotationSnap",null),J(this,"scaleSnap",null),J(this,"space","world"),J(this,"size",1),J(this,"dragging",!1),J(this,"showX",!0),J(this,"showY",!0),J(this,"showZ",!0),J(this,"changeEvent",{type:"change"}),J(this,"mouseDownEvent",{type:"mouseDown",mode:this.mode}),J(this,"mouseUpEvent",{type:"mouseUp",mode:this.mode}),J(this,"objectChangeEvent",{type:"objectChange"}),J(this,"intersectObjectWithRay",(o,r,s)=>{const a=r.intersectObject(o,!0);for(let c=0;c<a.length;c++)if(a[c].object.visible||s)return a[c];return!1}),J(this,"attach",o=>(this.object=o,this.visible=!0,this)),J(this,"detach",()=>(this.object=void 0,this.visible=!1,this.axis=null,this)),J(this,"reset",()=>this.enabled?(this.dragging&&this.object!==void 0&&(this.object.position.copy(this.positionStart),this.object.quaternion.copy(this.quaternionStart),this.object.scale.copy(this.scaleStart),this.dispatchEvent(this.changeEvent),this.dispatchEvent(this.objectChangeEvent),this.pointStart.copy(this.pointEnd)),this):this),J(this,"updateMatrixWorld",()=>{this.object!==void 0&&(this.object.updateMatrixWorld(),this.object.parent===null?console.error("TransformControls: The attached 3D object must be a part of the scene graph."):this.object.parent.matrixWorld.decompose(this.parentPosition,this.parentQuaternion,this.parentScale),this.object.matrixWorld.decompose(this.worldPosition,this.worldQuaternion,this.worldScale),this.parentQuaternionInv.copy(this.parentQuaternion).invert(),this.worldQuaternionInv.copy(this.worldQuaternion).invert()),this.camera.updateMatrixWorld(),this.camera.matrixWorld.decompose(this.cameraPosition,this.cameraQuaternion,this.cameraScale),this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(),super.updateMatrixWorld()}),J(this,"pointerHover",o=>{if(this.object===void 0||this.dragging===!0)return;this.raycaster.setFromCamera(o,this.camera);const r=this.intersectObjectWithRay(this.gizmo.picker[this.mode],this.raycaster);r?this.axis=r.object.name:this.axis=null}),J(this,"pointerDown",o=>{if(!(this.object===void 0||this.dragging===!0||o.button!==0)&&this.axis!==null){this.raycaster.setFromCamera(o,this.camera);const r=this.intersectObjectWithRay(this.plane,this.raycaster,!0);if(r){let s=this.space;if(this.mode==="scale"?s="local":(this.axis==="E"||this.axis==="XYZE"||this.axis==="XYZ")&&(s="world"),s==="local"&&this.mode==="rotate"){const a=this.rotationSnap;this.axis==="X"&&a&&(this.object.rotation.x=Math.round(this.object.rotation.x/a)*a),this.axis==="Y"&&a&&(this.object.rotation.y=Math.round(this.object.rotation.y/a)*a),this.axis==="Z"&&a&&(this.object.rotation.z=Math.round(this.object.rotation.z/a)*a)}this.object.updateMatrixWorld(),this.object.parent&&this.object.parent.updateMatrixWorld(),this.positionStart.copy(this.object.position),this.quaternionStart.copy(this.object.quaternion),this.scaleStart.copy(this.object.scale),this.object.matrixWorld.decompose(this.worldPositionStart,this.worldQuaternionStart,this.worldScaleStart),this.pointStart.copy(r.point).sub(this.worldPositionStart)}this.dragging=!0,this.mouseDownEvent.mode=this.mode,this.dispatchEvent(this.mouseDownEvent)}}),J(this,"pointerMove",o=>{const r=this.axis,s=this.mode,a=this.object;let c=this.space;if(s==="scale"?c="local":(r==="E"||r==="XYZE"||r==="XYZ")&&(c="world"),a===void 0||r===null||this.dragging===!1||o.button!==-1)return;this.raycaster.setFromCamera(o,this.camera);const h=this.intersectObjectWithRay(this.plane,this.raycaster,!0);if(h){if(this.pointEnd.copy(h.point).sub(this.worldPositionStart),s==="translate")this.offset.copy(this.pointEnd).sub(this.pointStart),c==="local"&&r!=="XYZ"&&this.offset.applyQuaternion(this.worldQuaternionInv),r.indexOf("X")===-1&&(this.offset.x=0),r.indexOf("Y")===-1&&(this.offset.y=0),r.indexOf("Z")===-1&&(this.offset.z=0),c==="local"&&r!=="XYZ"?this.offset.applyQuaternion(this.quaternionStart).divide(this.parentScale):this.offset.applyQuaternion(this.parentQuaternionInv).divide(this.parentScale),a.position.copy(this.offset).add(this.positionStart),this.translationSnap&&(c==="local"&&(a.position.applyQuaternion(this.tempQuaternion.copy(this.quaternionStart).invert()),r.search("X")!==-1&&(a.position.x=Math.round(a.position.x/this.translationSnap)*this.translationSnap),r.search("Y")!==-1&&(a.position.y=Math.round(a.position.y/this.translationSnap)*this.translationSnap),r.search("Z")!==-1&&(a.position.z=Math.round(a.position.z/this.translationSnap)*this.translationSnap),a.position.applyQuaternion(this.quaternionStart)),c==="world"&&(a.parent&&a.position.add(this.tempVector.setFromMatrixPosition(a.parent.matrixWorld)),r.search("X")!==-1&&(a.position.x=Math.round(a.position.x/this.translationSnap)*this.translationSnap),r.search("Y")!==-1&&(a.position.y=Math.round(a.position.y/this.translationSnap)*this.translationSnap),r.search("Z")!==-1&&(a.position.z=Math.round(a.position.z/this.translationSnap)*this.translationSnap),a.parent&&a.position.sub(this.tempVector.setFromMatrixPosition(a.parent.matrixWorld))));else if(s==="scale"){if(r.search("XYZ")!==-1){let p=this.pointEnd.length()/this.pointStart.length();this.pointEnd.dot(this.pointStart)<0&&(p*=-1),this.tempVector2.set(p,p,p)}else this.tempVector.copy(this.pointStart),this.tempVector2.copy(this.pointEnd),this.tempVector.applyQuaternion(this.worldQuaternionInv),this.tempVector2.applyQuaternion(this.worldQuaternionInv),this.tempVector2.divide(this.tempVector),r.search("X")===-1&&(this.tempVector2.x=1),r.search("Y")===-1&&(this.tempVector2.y=1),r.search("Z")===-1&&(this.tempVector2.z=1);a.scale.copy(this.scaleStart).multiply(this.tempVector2),this.scaleSnap&&this.object&&(r.search("X")!==-1&&(this.object.scale.x=Math.round(a.scale.x/this.scaleSnap)*this.scaleSnap||this.scaleSnap),r.search("Y")!==-1&&(a.scale.y=Math.round(a.scale.y/this.scaleSnap)*this.scaleSnap||this.scaleSnap),r.search("Z")!==-1&&(a.scale.z=Math.round(a.scale.z/this.scaleSnap)*this.scaleSnap||this.scaleSnap))}else if(s==="rotate"){this.offset.copy(this.pointEnd).sub(this.pointStart);const p=20/this.worldPosition.distanceTo(this.tempVector.setFromMatrixPosition(this.camera.matrixWorld));r==="E"?(this.rotationAxis.copy(this.eye),this.rotationAngle=this.pointEnd.angleTo(this.pointStart),this.startNorm.copy(this.pointStart).normalize(),this.endNorm.copy(this.pointEnd).normalize(),this.rotationAngle*=this.endNorm.cross(this.startNorm).dot(this.eye)<0?1:-1):r==="XYZE"?(this.rotationAxis.copy(this.offset).cross(this.eye).normalize(),this.rotationAngle=this.offset.dot(this.tempVector.copy(this.rotationAxis).cross(this.eye))*p):(r==="X"||r==="Y"||r==="Z")&&(this.rotationAxis.copy(this.unit[r]),this.tempVector.copy(this.unit[r]),c==="local"&&this.tempVector.applyQuaternion(this.worldQuaternion),this.rotationAngle=this.offset.dot(this.tempVector.cross(this.eye).normalize())*p),this.rotationSnap&&(this.rotationAngle=Math.round(this.rotationAngle/this.rotationSnap)*this.rotationSnap),c==="local"&&r!=="E"&&r!=="XYZE"?(a.quaternion.copy(this.quaternionStart),a.quaternion.multiply(this.tempQuaternion.setFromAxisAngle(this.rotationAxis,this.rotationAngle)).normalize()):(this.rotationAxis.applyQuaternion(this.parentQuaternionInv),a.quaternion.copy(this.tempQuaternion.setFromAxisAngle(this.rotationAxis,this.rotationAngle)),a.quaternion.multiply(this.quaternionStart).normalize())}this.dispatchEvent(this.changeEvent),this.dispatchEvent(this.objectChangeEvent)}}),J(this,"pointerUp",o=>{o.button===0&&(this.dragging&&this.axis!==null&&(this.mouseUpEvent.mode=this.mode,this.dispatchEvent(this.mouseUpEvent)),this.dragging=!1,this.axis=null)}),J(this,"getPointer",o=>{var r;if(this.domElement&&((r=this.domElement.ownerDocument)!=null&&r.pointerLockElement))return{x:0,y:0,button:o.button};{const s=o.changedTouches?o.changedTouches[0]:o,a=this.domElement.getBoundingClientRect();return{x:(s.clientX-a.left)/a.width*2-1,y:-(s.clientY-a.top)/a.height*2+1,button:o.button}}}),J(this,"onPointerHover",o=>{if(this.enabled)switch(o.pointerType){case"mouse":case"pen":this.pointerHover(this.getPointer(o));break}}),J(this,"onPointerDown",o=>{!this.enabled||!this.domElement||(this.domElement.style.touchAction="none",this.domElement.ownerDocument.addEventListener("pointermove",this.onPointerMove),this.pointerHover(this.getPointer(o)),this.pointerDown(this.getPointer(o)))}),J(this,"onPointerMove",o=>{this.enabled&&this.pointerMove(this.getPointer(o))}),J(this,"onPointerUp",o=>{!this.enabled||!this.domElement||(this.domElement.style.touchAction="",this.domElement.ownerDocument.removeEventListener("pointermove",this.onPointerMove),this.pointerUp(this.getPointer(o)))}),J(this,"getMode",()=>this.mode),J(this,"setMode",o=>{this.mode=o}),J(this,"setTranslationSnap",o=>{this.translationSnap=o}),J(this,"setRotationSnap",o=>{this.rotationSnap=o}),J(this,"setScaleSnap",o=>{this.scaleSnap=o}),J(this,"setSize",o=>{this.size=o}),J(this,"setSpace",o=>{this.space=o}),J(this,"update",()=>{console.warn("THREE.TransformControls: update function has no more functionality and therefore has been deprecated.")}),J(this,"connect",o=>{o===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),this.domElement=o,this.domElement.addEventListener("pointerdown",this.onPointerDown),this.domElement.addEventListener("pointermove",this.onPointerHover),this.domElement.ownerDocument.addEventListener("pointerup",this.onPointerUp)}),J(this,"dispose",()=>{var o,r,s,a,c,h;(o=this.domElement)==null||o.removeEventListener("pointerdown",this.onPointerDown),(r=this.domElement)==null||r.removeEventListener("pointermove",this.onPointerHover),(a=(s=this.domElement)==null?void 0:s.ownerDocument)==null||a.removeEventListener("pointermove",this.onPointerMove),(h=(c=this.domElement)==null?void 0:c.ownerDocument)==null||h.removeEventListener("pointerup",this.onPointerUp),this.traverse(p=>{const f=p;f.geometry&&f.geometry.dispose(),f.material&&f.material.dispose()})}),this.domElement=t,this.camera=e,this.gizmo=new Qa,this.add(this.gizmo),this.plane=new Ja,this.add(this.plane);const n=(o,r)=>{let s=r;Object.defineProperty(this,o,{get:function(){return s!==void 0?s:r},set:function(a){s!==a&&(s=a,this.plane[o]=a,this.gizmo[o]=a,this.dispatchEvent({type:o+"-changed",value:a}),this.dispatchEvent(this.changeEvent))}}),this[o]=r,this.plane[o]=r,this.gizmo[o]=r};n("camera",this.camera),n("object",this.object),n("enabled",this.enabled),n("axis",this.axis),n("mode",this.mode),n("translationSnap",this.translationSnap),n("rotationSnap",this.rotationSnap),n("scaleSnap",this.scaleSnap),n("space",this.space),n("size",this.size),n("dragging",this.dragging),n("showX",this.showX),n("showY",this.showY),n("showZ",this.showZ),n("worldPosition",this.worldPosition),n("worldPositionStart",this.worldPositionStart),n("worldQuaternion",this.worldQuaternion),n("worldQuaternionStart",this.worldQuaternionStart),n("cameraPosition",this.cameraPosition),n("cameraQuaternion",this.cameraQuaternion),n("pointStart",this.pointStart),n("pointEnd",this.pointEnd),n("rotationAxis",this.rotationAxis),n("rotationAngle",this.rotationAngle),n("eye",this.eye),t!==void 0&&this.connect(t)}}class Qa extends l.Object3D{constructor(){super(),J(this,"isTransformControlsGizmo",!0),J(this,"type","TransformControlsGizmo"),J(this,"tempVector",new l.Vector3(0,0,0)),J(this,"tempEuler",new l.Euler),J(this,"alignVector",new l.Vector3(0,1,0)),J(this,"zeroVector",new l.Vector3(0,0,0)),J(this,"lookAtMatrix",new l.Matrix4),J(this,"tempQuaternion",new l.Quaternion),J(this,"tempQuaternion2",new l.Quaternion),J(this,"identityQuaternion",new l.Quaternion),J(this,"unitX",new l.Vector3(1,0,0)),J(this,"unitY",new l.Vector3(0,1,0)),J(this,"unitZ",new l.Vector3(0,0,1)),J(this,"gizmo"),J(this,"picker"),J(this,"helper"),J(this,"rotationAxis",new l.Vector3),J(this,"cameraPosition",new l.Vector3),J(this,"worldPositionStart",new l.Vector3),J(this,"worldQuaternionStart",new l.Quaternion),J(this,"worldPosition",new l.Vector3),J(this,"worldQuaternion",new l.Quaternion),J(this,"eye",new l.Vector3),J(this,"camera",null),J(this,"enabled",!0),J(this,"axis",null),J(this,"mode","translate"),J(this,"space","world"),J(this,"size",1),J(this,"dragging",!1),J(this,"showX",!0),J(this,"showY",!0),J(this,"showZ",!0),J(this,"updateMatrixWorld",()=>{let te=this.space;this.mode==="scale"&&(te="local");const ce=te==="local"?this.worldQuaternion:this.identityQuaternion;this.gizmo.translate.visible=this.mode==="translate",this.gizmo.rotate.visible=this.mode==="rotate",this.gizmo.scale.visible=this.mode==="scale",this.helper.translate.visible=this.mode==="translate",this.helper.rotate.visible=this.mode==="rotate",this.helper.scale.visible=this.mode==="scale";let le=[];le=le.concat(this.picker[this.mode].children),le=le.concat(this.gizmo[this.mode].children),le=le.concat(this.helper[this.mode].children);for(let de=0;de<le.length;de++){const k=le[de];k.visible=!0,k.rotation.set(0,0,0),k.position.copy(this.worldPosition);let V;if(this.camera.isOrthographicCamera?V=(this.camera.top-this.camera.bottom)/this.camera.zoom:V=this.worldPosition.distanceTo(this.cameraPosition)*Math.min(1.9*Math.tan(Math.PI*this.camera.fov/360)/this.camera.zoom,7),k.scale.set(1,1,1).multiplyScalar(V*this.size/7),k.tag==="helper"){k.visible=!1,k.name==="AXIS"?(k.position.copy(this.worldPositionStart),k.visible=!!this.axis,this.axis==="X"&&(this.tempQuaternion.setFromEuler(this.tempEuler.set(0,0,0)),k.quaternion.copy(ce).multiply(this.tempQuaternion),Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(ce).dot(this.eye))>.9&&(k.visible=!1)),this.axis==="Y"&&(this.tempQuaternion.setFromEuler(this.tempEuler.set(0,0,Math.PI/2)),k.quaternion.copy(ce).multiply(this.tempQuaternion),Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(ce).dot(this.eye))>.9&&(k.visible=!1)),this.axis==="Z"&&(this.tempQuaternion.setFromEuler(this.tempEuler.set(0,Math.PI/2,0)),k.quaternion.copy(ce).multiply(this.tempQuaternion),Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(ce).dot(this.eye))>.9&&(k.visible=!1)),this.axis==="XYZE"&&(this.tempQuaternion.setFromEuler(this.tempEuler.set(0,Math.PI/2,0)),this.alignVector.copy(this.rotationAxis),k.quaternion.setFromRotationMatrix(this.lookAtMatrix.lookAt(this.zeroVector,this.alignVector,this.unitY)),k.quaternion.multiply(this.tempQuaternion),k.visible=this.dragging),this.axis==="E"&&(k.visible=!1)):k.name==="START"?(k.position.copy(this.worldPositionStart),k.visible=this.dragging):k.name==="END"?(k.position.copy(this.worldPosition),k.visible=this.dragging):k.name==="DELTA"?(k.position.copy(this.worldPositionStart),k.quaternion.copy(this.worldQuaternionStart),this.tempVector.set(1e-10,1e-10,1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1),this.tempVector.applyQuaternion(this.worldQuaternionStart.clone().invert()),k.scale.copy(this.tempVector),k.visible=this.dragging):(k.quaternion.copy(ce),this.dragging?k.position.copy(this.worldPositionStart):k.position.copy(this.worldPosition),this.axis&&(k.visible=this.axis.search(k.name)!==-1));continue}k.quaternion.copy(ce),this.mode==="translate"||this.mode==="scale"?((k.name==="X"||k.name==="XYZX")&&Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(ce).dot(this.eye))>.99&&(k.scale.set(1e-10,1e-10,1e-10),k.visible=!1),(k.name==="Y"||k.name==="XYZY")&&Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(ce).dot(this.eye))>.99&&(k.scale.set(1e-10,1e-10,1e-10),k.visible=!1),(k.name==="Z"||k.name==="XYZZ")&&Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(ce).dot(this.eye))>.99&&(k.scale.set(1e-10,1e-10,1e-10),k.visible=!1),k.name==="XY"&&Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(ce).dot(this.eye))<.2&&(k.scale.set(1e-10,1e-10,1e-10),k.visible=!1),k.name==="YZ"&&Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(ce).dot(this.eye))<.2&&(k.scale.set(1e-10,1e-10,1e-10),k.visible=!1),k.name==="XZ"&&Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(ce).dot(this.eye))<.2&&(k.scale.set(1e-10,1e-10,1e-10),k.visible=!1),k.name.search("X")!==-1&&(this.alignVector.copy(this.unitX).applyQuaternion(ce).dot(this.eye)<0?k.tag==="fwd"?k.visible=!1:k.scale.x*=-1:k.tag==="bwd"&&(k.visible=!1)),k.name.search("Y")!==-1&&(this.alignVector.copy(this.unitY).applyQuaternion(ce).dot(this.eye)<0?k.tag==="fwd"?k.visible=!1:k.scale.y*=-1:k.tag==="bwd"&&(k.visible=!1)),k.name.search("Z")!==-1&&(this.alignVector.copy(this.unitZ).applyQuaternion(ce).dot(this.eye)<0?k.tag==="fwd"?k.visible=!1:k.scale.z*=-1:k.tag==="bwd"&&(k.visible=!1))):this.mode==="rotate"&&(this.tempQuaternion2.copy(ce),this.alignVector.copy(this.eye).applyQuaternion(this.tempQuaternion.copy(ce).invert()),k.name.search("E")!==-1&&k.quaternion.setFromRotationMatrix(this.lookAtMatrix.lookAt(this.eye,this.zeroVector,this.unitY)),k.name==="X"&&(this.tempQuaternion.setFromAxisAngle(this.unitX,Math.atan2(-this.alignVector.y,this.alignVector.z)),this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2,this.tempQuaternion),k.quaternion.copy(this.tempQuaternion)),k.name==="Y"&&(this.tempQuaternion.setFromAxisAngle(this.unitY,Math.atan2(this.alignVector.x,this.alignVector.z)),this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2,this.tempQuaternion),k.quaternion.copy(this.tempQuaternion)),k.name==="Z"&&(this.tempQuaternion.setFromAxisAngle(this.unitZ,Math.atan2(this.alignVector.y,this.alignVector.x)),this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2,this.tempQuaternion),k.quaternion.copy(this.tempQuaternion))),k.visible=k.visible&&(k.name.indexOf("X")===-1||this.showX),k.visible=k.visible&&(k.name.indexOf("Y")===-1||this.showY),k.visible=k.visible&&(k.name.indexOf("Z")===-1||this.showZ),k.visible=k.visible&&(k.name.indexOf("E")===-1||this.showX&&this.showY&&this.showZ),k.material.tempOpacity=k.material.tempOpacity||k.material.opacity,k.material.tempColor=k.material.tempColor||k.material.color.clone(),k.material.color.copy(k.material.tempColor),k.material.opacity=k.material.tempOpacity,this.enabled?this.axis&&(k.name===this.axis?(k.material.opacity=1,k.material.color.lerp(new l.Color(1,1,1),.5)):this.axis.split("").some(function(U){return k.name===U})?(k.material.opacity=1,k.material.color.lerp(new l.Color(1,1,1),.5)):(k.material.opacity*=.25,k.material.color.lerp(new l.Color(1,1,1),.5))):(k.material.opacity*=.5,k.material.color.lerp(new l.Color(1,1,1),.5))}super.updateMatrixWorld()});const e=new l.MeshBasicMaterial({depthTest:!1,depthWrite:!1,transparent:!0,side:l.DoubleSide,fog:!1,toneMapped:!1}),t=new l.LineBasicMaterial({depthTest:!1,depthWrite:!1,transparent:!0,linewidth:1,fog:!1,toneMapped:!1}),n=e.clone();n.opacity=.15;const o=e.clone();o.opacity=.33;const r=e.clone();r.color.set(16711680);const s=e.clone();s.color.set(65280);const a=e.clone();a.color.set(255);const c=e.clone();c.opacity=.25;const h=c.clone();h.color.set(16776960);const p=c.clone();p.color.set(65535);const f=c.clone();f.color.set(16711935),e.clone().color.set(16776960);const d=t.clone();d.color.set(16711680);const y=t.clone();y.color.set(65280);const _=t.clone();_.color.set(255);const v=t.clone();v.color.set(65535);const g=t.clone();g.color.set(16711935);const A=t.clone();A.color.set(16776960);const w=t.clone();w.color.set(7895160);const C=A.clone();C.opacity=.25;const L=new l.CylinderGeometry(0,.05,.2,12,1,!1),M=new l.BoxGeometry(.125,.125,.125),P=new l.BufferGeometry;P.setAttribute("position",new l.Float32BufferAttribute([0,0,0,1,0,0],3));const b=(te,ce)=>{const le=new l.BufferGeometry,de=[];for(let k=0;k<=64*ce;++k)de.push(0,Math.cos(k/32*Math.PI)*te,Math.sin(k/32*Math.PI)*te);return le.setAttribute("position",new l.Float32BufferAttribute(de,3)),le},S=()=>{const te=new l.BufferGeometry;return te.setAttribute("position",new l.Float32BufferAttribute([0,0,0,1,1,1],3)),te},x={X:[[new l.Mesh(L,r),[1,0,0],[0,0,-Math.PI/2],null,"fwd"],[new l.Mesh(L,r),[1,0,0],[0,0,Math.PI/2],null,"bwd"],[new l.Line(P,d)]],Y:[[new l.Mesh(L,s),[0,1,0],null,null,"fwd"],[new l.Mesh(L,s),[0,1,0],[Math.PI,0,0],null,"bwd"],[new l.Line(P,y),null,[0,0,Math.PI/2]]],Z:[[new l.Mesh(L,a),[0,0,1],[Math.PI/2,0,0],null,"fwd"],[new l.Mesh(L,a),[0,0,1],[-Math.PI/2,0,0],null,"bwd"],[new l.Line(P,_),null,[0,-Math.PI/2,0]]],XYZ:[[new l.Mesh(new l.OctahedronGeometry(.1,0),c.clone()),[0,0,0],[0,0,0]]],XY:[[new l.Mesh(new l.PlaneGeometry(.295,.295),h.clone()),[.15,.15,0]],[new l.Line(P,A),[.18,.3,0],null,[.125,1,1]],[new l.Line(P,A),[.3,.18,0],[0,0,Math.PI/2],[.125,1,1]]],YZ:[[new l.Mesh(new l.PlaneGeometry(.295,.295),p.clone()),[0,.15,.15],[0,Math.PI/2,0]],[new l.Line(P,v),[0,.18,.3],[0,0,Math.PI/2],[.125,1,1]],[new l.Line(P,v),[0,.3,.18],[0,-Math.PI/2,0],[.125,1,1]]],XZ:[[new l.Mesh(new l.PlaneGeometry(.295,.295),f.clone()),[.15,0,.15],[-Math.PI/2,0,0]],[new l.Line(P,g),[.18,0,.3],null,[.125,1,1]],[new l.Line(P,g),[.3,0,.18],[0,-Math.PI/2,0],[.125,1,1]]]},I={X:[[new l.Mesh(new l.CylinderGeometry(.2,0,1,4,1,!1),n),[.6,0,0],[0,0,-Math.PI/2]]],Y:[[new l.Mesh(new l.CylinderGeometry(.2,0,1,4,1,!1),n),[0,.6,0]]],Z:[[new l.Mesh(new l.CylinderGeometry(.2,0,1,4,1,!1),n),[0,0,.6],[Math.PI/2,0,0]]],XYZ:[[new l.Mesh(new l.OctahedronGeometry(.2,0),n)]],XY:[[new l.Mesh(new l.PlaneGeometry(.4,.4),n),[.2,.2,0]]],YZ:[[new l.Mesh(new l.PlaneGeometry(.4,.4),n),[0,.2,.2],[0,Math.PI/2,0]]],XZ:[[new l.Mesh(new l.PlaneGeometry(.4,.4),n),[.2,0,.2],[-Math.PI/2,0,0]]]},D={START:[[new l.Mesh(new l.OctahedronGeometry(.01,2),o),null,null,null,"helper"]],END:[[new l.Mesh(new l.OctahedronGeometry(.01,2),o),null,null,null,"helper"]],DELTA:[[new l.Line(S(),o),null,null,null,"helper"]],X:[[new l.Line(P,o.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new l.Line(P,o.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new l.Line(P,o.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]},z={X:[[new l.Line(b(1,.5),d)],[new l.Mesh(new l.OctahedronGeometry(.04,0),r),[0,0,.99],null,[1,3,1]]],Y:[[new l.Line(b(1,.5),y),null,[0,0,-Math.PI/2]],[new l.Mesh(new l.OctahedronGeometry(.04,0),s),[0,0,.99],null,[3,1,1]]],Z:[[new l.Line(b(1,.5),_),null,[0,Math.PI/2,0]],[new l.Mesh(new l.OctahedronGeometry(.04,0),a),[.99,0,0],null,[1,3,1]]],E:[[new l.Line(b(1.25,1),C),null,[0,Math.PI/2,0]],[new l.Mesh(new l.CylinderGeometry(.03,0,.15,4,1,!1),C),[1.17,0,0],[0,0,-Math.PI/2],[1,1,.001]],[new l.Mesh(new l.CylinderGeometry(.03,0,.15,4,1,!1),C),[-1.17,0,0],[0,0,Math.PI/2],[1,1,.001]],[new l.Mesh(new l.CylinderGeometry(.03,0,.15,4,1,!1),C),[0,-1.17,0],[Math.PI,0,0],[1,1,.001]],[new l.Mesh(new l.CylinderGeometry(.03,0,.15,4,1,!1),C),[0,1.17,0],[0,0,0],[1,1,.001]]],XYZE:[[new l.Line(b(1,1),w),null,[0,Math.PI/2,0]]]},G={AXIS:[[new l.Line(P,o.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]]},E={X:[[new l.Mesh(new l.TorusGeometry(1,.1,4,24),n),[0,0,0],[0,-Math.PI/2,-Math.PI/2]]],Y:[[new l.Mesh(new l.TorusGeometry(1,.1,4,24),n),[0,0,0],[Math.PI/2,0,0]]],Z:[[new l.Mesh(new l.TorusGeometry(1,.1,4,24),n),[0,0,0],[0,0,-Math.PI/2]]],E:[[new l.Mesh(new l.TorusGeometry(1.25,.1,2,24),n)]],XYZE:[[new l.Mesh(new l.SphereGeometry(.7,10,8),n)]]},X={X:[[new l.Mesh(M,r),[.8,0,0],[0,0,-Math.PI/2]],[new l.Line(P,d),null,null,[.8,1,1]]],Y:[[new l.Mesh(M,s),[0,.8,0]],[new l.Line(P,y),null,[0,0,Math.PI/2],[.8,1,1]]],Z:[[new l.Mesh(M,a),[0,0,.8],[Math.PI/2,0,0]],[new l.Line(P,_),null,[0,-Math.PI/2,0],[.8,1,1]]],XY:[[new l.Mesh(M,h),[.85,.85,0],null,[2,2,.2]],[new l.Line(P,A),[.855,.98,0],null,[.125,1,1]],[new l.Line(P,A),[.98,.855,0],[0,0,Math.PI/2],[.125,1,1]]],YZ:[[new l.Mesh(M,p),[0,.85,.85],null,[.2,2,2]],[new l.Line(P,v),[0,.855,.98],[0,0,Math.PI/2],[.125,1,1]],[new l.Line(P,v),[0,.98,.855],[0,-Math.PI/2,0],[.125,1,1]]],XZ:[[new l.Mesh(M,f),[.85,0,.85],null,[2,.2,2]],[new l.Line(P,g),[.855,0,.98],null,[.125,1,1]],[new l.Line(P,g),[.98,0,.855],[0,-Math.PI/2,0],[.125,1,1]]],XYZX:[[new l.Mesh(new l.BoxGeometry(.125,.125,.125),c.clone()),[1.1,0,0]]],XYZY:[[new l.Mesh(new l.BoxGeometry(.125,.125,.125),c.clone()),[0,1.1,0]]],XYZZ:[[new l.Mesh(new l.BoxGeometry(.125,.125,.125),c.clone()),[0,0,1.1]]]},oe={X:[[new l.Mesh(new l.CylinderGeometry(.2,0,.8,4,1,!1),n),[.5,0,0],[0,0,-Math.PI/2]]],Y:[[new l.Mesh(new l.CylinderGeometry(.2,0,.8,4,1,!1),n),[0,.5,0]]],Z:[[new l.Mesh(new l.CylinderGeometry(.2,0,.8,4,1,!1),n),[0,0,.5],[Math.PI/2,0,0]]],XY:[[new l.Mesh(M,n),[.85,.85,0],null,[3,3,.2]]],YZ:[[new l.Mesh(M,n),[0,.85,.85],null,[.2,3,3]]],XZ:[[new l.Mesh(M,n),[.85,0,.85],null,[3,.2,3]]],XYZX:[[new l.Mesh(new l.BoxGeometry(.2,.2,.2),n),[1.1,0,0]]],XYZY:[[new l.Mesh(new l.BoxGeometry(.2,.2,.2),n),[0,1.1,0]]],XYZZ:[[new l.Mesh(new l.BoxGeometry(.2,.2,.2),n),[0,0,1.1]]]},q={X:[[new l.Line(P,o.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new l.Line(P,o.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new l.Line(P,o.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]},ee=te=>{const ce=new l.Object3D;for(let le in te)for(let de=te[le].length;de--;){const k=te[le][de][0].clone(),V=te[le][de][1],U=te[le][de][2],B=te[le][de][3],R=te[le][de][4];k.name=le,k.tag=R,V&&k.position.set(V[0],V[1],V[2]),U&&k.rotation.set(U[0],U[1],U[2]),B&&k.scale.set(B[0],B[1],B[2]),k.updateMatrix();const T=k.geometry.clone();T.applyMatrix4(k.matrix),k.geometry=T,k.renderOrder=1/0,k.position.set(0,0,0),k.rotation.set(0,0,0),k.scale.set(1,1,1),ce.add(k)}return ce};this.gizmo={},this.picker={},this.helper={},this.add(this.gizmo.translate=ee(x)),this.add(this.gizmo.rotate=ee(z)),this.add(this.gizmo.scale=ee(X)),this.add(this.picker.translate=ee(I)),this.add(this.picker.rotate=ee(E)),this.add(this.picker.scale=ee(oe)),this.add(this.helper.translate=ee(D)),this.add(this.helper.rotate=ee(G)),this.add(this.helper.scale=ee(q)),this.picker.translate.visible=!1,this.picker.rotate.visible=!1,this.picker.scale.visible=!1}}class Ja extends l.Mesh{constructor(){super(new l.PlaneGeometry(1e5,1e5,2,2),new l.MeshBasicMaterial({visible:!1,wireframe:!0,side:l.DoubleSide,transparent:!0,opacity:.1,toneMapped:!1})),J(this,"isTransformControlsPlane",!0),J(this,"type","TransformControlsPlane"),J(this,"unitX",new l.Vector3(1,0,0)),J(this,"unitY",new l.Vector3(0,1,0)),J(this,"unitZ",new l.Vector3(0,0,1)),J(this,"tempVector",new l.Vector3),J(this,"dirVector",new l.Vector3),J(this,"alignVector",new l.Vector3),J(this,"tempMatrix",new l.Matrix4),J(this,"identityQuaternion",new l.Quaternion),J(this,"cameraQuaternion",new l.Quaternion),J(this,"worldPosition",new l.Vector3),J(this,"worldQuaternion",new l.Quaternion),J(this,"eye",new l.Vector3),J(this,"axis",null),J(this,"mode","translate"),J(this,"space","world"),J(this,"updateMatrixWorld",()=>{let e=this.space;switch(this.position.copy(this.worldPosition),this.mode==="scale"&&(e="local"),this.unitX.set(1,0,0).applyQuaternion(e==="local"?this.worldQuaternion:this.identityQuaternion),this.unitY.set(0,1,0).applyQuaternion(e==="local"?this.worldQuaternion:this.identityQuaternion),this.unitZ.set(0,0,1).applyQuaternion(e==="local"?this.worldQuaternion:this.identityQuaternion),this.alignVector.copy(this.unitY),this.mode){case"translate":case"scale":switch(this.axis){case"X":this.alignVector.copy(this.eye).cross(this.unitX),this.dirVector.copy(this.unitX).cross(this.alignVector);break;case"Y":this.alignVector.copy(this.eye).cross(this.unitY),this.dirVector.copy(this.unitY).cross(this.alignVector);break;case"Z":this.alignVector.copy(this.eye).cross(this.unitZ),this.dirVector.copy(this.unitZ).cross(this.alignVector);break;case"XY":this.dirVector.copy(this.unitZ);break;case"YZ":this.dirVector.copy(this.unitX);break;case"XZ":this.alignVector.copy(this.unitZ),this.dirVector.copy(this.unitY);break;case"XYZ":case"E":this.dirVector.set(0,0,0);break}break;case"rotate":default:this.dirVector.set(0,0,0)}this.dirVector.length()===0?this.quaternion.copy(this.cameraQuaternion):(this.tempMatrix.lookAt(this.tempVector.set(0,0,0),this.dirVector,this.alignVector),this.quaternion.setFromRotationMatrix(this.tempMatrix)),super.updateMatrixWorld()})}}var Ha=Object.defineProperty,$a=(i,e,t)=>e in i?Ha(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,ke=(i,e,t)=>($a(i,typeof e!="symbol"?e+"":e,t),t);const Dt=new l.Euler(0,0,0,"YXZ"),kt=new l.Vector3,el={type:"change"},tl={type:"lock"},nl={type:"unlock"},_r=Math.PI/2;class vr extends l.EventDispatcher{constructor(e,t){super(),ke(this,"camera"),ke(this,"domElement"),ke(this,"isLocked"),ke(this,"minPolarAngle"),ke(this,"maxPolarAngle"),ke(this,"pointerSpeed"),ke(this,"onMouseMove",n=>{if(!this.domElement||this.isLocked===!1)return;const o=n.movementX||n.mozMovementX||n.webkitMovementX||0,r=n.movementY||n.mozMovementY||n.webkitMovementY||0;Dt.setFromQuaternion(this.camera.quaternion),Dt.y-=o*.002*this.pointerSpeed,Dt.x-=r*.002*this.pointerSpeed,Dt.x=Math.max(_r-this.maxPolarAngle,Math.min(_r-this.minPolarAngle,Dt.x)),this.camera.quaternion.setFromEuler(Dt),this.dispatchEvent(el)}),ke(this,"onPointerlockChange",()=>{this.domElement&&(this.domElement.ownerDocument.pointerLockElement===this.domElement?(this.dispatchEvent(tl),this.isLocked=!0):(this.dispatchEvent(nl),this.isLocked=!1))}),ke(this,"onPointerlockError",()=>{console.error("THREE.PointerLockControls: Unable to use Pointer Lock API")}),ke(this,"connect",n=>{this.domElement=n||this.domElement,this.domElement&&(this.domElement.ownerDocument.addEventListener("mousemove",this.onMouseMove),this.domElement.ownerDocument.addEventListener("pointerlockchange",this.onPointerlockChange),this.domElement.ownerDocument.addEventListener("pointerlockerror",this.onPointerlockError))}),ke(this,"disconnect",()=>{this.domElement&&(this.domElement.ownerDocument.removeEventListener("mousemove",this.onMouseMove),this.domElement.ownerDocument.removeEventListener("pointerlockchange",this.onPointerlockChange),this.domElement.ownerDocument.removeEventListener("pointerlockerror",this.onPointerlockError))}),ke(this,"dispose",()=>{this.disconnect()}),ke(this,"getObject",()=>this.camera),ke(this,"direction",new l.Vector3(0,0,-1)),ke(this,"getDirection",n=>n.copy(this.direction).applyQuaternion(this.camera.quaternion)),ke(this,"moveForward",n=>{kt.setFromMatrixColumn(this.camera.matrix,0),kt.crossVectors(this.camera.up,kt),this.camera.position.addScaledVector(kt,n)}),ke(this,"moveRight",n=>{kt.setFromMatrixColumn(this.camera.matrix,0),this.camera.position.addScaledVector(kt,n)}),ke(this,"lock",()=>{this.domElement&&this.domElement.requestPointerLock()}),ke(this,"unlock",()=>{this.domElement&&this.domElement.ownerDocument.exitPointerLock()}),this.camera=e,this.domElement=t,this.isLocked=!1,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.pointerSpeed=1,t&&this.connect(t)}}var ol=Object.defineProperty,rl=(i,e,t)=>e in i?ol(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,fe=(i,e,t)=>(rl(i,typeof e!="symbol"?e+"":e,t),t);const yn=new l.Ray,xr=new l.Plane,sl=Math.cos(70*(Math.PI/180)),wr=(i,e)=>(i%e+e)%e;class br extends l.EventDispatcher{constructor(e,t){super(),fe(this,"object"),fe(this,"domElement"),fe(this,"enabled",!0),fe(this,"target",new l.Vector3),fe(this,"minDistance",0),fe(this,"maxDistance",1/0),fe(this,"minZoom",0),fe(this,"maxZoom",1/0),fe(this,"minPolarAngle",0),fe(this,"maxPolarAngle",Math.PI),fe(this,"minAzimuthAngle",-1/0),fe(this,"maxAzimuthAngle",1/0),fe(this,"enableDamping",!1),fe(this,"dampingFactor",.05),fe(this,"enableZoom",!0),fe(this,"zoomSpeed",1),fe(this,"enableRotate",!0),fe(this,"rotateSpeed",1),fe(this,"enablePan",!0),fe(this,"panSpeed",1),fe(this,"screenSpacePanning",!0),fe(this,"keyPanSpeed",7),fe(this,"zoomToCursor",!1),fe(this,"autoRotate",!1),fe(this,"autoRotateSpeed",2),fe(this,"reverseOrbit",!1),fe(this,"reverseHorizontalOrbit",!1),fe(this,"reverseVerticalOrbit",!1),fe(this,"keys",{LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"}),fe(this,"mouseButtons",{LEFT:l.MOUSE.ROTATE,MIDDLE:l.MOUSE.DOLLY,RIGHT:l.MOUSE.PAN}),fe(this,"touches",{ONE:l.TOUCH.ROTATE,TWO:l.TOUCH.DOLLY_PAN}),fe(this,"target0"),fe(this,"position0"),fe(this,"zoom0"),fe(this,"_domElementKeyEvents",null),fe(this,"getPolarAngle"),fe(this,"getAzimuthalAngle"),fe(this,"setPolarAngle"),fe(this,"setAzimuthalAngle"),fe(this,"getDistance"),fe(this,"getZoomScale"),fe(this,"listenToKeyEvents"),fe(this,"stopListenToKeyEvents"),fe(this,"saveState"),fe(this,"reset"),fe(this,"update"),fe(this,"connect"),fe(this,"dispose"),fe(this,"dollyIn"),fe(this,"dollyOut"),fe(this,"getScale"),fe(this,"setScale"),this.object=e,this.domElement=t,this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this.getPolarAngle=()=>p.phi,this.getAzimuthalAngle=()=>p.theta,this.setPolarAngle=Z=>{let ae=wr(Z,2*Math.PI),ge=p.phi;ge<0&&(ge+=2*Math.PI),ae<0&&(ae+=2*Math.PI);let Me=Math.abs(ae-ge);2*Math.PI-Me<Me&&(ae<ge?ae+=2*Math.PI:ge+=2*Math.PI),f.phi=ae-ge,n.update()},this.setAzimuthalAngle=Z=>{let ae=wr(Z,2*Math.PI),ge=p.theta;ge<0&&(ge+=2*Math.PI),ae<0&&(ae+=2*Math.PI);let Me=Math.abs(ae-ge);2*Math.PI-Me<Me&&(ae<ge?ae+=2*Math.PI:ge+=2*Math.PI),f.theta=ae-ge,n.update()},this.getDistance=()=>n.object.position.distanceTo(n.target),this.listenToKeyEvents=Z=>{Z.addEventListener("keydown",st),this._domElementKeyEvents=Z},this.stopListenToKeyEvents=()=>{this._domElementKeyEvents.removeEventListener("keydown",st),this._domElementKeyEvents=null},this.saveState=()=>{n.target0.copy(n.target),n.position0.copy(n.object.position),n.zoom0=n.object.zoom},this.reset=()=>{n.target.copy(n.target0),n.object.position.copy(n.position0),n.object.zoom=n.zoom0,n.object.updateProjectionMatrix(),n.dispatchEvent(o),n.update(),c=a.NONE},this.update=(()=>{const Z=new l.Vector3,ae=new l.Vector3(0,1,0),ge=new l.Quaternion().setFromUnitVectors(e.up,ae),Me=ge.clone().invert(),Be=new l.Vector3,ht=new l.Quaternion,bt=2*Math.PI;return function(){const Hs=n.object.position;ge.setFromUnitVectors(e.up,ae),Me.copy(ge).invert(),Z.copy(Hs).sub(n.target),Z.applyQuaternion(ge),p.setFromVector3(Z),n.autoRotate&&c===a.NONE&&G(D()),n.enableDamping?(p.theta+=f.theta*n.dampingFactor,p.phi+=f.phi*n.dampingFactor):(p.theta+=f.theta,p.phi+=f.phi);let ft=n.minAzimuthAngle,dt=n.maxAzimuthAngle;isFinite(ft)&&isFinite(dt)&&(ft<-Math.PI?ft+=bt:ft>Math.PI&&(ft-=bt),dt<-Math.PI?dt+=bt:dt>Math.PI&&(dt-=bt),ft<=dt?p.theta=Math.max(ft,Math.min(dt,p.theta)):p.theta=p.theta>(ft+dt)/2?Math.max(ft,p.theta):Math.min(dt,p.theta)),p.phi=Math.max(n.minPolarAngle,Math.min(n.maxPolarAngle,p.phi)),p.makeSafe(),n.enableDamping===!0?n.target.addScaledVector(d,n.dampingFactor):n.target.add(d),n.zoomToCursor&&S||n.object.isOrthographicCamera?p.radius=de(p.radius):p.radius=de(p.radius*m),Z.setFromSpherical(p),Z.applyQuaternion(Me),Hs.copy(n.target).add(Z),n.object.matrixAutoUpdate||n.object.updateMatrix(),n.object.lookAt(n.target),n.enableDamping===!0?(f.theta*=1-n.dampingFactor,f.phi*=1-n.dampingFactor,d.multiplyScalar(1-n.dampingFactor)):(f.set(0,0,0),d.set(0,0,0));let an=!1;if(n.zoomToCursor&&S){let ln=null;if(n.object instanceof l.PerspectiveCamera&&n.object.isPerspectiveCamera){const cn=Z.length();ln=de(cn*m);const Un=cn-ln;n.object.position.addScaledVector(P,Un),n.object.updateMatrixWorld()}else if(n.object.isOrthographicCamera){const cn=new l.Vector3(b.x,b.y,0);cn.unproject(n.object),n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/m)),n.object.updateProjectionMatrix(),an=!0;const Un=new l.Vector3(b.x,b.y,0);Un.unproject(n.object),n.object.position.sub(Un).add(cn),n.object.updateMatrixWorld(),ln=Z.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),n.zoomToCursor=!1;ln!==null&&(n.screenSpacePanning?n.target.set(0,0,-1).transformDirection(n.object.matrix).multiplyScalar(ln).add(n.object.position):(yn.origin.copy(n.object.position),yn.direction.set(0,0,-1).transformDirection(n.object.matrix),Math.abs(n.object.up.dot(yn.direction))<sl?e.lookAt(n.target):(xr.setFromNormalAndCoplanarPoint(n.object.up,n.target),yn.intersectPlane(xr,n.target))))}else n.object instanceof l.OrthographicCamera&&n.object.isOrthographicCamera&&(an=m!==1,an&&(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/m)),n.object.updateProjectionMatrix()));return m=1,S=!1,an||Be.distanceToSquared(n.object.position)>h||8*(1-ht.dot(n.object.quaternion))>h?(n.dispatchEvent(o),Be.copy(n.object.position),ht.copy(n.object.quaternion),an=!1,!0):!1}})(),this.connect=Z=>{n.domElement=Z,n.domElement.style.touchAction="none",n.domElement.addEventListener("contextmenu",sn),n.domElement.addEventListener("pointerdown",_e),n.domElement.addEventListener("pointercancel",Pe),n.domElement.addEventListener("wheel",It)},this.dispose=()=>{var Z,ae,ge,Me,Be,ht;n.domElement&&(n.domElement.style.touchAction="auto"),(Z=n.domElement)==null||Z.removeEventListener("contextmenu",sn),(ae=n.domElement)==null||ae.removeEventListener("pointerdown",_e),(ge=n.domElement)==null||ge.removeEventListener("pointercancel",Pe),(Me=n.domElement)==null||Me.removeEventListener("wheel",It),(Be=n.domElement)==null||Be.ownerDocument.removeEventListener("pointermove",Le),(ht=n.domElement)==null||ht.ownerDocument.removeEventListener("pointerup",Pe),n._domElementKeyEvents!==null&&n._domElementKeyEvents.removeEventListener("keydown",st)};const n=this,o={type:"change"},r={type:"start"},s={type:"end"},a={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let c=a.NONE;const h=1e-6,p=new l.Spherical,f=new l.Spherical;let m=1;const d=new l.Vector3,y=new l.Vector2,_=new l.Vector2,v=new l.Vector2,g=new l.Vector2,A=new l.Vector2,w=new l.Vector2,C=new l.Vector2,L=new l.Vector2,M=new l.Vector2,P=new l.Vector3,b=new l.Vector2;let S=!1;const x=[],I={};function D(){return 2*Math.PI/60/60*n.autoRotateSpeed}function z(){return Math.pow(.95,n.zoomSpeed)}function G(Z){n.reverseOrbit||n.reverseHorizontalOrbit?f.theta+=Z:f.theta-=Z}function E(Z){n.reverseOrbit||n.reverseVerticalOrbit?f.phi+=Z:f.phi-=Z}const X=(()=>{const Z=new l.Vector3;return function(ge,Me){Z.setFromMatrixColumn(Me,0),Z.multiplyScalar(-ge),d.add(Z)}})(),oe=(()=>{const Z=new l.Vector3;return function(ge,Me){n.screenSpacePanning===!0?Z.setFromMatrixColumn(Me,1):(Z.setFromMatrixColumn(Me,0),Z.crossVectors(n.object.up,Z)),Z.multiplyScalar(ge),d.add(Z)}})(),q=(()=>{const Z=new l.Vector3;return function(ge,Me){const Be=n.domElement;if(Be&&n.object instanceof l.PerspectiveCamera&&n.object.isPerspectiveCamera){const ht=n.object.position;Z.copy(ht).sub(n.target);let bt=Z.length();bt*=Math.tan(n.object.fov/2*Math.PI/180),X(2*ge*bt/Be.clientHeight,n.object.matrix),oe(2*Me*bt/Be.clientHeight,n.object.matrix)}else Be&&n.object instanceof l.OrthographicCamera&&n.object.isOrthographicCamera?(X(ge*(n.object.right-n.object.left)/n.object.zoom/Be.clientWidth,n.object.matrix),oe(Me*(n.object.top-n.object.bottom)/n.object.zoom/Be.clientHeight,n.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),n.enablePan=!1)}})();function ee(Z){n.object instanceof l.PerspectiveCamera&&n.object.isPerspectiveCamera||n.object instanceof l.OrthographicCamera&&n.object.isOrthographicCamera?m=Z:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function te(Z){ee(m/Z)}function ce(Z){ee(m*Z)}function le(Z){if(!n.zoomToCursor||!n.domElement)return;S=!0;const ae=n.domElement.getBoundingClientRect(),ge=Z.clientX-ae.left,Me=Z.clientY-ae.top,Be=ae.width,ht=ae.height;b.x=ge/Be*2-1,b.y=-(Me/ht)*2+1,P.set(b.x,b.y,1).unproject(n.object).sub(n.object.position).normalize()}function de(Z){return Math.max(n.minDistance,Math.min(n.maxDistance,Z))}function k(Z){y.set(Z.clientX,Z.clientY)}function V(Z){le(Z),C.set(Z.clientX,Z.clientY)}function U(Z){g.set(Z.clientX,Z.clientY)}function B(Z){_.set(Z.clientX,Z.clientY),v.subVectors(_,y).multiplyScalar(n.rotateSpeed);const ae=n.domElement;ae&&(G(2*Math.PI*v.x/ae.clientHeight),E(2*Math.PI*v.y/ae.clientHeight)),y.copy(_),n.update()}function R(Z){L.set(Z.clientX,Z.clientY),M.subVectors(L,C),M.y>0?te(z()):M.y<0&&ce(z()),C.copy(L),n.update()}function T(Z){A.set(Z.clientX,Z.clientY),w.subVectors(A,g).multiplyScalar(n.panSpeed),q(w.x,w.y),g.copy(A),n.update()}function O(Z){le(Z),Z.deltaY<0?ce(z()):Z.deltaY>0&&te(z()),n.update()}function N(Z){let ae=!1;switch(Z.code){case n.keys.UP:q(0,n.keyPanSpeed),ae=!0;break;case n.keys.BOTTOM:q(0,-n.keyPanSpeed),ae=!0;break;case n.keys.LEFT:q(n.keyPanSpeed,0),ae=!0;break;case n.keys.RIGHT:q(-n.keyPanSpeed,0),ae=!0;break}ae&&(Z.preventDefault(),n.update())}function K(){if(x.length==1)y.set(x[0].pageX,x[0].pageY);else{const Z=.5*(x[0].pageX+x[1].pageX),ae=.5*(x[0].pageY+x[1].pageY);y.set(Z,ae)}}function W(){if(x.length==1)g.set(x[0].pageX,x[0].pageY);else{const Z=.5*(x[0].pageX+x[1].pageX),ae=.5*(x[0].pageY+x[1].pageY);g.set(Z,ae)}}function Y(){const Z=x[0].pageX-x[1].pageX,ae=x[0].pageY-x[1].pageY,ge=Math.sqrt(Z*Z+ae*ae);C.set(0,ge)}function Q(){n.enableZoom&&Y(),n.enablePan&&W()}function re(){n.enableZoom&&Y(),n.enableRotate&&K()}function se(Z){if(x.length==1)_.set(Z.pageX,Z.pageY);else{const ge=Wo(Z),Me=.5*(Z.pageX+ge.x),Be=.5*(Z.pageY+ge.y);_.set(Me,Be)}v.subVectors(_,y).multiplyScalar(n.rotateSpeed);const ae=n.domElement;ae&&(G(2*Math.PI*v.x/ae.clientHeight),E(2*Math.PI*v.y/ae.clientHeight)),y.copy(_)}function j(Z){if(x.length==1)A.set(Z.pageX,Z.pageY);else{const ae=Wo(Z),ge=.5*(Z.pageX+ae.x),Me=.5*(Z.pageY+ae.y);A.set(ge,Me)}w.subVectors(A,g).multiplyScalar(n.panSpeed),q(w.x,w.y),g.copy(A)}function F(Z){const ae=Wo(Z),ge=Z.pageX-ae.x,Me=Z.pageY-ae.y,Be=Math.sqrt(ge*ge+Me*Me);L.set(0,Be),M.set(0,Math.pow(L.y/C.y,n.zoomSpeed)),te(M.y),C.copy(L)}function ie(Z){n.enableZoom&&F(Z),n.enablePan&&j(Z)}function he(Z){n.enableZoom&&F(Z),n.enableRotate&&se(Z)}function _e(Z){var ae,ge;n.enabled!==!1&&(x.length===0&&((ae=n.domElement)==null||ae.ownerDocument.addEventListener("pointermove",Le),(ge=n.domElement)==null||ge.ownerDocument.addEventListener("pointerup",Pe)),kn(Z),Z.pointerType==="touch"?Ee(Z):Je(Z))}function Le(Z){n.enabled!==!1&&(Z.pointerType==="touch"?it(Z):wt(Z))}function Pe(Z){var ae,ge,Me;jo(Z),x.length===0&&((ae=n.domElement)==null||ae.releasePointerCapture(Z.pointerId),(ge=n.domElement)==null||ge.ownerDocument.removeEventListener("pointermove",Le),(Me=n.domElement)==null||Me.ownerDocument.removeEventListener("pointerup",Pe)),n.dispatchEvent(s),c=a.NONE}function Je(Z){let ae;switch(Z.button){case 0:ae=n.mouseButtons.LEFT;break;case 1:ae=n.mouseButtons.MIDDLE;break;case 2:ae=n.mouseButtons.RIGHT;break;default:ae=-1}switch(ae){case l.MOUSE.DOLLY:if(n.enableZoom===!1)return;V(Z),c=a.DOLLY;break;case l.MOUSE.ROTATE:if(Z.ctrlKey||Z.metaKey||Z.shiftKey){if(n.enablePan===!1)return;U(Z),c=a.PAN}else{if(n.enableRotate===!1)return;k(Z),c=a.ROTATE}break;case l.MOUSE.PAN:if(Z.ctrlKey||Z.metaKey||Z.shiftKey){if(n.enableRotate===!1)return;k(Z),c=a.ROTATE}else{if(n.enablePan===!1)return;U(Z),c=a.PAN}break;default:c=a.NONE}c!==a.NONE&&n.dispatchEvent(r)}function wt(Z){if(n.enabled!==!1)switch(c){case a.ROTATE:if(n.enableRotate===!1)return;B(Z);break;case a.DOLLY:if(n.enableZoom===!1)return;R(Z);break;case a.PAN:if(n.enablePan===!1)return;T(Z);break}}function It(Z){n.enabled===!1||n.enableZoom===!1||c!==a.NONE&&c!==a.ROTATE||(Z.preventDefault(),n.dispatchEvent(r),O(Z),n.dispatchEvent(s))}function st(Z){n.enabled===!1||n.enablePan===!1||N(Z)}function Ee(Z){switch(Bn(Z),x.length){case 1:switch(n.touches.ONE){case l.TOUCH.ROTATE:if(n.enableRotate===!1)return;K(),c=a.TOUCH_ROTATE;break;case l.TOUCH.PAN:if(n.enablePan===!1)return;W(),c=a.TOUCH_PAN;break;default:c=a.NONE}break;case 2:switch(n.touches.TWO){case l.TOUCH.DOLLY_PAN:if(n.enableZoom===!1&&n.enablePan===!1)return;Q(),c=a.TOUCH_DOLLY_PAN;break;case l.TOUCH.DOLLY_ROTATE:if(n.enableZoom===!1&&n.enableRotate===!1)return;re(),c=a.TOUCH_DOLLY_ROTATE;break;default:c=a.NONE}break;default:c=a.NONE}c!==a.NONE&&n.dispatchEvent(r)}function it(Z){switch(Bn(Z),c){case a.TOUCH_ROTATE:if(n.enableRotate===!1)return;se(Z),n.update();break;case a.TOUCH_PAN:if(n.enablePan===!1)return;j(Z),n.update();break;case a.TOUCH_DOLLY_PAN:if(n.enableZoom===!1&&n.enablePan===!1)return;ie(Z),n.update();break;case a.TOUCH_DOLLY_ROTATE:if(n.enableZoom===!1&&n.enableRotate===!1)return;he(Z),n.update();break;default:c=a.NONE}}function sn(Z){n.enabled!==!1&&Z.preventDefault()}function kn(Z){x.push(Z)}function jo(Z){delete I[Z.pointerId];for(let ae=0;ae<x.length;ae++)if(x[ae].pointerId==Z.pointerId){x.splice(ae,1);return}}function Bn(Z){let ae=I[Z.pointerId];ae===void 0&&(ae=new l.Vector2,I[Z.pointerId]=ae),ae.set(Z.pageX,Z.pageY)}function Wo(Z){const ae=Z.pointerId===x[0].pointerId?x[1]:x[0];return I[ae.pointerId]}this.dollyIn=(Z=z())=>{ce(Z),n.update()},this.dollyOut=(Z=z())=>{te(Z),n.update()},this.getScale=()=>m,this.setScale=Z=>{ee(Z),n.update()},this.getZoomScale=()=>z(),t!==void 0&&this.connect(t),this.update()}}class il extends br{constructor(e,t){super(e,t),this.screenSpacePanning=!1,this.mouseButtons.LEFT=l.MOUSE.PAN,this.mouseButtons.RIGHT=l.MOUSE.ROTATE,this.touches.ONE=l.TOUCH.PAN,this.touches.TWO=l.TOUCH.DOLLY_ROTATE}}function Bt(i){if(typeof TextDecoder<"u")return new TextDecoder().decode(i);let e="";for(let t=0,n=i.length;t<n;t++)e+=String.fromCharCode(i[t]);try{return decodeURIComponent(escape(e))}catch{return e}}const St="srgb",lt="srgb-linear",Mr=3001,al=3e3;class ll extends l.Loader{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(t){return new dl(t)}),this.register(function(t){return new pl(t)}),this.register(function(t){return new Ml(t)}),this.register(function(t){return new Sl(t)}),this.register(function(t){return new Al(t)}),this.register(function(t){return new gl(t)}),this.register(function(t){return new yl(t)}),this.register(function(t){return new _l(t)}),this.register(function(t){return new vl(t)}),this.register(function(t){return new fl(t)}),this.register(function(t){return new xl(t)}),this.register(function(t){return new ml(t)}),this.register(function(t){return new bl(t)}),this.register(function(t){return new wl(t)}),this.register(function(t){return new ul(t)}),this.register(function(t){return new Pl(t)}),this.register(function(t){return new Cl(t)})}load(e,t,n,o){const r=this;let s;if(this.resourcePath!=="")s=this.resourcePath;else if(this.path!==""){const h=l.LoaderUtils.extractUrlBase(e);s=l.LoaderUtils.resolveURL(h,this.path)}else s=l.LoaderUtils.extractUrlBase(e);this.manager.itemStart(e);const a=function(h){o?o(h):console.error(h),r.manager.itemError(e),r.manager.itemEnd(e)},c=new l.FileLoader(this.manager);c.setPath(this.path),c.setResponseType("arraybuffer"),c.setRequestHeader(this.requestHeader),c.setWithCredentials(this.withCredentials),c.load(e,function(h){try{r.parse(h,s,function(p){t(p),r.manager.itemEnd(e)},a)}catch(p){a(p)}},n,a)}setDRACOLoader(e){return this.dracoLoader=e,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,n,o){let r;const s={},a={};if(typeof e=="string")r=JSON.parse(e);else if(e instanceof ArrayBuffer)if(Bt(new Uint8Array(e.slice(0,4)))===Sr){try{s[ve.KHR_BINARY_GLTF]=new Tl(e)}catch(p){o&&o(p);return}r=JSON.parse(s[ve.KHR_BINARY_GLTF].content)}else r=JSON.parse(Bt(new Uint8Array(e)));else r=e;if(r.asset===void 0||r.asset.version[0]<2){o&&o(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const c=new Rl(r,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});c.fileLoader.setRequestHeader(this.requestHeader);for(let h=0;h<this.pluginCallbacks.length;h++){const p=this.pluginCallbacks[h](c);p.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),a[p.name]=p,s[p.name]=!0}if(r.extensionsUsed)for(let h=0;h<r.extensionsUsed.length;++h){const p=r.extensionsUsed[h],f=r.extensionsRequired||[];switch(p){case ve.KHR_MATERIALS_UNLIT:s[p]=new hl;break;case ve.KHR_DRACO_MESH_COMPRESSION:s[p]=new Il(r,this.dracoLoader);break;case ve.KHR_TEXTURE_TRANSFORM:s[p]=new Ol;break;case ve.KHR_MESH_QUANTIZATION:s[p]=new Ll;break;default:f.indexOf(p)>=0&&a[p]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+p+'".')}}c.setExtensions(s),c.setPlugins(a),c.parse(n,o)}parseAsync(e,t){const n=this;return new Promise(function(o,r){n.parse(e,t,o,r)})}}function cl(){let i={};return{get:function(e){return i[e]},add:function(e,t){i[e]=t},remove:function(e){delete i[e]},removeAll:function(){i={}}}}const ve={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_DISPERSION:"KHR_materials_dispersion",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class ul{constructor(e){this.parser=e,this.name=ve.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let n=0,o=t.length;n<o;n++){const r=t[n];r.extensions&&r.extensions[this.name]&&r.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,r.extensions[this.name].light)}}_loadLight(e){const t=this.parser,n="light:"+e;let o=t.cache.get(n);if(o)return o;const r=t.json,c=((r.extensions&&r.extensions[this.name]||{}).lights||[])[e];let h;const p=new l.Color(16777215);c.color!==void 0&&p.setRGB(c.color[0],c.color[1],c.color[2],lt);const f=c.range!==void 0?c.range:0;switch(c.type){case"directional":h=new l.DirectionalLight(p),h.target.position.set(0,0,-1),h.add(h.target);break;case"point":h=new l.PointLight(p),h.distance=f;break;case"spot":h=new l.SpotLight(p),h.distance=f,c.spot=c.spot||{},c.spot.innerConeAngle=c.spot.innerConeAngle!==void 0?c.spot.innerConeAngle:0,c.spot.outerConeAngle=c.spot.outerConeAngle!==void 0?c.spot.outerConeAngle:Math.PI/4,h.angle=c.spot.outerConeAngle,h.penumbra=1-c.spot.innerConeAngle/c.spot.outerConeAngle,h.target.position.set(0,0,-1),h.add(h.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+c.type)}return h.position.set(0,0,0),h.decay=2,ct(h,c),c.intensity!==void 0&&(h.intensity=c.intensity),h.name=t.createUniqueName(c.name||"light_"+e),o=Promise.resolve(h),t.cache.add(n,o),o}getDependency(e,t){if(e==="light")return this._loadLight(t)}createNodeAttachment(e){const t=this,n=this.parser,r=n.json.nodes[e],a=(r.extensions&&r.extensions[this.name]||{}).light;return a===void 0?null:this._loadLight(a).then(function(c){return n._getNodeRef(t.cache,a,c)})}}class hl{constructor(){this.name=ve.KHR_MATERIALS_UNLIT}getMaterialType(){return l.MeshBasicMaterial}extendParams(e,t,n){const o=[];e.color=new l.Color(1,1,1),e.opacity=1;const r=t.pbrMetallicRoughness;if(r){if(Array.isArray(r.baseColorFactor)){const s=r.baseColorFactor;e.color.setRGB(s[0],s[1],s[2],lt),e.opacity=s[3]}r.baseColorTexture!==void 0&&o.push(n.assignTexture(e,"map",r.baseColorTexture,St))}return Promise.all(o)}}class fl{constructor(e){this.parser=e,this.name=ve.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const o=this.parser.json.materials[e];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();const r=o.extensions[this.name].emissiveStrength;return r!==void 0&&(t.emissiveIntensity=r),Promise.resolve()}}class dl{constructor(e){this.parser=e,this.name=ve.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:l.MeshPhysicalMaterial}extendMaterialParams(e,t){const n=this.parser,o=n.json.materials[e];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();const r=[],s=o.extensions[this.name];if(s.clearcoatFactor!==void 0&&(t.clearcoat=s.clearcoatFactor),s.clearcoatTexture!==void 0&&r.push(n.assignTexture(t,"clearcoatMap",s.clearcoatTexture)),s.clearcoatRoughnessFactor!==void 0&&(t.clearcoatRoughness=s.clearcoatRoughnessFactor),s.clearcoatRoughnessTexture!==void 0&&r.push(n.assignTexture(t,"clearcoatRoughnessMap",s.clearcoatRoughnessTexture)),s.clearcoatNormalTexture!==void 0&&(r.push(n.assignTexture(t,"clearcoatNormalMap",s.clearcoatNormalTexture)),s.clearcoatNormalTexture.scale!==void 0)){const a=s.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new l.Vector2(a,a)}return Promise.all(r)}}class pl{constructor(e){this.parser=e,this.name=ve.KHR_MATERIALS_DISPERSION}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:l.MeshPhysicalMaterial}extendMaterialParams(e,t){const o=this.parser.json.materials[e];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();const r=o.extensions[this.name];return t.dispersion=r.dispersion!==void 0?r.dispersion:0,Promise.resolve()}}class ml{constructor(e){this.parser=e,this.name=ve.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:l.MeshPhysicalMaterial}extendMaterialParams(e,t){const n=this.parser,o=n.json.materials[e];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();const r=[],s=o.extensions[this.name];return s.iridescenceFactor!==void 0&&(t.iridescence=s.iridescenceFactor),s.iridescenceTexture!==void 0&&r.push(n.assignTexture(t,"iridescenceMap",s.iridescenceTexture)),s.iridescenceIor!==void 0&&(t.iridescenceIOR=s.iridescenceIor),t.iridescenceThicknessRange===void 0&&(t.iridescenceThicknessRange=[100,400]),s.iridescenceThicknessMinimum!==void 0&&(t.iridescenceThicknessRange[0]=s.iridescenceThicknessMinimum),s.iridescenceThicknessMaximum!==void 0&&(t.iridescenceThicknessRange[1]=s.iridescenceThicknessMaximum),s.iridescenceThicknessTexture!==void 0&&r.push(n.assignTexture(t,"iridescenceThicknessMap",s.iridescenceThicknessTexture)),Promise.all(r)}}class gl{constructor(e){this.parser=e,this.name=ve.KHR_MATERIALS_SHEEN}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:l.MeshPhysicalMaterial}extendMaterialParams(e,t){const n=this.parser,o=n.json.materials[e];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();const r=[];t.sheenColor=new l.Color(0,0,0),t.sheenRoughness=0,t.sheen=1;const s=o.extensions[this.name];if(s.sheenColorFactor!==void 0){const a=s.sheenColorFactor;t.sheenColor.setRGB(a[0],a[1],a[2],lt)}return s.sheenRoughnessFactor!==void 0&&(t.sheenRoughness=s.sheenRoughnessFactor),s.sheenColorTexture!==void 0&&r.push(n.assignTexture(t,"sheenColorMap",s.sheenColorTexture,St)),s.sheenRoughnessTexture!==void 0&&r.push(n.assignTexture(t,"sheenRoughnessMap",s.sheenRoughnessTexture)),Promise.all(r)}}class yl{constructor(e){this.parser=e,this.name=ve.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:l.MeshPhysicalMaterial}extendMaterialParams(e,t){const n=this.parser,o=n.json.materials[e];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();const r=[],s=o.extensions[this.name];return s.transmissionFactor!==void 0&&(t.transmission=s.transmissionFactor),s.transmissionTexture!==void 0&&r.push(n.assignTexture(t,"transmissionMap",s.transmissionTexture)),Promise.all(r)}}class _l{constructor(e){this.parser=e,this.name=ve.KHR_MATERIALS_VOLUME}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:l.MeshPhysicalMaterial}extendMaterialParams(e,t){const n=this.parser,o=n.json.materials[e];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();const r=[],s=o.extensions[this.name];t.thickness=s.thicknessFactor!==void 0?s.thicknessFactor:0,s.thicknessTexture!==void 0&&r.push(n.assignTexture(t,"thicknessMap",s.thicknessTexture)),t.attenuationDistance=s.attenuationDistance||1/0;const a=s.attenuationColor||[1,1,1];return t.attenuationColor=new l.Color().setRGB(a[0],a[1],a[2],lt),Promise.all(r)}}class vl{constructor(e){this.parser=e,this.name=ve.KHR_MATERIALS_IOR}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:l.MeshPhysicalMaterial}extendMaterialParams(e,t){const o=this.parser.json.materials[e];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();const r=o.extensions[this.name];return t.ior=r.ior!==void 0?r.ior:1.5,Promise.resolve()}}class xl{constructor(e){this.parser=e,this.name=ve.KHR_MATERIALS_SPECULAR}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:l.MeshPhysicalMaterial}extendMaterialParams(e,t){const n=this.parser,o=n.json.materials[e];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();const r=[],s=o.extensions[this.name];t.specularIntensity=s.specularFactor!==void 0?s.specularFactor:1,s.specularTexture!==void 0&&r.push(n.assignTexture(t,"specularIntensityMap",s.specularTexture));const a=s.specularColorFactor||[1,1,1];return t.specularColor=new l.Color().setRGB(a[0],a[1],a[2],lt),s.specularColorTexture!==void 0&&r.push(n.assignTexture(t,"specularColorMap",s.specularColorTexture,St)),Promise.all(r)}}class wl{constructor(e){this.parser=e,this.name=ve.EXT_MATERIALS_BUMP}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:l.MeshPhysicalMaterial}extendMaterialParams(e,t){const n=this.parser,o=n.json.materials[e];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();const r=[],s=o.extensions[this.name];return t.bumpScale=s.bumpFactor!==void 0?s.bumpFactor:1,s.bumpTexture!==void 0&&r.push(n.assignTexture(t,"bumpMap",s.bumpTexture)),Promise.all(r)}}class bl{constructor(e){this.parser=e,this.name=ve.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:l.MeshPhysicalMaterial}extendMaterialParams(e,t){const n=this.parser,o=n.json.materials[e];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();const r=[],s=o.extensions[this.name];return s.anisotropyStrength!==void 0&&(t.anisotropy=s.anisotropyStrength),s.anisotropyRotation!==void 0&&(t.anisotropyRotation=s.anisotropyRotation),s.anisotropyTexture!==void 0&&r.push(n.assignTexture(t,"anisotropyMap",s.anisotropyTexture)),Promise.all(r)}}class Ml{constructor(e){this.parser=e,this.name=ve.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,n=t.json,o=n.textures[e];if(!o.extensions||!o.extensions[this.name])return null;const r=o.extensions[this.name],s=t.options.ktx2Loader;if(!s){if(n.extensionsRequired&&n.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,r.source,s)}}class Sl{constructor(e){this.parser=e,this.name=ve.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const t=this.name,n=this.parser,o=n.json,r=o.textures[e];if(!r.extensions||!r.extensions[t])return null;const s=r.extensions[t],a=o.images[s.source];let c=n.textureLoader;if(a.uri){const h=n.options.manager.getHandler(a.uri);h!==null&&(c=h)}return this.detectSupport().then(function(h){if(h)return n.loadTextureImage(e,s.source,c);if(o.extensionsRequired&&o.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return n.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class Al{constructor(e){this.parser=e,this.name=ve.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(e){const t=this.name,n=this.parser,o=n.json,r=o.textures[e];if(!r.extensions||!r.extensions[t])return null;const s=r.extensions[t],a=o.images[s.source];let c=n.textureLoader;if(a.uri){const h=n.options.manager.getHandler(a.uri);h!==null&&(c=h)}return this.detectSupport().then(function(h){if(h)return n.loadTextureImage(e,s.source,c);if(o.extensionsRequired&&o.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return n.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class Pl{constructor(e){this.name=ve.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,n=t.bufferViews[e];if(n.extensions&&n.extensions[this.name]){const o=n.extensions[this.name],r=this.parser.getDependency("buffer",o.buffer),s=this.parser.options.meshoptDecoder;if(!s||!s.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return r.then(function(a){const c=o.byteOffset||0,h=o.byteLength||0,p=o.count,f=o.byteStride,m=new Uint8Array(a,c,h);return s.decodeGltfBufferAsync?s.decodeGltfBufferAsync(p,f,m,o.mode,o.filter).then(function(d){return d.buffer}):s.ready.then(function(){const d=new ArrayBuffer(p*f);return s.decodeGltfBuffer(new Uint8Array(d),p,f,m,o.mode,o.filter),d})})}else return null}}class Cl{constructor(e){this.name=ve.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const t=this.parser.json,n=t.nodes[e];if(!n.extensions||!n.extensions[this.name]||n.mesh===void 0)return null;const o=t.meshes[n.mesh];for(const h of o.primitives)if(h.mode!==Ke.TRIANGLES&&h.mode!==Ke.TRIANGLE_STRIP&&h.mode!==Ke.TRIANGLE_FAN&&h.mode!==void 0)return null;const s=n.extensions[this.name].attributes,a=[],c={};for(const h in s)a.push(this.parser.getDependency("accessor",s[h]).then(p=>(c[h]=p,c[h])));return a.length<1?null:(a.push(this.parser.createNodeMesh(e)),Promise.all(a).then(h=>{const p=h.pop(),f=p.isGroup?p.children:[p],m=h[0].count,d=[];for(const y of f){const _=new l.Matrix4,v=new l.Vector3,g=new l.Quaternion,A=new l.Vector3(1,1,1),w=new l.InstancedMesh(y.geometry,y.material,m);for(let C=0;C<m;C++)c.TRANSLATION&&v.fromBufferAttribute(c.TRANSLATION,C),c.ROTATION&&g.fromBufferAttribute(c.ROTATION,C),c.SCALE&&A.fromBufferAttribute(c.SCALE,C),w.setMatrixAt(C,_.compose(v,g,A));for(const C in c)if(C==="_COLOR_0"){const L=c[C];w.instanceColor=new l.InstancedBufferAttribute(L.array,L.itemSize,L.normalized)}else C!=="TRANSLATION"&&C!=="ROTATION"&&C!=="SCALE"&&y.geometry.setAttribute(C,c[C]);l.Object3D.prototype.copy.call(w,y),this.parser.assignFinalMaterial(w),d.push(w)}return p.isGroup?(p.clear(),p.add(...d),p):d[0]}))}}const Sr="glTF",qt=12,Ar={JSON:1313821514,BIN:5130562};class Tl{constructor(e){this.name=ve.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,qt);if(this.header={magic:Bt(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==Sr)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const n=this.header.length-qt,o=new DataView(e,qt);let r=0;for(;r<n;){const s=o.getUint32(r,!0);r+=4;const a=o.getUint32(r,!0);if(r+=4,a===Ar.JSON){const c=new Uint8Array(e,qt+r,s);this.content=Bt(c)}else if(a===Ar.BIN){const c=qt+r;this.body=e.slice(c,c+s)}r+=s}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class Il{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=ve.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const n=this.json,o=this.dracoLoader,r=e.extensions[this.name].bufferView,s=e.extensions[this.name].attributes,a={},c={},h={};for(const p in s){const f=eo[p]||p.toLowerCase();a[f]=s[p]}for(const p in e.attributes){const f=eo[p]||p.toLowerCase();if(s[p]!==void 0){const m=n.accessors[e.attributes[p]],d=Ut[m.componentType];h[f]=d.name,c[f]=m.normalized===!0}}return t.getDependency("bufferView",r).then(function(p){return new Promise(function(f,m){o.decodeDracoFile(p,function(d){for(const y in d.attributes){const _=d.attributes[y],v=c[y];v!==void 0&&(_.normalized=v)}f(d)},a,h,lt,m)})})}}class Ol{constructor(){this.name=ve.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return(t.texCoord===void 0||t.texCoord===e.channel)&&t.offset===void 0&&t.rotation===void 0&&t.scale===void 0||(e=e.clone(),t.texCoord!==void 0&&(e.channel=t.texCoord),t.offset!==void 0&&e.offset.fromArray(t.offset),t.rotation!==void 0&&(e.rotation=t.rotation),t.scale!==void 0&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}class Ll{constructor(){this.name=ve.KHR_MESH_QUANTIZATION}}class Pr extends l.Interpolant{constructor(e,t,n,o){super(e,t,n,o)}copySampleValue_(e){const t=this.resultBuffer,n=this.sampleValues,o=this.valueSize,r=e*o*3+o;for(let s=0;s!==o;s++)t[s]=n[r+s];return t}interpolate_(e,t,n,o){const r=this.resultBuffer,s=this.sampleValues,a=this.valueSize,c=a*2,h=a*3,p=o-t,f=(n-t)/p,m=f*f,d=m*f,y=e*h,_=y-h,v=-2*d+3*m,g=d-m,A=1-v,w=g-m+f;for(let C=0;C!==a;C++){const L=s[_+C+a],M=s[_+C+c]*p,P=s[y+C+a],b=s[y+C]*p;r[C]=A*L+w*M+v*P+g*b}return r}}const Dl=new l.Quaternion;class kl extends Pr{interpolate_(e,t,n,o){const r=super.interpolate_(e,t,n,o);return Dl.fromArray(r).normalize().toArray(r),r}}const Ke={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6},Ut={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},Cr={9728:l.NearestFilter,9729:l.LinearFilter,9984:l.NearestMipmapNearestFilter,9985:l.LinearMipmapNearestFilter,9986:l.NearestMipmapLinearFilter,9987:l.LinearMipmapLinearFilter},Tr={33071:l.ClampToEdgeWrapping,33648:l.MirroredRepeatWrapping,10497:l.RepeatWrapping},$n={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},eo={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",...Xt>=152?{TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3"}:{TEXCOORD_0:"uv",TEXCOORD_1:"uv2"},COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},_t={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},Bl={CUBICSPLINE:void 0,LINEAR:l.InterpolateLinear,STEP:l.InterpolateDiscrete},to={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function Ul(i){return i.DefaultMaterial===void 0&&(i.DefaultMaterial=new l.MeshStandardMaterial({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:l.FrontSide})),i.DefaultMaterial}function At(i,e,t){for(const n in t.extensions)i[n]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[n]=t.extensions[n])}function ct(i,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(i.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function Nl(i,e,t){let n=!1,o=!1,r=!1;for(let h=0,p=e.length;h<p;h++){const f=e[h];if(f.POSITION!==void 0&&(n=!0),f.NORMAL!==void 0&&(o=!0),f.COLOR_0!==void 0&&(r=!0),n&&o&&r)break}if(!n&&!o&&!r)return Promise.resolve(i);const s=[],a=[],c=[];for(let h=0,p=e.length;h<p;h++){const f=e[h];if(n){const m=f.POSITION!==void 0?t.getDependency("accessor",f.POSITION):i.attributes.position;s.push(m)}if(o){const m=f.NORMAL!==void 0?t.getDependency("accessor",f.NORMAL):i.attributes.normal;a.push(m)}if(r){const m=f.COLOR_0!==void 0?t.getDependency("accessor",f.COLOR_0):i.attributes.color;c.push(m)}}return Promise.all([Promise.all(s),Promise.all(a),Promise.all(c)]).then(function(h){const p=h[0],f=h[1],m=h[2];return n&&(i.morphAttributes.position=p),o&&(i.morphAttributes.normal=f),r&&(i.morphAttributes.color=m),i.morphTargetsRelative=!0,i})}function Fl(i,e){if(i.updateMorphTargets(),e.weights!==void 0)for(let t=0,n=e.weights.length;t<n;t++)i.morphTargetInfluences[t]=e.weights[t];if(e.extras&&Array.isArray(e.extras.targetNames)){const t=e.extras.targetNames;if(i.morphTargetInfluences.length===t.length){i.morphTargetDictionary={};for(let n=0,o=t.length;n<o;n++)i.morphTargetDictionary[t[n]]=n}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function zl(i){let e;const t=i.extensions&&i.extensions[ve.KHR_DRACO_MESH_COMPRESSION];if(t?e="draco:"+t.bufferView+":"+t.indices+":"+no(t.attributes):e=i.indices+":"+no(i.attributes)+":"+i.mode,i.targets!==void 0)for(let n=0,o=i.targets.length;n<o;n++)e+=":"+no(i.targets[n]);return e}function no(i){let e="";const t=Object.keys(i).sort();for(let n=0,o=t.length;n<o;n++)e+=t[n]+":"+i[t[n]]+";";return e}function oo(i){switch(i){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function Vl(i){return i.search(/\.jpe?g($|\?)/i)>0||i.search(/^data\:image\/jpeg/)===0?"image/jpeg":i.search(/\.webp($|\?)/i)>0||i.search(/^data\:image\/webp/)===0?"image/webp":"image/png"}const Gl=new l.Matrix4;class Rl{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new cl,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let n=!1,o=!1,r=-1;typeof navigator<"u"&&typeof navigator.userAgent<"u"&&(n=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)===!0,o=navigator.userAgent.indexOf("Firefox")>-1,r=o?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1),typeof createImageBitmap>"u"||n||o&&r<98?this.textureLoader=new l.TextureLoader(this.options.manager):this.textureLoader=new l.ImageBitmapLoader(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new l.FileLoader(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const n=this,o=this.json,r=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(s){return s._markDefs&&s._markDefs()}),Promise.all(this._invokeAll(function(s){return s.beforeRoot&&s.beforeRoot()})).then(function(){return Promise.all([n.getDependencies("scene"),n.getDependencies("animation"),n.getDependencies("camera")])}).then(function(s){const a={scene:s[0][o.scene||0],scenes:s[0],animations:s[1],cameras:s[2],asset:o.asset,parser:n,userData:{}};return At(r,a,o),ct(a,o),Promise.all(n._invokeAll(function(c){return c.afterRoot&&c.afterRoot(a)})).then(function(){for(const c of a.scenes)c.updateMatrixWorld();e(a)})}).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],n=this.json.meshes||[];for(let o=0,r=t.length;o<r;o++){const s=t[o].joints;for(let a=0,c=s.length;a<c;a++)e[s[a]].isBone=!0}for(let o=0,r=e.length;o<r;o++){const s=e[o];s.mesh!==void 0&&(this._addNodeRef(this.meshCache,s.mesh),s.skin!==void 0&&(n[s.mesh].isSkinnedMesh=!0)),s.camera!==void 0&&this._addNodeRef(this.cameraCache,s.camera)}}_addNodeRef(e,t){t!==void 0&&(e.refs[t]===void 0&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,n){if(e.refs[t]<=1)return n;const o=n.clone(),r=(s,a)=>{const c=this.associations.get(s);c!=null&&this.associations.set(a,c);for(const[h,p]of s.children.entries())r(p,a.children[h])};return r(n,o),o.name+="_instance_"+e.uses[t]++,o}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let n=0;n<t.length;n++){const o=e(t[n]);if(o)return o}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const n=[];for(let o=0;o<t.length;o++){const r=e(t[o]);r&&n.push(r)}return n}getDependency(e,t){const n=e+":"+t;let o=this.cache.get(n);if(!o){switch(e){case"scene":o=this.loadScene(t);break;case"node":o=this._invokeOne(function(r){return r.loadNode&&r.loadNode(t)});break;case"mesh":o=this._invokeOne(function(r){return r.loadMesh&&r.loadMesh(t)});break;case"accessor":o=this.loadAccessor(t);break;case"bufferView":o=this._invokeOne(function(r){return r.loadBufferView&&r.loadBufferView(t)});break;case"buffer":o=this.loadBuffer(t);break;case"material":o=this._invokeOne(function(r){return r.loadMaterial&&r.loadMaterial(t)});break;case"texture":o=this._invokeOne(function(r){return r.loadTexture&&r.loadTexture(t)});break;case"skin":o=this.loadSkin(t);break;case"animation":o=this._invokeOne(function(r){return r.loadAnimation&&r.loadAnimation(t)});break;case"camera":o=this.loadCamera(t);break;default:if(o=this._invokeOne(function(r){return r!=this&&r.getDependency&&r.getDependency(e,t)}),!o)throw new Error("Unknown type: "+e);break}this.cache.add(n,o)}return o}getDependencies(e){let t=this.cache.get(e);if(!t){const n=this,o=this.json[e+(e==="mesh"?"es":"s")]||[];t=Promise.all(o.map(function(r,s){return n.getDependency(e,s)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],n=this.fileLoader;if(t.type&&t.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(t.uri===void 0&&e===0)return Promise.resolve(this.extensions[ve.KHR_BINARY_GLTF].body);const o=this.options;return new Promise(function(r,s){n.load(l.LoaderUtils.resolveURL(t.uri,o.path),r,void 0,function(){s(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(n){const o=t.byteLength||0,r=t.byteOffset||0;return n.slice(r,r+o)})}loadAccessor(e){const t=this,n=this.json,o=this.json.accessors[e];if(o.bufferView===void 0&&o.sparse===void 0){const s=$n[o.type],a=Ut[o.componentType],c=o.normalized===!0,h=new a(o.count*s);return Promise.resolve(new l.BufferAttribute(h,s,c))}const r=[];return o.bufferView!==void 0?r.push(this.getDependency("bufferView",o.bufferView)):r.push(null),o.sparse!==void 0&&(r.push(this.getDependency("bufferView",o.sparse.indices.bufferView)),r.push(this.getDependency("bufferView",o.sparse.values.bufferView))),Promise.all(r).then(function(s){const a=s[0],c=$n[o.type],h=Ut[o.componentType],p=h.BYTES_PER_ELEMENT,f=p*c,m=o.byteOffset||0,d=o.bufferView!==void 0?n.bufferViews[o.bufferView].byteStride:void 0,y=o.normalized===!0;let _,v;if(d&&d!==f){const g=Math.floor(m/d),A="InterleavedBuffer:"+o.bufferView+":"+o.componentType+":"+g+":"+o.count;let w=t.cache.get(A);w||(_=new h(a,g*d,o.count*d/p),w=new l.InterleavedBuffer(_,d/p),t.cache.add(A,w)),v=new l.InterleavedBufferAttribute(w,c,m%d/p,y)}else a===null?_=new h(o.count*c):_=new h(a,m,o.count*c),v=new l.BufferAttribute(_,c,y);if(o.sparse!==void 0){const g=$n.SCALAR,A=Ut[o.sparse.indices.componentType],w=o.sparse.indices.byteOffset||0,C=o.sparse.values.byteOffset||0,L=new A(s[1],w,o.sparse.count*g),M=new h(s[2],C,o.sparse.count*c);a!==null&&(v=new l.BufferAttribute(v.array.slice(),v.itemSize,v.normalized));for(let P=0,b=L.length;P<b;P++){const S=L[P];if(v.setX(S,M[P*c]),c>=2&&v.setY(S,M[P*c+1]),c>=3&&v.setZ(S,M[P*c+2]),c>=4&&v.setW(S,M[P*c+3]),c>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return v})}loadTexture(e){const t=this.json,n=this.options,r=t.textures[e].source,s=t.images[r];let a=this.textureLoader;if(s.uri){const c=n.manager.getHandler(s.uri);c!==null&&(a=c)}return this.loadTextureImage(e,r,a)}loadTextureImage(e,t,n){const o=this,r=this.json,s=r.textures[e],a=r.images[t],c=(a.uri||a.bufferView)+":"+s.sampler;if(this.textureCache[c])return this.textureCache[c];const h=this.loadImageSource(t,n).then(function(p){p.flipY=!1,p.name=s.name||a.name||"",p.name===""&&typeof a.uri=="string"&&a.uri.startsWith("data:image/")===!1&&(p.name=a.uri);const m=(r.samplers||{})[s.sampler]||{};return p.magFilter=Cr[m.magFilter]||l.LinearFilter,p.minFilter=Cr[m.minFilter]||l.LinearMipmapLinearFilter,p.wrapS=Tr[m.wrapS]||l.RepeatWrapping,p.wrapT=Tr[m.wrapT]||l.RepeatWrapping,o.associations.set(p,{textures:e}),p}).catch(function(){return null});return this.textureCache[c]=h,h}loadImageSource(e,t){const n=this,o=this.json,r=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then(f=>f.clone());const s=o.images[e],a=self.URL||self.webkitURL;let c=s.uri||"",h=!1;if(s.bufferView!==void 0)c=n.getDependency("bufferView",s.bufferView).then(function(f){h=!0;const m=new Blob([f],{type:s.mimeType});return c=a.createObjectURL(m),c});else if(s.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const p=Promise.resolve(c).then(function(f){return new Promise(function(m,d){let y=m;t.isImageBitmapLoader===!0&&(y=function(_){const v=new l.Texture(_);v.needsUpdate=!0,m(v)}),t.load(l.LoaderUtils.resolveURL(f,r.path),y,void 0,d)})}).then(function(f){return h===!0&&a.revokeObjectURL(c),ct(f,s),f.userData.mimeType=s.mimeType||Vl(s.uri),f}).catch(function(f){throw console.error("THREE.GLTFLoader: Couldn't load texture",c),f});return this.sourceCache[e]=p,p}assignTexture(e,t,n,o){const r=this;return this.getDependency("texture",n.index).then(function(s){if(!s)return null;if(n.texCoord!==void 0&&n.texCoord>0&&(s=s.clone(),s.channel=n.texCoord),r.extensions[ve.KHR_TEXTURE_TRANSFORM]){const a=n.extensions!==void 0?n.extensions[ve.KHR_TEXTURE_TRANSFORM]:void 0;if(a){const c=r.associations.get(s);s=r.extensions[ve.KHR_TEXTURE_TRANSFORM].extendTexture(s,a),r.associations.set(s,c)}}return o!==void 0&&(typeof o=="number"&&(o=o===Mr?St:lt),"colorSpace"in s?s.colorSpace=o:s.encoding=o===St?Mr:al),e[t]=s,s})}assignFinalMaterial(e){const t=e.geometry;let n=e.material;const o=t.attributes.tangent===void 0,r=t.attributes.color!==void 0,s=t.attributes.normal===void 0;if(e.isPoints){const a="PointsMaterial:"+n.uuid;let c=this.cache.get(a);c||(c=new l.PointsMaterial,l.Material.prototype.copy.call(c,n),c.color.copy(n.color),c.map=n.map,c.sizeAttenuation=!1,this.cache.add(a,c)),n=c}else if(e.isLine){const a="LineBasicMaterial:"+n.uuid;let c=this.cache.get(a);c||(c=new l.LineBasicMaterial,l.Material.prototype.copy.call(c,n),c.color.copy(n.color),c.map=n.map,this.cache.add(a,c)),n=c}if(o||r||s){let a="ClonedMaterial:"+n.uuid+":";o&&(a+="derivative-tangents:"),r&&(a+="vertex-colors:"),s&&(a+="flat-shading:");let c=this.cache.get(a);c||(c=n.clone(),r&&(c.vertexColors=!0),s&&(c.flatShading=!0),o&&(c.normalScale&&(c.normalScale.y*=-1),c.clearcoatNormalScale&&(c.clearcoatNormalScale.y*=-1)),this.cache.add(a,c),this.associations.set(c,this.associations.get(n))),n=c}e.material=n}getMaterialType(){return l.MeshStandardMaterial}loadMaterial(e){const t=this,n=this.json,o=this.extensions,r=n.materials[e];let s;const a={},c=r.extensions||{},h=[];if(c[ve.KHR_MATERIALS_UNLIT]){const f=o[ve.KHR_MATERIALS_UNLIT];s=f.getMaterialType(),h.push(f.extendParams(a,r,t))}else{const f=r.pbrMetallicRoughness||{};if(a.color=new l.Color(1,1,1),a.opacity=1,Array.isArray(f.baseColorFactor)){const m=f.baseColorFactor;a.color.setRGB(m[0],m[1],m[2],lt),a.opacity=m[3]}f.baseColorTexture!==void 0&&h.push(t.assignTexture(a,"map",f.baseColorTexture,St)),a.metalness=f.metallicFactor!==void 0?f.metallicFactor:1,a.roughness=f.roughnessFactor!==void 0?f.roughnessFactor:1,f.metallicRoughnessTexture!==void 0&&(h.push(t.assignTexture(a,"metalnessMap",f.metallicRoughnessTexture)),h.push(t.assignTexture(a,"roughnessMap",f.metallicRoughnessTexture))),s=this._invokeOne(function(m){return m.getMaterialType&&m.getMaterialType(e)}),h.push(Promise.all(this._invokeAll(function(m){return m.extendMaterialParams&&m.extendMaterialParams(e,a)})))}r.doubleSided===!0&&(a.side=l.DoubleSide);const p=r.alphaMode||to.OPAQUE;if(p===to.BLEND?(a.transparent=!0,a.depthWrite=!1):(a.transparent=!1,p===to.MASK&&(a.alphaTest=r.alphaCutoff!==void 0?r.alphaCutoff:.5)),r.normalTexture!==void 0&&s!==l.MeshBasicMaterial&&(h.push(t.assignTexture(a,"normalMap",r.normalTexture)),a.normalScale=new l.Vector2(1,1),r.normalTexture.scale!==void 0)){const f=r.normalTexture.scale;a.normalScale.set(f,f)}if(r.occlusionTexture!==void 0&&s!==l.MeshBasicMaterial&&(h.push(t.assignTexture(a,"aoMap",r.occlusionTexture)),r.occlusionTexture.strength!==void 0&&(a.aoMapIntensity=r.occlusionTexture.strength)),r.emissiveFactor!==void 0&&s!==l.MeshBasicMaterial){const f=r.emissiveFactor;a.emissive=new l.Color().setRGB(f[0],f[1],f[2],lt)}return r.emissiveTexture!==void 0&&s!==l.MeshBasicMaterial&&h.push(t.assignTexture(a,"emissiveMap",r.emissiveTexture,St)),Promise.all(h).then(function(){const f=new s(a);return r.name&&(f.name=r.name),ct(f,r),t.associations.set(f,{materials:e}),r.extensions&&At(o,f,r),f})}createUniqueName(e){const t=l.PropertyBinding.sanitizeNodeName(e||"");return t in this.nodeNamesUsed?t+"_"+ ++this.nodeNamesUsed[t]:(this.nodeNamesUsed[t]=0,t)}loadGeometries(e){const t=this,n=this.extensions,o=this.primitiveCache;function r(a){return n[ve.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a,t).then(function(c){return Ir(c,a,t)})}const s=[];for(let a=0,c=e.length;a<c;a++){const h=e[a],p=zl(h),f=o[p];if(f)s.push(f.promise);else{let m;h.extensions&&h.extensions[ve.KHR_DRACO_MESH_COMPRESSION]?m=r(h):m=Ir(new l.BufferGeometry,h,t),o[p]={primitive:h,promise:m},s.push(m)}}return Promise.all(s)}loadMesh(e){const t=this,n=this.json,o=this.extensions,r=n.meshes[e],s=r.primitives,a=[];for(let c=0,h=s.length;c<h;c++){const p=s[c].material===void 0?Ul(this.cache):this.getDependency("material",s[c].material);a.push(p)}return a.push(t.loadGeometries(s)),Promise.all(a).then(function(c){const h=c.slice(0,c.length-1),p=c[c.length-1],f=[];for(let d=0,y=p.length;d<y;d++){const _=p[d],v=s[d];let g;const A=h[d];if(v.mode===Ke.TRIANGLES||v.mode===Ke.TRIANGLE_STRIP||v.mode===Ke.TRIANGLE_FAN||v.mode===void 0)g=r.isSkinnedMesh===!0?new l.SkinnedMesh(_,A):new l.Mesh(_,A),g.isSkinnedMesh===!0&&g.normalizeSkinWeights(),v.mode===Ke.TRIANGLE_STRIP?g.geometry=Qo(g.geometry,l.TriangleStripDrawMode):v.mode===Ke.TRIANGLE_FAN&&(g.geometry=Qo(g.geometry,l.TriangleFanDrawMode));else if(v.mode===Ke.LINES)g=new l.LineSegments(_,A);else if(v.mode===Ke.LINE_STRIP)g=new l.Line(_,A);else if(v.mode===Ke.LINE_LOOP)g=new l.LineLoop(_,A);else if(v.mode===Ke.POINTS)g=new l.Points(_,A);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+v.mode);Object.keys(g.geometry.morphAttributes).length>0&&Fl(g,r),g.name=t.createUniqueName(r.name||"mesh_"+e),ct(g,r),v.extensions&&At(o,g,v),t.assignFinalMaterial(g),f.push(g)}for(let d=0,y=f.length;d<y;d++)t.associations.set(f[d],{meshes:e,primitives:d});if(f.length===1)return r.extensions&&At(o,f[0],r),f[0];const m=new l.Group;r.extensions&&At(o,m,r),t.associations.set(m,{meshes:e});for(let d=0,y=f.length;d<y;d++)m.add(f[d]);return m})}loadCamera(e){let t;const n=this.json.cameras[e],o=n[n.type];if(!o){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return n.type==="perspective"?t=new l.PerspectiveCamera(l.MathUtils.radToDeg(o.yfov),o.aspectRatio||1,o.znear||1,o.zfar||2e6):n.type==="orthographic"&&(t=new l.OrthographicCamera(-o.xmag,o.xmag,o.ymag,-o.ymag,o.znear,o.zfar)),n.name&&(t.name=this.createUniqueName(n.name)),ct(t,n),Promise.resolve(t)}loadSkin(e){const t=this.json.skins[e],n=[];for(let o=0,r=t.joints.length;o<r;o++)n.push(this._loadNodeShallow(t.joints[o]));return t.inverseBindMatrices!==void 0?n.push(this.getDependency("accessor",t.inverseBindMatrices)):n.push(null),Promise.all(n).then(function(o){const r=o.pop(),s=o,a=[],c=[];for(let h=0,p=s.length;h<p;h++){const f=s[h];if(f){a.push(f);const m=new l.Matrix4;r!==null&&m.fromArray(r.array,h*16),c.push(m)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[h])}return new l.Skeleton(a,c)})}loadAnimation(e){const t=this.json,n=this,o=t.animations[e],r=o.name?o.name:"animation_"+e,s=[],a=[],c=[],h=[],p=[];for(let f=0,m=o.channels.length;f<m;f++){const d=o.channels[f],y=o.samplers[d.sampler],_=d.target,v=_.node,g=o.parameters!==void 0?o.parameters[y.input]:y.input,A=o.parameters!==void 0?o.parameters[y.output]:y.output;_.node!==void 0&&(s.push(this.getDependency("node",v)),a.push(this.getDependency("accessor",g)),c.push(this.getDependency("accessor",A)),h.push(y),p.push(_))}return Promise.all([Promise.all(s),Promise.all(a),Promise.all(c),Promise.all(h),Promise.all(p)]).then(function(f){const m=f[0],d=f[1],y=f[2],_=f[3],v=f[4],g=[];for(let A=0,w=m.length;A<w;A++){const C=m[A],L=d[A],M=y[A],P=_[A],b=v[A];if(C===void 0)continue;C.updateMatrix&&C.updateMatrix();const S=n._createAnimationTracks(C,L,M,P,b);if(S)for(let x=0;x<S.length;x++)g.push(S[x])}return new l.AnimationClip(r,void 0,g)})}createNodeMesh(e){const t=this.json,n=this,o=t.nodes[e];return o.mesh===void 0?null:n.getDependency("mesh",o.mesh).then(function(r){const s=n._getNodeRef(n.meshCache,o.mesh,r);return o.weights!==void 0&&s.traverse(function(a){if(a.isMesh)for(let c=0,h=o.weights.length;c<h;c++)a.morphTargetInfluences[c]=o.weights[c]}),s})}loadNode(e){const t=this.json,n=this,o=t.nodes[e],r=n._loadNodeShallow(e),s=[],a=o.children||[];for(let h=0,p=a.length;h<p;h++)s.push(n.getDependency("node",a[h]));const c=o.skin===void 0?Promise.resolve(null):n.getDependency("skin",o.skin);return Promise.all([r,Promise.all(s),c]).then(function(h){const p=h[0],f=h[1],m=h[2];m!==null&&p.traverse(function(d){d.isSkinnedMesh&&d.bind(m,Gl)});for(let d=0,y=f.length;d<y;d++)p.add(f[d]);return p})}_loadNodeShallow(e){const t=this.json,n=this.extensions,o=this;if(this.nodeCache[e]!==void 0)return this.nodeCache[e];const r=t.nodes[e],s=r.name?o.createUniqueName(r.name):"",a=[],c=o._invokeOne(function(h){return h.createNodeMesh&&h.createNodeMesh(e)});return c&&a.push(c),r.camera!==void 0&&a.push(o.getDependency("camera",r.camera).then(function(h){return o._getNodeRef(o.cameraCache,r.camera,h)})),o._invokeAll(function(h){return h.createNodeAttachment&&h.createNodeAttachment(e)}).forEach(function(h){a.push(h)}),this.nodeCache[e]=Promise.all(a).then(function(h){let p;if(r.isBone===!0?p=new l.Bone:h.length>1?p=new l.Group:h.length===1?p=h[0]:p=new l.Object3D,p!==h[0])for(let f=0,m=h.length;f<m;f++)p.add(h[f]);if(r.name&&(p.userData.name=r.name,p.name=s),ct(p,r),r.extensions&&At(n,p,r),r.matrix!==void 0){const f=new l.Matrix4;f.fromArray(r.matrix),p.applyMatrix4(f)}else r.translation!==void 0&&p.position.fromArray(r.translation),r.rotation!==void 0&&p.quaternion.fromArray(r.rotation),r.scale!==void 0&&p.scale.fromArray(r.scale);return o.associations.has(p)||o.associations.set(p,{}),o.associations.get(p).nodes=e,p}),this.nodeCache[e]}loadScene(e){const t=this.extensions,n=this.json.scenes[e],o=this,r=new l.Group;n.name&&(r.name=o.createUniqueName(n.name)),ct(r,n),n.extensions&&At(t,r,n);const s=n.nodes||[],a=[];for(let c=0,h=s.length;c<h;c++)a.push(o.getDependency("node",s[c]));return Promise.all(a).then(function(c){for(let p=0,f=c.length;p<f;p++)r.add(c[p]);const h=p=>{const f=new Map;for(const[m,d]of o.associations)(m instanceof l.Material||m instanceof l.Texture)&&f.set(m,d);return p.traverse(m=>{const d=o.associations.get(m);d!=null&&f.set(m,d)}),f};return o.associations=h(r),r})}_createAnimationTracks(e,t,n,o,r){const s=[],a=e.name?e.name:e.uuid,c=[];_t[r.path]===_t.weights?e.traverse(function(m){m.morphTargetInfluences&&c.push(m.name?m.name:m.uuid)}):c.push(a);let h;switch(_t[r.path]){case _t.weights:h=l.NumberKeyframeTrack;break;case _t.rotation:h=l.QuaternionKeyframeTrack;break;case _t.position:case _t.scale:h=l.VectorKeyframeTrack;break;default:switch(n.itemSize){case 1:h=l.NumberKeyframeTrack;break;case 2:case 3:default:h=l.VectorKeyframeTrack;break}break}const p=o.interpolation!==void 0?Bl[o.interpolation]:l.InterpolateLinear,f=this._getArrayFromAccessor(n);for(let m=0,d=c.length;m<d;m++){const y=new h(c[m]+"."+_t[r.path],t.array,f,p);o.interpolation==="CUBICSPLINE"&&this._createCubicSplineTrackInterpolant(y),s.push(y)}return s}_getArrayFromAccessor(e){let t=e.array;if(e.normalized){const n=oo(t.constructor),o=new Float32Array(t.length);for(let r=0,s=t.length;r<s;r++)o[r]=t[r]*n;t=o}return t}_createCubicSplineTrackInterpolant(e){e.createInterpolant=function(n){const o=this instanceof l.QuaternionKeyframeTrack?kl:Pr;return new o(this.times,this.values,this.getValueSize()/3,n)},e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function jl(i,e,t){const n=e.attributes,o=new l.Box3;if(n.POSITION!==void 0){const a=t.json.accessors[n.POSITION],c=a.min,h=a.max;if(c!==void 0&&h!==void 0){if(o.set(new l.Vector3(c[0],c[1],c[2]),new l.Vector3(h[0],h[1],h[2])),a.normalized){const p=oo(Ut[a.componentType]);o.min.multiplyScalar(p),o.max.multiplyScalar(p)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const r=e.targets;if(r!==void 0){const a=new l.Vector3,c=new l.Vector3;for(let h=0,p=r.length;h<p;h++){const f=r[h];if(f.POSITION!==void 0){const m=t.json.accessors[f.POSITION],d=m.min,y=m.max;if(d!==void 0&&y!==void 0){if(c.setX(Math.max(Math.abs(d[0]),Math.abs(y[0]))),c.setY(Math.max(Math.abs(d[1]),Math.abs(y[1]))),c.setZ(Math.max(Math.abs(d[2]),Math.abs(y[2]))),m.normalized){const _=oo(Ut[m.componentType]);c.multiplyScalar(_)}a.max(c)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}o.expandByVector(a)}i.boundingBox=o;const s=new l.Sphere;o.getCenter(s.center),s.radius=o.min.distanceTo(o.max)/2,i.boundingSphere=s}function Ir(i,e,t){const n=e.attributes,o=[];function r(s,a){return t.getDependency("accessor",s).then(function(c){i.setAttribute(a,c)})}for(const s in n){const a=eo[s]||s.toLowerCase();a in i.attributes||o.push(r(n[s],a))}if(e.indices!==void 0&&!i.index){const s=t.getDependency("accessor",e.indices).then(function(a){i.setIndex(a)});o.push(s)}return ct(i,e),jl(i,e,t),Promise.all(o).then(function(){return e.targets!==void 0?Nl(i,e.targets,t):i})}const Qt=new l.Vector3;function qe(i,e,t,n,o,r){const s=2*Math.PI*o/4,a=Math.max(r-2*o,0),c=Math.PI/4;Qt.copy(e),Qt[n]=0,Qt.normalize();const h=.5*s/(s+a),p=1-Qt.angleTo(i)/c;return Math.sign(Qt[t])===1?p*h:a/(s+a)+h+h*(1-p)}class Wl extends l.BoxGeometry{constructor(e=1,t=1,n=1,o=2,r=.1){if(o=o*2+1,r=Math.min(e/2,t/2,n/2,r),super(1,1,1,o,o,o),o===1)return;const s=this.toNonIndexed();this.index=null,this.attributes.position=s.attributes.position,this.attributes.normal=s.attributes.normal,this.attributes.uv=s.attributes.uv;const a=new l.Vector3,c=new l.Vector3,h=new l.Vector3(e,t,n).divideScalar(2).subScalar(r),p=this.attributes.position.array,f=this.attributes.normal.array,m=this.attributes.uv.array,d=p.length/6,y=new l.Vector3,_=.5/o;for(let v=0,g=0;v<p.length;v+=3,g+=2)switch(a.fromArray(p,v),c.copy(a),c.x-=Math.sign(c.x)*_,c.y-=Math.sign(c.y)*_,c.z-=Math.sign(c.z)*_,c.normalize(),p[v+0]=h.x*Math.sign(a.x)+c.x*r,p[v+1]=h.y*Math.sign(a.y)+c.y*r,p[v+2]=h.z*Math.sign(a.z)+c.z*r,f[v+0]=c.x,f[v+1]=c.y,f[v+2]=c.z,Math.floor(v/d)){case 0:y.set(1,0,0),m[g+0]=qe(y,c,"z","y",r,n),m[g+1]=1-qe(y,c,"y","z",r,t);break;case 1:y.set(-1,0,0),m[g+0]=1-qe(y,c,"z","y",r,n),m[g+1]=1-qe(y,c,"y","z",r,t);break;case 2:y.set(0,1,0),m[g+0]=1-qe(y,c,"x","z",r,e),m[g+1]=qe(y,c,"z","x",r,n);break;case 3:y.set(0,-1,0),m[g+0]=1-qe(y,c,"x","z",r,e),m[g+1]=1-qe(y,c,"z","x",r,n);break;case 4:y.set(0,0,1),m[g+0]=1-qe(y,c,"x","y",r,e),m[g+1]=1-qe(y,c,"y","x",r,t);break;case 5:y.set(0,0,-1),m[g+0]=qe(y,c,"x","y",r,e),m[g+1]=1-qe(y,c,"y","x",r,t);break}}}class Or extends l.ExtrudeGeometry{constructor(e,t={}){const{bevelEnabled:n=!1,bevelSize:o=8,bevelThickness:r=10,font:s,height:a=50,size:c=100,lineHeight:h=1,letterSpacing:p=0,...f}=t;if(s===void 0)super();else{const m=s.generateShapes(e,c,{lineHeight:h,letterSpacing:p});super(m,{...f,bevelEnabled:n,bevelSize:o,bevelThickness:r,depth:a})}this.type="TextGeometry"}}const Yl={uniforms:{tDiffuse:{value:null},h:{value:1/512}},vertexShader:`
      varying vec2 vUv;

      void main() {

        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

      }
  `,fragmentShader:`
    uniform sampler2D tDiffuse;
    uniform float h;

    varying vec2 vUv;

    void main() {

    	vec4 sum = vec4( 0.0 );

    	sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;
    	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;

    	gl_FragColor = sum;

    }
  `},Xl={uniforms:{tDiffuse:{value:null},v:{value:1/512}},vertexShader:`
    varying vec2 vUv;

    void main() {

      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

    }
  `,fragmentShader:`

  uniform sampler2D tDiffuse;
  uniform float v;

  varying vec2 vUv;

  void main() {

    vec4 sum = vec4( 0.0 );

    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;

    gl_FragColor = sum;

  }
  `};function Lr(i,e,t){const n=t.length-i-1;if(e>=t[n])return n-1;if(e<=t[i])return i;let o=i,r=n,s=Math.floor((o+r)/2);for(;e<t[s]||e>=t[s+1];)e<t[s]?r=s:o=s,s=Math.floor((o+r)/2);return s}function El(i,e,t,n){const o=[],r=[],s=[];o[0]=1;for(let a=1;a<=t;++a){r[a]=e-n[i+1-a],s[a]=n[i+a]-e;let c=0;for(let h=0;h<a;++h){const p=s[h+1],f=r[a-h],m=o[h]/(p+f);o[h]=c+p*m,c=f*m}o[a]=c}return o}function Zl(i,e,t,n){const o=Lr(i,n,e),r=El(o,n,i,e),s=new l.Vector4(0,0,0,0);for(let a=0;a<=i;++a){const c=t[o-i+a],h=r[a],p=c.w*h;s.x+=c.x*p,s.y+=c.y*p,s.z+=c.z*p,s.w+=c.w*h}return s}function Kl(i,e,t,n,o){const r=[];for(let f=0;f<=t;++f)r[f]=0;const s=[];for(let f=0;f<=n;++f)s[f]=r.slice(0);const a=[];for(let f=0;f<=t;++f)a[f]=r.slice(0);a[0][0]=1;const c=r.slice(0),h=r.slice(0);for(let f=1;f<=t;++f){c[f]=e-o[i+1-f],h[f]=o[i+f]-e;let m=0;for(let d=0;d<f;++d){const y=h[d+1],_=c[f-d];a[f][d]=y+_;const v=a[d][f-1]/a[f][d];a[d][f]=m+y*v,m=_*v}a[f][f]=m}for(let f=0;f<=t;++f)s[0][f]=a[f][t];for(let f=0;f<=t;++f){let m=0,d=1;const y=[];for(let _=0;_<=t;++_)y[_]=r.slice(0);y[0][0]=1;for(let _=1;_<=n;++_){let v=0;const g=f-_,A=t-_;f>=_&&(y[d][0]=y[m][0]/a[A+1][g],v=y[d][0]*a[g][A]);const w=g>=-1?1:-g,C=f-1<=A?_-1:t-f;for(let M=w;M<=C;++M)y[d][M]=(y[m][M]-y[m][M-1])/a[A+1][g+M],v+=y[d][M]*a[g+M][A];f<=A&&(y[d][_]=-y[m][_-1]/a[A+1][f],v+=y[d][_]*a[f][A]),s[_][f]=v;const L=m;m=d,d=L}}let p=t;for(let f=1;f<=n;++f){for(let m=0;m<=t;++m)s[f][m]*=p;p*=t-f}return s}function ql(i,e,t,n,o){const r=o<i?o:i,s=[],a=Lr(i,n,e),c=Kl(a,n,i,r,e),h=[];for(let p=0;p<t.length;++p){const f=t[p].clone(),m=f.w;f.x*=m,f.y*=m,f.z*=m,h[p]=f}for(let p=0;p<=r;++p){const f=h[a-i].clone().multiplyScalar(c[p][0]);for(let m=1;m<=i;++m)f.add(h[a-i+m].clone().multiplyScalar(c[p][m]));s[p]=f}for(let p=r+1;p<=o+1;++p)s[p]=new l.Vector4(0,0,0);return s}function Ql(i,e){let t=1;for(let o=2;o<=i;++o)t*=o;let n=1;for(let o=2;o<=e;++o)n*=o;for(let o=2;o<=i-e;++o)n*=o;return t/n}function Jl(i){const e=i.length,t=[],n=[];for(let r=0;r<e;++r){const s=i[r];t[r]=new l.Vector3(s.x,s.y,s.z),n[r]=s.w}const o=[];for(let r=0;r<e;++r){const s=t[r].clone();for(let a=1;a<=r;++a)s.sub(o[r-a].clone().multiplyScalar(Ql(r,a)*n[a]));o[r]=s.divideScalar(n[0])}return o}function Hl(i,e,t,n,o){const r=ql(i,e,t,n,o);return Jl(r)}class Dr extends l.Curve{constructor(e,t,n,o,r){super(),this.degree=e,this.knots=t,this.controlPoints=[],this.startKnot=o||0,this.endKnot=r||this.knots.length-1;for(let s=0;s<n.length;++s){const a=n[s];this.controlPoints[s]=new l.Vector4(a.x,a.y,a.z,a.w)}}getPoint(e,t){const n=t||new l.Vector3,o=this.knots[this.startKnot]+e*(this.knots[this.endKnot]-this.knots[this.startKnot]),r=Zl(this.degree,this.knots,this.controlPoints,o);return r.w!=1&&r.divideScalar(r.w),n.set(r.x,r.y,r.z)}getTangent(e,t){const n=t||new l.Vector3,o=this.knots[0]+e*(this.knots[this.knots.length-1]-this.knots[0]),r=Hl(this.degree,this.knots,this.controlPoints,o,1);return n.copy(r[1]).normalize(),n}}let xe,De,Re;class $l extends l.Loader{constructor(e){super(e)}load(e,t,n,o){const r=this,s=r.path===""?l.LoaderUtils.extractUrlBase(e):r.path,a=new l.FileLoader(this.manager);a.setPath(r.path),a.setResponseType("arraybuffer"),a.setRequestHeader(r.requestHeader),a.setWithCredentials(r.withCredentials),a.load(e,function(c){try{t(r.parse(c,s))}catch(h){o?o(h):console.error(h),r.manager.itemError(e)}},n,o)}parse(e,t){if(sc(e))xe=new rc().parse(e);else{const o=zr(e);if(!ic(o))throw new Error("THREE.FBXLoader: Unknown format.");if(Ur(o)<7e3)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+Ur(o));xe=new oc().parse(o)}const n=new l.TextureLoader(this.manager).setPath(this.resourcePath||t).setCrossOrigin(this.crossOrigin);return new ec(n,this.manager).parse(xe)}}class ec{constructor(e,t){this.textureLoader=e,this.manager=t}parse(){De=this.parseConnections();const e=this.parseImages(),t=this.parseTextures(e),n=this.parseMaterials(t),o=this.parseDeformers(),r=new tc().parse(o);return this.parseScene(o,r,n),Re}parseConnections(){const e=new Map;return"Connections"in xe&&xe.Connections.connections.forEach(function(n){const o=n[0],r=n[1],s=n[2];e.has(o)||e.set(o,{parents:[],children:[]});const a={ID:r,relationship:s};e.get(o).parents.push(a),e.has(r)||e.set(r,{parents:[],children:[]});const c={ID:o,relationship:s};e.get(r).children.push(c)}),e}parseImages(){const e={},t={};if("Video"in xe.Objects){const n=xe.Objects.Video;for(const o in n){const r=n[o],s=parseInt(o);if(e[s]=r.RelativeFilename||r.Filename,"Content"in r){const a=r.Content instanceof ArrayBuffer&&r.Content.byteLength>0,c=typeof r.Content=="string"&&r.Content!=="";if(a||c){const h=this.parseImage(n[o]);t[r.RelativeFilename||r.Filename]=h}}}}for(const n in e){const o=e[n];t[o]!==void 0?e[n]=t[o]:e[n]=e[n].split("\\").pop()}return e}parseImage(e){const t=e.Content,n=e.RelativeFilename||e.Filename,o=n.slice(n.lastIndexOf(".")+1).toLowerCase();let r;switch(o){case"bmp":r="image/bmp";break;case"jpg":case"jpeg":r="image/jpeg";break;case"png":r="image/png";break;case"tif":r="image/tiff";break;case"tga":this.manager.getHandler(".tga")===null&&console.warn("FBXLoader: TGA loader not found, skipping ",n),r="image/tga";break;default:console.warn('FBXLoader: Image type "'+o+'" is not supported.');return}if(typeof t=="string")return"data:"+r+";base64,"+t;{const s=new Uint8Array(t);return window.URL.createObjectURL(new Blob([s],{type:r}))}}parseTextures(e){const t=new Map;if("Texture"in xe.Objects){const n=xe.Objects.Texture;for(const o in n){const r=this.parseTexture(n[o],e);t.set(parseInt(o),r)}}return t}parseTexture(e,t){const n=this.loadTexture(e,t);n.ID=e.id,n.name=e.attrName;const o=e.WrapModeU,r=e.WrapModeV,s=o!==void 0?o.value:0,a=r!==void 0?r.value:0;if(n.wrapS=s===0?l.RepeatWrapping:l.ClampToEdgeWrapping,n.wrapT=a===0?l.RepeatWrapping:l.ClampToEdgeWrapping,"Scaling"in e){const c=e.Scaling.value;n.repeat.x=c[0],n.repeat.y=c[1]}return n}loadTexture(e,t){let n;const o=this.textureLoader.path,r=De.get(e.id).children;r!==void 0&&r.length>0&&t[r[0].ID]!==void 0&&(n=t[r[0].ID],(n.indexOf("blob:")===0||n.indexOf("data:")===0)&&this.textureLoader.setPath(void 0));let s;const a=e.FileName.slice(-3).toLowerCase();if(a==="tga"){const c=this.manager.getHandler(".tga");c===null?(console.warn("FBXLoader: TGA loader not found, creating placeholder texture for",e.RelativeFilename),s=new l.Texture):(c.setPath(this.textureLoader.path),s=c.load(n))}else a==="psd"?(console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for",e.RelativeFilename),s=new l.Texture):s=this.textureLoader.load(n);return this.textureLoader.setPath(o),s}parseMaterials(e){const t=new Map;if("Material"in xe.Objects){const n=xe.Objects.Material;for(const o in n){const r=this.parseMaterial(n[o],e);r!==null&&t.set(parseInt(o),r)}}return t}parseMaterial(e,t){const n=e.id,o=e.attrName;let r=e.ShadingModel;if(typeof r=="object"&&(r=r.value),!De.has(n))return null;const s=this.parseParameters(e,t,n);let a;switch(r.toLowerCase()){case"phong":a=new l.MeshPhongMaterial;break;case"lambert":a=new l.MeshLambertMaterial;break;default:console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.',r),a=new l.MeshPhongMaterial;break}return a.setValues(s),a.name=o,a}parseParameters(e,t,n){const o={};e.BumpFactor&&(o.bumpScale=e.BumpFactor.value),e.Diffuse?o.color=new l.Color().fromArray(e.Diffuse.value):e.DiffuseColor&&(e.DiffuseColor.type==="Color"||e.DiffuseColor.type==="ColorRGB")&&(o.color=new l.Color().fromArray(e.DiffuseColor.value)),e.DisplacementFactor&&(o.displacementScale=e.DisplacementFactor.value),e.Emissive?o.emissive=new l.Color().fromArray(e.Emissive.value):e.EmissiveColor&&(e.EmissiveColor.type==="Color"||e.EmissiveColor.type==="ColorRGB")&&(o.emissive=new l.Color().fromArray(e.EmissiveColor.value)),e.EmissiveFactor&&(o.emissiveIntensity=parseFloat(e.EmissiveFactor.value)),e.Opacity&&(o.opacity=parseFloat(e.Opacity.value)),o.opacity<1&&(o.transparent=!0),e.ReflectionFactor&&(o.reflectivity=e.ReflectionFactor.value),e.Shininess&&(o.shininess=e.Shininess.value),e.Specular?o.specular=new l.Color().fromArray(e.Specular.value):e.SpecularColor&&e.SpecularColor.type==="Color"&&(o.specular=new l.Color().fromArray(e.SpecularColor.value));const r=this;return De.get(n).children.forEach(function(s){const a=s.relationship;switch(a){case"Bump":o.bumpMap=r.getTexture(t,s.ID);break;case"Maya|TEX_ao_map":o.aoMap=r.getTexture(t,s.ID);break;case"DiffuseColor":case"Maya|TEX_color_map":o.map=r.getTexture(t,s.ID),o.map!==void 0&&("colorSpace"in o.map?o.map.colorSpace="srgb":o.map.encoding=3001);break;case"DisplacementColor":o.displacementMap=r.getTexture(t,s.ID);break;case"EmissiveColor":o.emissiveMap=r.getTexture(t,s.ID),o.emissiveMap!==void 0&&("colorSpace"in o.emissiveMap?o.emissiveMap.colorSpace="srgb":o.emissiveMap.encoding=3001);break;case"NormalMap":case"Maya|TEX_normal_map":o.normalMap=r.getTexture(t,s.ID);break;case"ReflectionColor":o.envMap=r.getTexture(t,s.ID),o.envMap!==void 0&&(o.envMap.mapping=l.EquirectangularReflectionMapping,"colorSpace"in o.envMap?o.envMap.colorSpace="srgb":o.envMap.encoding=3001);break;case"SpecularColor":o.specularMap=r.getTexture(t,s.ID),o.specularMap!==void 0&&("colorSpace"in o.specularMap?o.specularMap.colorSpace="srgb":o.specularMap.encoding=3001);break;case"TransparentColor":case"TransparencyFactor":o.alphaMap=r.getTexture(t,s.ID),o.transparent=!0;break;case"AmbientColor":case"ShininessExponent":case"SpecularFactor":case"VectorDisplacementColor":default:console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.",a);break}}),o}getTexture(e,t){return"LayeredTexture"in xe.Objects&&t in xe.Objects.LayeredTexture&&(console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."),t=De.get(t).children[0].ID),e.get(t)}parseDeformers(){const e={},t={};if("Deformer"in xe.Objects){const n=xe.Objects.Deformer;for(const o in n){const r=n[o],s=De.get(parseInt(o));if(r.attrType==="Skin"){const a=this.parseSkeleton(s,n);a.ID=o,s.parents.length>1&&console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."),a.geometryID=s.parents[0].ID,e[o]=a}else if(r.attrType==="BlendShape"){const a={id:o};a.rawTargets=this.parseMorphTargets(s,n),a.id=o,s.parents.length>1&&console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."),t[o]=a}}}return{skeletons:e,morphTargets:t}}parseSkeleton(e,t){const n=[];return e.children.forEach(function(o){const r=t[o.ID];if(r.attrType!=="Cluster")return;const s={ID:o.ID,indices:[],weights:[],transformLink:new l.Matrix4().fromArray(r.TransformLink.a)};"Indexes"in r&&(s.indices=r.Indexes.a,s.weights=r.Weights.a),n.push(s)}),{rawBones:n,bones:[]}}parseMorphTargets(e,t){const n=[];for(let o=0;o<e.children.length;o++){const r=e.children[o],s=t[r.ID],a={name:s.attrName,initialWeight:s.DeformPercent,id:s.id,fullWeights:s.FullWeights.a};if(s.attrType!=="BlendShapeChannel")return;a.geoID=De.get(parseInt(r.ID)).children.filter(function(c){return c.relationship===void 0})[0].ID,n.push(a)}return n}parseScene(e,t,n){Re=new l.Group;const o=this.parseModels(e.skeletons,t,n),r=xe.Objects.Model,s=this;o.forEach(function(c){const h=r[c.ID];s.setLookAtProperties(c,h),De.get(c.ID).parents.forEach(function(f){const m=o.get(f.ID);m!==void 0&&m.add(c)}),c.parent===null&&Re.add(c)}),this.bindSkeleton(e.skeletons,t,o),this.createAmbientLight(),Re.traverse(function(c){if(c.userData.transformData){c.parent&&(c.userData.transformData.parentMatrix=c.parent.matrix,c.userData.transformData.parentMatrixWorld=c.parent.matrixWorld);const h=Nr(c.userData.transformData);c.applyMatrix4(h),c.updateWorldMatrix()}});const a=new nc().parse();Re.children.length===1&&Re.children[0].isGroup&&(Re.children[0].animations=a,Re=Re.children[0]),Re.animations=a}parseModels(e,t,n){const o=new Map,r=xe.Objects.Model;for(const s in r){const a=parseInt(s),c=r[s],h=De.get(a);let p=this.buildSkeleton(h,e,a,c.attrName);if(!p){switch(c.attrType){case"Camera":p=this.createCamera(h);break;case"Light":p=this.createLight(h);break;case"Mesh":p=this.createMesh(h,t,n);break;case"NurbsCurve":p=this.createCurve(h,t);break;case"LimbNode":case"Root":p=new l.Bone;break;case"Null":default:p=new l.Group;break}p.name=c.attrName?l.PropertyBinding.sanitizeNodeName(c.attrName):"",p.ID=a}this.getTransformData(p,c),o.set(a,p)}return o}buildSkeleton(e,t,n,o){let r=null;return e.parents.forEach(function(s){for(const a in t){const c=t[a];c.rawBones.forEach(function(h,p){if(h.ID===s.ID){const f=r;r=new l.Bone,r.matrixWorld.copy(h.transformLink),r.name=o?l.PropertyBinding.sanitizeNodeName(o):"",r.ID=n,c.bones[p]=r,f!==null&&r.add(f)}})}}),r}createCamera(e){let t,n;if(e.children.forEach(function(o){const r=xe.Objects.NodeAttribute[o.ID];r!==void 0&&(n=r)}),n===void 0)t=new l.Object3D;else{let o=0;n.CameraProjectionType!==void 0&&n.CameraProjectionType.value===1&&(o=1);let r=1;n.NearPlane!==void 0&&(r=n.NearPlane.value/1e3);let s=1e3;n.FarPlane!==void 0&&(s=n.FarPlane.value/1e3);let a=window.innerWidth,c=window.innerHeight;n.AspectWidth!==void 0&&n.AspectHeight!==void 0&&(a=n.AspectWidth.value,c=n.AspectHeight.value);const h=a/c;let p=45;n.FieldOfView!==void 0&&(p=n.FieldOfView.value);const f=n.FocalLength?n.FocalLength.value:null;switch(o){case 0:t=new l.PerspectiveCamera(p,h,r,s),f!==null&&t.setFocalLength(f);break;case 1:t=new l.OrthographicCamera(-a/2,a/2,c/2,-c/2,r,s);break;default:console.warn("THREE.FBXLoader: Unknown camera type "+o+"."),t=new l.Object3D;break}}return t}createLight(e){let t,n;if(e.children.forEach(function(o){const r=xe.Objects.NodeAttribute[o.ID];r!==void 0&&(n=r)}),n===void 0)t=new l.Object3D;else{let o;n.LightType===void 0?o=0:o=n.LightType.value;let r=16777215;n.Color!==void 0&&(r=new l.Color().fromArray(n.Color.value));let s=n.Intensity===void 0?1:n.Intensity.value/100;n.CastLightOnObject!==void 0&&n.CastLightOnObject.value===0&&(s=0);let a=0;n.FarAttenuationEnd!==void 0&&(n.EnableFarAttenuation!==void 0&&n.EnableFarAttenuation.value===0?a=0:a=n.FarAttenuationEnd.value);const c=1;switch(o){case 0:t=new l.PointLight(r,s,a,c);break;case 1:t=new l.DirectionalLight(r,s);break;case 2:let h=Math.PI/3;n.InnerAngle!==void 0&&(h=l.MathUtils.degToRad(n.InnerAngle.value));let p=0;n.OuterAngle!==void 0&&(p=l.MathUtils.degToRad(n.OuterAngle.value),p=Math.max(p,1)),t=new l.SpotLight(r,s,a,h,p,c);break;default:console.warn("THREE.FBXLoader: Unknown light type "+n.LightType.value+", defaulting to a PointLight."),t=new l.PointLight(r,s);break}n.CastShadows!==void 0&&n.CastShadows.value===1&&(t.castShadow=!0)}return t}createMesh(e,t,n){let o,r=null,s=null;const a=[];return e.children.forEach(function(c){t.has(c.ID)&&(r=t.get(c.ID)),n.has(c.ID)&&a.push(n.get(c.ID))}),a.length>1?s=a:a.length>0?s=a[0]:(s=new l.MeshPhongMaterial({color:13421772}),a.push(s)),"color"in r.attributes&&a.forEach(function(c){c.vertexColors=!0}),r.FBX_Deformer?(o=new l.SkinnedMesh(r,s),o.normalizeSkinWeights()):o=new l.Mesh(r,s),o}createCurve(e,t){const n=e.children.reduce(function(r,s){return t.has(s.ID)&&(r=t.get(s.ID)),r},null),o=new l.LineBasicMaterial({color:3342591,linewidth:1});return new l.Line(n,o)}getTransformData(e,t){const n={};"InheritType"in t&&(n.inheritType=parseInt(t.InheritType.value)),"RotationOrder"in t?n.eulerOrder=Fr(t.RotationOrder.value):n.eulerOrder="ZYX","Lcl_Translation"in t&&(n.translation=t.Lcl_Translation.value),"PreRotation"in t&&(n.preRotation=t.PreRotation.value),"Lcl_Rotation"in t&&(n.rotation=t.Lcl_Rotation.value),"PostRotation"in t&&(n.postRotation=t.PostRotation.value),"Lcl_Scaling"in t&&(n.scale=t.Lcl_Scaling.value),"ScalingOffset"in t&&(n.scalingOffset=t.ScalingOffset.value),"ScalingPivot"in t&&(n.scalingPivot=t.ScalingPivot.value),"RotationOffset"in t&&(n.rotationOffset=t.RotationOffset.value),"RotationPivot"in t&&(n.rotationPivot=t.RotationPivot.value),e.userData.transformData=n}setLookAtProperties(e,t){"LookAtProperty"in t&&De.get(e.ID).children.forEach(function(o){if(o.relationship==="LookAtProperty"){const r=xe.Objects.Model[o.ID];if("Lcl_Translation"in r){const s=r.Lcl_Translation.value;e.target!==void 0?(e.target.position.fromArray(s),Re.add(e.target)):e.lookAt(new l.Vector3().fromArray(s))}}})}bindSkeleton(e,t,n){const o=this.parsePoseNodes();for(const r in e){const s=e[r];De.get(parseInt(s.ID)).parents.forEach(function(c){if(t.has(c.ID)){const h=c.ID;De.get(h).parents.forEach(function(f){n.has(f.ID)&&n.get(f.ID).bind(new l.Skeleton(s.bones),o[f.ID])})}})}}parsePoseNodes(){const e={};if("Pose"in xe.Objects){const t=xe.Objects.Pose;for(const n in t)if(t[n].attrType==="BindPose"&&t[n].NbPoseNodes>0){const o=t[n].PoseNode;Array.isArray(o)?o.forEach(function(r){e[r.Node]=new l.Matrix4().fromArray(r.Matrix.a)}):e[o.Node]=new l.Matrix4().fromArray(o.Matrix.a)}}return e}createAmbientLight(){if("GlobalSettings"in xe&&"AmbientColor"in xe.GlobalSettings){const e=xe.GlobalSettings.AmbientColor.value,t=e[0],n=e[1],o=e[2];if(t!==0||n!==0||o!==0){const r=new l.Color(t,n,o);Re.add(new l.AmbientLight(r,1))}}}}class tc{parse(e){const t=new Map;if("Geometry"in xe.Objects){const n=xe.Objects.Geometry;for(const o in n){const r=De.get(parseInt(o)),s=this.parseGeometry(r,n[o],e);t.set(parseInt(o),s)}}return t}parseGeometry(e,t,n){switch(t.attrType){case"Mesh":return this.parseMeshGeometry(e,t,n);case"NurbsCurve":return this.parseNurbsGeometry(t)}}parseMeshGeometry(e,t,n){const o=n.skeletons,r=[],s=e.parents.map(function(f){return xe.Objects.Model[f.ID]});if(s.length===0)return;const a=e.children.reduce(function(f,m){return o[m.ID]!==void 0&&(f=o[m.ID]),f},null);e.children.forEach(function(f){n.morphTargets[f.ID]!==void 0&&r.push(n.morphTargets[f.ID])});const c=s[0],h={};"RotationOrder"in c&&(h.eulerOrder=Fr(c.RotationOrder.value)),"InheritType"in c&&(h.inheritType=parseInt(c.InheritType.value)),"GeometricTranslation"in c&&(h.translation=c.GeometricTranslation.value),"GeometricRotation"in c&&(h.rotation=c.GeometricRotation.value),"GeometricScaling"in c&&(h.scale=c.GeometricScaling.value);const p=Nr(h);return this.genGeometry(t,a,r,p)}genGeometry(e,t,n,o){const r=new l.BufferGeometry;e.attrName&&(r.name=e.attrName);const s=this.parseGeoNode(e,t),a=this.genBuffers(s),c=new l.Float32BufferAttribute(a.vertex,3);if(c.applyMatrix4(o),r.setAttribute("position",c),a.colors.length>0&&r.setAttribute("color",new l.Float32BufferAttribute(a.colors,3)),t&&(r.setAttribute("skinIndex",new l.Uint16BufferAttribute(a.weightsIndices,4)),r.setAttribute("skinWeight",new l.Float32BufferAttribute(a.vertexWeights,4)),r.FBX_Deformer=t),a.normal.length>0){const h=new l.Matrix3().getNormalMatrix(o),p=new l.Float32BufferAttribute(a.normal,3);p.applyNormalMatrix(h),r.setAttribute("normal",p)}if(a.uvs.forEach(function(h,p){Gn==="uv2"&&p++;const f=p===0?"uv":`uv${p}`;r.setAttribute(f,new l.Float32BufferAttribute(a.uvs[p],2))}),s.material&&s.material.mappingType!=="AllSame"){let h=a.materialIndex[0],p=0;if(a.materialIndex.forEach(function(f,m){f!==h&&(r.addGroup(p,m-p,h),h=f,p=m)}),r.groups.length>0){const f=r.groups[r.groups.length-1],m=f.start+f.count;m!==a.materialIndex.length&&r.addGroup(m,a.materialIndex.length-m,h)}r.groups.length===0&&r.addGroup(0,a.materialIndex.length,a.materialIndex[0])}return this.addMorphTargets(r,e,n,o),r}parseGeoNode(e,t){const n={};if(n.vertexPositions=e.Vertices!==void 0?e.Vertices.a:[],n.vertexIndices=e.PolygonVertexIndex!==void 0?e.PolygonVertexIndex.a:[],e.LayerElementColor&&(n.color=this.parseVertexColors(e.LayerElementColor[0])),e.LayerElementMaterial&&(n.material=this.parseMaterialIndices(e.LayerElementMaterial[0])),e.LayerElementNormal&&(n.normal=this.parseNormals(e.LayerElementNormal[0])),e.LayerElementUV){n.uv=[];let o=0;for(;e.LayerElementUV[o];)e.LayerElementUV[o].UV&&n.uv.push(this.parseUVs(e.LayerElementUV[o])),o++}return n.weightTable={},t!==null&&(n.skeleton=t,t.rawBones.forEach(function(o,r){o.indices.forEach(function(s,a){n.weightTable[s]===void 0&&(n.weightTable[s]=[]),n.weightTable[s].push({id:r,weight:o.weights[a]})})})),n}genBuffers(e){const t={vertex:[],normal:[],colors:[],uvs:[],materialIndex:[],vertexWeights:[],weightsIndices:[]};let n=0,o=0,r=!1,s=[],a=[],c=[],h=[],p=[],f=[];const m=this;return e.vertexIndices.forEach(function(d,y){let _,v=!1;d<0&&(d=d^-1,v=!0);let g=[],A=[];if(s.push(d*3,d*3+1,d*3+2),e.color){const w=_n(y,n,d,e.color);c.push(w[0],w[1],w[2])}if(e.skeleton){if(e.weightTable[d]!==void 0&&e.weightTable[d].forEach(function(w){A.push(w.weight),g.push(w.id)}),A.length>4){r||(console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."),r=!0);const w=[0,0,0,0],C=[0,0,0,0];A.forEach(function(L,M){let P=L,b=g[M];C.forEach(function(S,x,I){if(P>S){I[x]=P,P=S;const D=w[x];w[x]=b,b=D}})}),g=w,A=C}for(;A.length<4;)A.push(0),g.push(0);for(let w=0;w<4;++w)p.push(A[w]),f.push(g[w])}if(e.normal){const w=_n(y,n,d,e.normal);a.push(w[0],w[1],w[2])}e.material&&e.material.mappingType!=="AllSame"&&(_=_n(y,n,d,e.material)[0]),e.uv&&e.uv.forEach(function(w,C){const L=_n(y,n,d,w);h[C]===void 0&&(h[C]=[]),h[C].push(L[0]),h[C].push(L[1])}),o++,v&&(m.genFace(t,e,s,_,a,c,h,p,f,o),n++,o=0,s=[],a=[],c=[],h=[],p=[],f=[])}),t}genFace(e,t,n,o,r,s,a,c,h,p){for(let f=2;f<p;f++)e.vertex.push(t.vertexPositions[n[0]]),e.vertex.push(t.vertexPositions[n[1]]),e.vertex.push(t.vertexPositions[n[2]]),e.vertex.push(t.vertexPositions[n[(f-1)*3]]),e.vertex.push(t.vertexPositions[n[(f-1)*3+1]]),e.vertex.push(t.vertexPositions[n[(f-1)*3+2]]),e.vertex.push(t.vertexPositions[n[f*3]]),e.vertex.push(t.vertexPositions[n[f*3+1]]),e.vertex.push(t.vertexPositions[n[f*3+2]]),t.skeleton&&(e.vertexWeights.push(c[0]),e.vertexWeights.push(c[1]),e.vertexWeights.push(c[2]),e.vertexWeights.push(c[3]),e.vertexWeights.push(c[(f-1)*4]),e.vertexWeights.push(c[(f-1)*4+1]),e.vertexWeights.push(c[(f-1)*4+2]),e.vertexWeights.push(c[(f-1)*4+3]),e.vertexWeights.push(c[f*4]),e.vertexWeights.push(c[f*4+1]),e.vertexWeights.push(c[f*4+2]),e.vertexWeights.push(c[f*4+3]),e.weightsIndices.push(h[0]),e.weightsIndices.push(h[1]),e.weightsIndices.push(h[2]),e.weightsIndices.push(h[3]),e.weightsIndices.push(h[(f-1)*4]),e.weightsIndices.push(h[(f-1)*4+1]),e.weightsIndices.push(h[(f-1)*4+2]),e.weightsIndices.push(h[(f-1)*4+3]),e.weightsIndices.push(h[f*4]),e.weightsIndices.push(h[f*4+1]),e.weightsIndices.push(h[f*4+2]),e.weightsIndices.push(h[f*4+3])),t.color&&(e.colors.push(s[0]),e.colors.push(s[1]),e.colors.push(s[2]),e.colors.push(s[(f-1)*3]),e.colors.push(s[(f-1)*3+1]),e.colors.push(s[(f-1)*3+2]),e.colors.push(s[f*3]),e.colors.push(s[f*3+1]),e.colors.push(s[f*3+2])),t.material&&t.material.mappingType!=="AllSame"&&(e.materialIndex.push(o),e.materialIndex.push(o),e.materialIndex.push(o)),t.normal&&(e.normal.push(r[0]),e.normal.push(r[1]),e.normal.push(r[2]),e.normal.push(r[(f-1)*3]),e.normal.push(r[(f-1)*3+1]),e.normal.push(r[(f-1)*3+2]),e.normal.push(r[f*3]),e.normal.push(r[f*3+1]),e.normal.push(r[f*3+2])),t.uv&&t.uv.forEach(function(m,d){e.uvs[d]===void 0&&(e.uvs[d]=[]),e.uvs[d].push(a[d][0]),e.uvs[d].push(a[d][1]),e.uvs[d].push(a[d][(f-1)*2]),e.uvs[d].push(a[d][(f-1)*2+1]),e.uvs[d].push(a[d][f*2]),e.uvs[d].push(a[d][f*2+1])})}addMorphTargets(e,t,n,o){if(n.length===0)return;e.morphTargetsRelative=!0,e.morphAttributes.position=[];const r=this;n.forEach(function(s){s.rawTargets.forEach(function(a){const c=xe.Objects.Geometry[a.geoID];c!==void 0&&r.genMorphGeometry(e,t,c,o,a.name)})})}genMorphGeometry(e,t,n,o,r){const s=t.PolygonVertexIndex!==void 0?t.PolygonVertexIndex.a:[],a=n.Vertices!==void 0?n.Vertices.a:[],c=n.Indexes!==void 0?n.Indexes.a:[],h=e.attributes.position.count*3,p=new Float32Array(h);for(let y=0;y<c.length;y++){const _=c[y]*3;p[_]=a[y*3],p[_+1]=a[y*3+1],p[_+2]=a[y*3+2]}const f={vertexIndices:s,vertexPositions:p},m=this.genBuffers(f),d=new l.Float32BufferAttribute(m.vertex,3);d.name=r||n.attrName,d.applyMatrix4(o),e.morphAttributes.position.push(d)}parseNormals(e){const t=e.MappingInformationType,n=e.ReferenceInformationType,o=e.Normals.a;let r=[];return n==="IndexToDirect"&&("NormalIndex"in e?r=e.NormalIndex.a:"NormalsIndex"in e&&(r=e.NormalsIndex.a)),{dataSize:3,buffer:o,indices:r,mappingType:t,referenceType:n}}parseUVs(e){const t=e.MappingInformationType,n=e.ReferenceInformationType,o=e.UV.a;let r=[];return n==="IndexToDirect"&&(r=e.UVIndex.a),{dataSize:2,buffer:o,indices:r,mappingType:t,referenceType:n}}parseVertexColors(e){const t=e.MappingInformationType,n=e.ReferenceInformationType,o=e.Colors.a;let r=[];return n==="IndexToDirect"&&(r=e.ColorIndex.a),{dataSize:4,buffer:o,indices:r,mappingType:t,referenceType:n}}parseMaterialIndices(e){const t=e.MappingInformationType,n=e.ReferenceInformationType;if(t==="NoMappingInformation")return{dataSize:1,buffer:[0],indices:[0],mappingType:"AllSame",referenceType:n};const o=e.Materials.a,r=[];for(let s=0;s<o.length;++s)r.push(s);return{dataSize:1,buffer:o,indices:r,mappingType:t,referenceType:n}}parseNurbsGeometry(e){if(Dr===void 0)return console.error("THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."),new l.BufferGeometry;const t=parseInt(e.Order);if(isNaN(t))return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s",e.Order,e.id),new l.BufferGeometry;const n=t-1,o=e.KnotVector.a,r=[],s=e.Points.a;for(let f=0,m=s.length;f<m;f+=4)r.push(new l.Vector4().fromArray(s,f));let a,c;if(e.Form==="Closed")r.push(r[0]);else if(e.Form==="Periodic"){a=n,c=o.length-1-a;for(let f=0;f<n;++f)r.push(r[f])}const p=new Dr(n,o,r,a,c).getPoints(r.length*12);return new l.BufferGeometry().setFromPoints(p)}}class nc{parse(){const e=[],t=this.parseClips();if(t!==void 0)for(const n in t){const o=t[n],r=this.addClip(o);e.push(r)}return e}parseClips(){if(xe.Objects.AnimationCurve===void 0)return;const e=this.parseAnimationCurveNodes();this.parseAnimationCurves(e);const t=this.parseAnimationLayers(e);return this.parseAnimStacks(t)}parseAnimationCurveNodes(){const e=xe.Objects.AnimationCurveNode,t=new Map;for(const n in e){const o=e[n];if(o.attrName.match(/S|R|T|DeformPercent/)!==null){const r={id:o.id,attr:o.attrName,curves:{}};t.set(r.id,r)}}return t}parseAnimationCurves(e){const t=xe.Objects.AnimationCurve;for(const n in t){const o={id:t[n].id,times:t[n].KeyTime.a.map(ac),values:t[n].KeyValueFloat.a},r=De.get(o.id);if(r!==void 0){const s=r.parents[0].ID,a=r.parents[0].relationship;a.match(/X/)?e.get(s).curves.x=o:a.match(/Y/)?e.get(s).curves.y=o:a.match(/Z/)?e.get(s).curves.z=o:a.match(/d|DeformPercent/)&&e.has(s)&&(e.get(s).curves.morph=o)}}}parseAnimationLayers(e){const t=xe.Objects.AnimationLayer,n=new Map;for(const o in t){const r=[],s=De.get(parseInt(o));s!==void 0&&(s.children.forEach(function(c,h){if(e.has(c.ID)){const p=e.get(c.ID);if(p.curves.x!==void 0||p.curves.y!==void 0||p.curves.z!==void 0){if(r[h]===void 0){const f=De.get(c.ID).parents.filter(function(m){return m.relationship!==void 0})[0].ID;if(f!==void 0){const m=xe.Objects.Model[f.toString()];if(m===void 0){console.warn("THREE.FBXLoader: Encountered a unused curve.",c);return}const d={modelName:m.attrName?l.PropertyBinding.sanitizeNodeName(m.attrName):"",ID:m.id,initialPosition:[0,0,0],initialRotation:[0,0,0],initialScale:[1,1,1]};Re.traverse(function(y){y.ID===m.id&&(d.transform=y.matrix,y.userData.transformData&&(d.eulerOrder=y.userData.transformData.eulerOrder))}),d.transform||(d.transform=new l.Matrix4),"PreRotation"in m&&(d.preRotation=m.PreRotation.value),"PostRotation"in m&&(d.postRotation=m.PostRotation.value),r[h]=d}}r[h]&&(r[h][p.attr]=p)}else if(p.curves.morph!==void 0){if(r[h]===void 0){const f=De.get(c.ID).parents.filter(function(g){return g.relationship!==void 0})[0].ID,m=De.get(f).parents[0].ID,d=De.get(m).parents[0].ID,y=De.get(d).parents[0].ID,_=xe.Objects.Model[y],v={modelName:_.attrName?l.PropertyBinding.sanitizeNodeName(_.attrName):"",morphName:xe.Objects.Deformer[f].attrName};r[h]=v}r[h][p.attr]=p}}}),n.set(parseInt(o),r))}return n}parseAnimStacks(e){const t=xe.Objects.AnimationStack,n={};for(const o in t){const r=De.get(parseInt(o)).children;r.length>1&&console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");const s=e.get(r[0].ID);n[o]={name:t[o].attrName,layer:s}}return n}addClip(e){let t=[];const n=this;return e.layer.forEach(function(o){t=t.concat(n.generateTracks(o))}),new l.AnimationClip(e.name,-1,t)}generateTracks(e){const t=[];let n=new l.Vector3,o=new l.Quaternion,r=new l.Vector3;if(e.transform&&e.transform.decompose(n,o,r),n=n.toArray(),o=new l.Euler().setFromQuaternion(o,e.eulerOrder).toArray(),r=r.toArray(),e.T!==void 0&&Object.keys(e.T.curves).length>0){const s=this.generateVectorTrack(e.modelName,e.T.curves,n,"position");s!==void 0&&t.push(s)}if(e.R!==void 0&&Object.keys(e.R.curves).length>0){const s=this.generateRotationTrack(e.modelName,e.R.curves,o,e.preRotation,e.postRotation,e.eulerOrder);s!==void 0&&t.push(s)}if(e.S!==void 0&&Object.keys(e.S.curves).length>0){const s=this.generateVectorTrack(e.modelName,e.S.curves,r,"scale");s!==void 0&&t.push(s)}if(e.DeformPercent!==void 0){const s=this.generateMorphTrack(e);s!==void 0&&t.push(s)}return t}generateVectorTrack(e,t,n,o){const r=this.getTimesForAllAxes(t),s=this.getKeyframeTrackValues(r,t,n);return new l.VectorKeyframeTrack(e+"."+o,r,s)}generateRotationTrack(e,t,n,o,r,s){t.x!==void 0&&(this.interpolateRotations(t.x),t.x.values=t.x.values.map(l.MathUtils.degToRad)),t.y!==void 0&&(this.interpolateRotations(t.y),t.y.values=t.y.values.map(l.MathUtils.degToRad)),t.z!==void 0&&(this.interpolateRotations(t.z),t.z.values=t.z.values.map(l.MathUtils.degToRad));const a=this.getTimesForAllAxes(t),c=this.getKeyframeTrackValues(a,t,n);o!==void 0&&(o=o.map(l.MathUtils.degToRad),o.push(s),o=new l.Euler().fromArray(o),o=new l.Quaternion().setFromEuler(o)),r!==void 0&&(r=r.map(l.MathUtils.degToRad),r.push(s),r=new l.Euler().fromArray(r),r=new l.Quaternion().setFromEuler(r).invert());const h=new l.Quaternion,p=new l.Euler,f=[];for(let m=0;m<c.length;m+=3)p.set(c[m],c[m+1],c[m+2],s),h.setFromEuler(p),o!==void 0&&h.premultiply(o),r!==void 0&&h.multiply(r),h.toArray(f,m/3*4);return new l.QuaternionKeyframeTrack(e+".quaternion",a,f)}generateMorphTrack(e){const t=e.DeformPercent.curves.morph,n=t.values.map(function(r){return r/100}),o=Re.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];return new l.NumberKeyframeTrack(e.modelName+".morphTargetInfluences["+o+"]",t.times,n)}getTimesForAllAxes(e){let t=[];if(e.x!==void 0&&(t=t.concat(e.x.times)),e.y!==void 0&&(t=t.concat(e.y.times)),e.z!==void 0&&(t=t.concat(e.z.times)),t=t.sort(function(n,o){return n-o}),t.length>1){let n=1,o=t[0];for(let r=1;r<t.length;r++){const s=t[r];s!==o&&(t[n]=s,o=s,n++)}t=t.slice(0,n)}return t}getKeyframeTrackValues(e,t,n){const o=n,r=[];let s=-1,a=-1,c=-1;return e.forEach(function(h){if(t.x&&(s=t.x.times.indexOf(h)),t.y&&(a=t.y.times.indexOf(h)),t.z&&(c=t.z.times.indexOf(h)),s!==-1){const p=t.x.values[s];r.push(p),o[0]=p}else r.push(o[0]);if(a!==-1){const p=t.y.values[a];r.push(p),o[1]=p}else r.push(o[1]);if(c!==-1){const p=t.z.values[c];r.push(p),o[2]=p}else r.push(o[2])}),r}interpolateRotations(e){for(let t=1;t<e.values.length;t++){const n=e.values[t-1],o=e.values[t]-n,r=Math.abs(o);if(r>=180){const s=r/180,a=o/s;let c=n+a;const h=e.times[t-1],f=(e.times[t]-h)/s;let m=h+f;const d=[],y=[];for(;m<e.times[t];)d.push(m),m+=f,y.push(c),c+=a;e.times=Vr(e.times,t,d),e.values=Vr(e.values,t,y)}}}}class oc{getPrevNode(){return this.nodeStack[this.currentIndent-2]}getCurrentNode(){return this.nodeStack[this.currentIndent-1]}getCurrentProp(){return this.currentProp}pushStack(e){this.nodeStack.push(e),this.currentIndent+=1}popStack(){this.nodeStack.pop(),this.currentIndent-=1}setCurrentProp(e,t){this.currentProp=e,this.currentPropName=t}parse(e){this.currentIndent=0,this.allNodes=new Br,this.nodeStack=[],this.currentProp=[],this.currentPropName="";const t=this,n=e.split(/[\r\n]+/);return n.forEach(function(o,r){const s=o.match(/^[\s\t]*;/),a=o.match(/^[\s\t]*$/);if(s||a)return;const c=o.match("^\\t{"+t.currentIndent+"}(\\w+):(.*){",""),h=o.match("^\\t{"+t.currentIndent+"}(\\w+):[\\s\\t\\r\\n](.*)"),p=o.match("^\\t{"+(t.currentIndent-1)+"}}");c?t.parseNodeBegin(o,c):h?t.parseNodeProperty(o,h,n[++r]):p?t.popStack():o.match(/^[^\s\t}]/)&&t.parseNodePropertyContinued(o)}),this.allNodes}parseNodeBegin(e,t){const n=t[1].trim().replace(/^"/,"").replace(/"$/,""),o=t[2].split(",").map(function(c){return c.trim().replace(/^"/,"").replace(/"$/,"")}),r={name:n},s=this.parseNodeAttr(o),a=this.getCurrentNode();this.currentIndent===0?this.allNodes.add(n,r):n in a?(n==="PoseNode"?a.PoseNode.push(r):a[n].id!==void 0&&(a[n]={},a[n][a[n].id]=a[n]),s.id!==""&&(a[n][s.id]=r)):typeof s.id=="number"?(a[n]={},a[n][s.id]=r):n!=="Properties70"&&(n==="PoseNode"?a[n]=[r]:a[n]=r),typeof s.id=="number"&&(r.id=s.id),s.name!==""&&(r.attrName=s.name),s.type!==""&&(r.attrType=s.type),this.pushStack(r)}parseNodeAttr(e){let t=e[0];e[0]!==""&&(t=parseInt(e[0]),isNaN(t)&&(t=e[0]));let n="",o="";return e.length>1&&(n=e[1].replace(/^(\w+)::/,""),o=e[2]),{id:t,name:n,type:o}}parseNodeProperty(e,t,n){let o=t[1].replace(/^"/,"").replace(/"$/,"").trim(),r=t[2].replace(/^"/,"").replace(/"$/,"").trim();o==="Content"&&r===","&&(r=n.replace(/"/g,"").replace(/,$/,"").trim());const s=this.getCurrentNode();if(s.name==="Properties70"){this.parseNodeSpecialProperty(e,o,r);return}if(o==="C"){const c=r.split(",").slice(1),h=parseInt(c[0]),p=parseInt(c[1]);let f=r.split(",").slice(3);f=f.map(function(m){return m.trim().replace(/^"/,"")}),o="connections",r=[h,p],cc(r,f),s[o]===void 0&&(s[o]=[])}o==="Node"&&(s.id=r),o in s&&Array.isArray(s[o])?s[o].push(r):o!=="a"?s[o]=r:s.a=r,this.setCurrentProp(s,o),o==="a"&&r.slice(-1)!==","&&(s.a=so(r))}parseNodePropertyContinued(e){const t=this.getCurrentNode();t.a+=e,e.slice(-1)!==","&&(t.a=so(t.a))}parseNodeSpecialProperty(e,t,n){const o=n.split('",').map(function(p){return p.trim().replace(/^\"/,"").replace(/\s/,"_")}),r=o[0],s=o[1],a=o[2],c=o[3];let h=o[4];switch(s){case"int":case"enum":case"bool":case"ULongLong":case"double":case"Number":case"FieldOfView":h=parseFloat(h);break;case"Color":case"ColorRGB":case"Vector3D":case"Lcl_Translation":case"Lcl_Rotation":case"Lcl_Scaling":h=so(h);break}this.getPrevNode()[r]={type:s,type2:a,flag:c,value:h},this.setCurrentProp(this.getPrevNode(),r)}}class rc{parse(e){const t=new kr(e);t.skip(23);const n=t.getUint32();if(n<6400)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+n);const o=new Br;for(;!this.endOfContent(t);){const r=this.parseNode(t,n);r!==null&&o.add(r.name,r)}return o}endOfContent(e){return e.size()%16===0?(e.getOffset()+160+16&-16)>=e.size():e.getOffset()+160+16>=e.size()}parseNode(e,t){const n={},o=t>=7500?e.getUint64():e.getUint32(),r=t>=7500?e.getUint64():e.getUint32();t>=7500?e.getUint64():e.getUint32();const s=e.getUint8(),a=e.getString(s);if(o===0)return null;const c=[];for(let m=0;m<r;m++)c.push(this.parseProperty(e));const h=c.length>0?c[0]:"",p=c.length>1?c[1]:"",f=c.length>2?c[2]:"";for(n.singleProperty=r===1&&e.getOffset()===o;o>e.getOffset();){const m=this.parseNode(e,t);m!==null&&this.parseSubNode(a,n,m)}return n.propertyList=c,typeof h=="number"&&(n.id=h),p!==""&&(n.attrName=p),f!==""&&(n.attrType=f),a!==""&&(n.name=a),n}parseSubNode(e,t,n){if(n.singleProperty===!0){const o=n.propertyList[0];Array.isArray(o)?(t[n.name]=n,n.a=o):t[n.name]=o}else if(e==="Connections"&&n.name==="C"){const o=[];n.propertyList.forEach(function(r,s){s!==0&&o.push(r)}),t.connections===void 0&&(t.connections=[]),t.connections.push(o)}else if(n.name==="Properties70")Object.keys(n).forEach(function(r){t[r]=n[r]});else if(e==="Properties70"&&n.name==="P"){let o=n.propertyList[0],r=n.propertyList[1];const s=n.propertyList[2],a=n.propertyList[3];let c;o.indexOf("Lcl ")===0&&(o=o.replace("Lcl ","Lcl_")),r.indexOf("Lcl ")===0&&(r=r.replace("Lcl ","Lcl_")),r==="Color"||r==="ColorRGB"||r==="Vector"||r==="Vector3D"||r.indexOf("Lcl_")===0?c=[n.propertyList[4],n.propertyList[5],n.propertyList[6]]:c=n.propertyList[4],t[o]={type:r,type2:s,flag:a,value:c}}else t[n.name]===void 0?typeof n.id=="number"?(t[n.name]={},t[n.name][n.id]=n):t[n.name]=n:n.name==="PoseNode"?(Array.isArray(t[n.name])||(t[n.name]=[t[n.name]]),t[n.name].push(n)):t[n.name][n.id]===void 0&&(t[n.name][n.id]=n)}parseProperty(e){const t=e.getString(1);let n;switch(t){case"C":return e.getBoolean();case"D":return e.getFloat64();case"F":return e.getFloat32();case"I":return e.getInt32();case"L":return e.getInt64();case"R":return n=e.getUint32(),e.getArrayBuffer(n);case"S":return n=e.getUint32(),e.getString(n);case"Y":return e.getInt16();case"b":case"c":case"d":case"f":case"i":case"l":const o=e.getUint32(),r=e.getUint32(),s=e.getUint32();if(r===0)switch(t){case"b":case"c":return e.getBooleanArray(o);case"d":return e.getFloat64Array(o);case"f":return e.getFloat32Array(o);case"i":return e.getInt32Array(o);case"l":return e.getInt64Array(o)}const a=Ba(new Uint8Array(e.getArrayBuffer(s))),c=new kr(a.buffer);switch(t){case"b":case"c":return c.getBooleanArray(o);case"d":return c.getFloat64Array(o);case"f":return c.getFloat32Array(o);case"i":return c.getInt32Array(o);case"l":return c.getInt64Array(o)}default:throw new Error("THREE.FBXLoader: Unknown property type "+t)}}}class kr{constructor(e,t){this.dv=new DataView(e),this.offset=0,this.littleEndian=t!==void 0?t:!0}getOffset(){return this.offset}size(){return this.dv.buffer.byteLength}skip(e){this.offset+=e}getBoolean(){return(this.getUint8()&1)===1}getBooleanArray(e){const t=[];for(let n=0;n<e;n++)t.push(this.getBoolean());return t}getUint8(){const e=this.dv.getUint8(this.offset);return this.offset+=1,e}getInt16(){const e=this.dv.getInt16(this.offset,this.littleEndian);return this.offset+=2,e}getInt32(){const e=this.dv.getInt32(this.offset,this.littleEndian);return this.offset+=4,e}getInt32Array(e){const t=[];for(let n=0;n<e;n++)t.push(this.getInt32());return t}getUint32(){const e=this.dv.getUint32(this.offset,this.littleEndian);return this.offset+=4,e}getInt64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),t&2147483648?(t=~t&4294967295,e=~e&4294967295,e===4294967295&&(t=t+1&4294967295),e=e+1&4294967295,-(t*4294967296+e)):t*4294967296+e}getInt64Array(e){const t=[];for(let n=0;n<e;n++)t.push(this.getInt64());return t}getUint64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),t*4294967296+e}getFloat32(){const e=this.dv.getFloat32(this.offset,this.littleEndian);return this.offset+=4,e}getFloat32Array(e){const t=[];for(let n=0;n<e;n++)t.push(this.getFloat32());return t}getFloat64(){const e=this.dv.getFloat64(this.offset,this.littleEndian);return this.offset+=8,e}getFloat64Array(e){const t=[];for(let n=0;n<e;n++)t.push(this.getFloat64());return t}getArrayBuffer(e){const t=this.dv.buffer.slice(this.offset,this.offset+e);return this.offset+=e,t}getString(e){let t=[];for(let o=0;o<e;o++)t[o]=this.getUint8();const n=t.indexOf(0);return n>=0&&(t=t.slice(0,n)),Bt(new Uint8Array(t))}}class Br{add(e,t){this[e]=t}}function sc(i){const e="Kaydara FBX Binary  \0";return i.byteLength>=e.length&&e===zr(i,0,e.length)}function ic(i){const e=["K","a","y","d","a","r","a","\\","F","B","X","\\","B","i","n","a","r","y","\\","\\"];let t=0;function n(o){const r=i[o-1];return i=i.slice(t+o),t++,r}for(let o=0;o<e.length;++o)if(n(1)===e[o])return!1;return!0}function Ur(i){const e=/FBXVersion: (\d+)/,t=i.match(e);if(t)return parseInt(t[1]);throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")}function ac(i){return i/46186158e3}const lc=[];function _n(i,e,t,n){let o;switch(n.mappingType){case"ByPolygonVertex":o=i;break;case"ByPolygon":o=e;break;case"ByVertice":o=t;break;case"AllSame":o=n.indices[0];break;default:console.warn("THREE.FBXLoader: unknown attribute mapping type "+n.mappingType)}n.referenceType==="IndexToDirect"&&(o=n.indices[o]);const r=o*n.dataSize,s=r+n.dataSize;return uc(lc,n.buffer,r,s)}const ro=new l.Euler,Nt=new l.Vector3;function Nr(i){const e=new l.Matrix4,t=new l.Matrix4,n=new l.Matrix4,o=new l.Matrix4,r=new l.Matrix4,s=new l.Matrix4,a=new l.Matrix4,c=new l.Matrix4,h=new l.Matrix4,p=new l.Matrix4,f=new l.Matrix4,m=new l.Matrix4,d=i.inheritType?i.inheritType:0;if(i.translation&&e.setPosition(Nt.fromArray(i.translation)),i.preRotation){const x=i.preRotation.map(l.MathUtils.degToRad);x.push(i.eulerOrder),t.makeRotationFromEuler(ro.fromArray(x))}if(i.rotation){const x=i.rotation.map(l.MathUtils.degToRad);x.push(i.eulerOrder),n.makeRotationFromEuler(ro.fromArray(x))}if(i.postRotation){const x=i.postRotation.map(l.MathUtils.degToRad);x.push(i.eulerOrder),o.makeRotationFromEuler(ro.fromArray(x)),o.invert()}i.scale&&r.scale(Nt.fromArray(i.scale)),i.scalingOffset&&a.setPosition(Nt.fromArray(i.scalingOffset)),i.scalingPivot&&s.setPosition(Nt.fromArray(i.scalingPivot)),i.rotationOffset&&c.setPosition(Nt.fromArray(i.rotationOffset)),i.rotationPivot&&h.setPosition(Nt.fromArray(i.rotationPivot)),i.parentMatrixWorld&&(f.copy(i.parentMatrix),p.copy(i.parentMatrixWorld));const y=t.clone().multiply(n).multiply(o),_=new l.Matrix4;_.extractRotation(p);const v=new l.Matrix4;v.copyPosition(p);const g=v.clone().invert().multiply(p),A=_.clone().invert().multiply(g),w=r,C=new l.Matrix4;if(d===0)C.copy(_).multiply(y).multiply(A).multiply(w);else if(d===1)C.copy(_).multiply(A).multiply(y).multiply(w);else{const I=new l.Matrix4().scale(new l.Vector3().setFromMatrixScale(f)).clone().invert(),D=A.clone().multiply(I);C.copy(_).multiply(y).multiply(D).multiply(w)}const L=h.clone().invert(),M=s.clone().invert();let P=e.clone().multiply(c).multiply(h).multiply(t).multiply(n).multiply(o).multiply(L).multiply(a).multiply(s).multiply(r).multiply(M);const b=new l.Matrix4().copyPosition(P),S=p.clone().multiply(b);return m.copyPosition(S),P=m.clone().multiply(C),P.premultiply(p.invert()),P}function Fr(i){i=i||0;const e=["ZYX","YZX","XZY","ZXY","YXZ","XYZ"];return i===6?(console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."),e[0]):e[i]}function so(i){return i.split(",").map(function(t){return parseFloat(t)})}function zr(i,e,t){return e===void 0&&(e=0),t===void 0&&(t=i.byteLength),Bt(new Uint8Array(i,e,t))}function cc(i,e){for(let t=0,n=i.length,o=e.length;t<o;t++,n++)i[n]=e[t]}function uc(i,e,t,n){for(let o=t,r=0;o<n;o++,r++)i[r]=e[o];return i}function Vr(i,e,t){return i.slice(0,e).concat(t).concat(i.slice(e))}var hc=Object.defineProperty,fc=(i,e,t)=>e in i?hc(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,io=(i,e,t)=>(fc(i,typeof e!="symbol"?e+"":e,t),t);class dc extends l.Loader{constructor(e){super(e)}load(e,t,n,o){const r=new l.FileLoader(this.manager);r.setPath(this.path),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials),r.load(e,s=>{if(typeof s!="string")throw new Error("unsupported data type");const a=JSON.parse(s),c=this.parse(a);t&&t(c)},n,o)}loadAsync(e,t){return super.loadAsync(e,t)}parse(e){return new ao(e)}}class ao{constructor(e){io(this,"data"),this.data=e}generateShapes(e,t=100,n){const o=[],r={letterSpacing:0,lineHeight:1,...n},s=pc(e,t,this.data,r);for(let a=0,c=s.length;a<c;a++)Array.prototype.push.apply(o,s[a].toShapes(!1));return o}}io(ao,"isFont"),io(ao,"type");function pc(i,e,t,n){const o=Array.from(i),r=e/t.resolution,s=(t.boundingBox.yMax-t.boundingBox.yMin+t.underlineThickness)*r,a=[];let c=0,h=0;for(let p=0;p<o.length;p++){const f=o[p];if(f===`
`)c=0,h-=s*n.lineHeight;else{const m=mc(f,r,c,h,t);m&&(c+=m.offsetX+n.letterSpacing,a.push(m.path))}}return a}function mc(i,e,t,n,o){const r=o.glyphs[i]||o.glyphs["?"];if(!r){console.error('THREE.Font: character "'+i+'" does not exists in font family '+o.familyName+".");return}const s=new l.ShapePath;let a,c,h,p,f,m,d,y;if(r.o){const _=r._cachedOutline||(r._cachedOutline=r.o.split(" "));for(let v=0,g=_.length;v<g;)switch(_[v++]){case"m":a=parseInt(_[v++])*e+t,c=parseInt(_[v++])*e+n,s.moveTo(a,c);break;case"l":a=parseInt(_[v++])*e+t,c=parseInt(_[v++])*e+n,s.lineTo(a,c);break;case"q":h=parseInt(_[v++])*e+t,p=parseInt(_[v++])*e+n,f=parseInt(_[v++])*e+t,m=parseInt(_[v++])*e+n,s.quadraticCurveTo(f,m,h,p);break;case"b":h=parseInt(_[v++])*e+t,p=parseInt(_[v++])*e+n,f=parseInt(_[v++])*e+t,m=parseInt(_[v++])*e+n,d=parseInt(_[v++])*e+t,y=parseInt(_[v++])*e+n,s.bezierCurveTo(f,m,d,y,h,p);break}}return{offsetX:r.ha*e,path:s}}class Gr extends l.DataTextureLoader{constructor(e){super(e),this.type=l.HalfFloatType}parse(e){const s=function(b,S){switch(b){case 1:throw new Error("THREE.RGBELoader: Read Error: "+(S||""));case 2:throw new Error("THREE.RGBELoader: Write Error: "+(S||""));case 3:throw new Error("THREE.RGBELoader: Bad File Format: "+(S||""));default:case 4:throw new Error("THREE.RGBELoader: Memory Error: "+(S||""))}},p=`
`,f=function(b,S,x){S=S||1024;let D=b.pos,z=-1,G=0,E="",X=String.fromCharCode.apply(null,new Uint16Array(b.subarray(D,D+128)));for(;0>(z=X.indexOf(p))&&G<S&&D<b.byteLength;)E+=X,G+=X.length,D+=128,X+=String.fromCharCode.apply(null,new Uint16Array(b.subarray(D,D+128)));return-1<z?(b.pos+=G+z+1,E+X.slice(0,z)):!1},m=function(b){const S=/^#\?(\S+)/,x=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,I=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,D=/^\s*FORMAT=(\S+)\s*$/,z=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,G={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let E,X;for((b.pos>=b.byteLength||!(E=f(b)))&&s(1,"no header found"),(X=E.match(S))||s(3,"bad initial token"),G.valid|=1,G.programtype=X[1],G.string+=E+`
`;E=f(b),E!==!1;){if(G.string+=E+`
`,E.charAt(0)==="#"){G.comments+=E+`
`;continue}if((X=E.match(x))&&(G.gamma=parseFloat(X[1])),(X=E.match(I))&&(G.exposure=parseFloat(X[1])),(X=E.match(D))&&(G.valid|=2,G.format=X[1]),(X=E.match(z))&&(G.valid|=4,G.height=parseInt(X[1],10),G.width=parseInt(X[2],10)),G.valid&2&&G.valid&4)break}return G.valid&2||s(3,"missing format specifier"),G.valid&4||s(3,"missing image size specifier"),G},d=function(b,S,x){const I=S;if(I<8||I>32767||b[0]!==2||b[1]!==2||b[2]&128)return new Uint8Array(b);I!==(b[2]<<8|b[3])&&s(3,"wrong scanline width");const D=new Uint8Array(4*S*x);D.length||s(4,"unable to allocate buffer space");let z=0,G=0;const E=4*I,X=new Uint8Array(4),oe=new Uint8Array(E);let q=x;for(;q>0&&G<b.byteLength;){G+4>b.byteLength&&s(1),X[0]=b[G++],X[1]=b[G++],X[2]=b[G++],X[3]=b[G++],(X[0]!=2||X[1]!=2||(X[2]<<8|X[3])!=I)&&s(3,"bad rgbe scanline format");let ee=0,te;for(;ee<E&&G<b.byteLength;){te=b[G++];const le=te>128;if(le&&(te-=128),(te===0||ee+te>E)&&s(3,"bad scanline data"),le){const de=b[G++];for(let k=0;k<te;k++)oe[ee++]=de}else oe.set(b.subarray(G,G+te),ee),ee+=te,G+=te}const ce=I;for(let le=0;le<ce;le++){let de=0;D[z]=oe[le+de],de+=I,D[z+1]=oe[le+de],de+=I,D[z+2]=oe[le+de],de+=I,D[z+3]=oe[le+de],z+=4}q--}return D},y=function(b,S,x,I){const D=b[S+3],z=Math.pow(2,D-128)/255;x[I+0]=b[S+0]*z,x[I+1]=b[S+1]*z,x[I+2]=b[S+2]*z,x[I+3]=1},_=function(b,S,x,I){const D=b[S+3],z=Math.pow(2,D-128)/255;x[I+0]=l.DataUtils.toHalfFloat(Math.min(b[S+0]*z,65504)),x[I+1]=l.DataUtils.toHalfFloat(Math.min(b[S+1]*z,65504)),x[I+2]=l.DataUtils.toHalfFloat(Math.min(b[S+2]*z,65504)),x[I+3]=l.DataUtils.toHalfFloat(1)},v=new Uint8Array(e);v.pos=0;const g=m(v),A=g.width,w=g.height,C=d(v.subarray(v.pos),A,w);let L,M,P;switch(this.type){case l.FloatType:P=C.length/4;const b=new Float32Array(P*4);for(let x=0;x<P;x++)y(C,x*4,b,x*4);L=b,M=l.FloatType;break;case l.HalfFloatType:P=C.length/4;const S=new Uint16Array(P*4);for(let x=0;x<P;x++)_(C,x*4,S,x*4);L=S,M=l.HalfFloatType;break;default:throw new Error("THREE.RGBELoader: Unsupported type: "+this.type)}return{width:A,height:w,data:L,header:g.string,gamma:g.gamma,exposure:g.exposure,type:M}}setDataType(e){return this.type=e,this}load(e,t,n,o){function r(s,a){switch(s.type){case l.FloatType:case l.HalfFloatType:"colorSpace"in s?s.colorSpace="srgb-linear":s.encoding=3e3,s.minFilter=l.LinearFilter,s.magFilter=l.LinearFilter,s.generateMipmaps=!1,s.flipY=!0;break}t&&t(s,a)}return super.load(e,r,n,o)}}const gc="srgb";class Jt extends l.Loader{constructor(e){super(e),this.defaultDPI=90,this.defaultUnit="px"}load(e,t,n,o){const r=this,s=new l.FileLoader(r.manager);s.setPath(r.path),s.setRequestHeader(r.requestHeader),s.setWithCredentials(r.withCredentials),s.load(e,function(a){try{t(r.parse(a))}catch(c){o?o(c):console.error(c),r.manager.itemError(e)}},n,o)}parse(e){const t=this;function n(k,V){if(k.nodeType!==1)return;const U=C(k);let B=!1,R=null;switch(k.nodeName){case"svg":V=y(k,V);break;case"style":r(k);break;case"g":V=y(k,V);break;case"path":V=y(k,V),k.hasAttribute("d")&&(R=o(k));break;case"rect":V=y(k,V),R=c(k);break;case"polygon":V=y(k,V),R=h(k);break;case"polyline":V=y(k,V),R=p(k);break;case"circle":V=y(k,V),R=f(k);break;case"ellipse":V=y(k,V),R=m(k);break;case"line":V=y(k,V),R=d(k);break;case"defs":B=!0;break;case"use":V=y(k,V);const N=(k.getAttributeNS("http://www.w3.org/1999/xlink","href")||"").substring(1),K=k.viewportElement.getElementById(N);K?n(K,V):console.warn("SVGLoader: 'use node' references non-existent node id: "+N);break}R&&(V.fill!==void 0&&V.fill!=="none"&&R.color.setStyle(V.fill,gc),M(R,ce),D.push(R),R.userData={node:k,style:V});const T=k.childNodes;for(let O=0;O<T.length;O++){const N=T[O];B&&N.nodeName!=="style"&&N.nodeName!=="defs"||n(N,V)}U&&(G.pop(),G.length>0?ce.copy(G[G.length-1]):ce.identity())}function o(k){const V=new l.ShapePath,U=new l.Vector2,B=new l.Vector2,R=new l.Vector2;let T=!0,O=!1;const N=k.getAttribute("d");if(N===""||N==="none")return null;const K=N.match(/[a-df-z][^a-df-z]*/gi);for(let W=0,Y=K.length;W<Y;W++){const Q=K[W],re=Q.charAt(0),se=Q.slice(1).trim();T===!0&&(O=!0,T=!1);let j;switch(re){case"M":j=v(se);for(let F=0,ie=j.length;F<ie;F+=2)U.x=j[F+0],U.y=j[F+1],B.x=U.x,B.y=U.y,F===0?V.moveTo(U.x,U.y):V.lineTo(U.x,U.y),F===0&&R.copy(U);break;case"H":j=v(se);for(let F=0,ie=j.length;F<ie;F++)U.x=j[F],B.x=U.x,B.y=U.y,V.lineTo(U.x,U.y),F===0&&O===!0&&R.copy(U);break;case"V":j=v(se);for(let F=0,ie=j.length;F<ie;F++)U.y=j[F],B.x=U.x,B.y=U.y,V.lineTo(U.x,U.y),F===0&&O===!0&&R.copy(U);break;case"L":j=v(se);for(let F=0,ie=j.length;F<ie;F+=2)U.x=j[F+0],U.y=j[F+1],B.x=U.x,B.y=U.y,V.lineTo(U.x,U.y),F===0&&O===!0&&R.copy(U);break;case"C":j=v(se);for(let F=0,ie=j.length;F<ie;F+=6)V.bezierCurveTo(j[F+0],j[F+1],j[F+2],j[F+3],j[F+4],j[F+5]),B.x=j[F+2],B.y=j[F+3],U.x=j[F+4],U.y=j[F+5],F===0&&O===!0&&R.copy(U);break;case"S":j=v(se);for(let F=0,ie=j.length;F<ie;F+=4)V.bezierCurveTo(_(U.x,B.x),_(U.y,B.y),j[F+0],j[F+1],j[F+2],j[F+3]),B.x=j[F+0],B.y=j[F+1],U.x=j[F+2],U.y=j[F+3],F===0&&O===!0&&R.copy(U);break;case"Q":j=v(se);for(let F=0,ie=j.length;F<ie;F+=4)V.quadraticCurveTo(j[F+0],j[F+1],j[F+2],j[F+3]),B.x=j[F+0],B.y=j[F+1],U.x=j[F+2],U.y=j[F+3],F===0&&O===!0&&R.copy(U);break;case"T":j=v(se);for(let F=0,ie=j.length;F<ie;F+=2){const he=_(U.x,B.x),_e=_(U.y,B.y);V.quadraticCurveTo(he,_e,j[F+0],j[F+1]),B.x=he,B.y=_e,U.x=j[F+0],U.y=j[F+1],F===0&&O===!0&&R.copy(U)}break;case"A":j=v(se,[3,4],7);for(let F=0,ie=j.length;F<ie;F+=7){if(j[F+5]==U.x&&j[F+6]==U.y)continue;const he=U.clone();U.x=j[F+5],U.y=j[F+6],B.x=U.x,B.y=U.y,s(V,j[F],j[F+1],j[F+2],j[F+3],j[F+4],he,U),F===0&&O===!0&&R.copy(U)}break;case"m":j=v(se);for(let F=0,ie=j.length;F<ie;F+=2)U.x+=j[F+0],U.y+=j[F+1],B.x=U.x,B.y=U.y,F===0?V.moveTo(U.x,U.y):V.lineTo(U.x,U.y),F===0&&R.copy(U);break;case"h":j=v(se);for(let F=0,ie=j.length;F<ie;F++)U.x+=j[F],B.x=U.x,B.y=U.y,V.lineTo(U.x,U.y),F===0&&O===!0&&R.copy(U);break;case"v":j=v(se);for(let F=0,ie=j.length;F<ie;F++)U.y+=j[F],B.x=U.x,B.y=U.y,V.lineTo(U.x,U.y),F===0&&O===!0&&R.copy(U);break;case"l":j=v(se);for(let F=0,ie=j.length;F<ie;F+=2)U.x+=j[F+0],U.y+=j[F+1],B.x=U.x,B.y=U.y,V.lineTo(U.x,U.y),F===0&&O===!0&&R.copy(U);break;case"c":j=v(se);for(let F=0,ie=j.length;F<ie;F+=6)V.bezierCurveTo(U.x+j[F+0],U.y+j[F+1],U.x+j[F+2],U.y+j[F+3],U.x+j[F+4],U.y+j[F+5]),B.x=U.x+j[F+2],B.y=U.y+j[F+3],U.x+=j[F+4],U.y+=j[F+5],F===0&&O===!0&&R.copy(U);break;case"s":j=v(se);for(let F=0,ie=j.length;F<ie;F+=4)V.bezierCurveTo(_(U.x,B.x),_(U.y,B.y),U.x+j[F+0],U.y+j[F+1],U.x+j[F+2],U.y+j[F+3]),B.x=U.x+j[F+0],B.y=U.y+j[F+1],U.x+=j[F+2],U.y+=j[F+3],F===0&&O===!0&&R.copy(U);break;case"q":j=v(se);for(let F=0,ie=j.length;F<ie;F+=4)V.quadraticCurveTo(U.x+j[F+0],U.y+j[F+1],U.x+j[F+2],U.y+j[F+3]),B.x=U.x+j[F+0],B.y=U.y+j[F+1],U.x+=j[F+2],U.y+=j[F+3],F===0&&O===!0&&R.copy(U);break;case"t":j=v(se);for(let F=0,ie=j.length;F<ie;F+=2){const he=_(U.x,B.x),_e=_(U.y,B.y);V.quadraticCurveTo(he,_e,U.x+j[F+0],U.y+j[F+1]),B.x=he,B.y=_e,U.x=U.x+j[F+0],U.y=U.y+j[F+1],F===0&&O===!0&&R.copy(U)}break;case"a":j=v(se,[3,4],7);for(let F=0,ie=j.length;F<ie;F+=7){if(j[F+5]==0&&j[F+6]==0)continue;const he=U.clone();U.x+=j[F+5],U.y+=j[F+6],B.x=U.x,B.y=U.y,s(V,j[F],j[F+1],j[F+2],j[F+3],j[F+4],he,U),F===0&&O===!0&&R.copy(U)}break;case"Z":case"z":V.currentPath.autoClose=!0,V.currentPath.curves.length>0&&(U.copy(R),V.currentPath.currentPoint.copy(U),T=!0);break;default:console.warn(Q)}O=!1}return V}function r(k){if(!(!k.sheet||!k.sheet.cssRules||!k.sheet.cssRules.length))for(let V=0;V<k.sheet.cssRules.length;V++){const U=k.sheet.cssRules[V];if(U.type!==1)continue;const B=U.selectorText.split(/,/gm).filter(Boolean).map(R=>R.trim());for(let R=0;R<B.length;R++){const T=Object.fromEntries(Object.entries(U.style).filter(([,O])=>O!==""));z[B[R]]=Object.assign(z[B[R]]||{},T)}}}function s(k,V,U,B,R,T,O,N){if(V==0||U==0){k.lineTo(N.x,N.y);return}B=B*Math.PI/180,V=Math.abs(V),U=Math.abs(U);const K=(O.x-N.x)/2,W=(O.y-N.y)/2,Y=Math.cos(B)*K+Math.sin(B)*W,Q=-Math.sin(B)*K+Math.cos(B)*W;let re=V*V,se=U*U;const j=Y*Y,F=Q*Q,ie=j/re+F/se;if(ie>1){const it=Math.sqrt(ie);V=it*V,U=it*U,re=V*V,se=U*U}const he=re*F+se*j,_e=(re*se-he)/he;let Le=Math.sqrt(Math.max(0,_e));R===T&&(Le=-Le);const Pe=Le*V*Q/U,Je=-Le*U*Y/V,wt=Math.cos(B)*Pe-Math.sin(B)*Je+(O.x+N.x)/2,It=Math.sin(B)*Pe+Math.cos(B)*Je+(O.y+N.y)/2,st=a(1,0,(Y-Pe)/V,(Q-Je)/U),Ee=a((Y-Pe)/V,(Q-Je)/U,(-Y-Pe)/V,(-Q-Je)/U)%(Math.PI*2);k.currentPath.absellipse(wt,It,V,U,st,st+Ee,T===0,B)}function a(k,V,U,B){const R=k*U+V*B,T=Math.sqrt(k*k+V*V)*Math.sqrt(U*U+B*B);let O=Math.acos(Math.max(-1,Math.min(1,R/T)));return k*B-V*U<0&&(O=-O),O}function c(k){const V=w(k.getAttribute("x")||0),U=w(k.getAttribute("y")||0),B=w(k.getAttribute("rx")||k.getAttribute("ry")||0),R=w(k.getAttribute("ry")||k.getAttribute("rx")||0),T=w(k.getAttribute("width")),O=w(k.getAttribute("height")),N=1-.551915024494,K=new l.ShapePath;return K.moveTo(V+B,U),K.lineTo(V+T-B,U),(B!==0||R!==0)&&K.bezierCurveTo(V+T-B*N,U,V+T,U+R*N,V+T,U+R),K.lineTo(V+T,U+O-R),(B!==0||R!==0)&&K.bezierCurveTo(V+T,U+O-R*N,V+T-B*N,U+O,V+T-B,U+O),K.lineTo(V+B,U+O),(B!==0||R!==0)&&K.bezierCurveTo(V+B*N,U+O,V,U+O-R*N,V,U+O-R),K.lineTo(V,U+R),(B!==0||R!==0)&&K.bezierCurveTo(V,U+R*N,V+B*N,U,V+B,U),K}function h(k){function V(T,O,N){const K=w(O),W=w(N);R===0?B.moveTo(K,W):B.lineTo(K,W),R++}const U=/([+-]?\d*\.?\d+(?:e[+-]?\d+)?)(?:,|\s)([+-]?\d*\.?\d+(?:e[+-]?\d+)?)/g,B=new l.ShapePath;let R=0;return k.getAttribute("points").replace(U,V),B.currentPath.autoClose=!0,B}function p(k){function V(T,O,N){const K=w(O),W=w(N);R===0?B.moveTo(K,W):B.lineTo(K,W),R++}const U=/([+-]?\d*\.?\d+(?:e[+-]?\d+)?)(?:,|\s)([+-]?\d*\.?\d+(?:e[+-]?\d+)?)/g,B=new l.ShapePath;let R=0;return k.getAttribute("points").replace(U,V),B.currentPath.autoClose=!1,B}function f(k){const V=w(k.getAttribute("cx")||0),U=w(k.getAttribute("cy")||0),B=w(k.getAttribute("r")||0),R=new l.Path;R.absarc(V,U,B,0,Math.PI*2);const T=new l.ShapePath;return T.subPaths.push(R),T}function m(k){const V=w(k.getAttribute("cx")||0),U=w(k.getAttribute("cy")||0),B=w(k.getAttribute("rx")||0),R=w(k.getAttribute("ry")||0),T=new l.Path;T.absellipse(V,U,B,R,0,Math.PI*2);const O=new l.ShapePath;return O.subPaths.push(T),O}function d(k){const V=w(k.getAttribute("x1")||0),U=w(k.getAttribute("y1")||0),B=w(k.getAttribute("x2")||0),R=w(k.getAttribute("y2")||0),T=new l.ShapePath;return T.moveTo(V,U),T.lineTo(B,R),T.currentPath.autoClose=!1,T}function y(k,V){V=Object.assign({},V);let U={};if(k.hasAttribute("class")){const O=k.getAttribute("class").split(/\s/).filter(Boolean).map(N=>N.trim());for(let N=0;N<O.length;N++)U=Object.assign(U,z["."+O[N]])}k.hasAttribute("id")&&(U=Object.assign(U,z["#"+k.getAttribute("id")]));function B(O,N,K){K===void 0&&(K=function(Y){return Y.startsWith("url")&&console.warn("SVGLoader: url access in attributes is not implemented."),Y}),k.hasAttribute(O)&&(V[N]=K(k.getAttribute(O))),U[O]&&(V[N]=K(U[O])),k.style&&k.style[O]!==""&&(V[N]=K(k.style[O]))}function R(O){return Math.max(0,Math.min(1,w(O)))}function T(O){return Math.max(0,w(O))}return B("fill","fill"),B("fill-opacity","fillOpacity",R),B("fill-rule","fillRule"),B("opacity","opacity",R),B("stroke","stroke"),B("stroke-opacity","strokeOpacity",R),B("stroke-width","strokeWidth",T),B("stroke-linejoin","strokeLineJoin"),B("stroke-linecap","strokeLineCap"),B("stroke-miterlimit","strokeMiterLimit",T),B("visibility","visibility"),V}function _(k,V){return k-(V-k)}function v(k,V,U){if(typeof k!="string")throw new TypeError("Invalid input: "+typeof k);const B={WHITESPACE:/[ \t\r\n]/,DIGIT:/[\d]/,SIGN:/[-+]/,POINT:/\./,COMMA:/,/,EXP:/e/i,FLAGS:/[01]/},R=0,T=1,O=2,N=3;let K=R,W=!0,Y="",Q="";const re=[];function se(he,_e,Le){const Pe=new SyntaxError('Unexpected character "'+he+'" at index '+_e+".");throw Pe.partial=Le,Pe}function j(){Y!==""&&(Q===""?re.push(Number(Y)):re.push(Number(Y)*Math.pow(10,Number(Q)))),Y="",Q=""}let F;const ie=k.length;for(let he=0;he<ie;he++){if(F=k[he],Array.isArray(V)&&V.includes(re.length%U)&&B.FLAGS.test(F)){K=T,Y=F,j();continue}if(K===R){if(B.WHITESPACE.test(F))continue;if(B.DIGIT.test(F)||B.SIGN.test(F)){K=T,Y=F;continue}if(B.POINT.test(F)){K=O,Y=F;continue}B.COMMA.test(F)&&(W&&se(F,he,re),W=!0)}if(K===T){if(B.DIGIT.test(F)){Y+=F;continue}if(B.POINT.test(F)){Y+=F,K=O;continue}if(B.EXP.test(F)){K=N;continue}B.SIGN.test(F)&&Y.length===1&&B.SIGN.test(Y[0])&&se(F,he,re)}if(K===O){if(B.DIGIT.test(F)){Y+=F;continue}if(B.EXP.test(F)){K=N;continue}B.POINT.test(F)&&Y[Y.length-1]==="."&&se(F,he,re)}if(K===N){if(B.DIGIT.test(F)){Q+=F;continue}if(B.SIGN.test(F)){if(Q===""){Q+=F;continue}Q.length===1&&B.SIGN.test(Q)&&se(F,he,re)}}B.WHITESPACE.test(F)?(j(),K=R,W=!1):B.COMMA.test(F)?(j(),K=R,W=!0):B.SIGN.test(F)?(j(),K=T,Y=F):B.POINT.test(F)?(j(),K=O,Y=F):se(F,he,re)}return j(),re}const g=["mm","cm","in","pt","pc","px"],A={mm:{mm:1,cm:.1,in:1/25.4,pt:72/25.4,pc:6/25.4,px:-1},cm:{mm:10,cm:1,in:1/2.54,pt:72/2.54,pc:6/2.54,px:-1},in:{mm:25.4,cm:2.54,in:1,pt:72,pc:6,px:-1},pt:{mm:25.4/72,cm:2.54/72,in:1/72,pt:1,pc:6/72,px:-1},pc:{mm:25.4/6,cm:2.54/6,in:1/6,pt:72/6,pc:1,px:-1},px:{px:1}};function w(k){let V="px";if(typeof k=="string"||k instanceof String)for(let B=0,R=g.length;B<R;B++){const T=g[B];if(k.endsWith(T)){V=T,k=k.substring(0,k.length-T.length);break}}let U;return V==="px"&&t.defaultUnit!=="px"?U=A.in[t.defaultUnit]/t.defaultDPI:(U=A[V][t.defaultUnit],U<0&&(U=A[V].in*t.defaultDPI)),U*parseFloat(k)}function C(k){if(!(k.hasAttribute("transform")||k.nodeName==="use"&&(k.hasAttribute("x")||k.hasAttribute("y"))))return null;const V=L(k);return G.length>0&&V.premultiply(G[G.length-1]),ce.copy(V),G.push(V),V}function L(k){const V=new l.Matrix3,U=E;if(k.nodeName==="use"&&(k.hasAttribute("x")||k.hasAttribute("y"))){const B=w(k.getAttribute("x")),R=w(k.getAttribute("y"));V.translate(B,R)}if(k.hasAttribute("transform")){const B=k.getAttribute("transform").split(")");for(let R=B.length-1;R>=0;R--){const T=B[R].trim();if(T==="")continue;const O=T.indexOf("("),N=T.length;if(O>0&&O<N){const K=T.slice(0,O),W=v(T.slice(O+1));switch(U.identity(),K){case"translate":if(W.length>=1){const Y=W[0];let Q=0;W.length>=2&&(Q=W[1]),U.translate(Y,Q)}break;case"rotate":if(W.length>=1){let Y=0,Q=0,re=0;Y=W[0]*Math.PI/180,W.length>=3&&(Q=W[1],re=W[2]),X.makeTranslation(-Q,-re),oe.makeRotation(Y),q.multiplyMatrices(oe,X),X.makeTranslation(Q,re),U.multiplyMatrices(X,q)}break;case"scale":if(W.length>=1){const Y=W[0];let Q=Y;W.length>=2&&(Q=W[1]),U.scale(Y,Q)}break;case"skewX":W.length===1&&U.set(1,Math.tan(W[0]*Math.PI/180),0,0,1,0,0,0,1);break;case"skewY":W.length===1&&U.set(1,0,0,Math.tan(W[0]*Math.PI/180),1,0,0,0,1);break;case"matrix":W.length===6&&U.set(W[0],W[2],W[4],W[1],W[3],W[5],0,0,1);break}}V.premultiply(U)}}return V}function M(k,V){function U(O){te.set(O.x,O.y,1).applyMatrix3(V),O.set(te.x,te.y)}function B(O){const N=O.xRadius,K=O.yRadius,W=Math.cos(O.aRotation),Y=Math.sin(O.aRotation),Q=new l.Vector3(N*W,N*Y,0),re=new l.Vector3(-K*Y,K*W,0),se=Q.applyMatrix3(V),j=re.applyMatrix3(V),F=E.set(se.x,j.x,0,se.y,j.y,0,0,0,1),ie=X.copy(F).invert(),Le=oe.copy(ie).transpose().multiply(ie).elements,Pe=I(Le[0],Le[1],Le[4]),Je=Math.sqrt(Pe.rt1),wt=Math.sqrt(Pe.rt2);if(O.xRadius=1/Je,O.yRadius=1/wt,O.aRotation=Math.atan2(Pe.sn,Pe.cs),!((O.aEndAngle-O.aStartAngle)%(2*Math.PI)<Number.EPSILON)){const st=X.set(Je,0,0,0,wt,0,0,0,1),Ee=oe.set(Pe.cs,Pe.sn,0,-Pe.sn,Pe.cs,0,0,0,1),it=st.multiply(Ee).multiply(F),sn=kn=>{const{x:jo,y:Bn}=new l.Vector3(Math.cos(kn),Math.sin(kn),0).applyMatrix3(it);return Math.atan2(Bn,jo)};O.aStartAngle=sn(O.aStartAngle),O.aEndAngle=sn(O.aEndAngle),P(V)&&(O.aClockwise=!O.aClockwise)}}function R(O){const N=S(V),K=x(V);O.xRadius*=N,O.yRadius*=K;const W=N>Number.EPSILON?Math.atan2(V.elements[1],V.elements[0]):Math.atan2(-V.elements[3],V.elements[4]);O.aRotation+=W,P(V)&&(O.aStartAngle*=-1,O.aEndAngle*=-1,O.aClockwise=!O.aClockwise)}const T=k.subPaths;for(let O=0,N=T.length;O<N;O++){const W=T[O].curves;for(let Y=0;Y<W.length;Y++){const Q=W[Y];Q.isLineCurve?(U(Q.v1),U(Q.v2)):Q.isCubicBezierCurve?(U(Q.v0),U(Q.v1),U(Q.v2),U(Q.v3)):Q.isQuadraticBezierCurve?(U(Q.v0),U(Q.v1),U(Q.v2)):Q.isEllipseCurve&&(ee.set(Q.aX,Q.aY),U(ee),Q.aX=ee.x,Q.aY=ee.y,b(V)?B(Q):R(Q))}}}function P(k){const V=k.elements;return V[0]*V[4]-V[1]*V[3]<0}function b(k){const V=k.elements,U=V[0]*V[3]+V[1]*V[4];if(U===0)return!1;const B=S(k),R=x(k);return Math.abs(U/(B*R))>Number.EPSILON}function S(k){const V=k.elements;return Math.sqrt(V[0]*V[0]+V[1]*V[1])}function x(k){const V=k.elements;return Math.sqrt(V[3]*V[3]+V[4]*V[4])}function I(k,V,U){let B,R,T,O,N;const K=k+U,W=k-U,Y=Math.sqrt(W*W+4*V*V);return K>0?(B=.5*(K+Y),N=1/B,R=k*N*U-V*N*V):K<0?R=.5*(K-Y):(B=.5*Y,R=-.5*Y),W>0?T=W+Y:T=W-Y,Math.abs(T)>2*Math.abs(V)?(N=-2*V/T,O=1/Math.sqrt(1+N*N),T=N*O):Math.abs(V)===0?(T=1,O=0):(N=-.5*T/V,T=1/Math.sqrt(1+N*N),O=N*T),W>0&&(N=T,T=-O,O=N),{rt1:B,rt2:R,cs:T,sn:O}}const D=[],z={},G=[],E=new l.Matrix3,X=new l.Matrix3,oe=new l.Matrix3,q=new l.Matrix3,ee=new l.Vector2,te=new l.Vector3,ce=new l.Matrix3,le=new DOMParser().parseFromString(e,"image/svg+xml");return n(le.documentElement,{fill:"#000",fillOpacity:1,strokeOpacity:1,strokeWidth:1,strokeLineJoin:"miter",strokeLineCap:"butt",strokeMiterLimit:4}),{paths:D,xml:le.documentElement}}static createShapes(e){const n={ORIGIN:0,DESTINATION:1,BETWEEN:2,LEFT:3,RIGHT:4,BEHIND:5,BEYOND:6},o={loc:n.ORIGIN,t:0};function r(_,v,g,A){const w=_.x,C=v.x,L=g.x,M=A.x,P=_.y,b=v.y,S=g.y,x=A.y,I=(M-L)*(P-S)-(x-S)*(w-L),D=(C-w)*(P-S)-(b-P)*(w-L),z=(x-S)*(C-w)-(M-L)*(b-P),G=I/z,E=D/z;if(z===0&&I!==0||G<=0||G>=1||E<0||E>1)return null;if(I===0&&z===0){for(let X=0;X<2;X++)if(s(X===0?g:A,_,v),o.loc==n.ORIGIN){const oe=X===0?g:A;return{x:oe.x,y:oe.y,t:o.t}}else if(o.loc==n.BETWEEN){const oe=+(w+o.t*(C-w)).toPrecision(10),q=+(P+o.t*(b-P)).toPrecision(10);return{x:oe,y:q,t:o.t}}return null}else{for(let q=0;q<2;q++)if(s(q===0?g:A,_,v),o.loc==n.ORIGIN){const ee=q===0?g:A;return{x:ee.x,y:ee.y,t:o.t}}const X=+(w+G*(C-w)).toPrecision(10),oe=+(P+G*(b-P)).toPrecision(10);return{x:X,y:oe,t:G}}}function s(_,v,g){const A=g.x-v.x,w=g.y-v.y,C=_.x-v.x,L=_.y-v.y,M=A*L-C*w;if(_.x===v.x&&_.y===v.y){o.loc=n.ORIGIN,o.t=0;return}if(_.x===g.x&&_.y===g.y){o.loc=n.DESTINATION,o.t=1;return}if(M<-Number.EPSILON){o.loc=n.LEFT;return}if(M>Number.EPSILON){o.loc=n.RIGHT;return}if(A*C<0||w*L<0){o.loc=n.BEHIND;return}if(Math.sqrt(A*A+w*w)<Math.sqrt(C*C+L*L)){o.loc=n.BEYOND;return}let P;A!==0?P=C/A:P=L/w,o.loc=n.BETWEEN,o.t=P}function a(_,v){const g=[],A=[];for(let w=1;w<_.length;w++){const C=_[w-1],L=_[w];for(let M=1;M<v.length;M++){const P=v[M-1],b=v[M],S=r(C,L,P,b);S!==null&&g.find(x=>x.t<=S.t+Number.EPSILON&&x.t>=S.t-Number.EPSILON)===void 0&&(g.push(S),A.push(new l.Vector2(S.x,S.y)))}}return A}function c(_,v,g){const A=new l.Vector2;v.getCenter(A);const w=[];return g.forEach(C=>{C.boundingBox.containsPoint(A)&&a(_,C.points).forEach(M=>{w.push({identifier:C.identifier,isCW:C.isCW,point:M})})}),w.sort((C,L)=>C.point.x-L.point.x),w}function h(_,v,g,A,w){(w==null||w==="")&&(w="nonzero");const C=new l.Vector2;_.boundingBox.getCenter(C);const L=[new l.Vector2(g,C.y),new l.Vector2(A,C.y)],M=c(L,_.boundingBox,v);M.sort((D,z)=>D.point.x-z.point.x);const P=[],b=[];M.forEach(D=>{D.identifier===_.identifier?P.push(D):b.push(D)});const S=P[0].point.x,x=[];let I=0;for(;I<b.length&&b[I].point.x<S;)x.length>0&&x[x.length-1]===b[I].identifier?x.pop():x.push(b[I].identifier),I++;if(x.push(_.identifier),w==="evenodd"){const D=x.length%2===0,z=x[x.length-2];return{identifier:_.identifier,isHole:D,for:z}}else if(w==="nonzero"){let D=!0,z=null,G=null;for(let E=0;E<x.length;E++){const X=x[E];D?(G=v[X].isCW,D=!1,z=X):G!==v[X].isCW&&(G=v[X].isCW,D=!0)}return{identifier:_.identifier,isHole:D,for:z}}else console.warn('fill-rule: "'+w+'" is currently not implemented.')}let p=999999999,f=-999999999,m=e.subPaths.map(_=>{const v=_.getPoints();let g=-999999999,A=999999999,w=-999999999,C=999999999;for(let L=0;L<v.length;L++){const M=v[L];M.y>g&&(g=M.y),M.y<A&&(A=M.y),M.x>w&&(w=M.x),M.x<C&&(C=M.x)}return f<=w&&(f=w+1),p>=C&&(p=C-1),{curves:_.curves,points:v,isCW:l.ShapeUtils.isClockWise(v),identifier:-1,boundingBox:new l.Box2(new l.Vector2(C,A),new l.Vector2(w,g))}});m=m.filter(_=>_.points.length>1);for(let _=0;_<m.length;_++)m[_].identifier=_;const d=m.map(_=>h(_,m,p,f,e.userData?e.userData.style.fillRule:void 0)),y=[];return m.forEach(_=>{if(!d[_.identifier].isHole){const g=new l.Shape;g.curves=_.curves,d.filter(w=>w.isHole&&w.for===_.identifier).forEach(w=>{const C=m[w.identifier],L=new l.Path;L.curves=C.curves,g.holes.push(L)}),y.push(g)}}),y}static getStrokeStyle(e,t,n,o,r){return e=e!==void 0?e:1,t=t!==void 0?t:"#000",n=n!==void 0?n:"miter",o=o!==void 0?o:"butt",r=r!==void 0?r:4,{strokeColor:t,strokeWidth:e,strokeLineJoin:n,strokeLineCap:o,strokeMiterLimit:r}}static pointsToStroke(e,t,n,o){const r=[],s=[],a=[];if(Jt.pointsToStrokeWithBuffers(e,t,n,o,r,s,a)===0)return null;const c=new l.BufferGeometry;return c.setAttribute("position",new l.Float32BufferAttribute(r,3)),c.setAttribute("normal",new l.Float32BufferAttribute(s,3)),c.setAttribute("uv",new l.Float32BufferAttribute(a,2)),c}static pointsToStrokeWithBuffers(e,t,n,o,r,s,a,c){const h=new l.Vector2,p=new l.Vector2,f=new l.Vector2,m=new l.Vector2,d=new l.Vector2,y=new l.Vector2,_=new l.Vector2,v=new l.Vector2,g=new l.Vector2,A=new l.Vector2,w=new l.Vector2,C=new l.Vector2,L=new l.Vector2,M=new l.Vector2,P=new l.Vector2,b=new l.Vector2,S=new l.Vector2;n=n!==void 0?n:12,o=o!==void 0?o:.001,c=c!==void 0?c:0,e=W(e);const x=e.length;if(x<2)return 0;const I=e[0].equals(e[x-1]);let D,z=e[0],G;const E=t.strokeWidth/2,X=1/(x-1);let oe=0,q,ee,te,ce,le=!1,de=0,k=c*3,V=c*2;U(e[0],e[1],h).multiplyScalar(E),v.copy(e[0]).sub(h),g.copy(e[0]).add(h),A.copy(v),w.copy(g);for(let Y=1;Y<x;Y++){D=e[Y],Y===x-1?I?G=e[1]:G=void 0:G=e[Y+1];const Q=h;if(U(z,D,Q),f.copy(Q).multiplyScalar(E),C.copy(D).sub(f),L.copy(D).add(f),q=oe+X,ee=!1,G!==void 0){U(D,G,p),f.copy(p).multiplyScalar(E),M.copy(D).sub(f),P.copy(D).add(f),te=!0,f.subVectors(G,z),Q.dot(f)<0&&(te=!1),Y===1&&(le=te),f.subVectors(G,D),f.normalize();const re=Math.abs(Q.dot(f));if(re>Number.EPSILON){const se=E/re;f.multiplyScalar(-se),m.subVectors(D,z),d.copy(m).setLength(se).add(f),b.copy(d).negate();const j=d.length(),F=m.length();m.divideScalar(F),y.subVectors(G,D);const ie=y.length();switch(y.divideScalar(ie),m.dot(b)<F&&y.dot(b)<ie&&(ee=!0),S.copy(d).add(D),b.add(D),ce=!1,ee?te?(P.copy(b),L.copy(b)):(M.copy(b),C.copy(b)):T(),t.strokeLineJoin){case"bevel":O(te,ee,q);break;case"round":N(te,ee),te?R(D,C,M,q,0):R(D,P,L,q,1);break;case"miter":case"miter-clip":default:const he=E*t.strokeMiterLimit/j;if(he<1)if(t.strokeLineJoin!=="miter-clip"){O(te,ee,q);break}else N(te,ee),te?(y.subVectors(S,C).multiplyScalar(he).add(C),_.subVectors(S,M).multiplyScalar(he).add(M),B(C,q,0),B(y,q,0),B(D,q,.5),B(D,q,.5),B(y,q,0),B(_,q,0),B(D,q,.5),B(_,q,0),B(M,q,0)):(y.subVectors(S,L).multiplyScalar(he).add(L),_.subVectors(S,P).multiplyScalar(he).add(P),B(L,q,1),B(y,q,1),B(D,q,.5),B(D,q,.5),B(y,q,1),B(_,q,1),B(D,q,.5),B(_,q,1),B(P,q,1));else ee?(te?(B(g,oe,1),B(v,oe,0),B(S,q,0),B(g,oe,1),B(S,q,0),B(b,q,1)):(B(g,oe,1),B(v,oe,0),B(S,q,1),B(v,oe,0),B(b,q,0),B(S,q,1)),te?M.copy(S):P.copy(S)):te?(B(C,q,0),B(S,q,0),B(D,q,.5),B(D,q,.5),B(S,q,0),B(M,q,0)):(B(L,q,1),B(S,q,1),B(D,q,.5),B(D,q,.5),B(S,q,1),B(P,q,1)),ce=!0;break}}else T()}else T();!I&&Y===x-1&&K(e[0],A,w,te,!0,oe),oe=q,z=D,v.copy(M),g.copy(P)}if(!I)K(D,C,L,te,!1,q);else if(ee&&r){let Y=S,Q=b;le!==te&&(Y=b,Q=S),te?(ce||le)&&(Q.toArray(r,0*3),Q.toArray(r,3*3),ce&&Y.toArray(r,1*3)):(ce||!le)&&(Q.toArray(r,1*3),Q.toArray(r,3*3),ce&&Y.toArray(r,0*3))}return de;function U(Y,Q,re){return re.subVectors(Q,Y),re.set(-re.y,re.x).normalize()}function B(Y,Q,re){r&&(r[k]=Y.x,r[k+1]=Y.y,r[k+2]=0,s&&(s[k]=0,s[k+1]=0,s[k+2]=1),k+=3,a&&(a[V]=Q,a[V+1]=re,V+=2)),de+=3}function R(Y,Q,re,se,j){h.copy(Q).sub(Y).normalize(),p.copy(re).sub(Y).normalize();let F=Math.PI;const ie=h.dot(p);Math.abs(ie)<1&&(F=Math.abs(Math.acos(ie))),F/=n,f.copy(Q);for(let he=0,_e=n-1;he<_e;he++)m.copy(f).rotateAround(Y,F),B(f,se,j),B(m,se,j),B(Y,se,.5),f.copy(m);B(m,se,j),B(re,se,j),B(Y,se,.5)}function T(){B(g,oe,1),B(v,oe,0),B(C,q,0),B(g,oe,1),B(C,q,0),B(L,q,1)}function O(Y,Q,re){Q?Y?(B(g,oe,1),B(v,oe,0),B(C,q,0),B(g,oe,1),B(C,q,0),B(b,q,1),B(C,re,0),B(M,re,0),B(b,re,.5)):(B(g,oe,1),B(v,oe,0),B(L,q,1),B(v,oe,0),B(b,q,0),B(L,q,1),B(L,re,1),B(b,re,0),B(P,re,1)):Y?(B(C,re,0),B(M,re,0),B(D,re,.5)):(B(L,re,1),B(P,re,0),B(D,re,.5))}function N(Y,Q){Q&&(Y?(B(g,oe,1),B(v,oe,0),B(C,q,0),B(g,oe,1),B(C,q,0),B(b,q,1),B(C,oe,0),B(D,q,.5),B(b,q,1),B(D,q,.5),B(M,oe,0),B(b,q,1)):(B(g,oe,1),B(v,oe,0),B(L,q,1),B(v,oe,0),B(b,q,0),B(L,q,1),B(L,oe,1),B(b,q,0),B(D,q,.5),B(D,q,.5),B(b,q,0),B(P,oe,1)))}function K(Y,Q,re,se,j,F){switch(t.strokeLineCap){case"round":j?R(Y,re,Q,F,.5):R(Y,Q,re,F,.5);break;case"square":if(j)h.subVectors(Q,Y),p.set(h.y,-h.x),f.addVectors(h,p).add(Y),m.subVectors(p,h).add(Y),se?(f.toArray(r,1*3),m.toArray(r,0*3),m.toArray(r,3*3)):(f.toArray(r,1*3),a[3*2+1]===1?m.toArray(r,3*3):f.toArray(r,3*3),m.toArray(r,0*3));else{h.subVectors(re,Y),p.set(h.y,-h.x),f.addVectors(h,p).add(Y),m.subVectors(p,h).add(Y);const ie=r.length;se?(f.toArray(r,ie-1*3),m.toArray(r,ie-2*3),m.toArray(r,ie-4*3)):(m.toArray(r,ie-2*3),f.toArray(r,ie-1*3),m.toArray(r,ie-4*3))}break}}function W(Y){let Q=!1;for(let se=1,j=Y.length-1;se<j;se++)if(Y[se].distanceTo(Y[se+1])<o){Q=!0;break}if(!Q)return Y;const re=[];re.push(Y[0]);for(let se=1,j=Y.length-1;se<j;se++)Y[se].distanceTo(Y[se+1])>=o&&re.push(Y[se]);return re.push(Y[Y.length-1]),re}}}const lo=new WeakMap;class yc extends l.Loader{constructor(e){super(e),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(e){return this.decoderPath=e,this}setDecoderConfig(e){return this.decoderConfig=e,this}setWorkerLimit(e){return this.workerLimit=e,this}load(e,t,n,o){const r=new l.FileLoader(this.manager);r.setPath(this.path),r.setResponseType("arraybuffer"),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials),r.load(e,s=>{const a={attributeIDs:this.defaultAttributeIDs,attributeTypes:this.defaultAttributeTypes,useUniqueIDs:!1};this.decodeGeometry(s,a).then(t).catch(o)},n,o)}decodeDracoFile(e,t,n,o){const r={attributeIDs:n||this.defaultAttributeIDs,attributeTypes:o||this.defaultAttributeTypes,useUniqueIDs:!!n};this.decodeGeometry(e,r).then(t)}decodeGeometry(e,t){for(const c in t.attributeTypes){const h=t.attributeTypes[c];h.BYTES_PER_ELEMENT!==void 0&&(t.attributeTypes[c]=h.name)}const n=JSON.stringify(t);if(lo.has(e)){const c=lo.get(e);if(c.key===n)return c.promise;if(e.byteLength===0)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let o;const r=this.workerNextTaskID++,s=e.byteLength,a=this._getWorker(r,s).then(c=>(o=c,new Promise((h,p)=>{o._callbacks[r]={resolve:h,reject:p},o.postMessage({type:"decode",id:r,taskConfig:t,buffer:e},[e])}))).then(c=>this._createGeometry(c.geometry));return a.catch(()=>!0).then(()=>{o&&r&&this._releaseTask(o,r)}),lo.set(e,{key:n,promise:a}),a}_createGeometry(e){const t=new l.BufferGeometry;e.index&&t.setIndex(new l.BufferAttribute(e.index.array,1));for(let n=0;n<e.attributes.length;n++){const o=e.attributes[n],r=o.name,s=o.array,a=o.itemSize;t.setAttribute(r,new l.BufferAttribute(s,a))}return t}_loadLibrary(e,t){const n=new l.FileLoader(this.manager);return n.setPath(this.decoderPath),n.setResponseType(t),n.setWithCredentials(this.withCredentials),new Promise((o,r)=>{n.load(e,o,void 0,r)})}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const e=typeof WebAssembly!="object"||this.decoderConfig.type==="js",t=[];return e?t.push(this._loadLibrary("draco_decoder.js","text")):(t.push(this._loadLibrary("draco_wasm_wrapper.js","text")),t.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(t).then(n=>{const o=n[0];e||(this.decoderConfig.wasmBinary=n[1]);const r=_c.toString(),s=["/* draco decoder */",o,"","/* worker */",r.substring(r.indexOf("{")+1,r.lastIndexOf("}"))].join(`
`);this.workerSourceURL=URL.createObjectURL(new Blob([s]))}),this.decoderPending}_getWorker(e,t){return this._initDecoder().then(()=>{if(this.workerPool.length<this.workerLimit){const o=new Worker(this.workerSourceURL);o._callbacks={},o._taskCosts={},o._taskLoad=0,o.postMessage({type:"init",decoderConfig:this.decoderConfig}),o.onmessage=function(r){const s=r.data;switch(s.type){case"decode":o._callbacks[s.id].resolve(s);break;case"error":o._callbacks[s.id].reject(s);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+s.type+'"')}},this.workerPool.push(o)}else this.workerPool.sort(function(o,r){return o._taskLoad>r._taskLoad?-1:1});const n=this.workerPool[this.workerPool.length-1];return n._taskCosts[e]=t,n._taskLoad+=t,n})}_releaseTask(e,t){e._taskLoad-=e._taskCosts[t],delete e._callbacks[t],delete e._taskCosts[t]}debug(){console.log("Task load: ",this.workerPool.map(e=>e._taskLoad))}dispose(){for(let e=0;e<this.workerPool.length;++e)this.workerPool[e].terminate();return this.workerPool.length=0,this}}function _c(){let i,e;onmessage=function(s){const a=s.data;switch(a.type){case"init":i=a.decoderConfig,e=new Promise(function(p){i.onModuleLoaded=function(f){p({draco:f})},DracoDecoderModule(i)});break;case"decode":const c=a.buffer,h=a.taskConfig;e.then(p=>{const f=p.draco,m=new f.Decoder,d=new f.DecoderBuffer;d.Init(new Int8Array(c),c.byteLength);try{const y=t(f,m,d,h),_=y.attributes.map(v=>v.array.buffer);y.index&&_.push(y.index.array.buffer),self.postMessage({type:"decode",id:a.id,geometry:y},_)}catch(y){console.error(y),self.postMessage({type:"error",id:a.id,error:y.message})}finally{f.destroy(d),f.destroy(m)}});break}};function t(s,a,c,h){const p=h.attributeIDs,f=h.attributeTypes;let m,d;const y=a.GetEncodedGeometryType(c);if(y===s.TRIANGULAR_MESH)m=new s.Mesh,d=a.DecodeBufferToMesh(c,m);else if(y===s.POINT_CLOUD)m=new s.PointCloud,d=a.DecodeBufferToPointCloud(c,m);else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");if(!d.ok()||m.ptr===0)throw new Error("THREE.DRACOLoader: Decoding failed: "+d.error_msg());const _={index:null,attributes:[]};for(const v in p){const g=self[f[v]];let A,w;if(h.useUniqueIDs)w=p[v],A=a.GetAttributeByUniqueId(m,w);else{if(w=a.GetAttributeId(m,s[p[v]]),w===-1)continue;A=a.GetAttribute(m,w)}_.attributes.push(o(s,a,m,v,g,A))}return y===s.TRIANGULAR_MESH&&(_.index=n(s,a,m)),s.destroy(m),_}function n(s,a,c){const p=c.num_faces()*3,f=p*4,m=s._malloc(f);a.GetTrianglesUInt32Array(c,f,m);const d=new Uint32Array(s.HEAPF32.buffer,m,p).slice();return s._free(m),{array:d,itemSize:1}}function o(s,a,c,h,p,f){const m=f.num_components(),y=c.num_points()*m,_=y*p.BYTES_PER_ELEMENT,v=r(s,p),g=s._malloc(_);a.GetAttributeDataArrayForAllPoints(c,f,v,_,g);const A=new p(s.HEAPF32.buffer,g,y).slice();return s._free(g),{name:h,array:A,itemSize:m}}function r(s,a){switch(a){case Float32Array:return s.DT_FLOAT32;case Int8Array:return s.DT_INT8;case Int16Array:return s.DT_INT16;case Int32Array:return s.DT_INT32;case Uint8Array:return s.DT_UINT8;case Uint16Array:return s.DT_UINT16;case Uint32Array:return s.DT_UINT32}}}const Rr=new l.Box3,vn=new l.Vector3;class jr extends l.InstancedBufferGeometry{constructor(){super(),this.isLineSegmentsGeometry=!0,this.type="LineSegmentsGeometry";const e=[-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],t=[-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],n=[0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5];this.setIndex(n),this.setAttribute("position",new l.Float32BufferAttribute(e,3)),this.setAttribute("uv",new l.Float32BufferAttribute(t,2))}applyMatrix4(e){const t=this.attributes.instanceStart,n=this.attributes.instanceEnd;return t!==void 0&&(t.applyMatrix4(e),n.applyMatrix4(e),t.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}setPositions(e){let t;e instanceof Float32Array?t=e:Array.isArray(e)&&(t=new Float32Array(e));const n=new l.InstancedInterleavedBuffer(t,6,1);return this.setAttribute("instanceStart",new l.InterleavedBufferAttribute(n,3,0)),this.setAttribute("instanceEnd",new l.InterleavedBufferAttribute(n,3,3)),this.computeBoundingBox(),this.computeBoundingSphere(),this}setColors(e,t=3){let n;e instanceof Float32Array?n=e:Array.isArray(e)&&(n=new Float32Array(e));const o=new l.InstancedInterleavedBuffer(n,t*2,1);return this.setAttribute("instanceColorStart",new l.InterleavedBufferAttribute(o,t,0)),this.setAttribute("instanceColorEnd",new l.InterleavedBufferAttribute(o,t,t)),this}fromWireframeGeometry(e){return this.setPositions(e.attributes.position.array),this}fromEdgesGeometry(e){return this.setPositions(e.attributes.position.array),this}fromMesh(e){return this.fromWireframeGeometry(new l.WireframeGeometry(e.geometry)),this}fromLineSegments(e){const t=e.geometry;return this.setPositions(t.attributes.position.array),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new l.Box3);const e=this.attributes.instanceStart,t=this.attributes.instanceEnd;e!==void 0&&t!==void 0&&(this.boundingBox.setFromBufferAttribute(e),Rr.setFromBufferAttribute(t),this.boundingBox.union(Rr))}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new l.Sphere),this.boundingBox===null&&this.computeBoundingBox();const e=this.attributes.instanceStart,t=this.attributes.instanceEnd;if(e!==void 0&&t!==void 0){const n=this.boundingSphere.center;this.boundingBox.getCenter(n);let o=0;for(let r=0,s=e.count;r<s;r++)vn.fromBufferAttribute(e,r),o=Math.max(o,n.distanceToSquared(vn)),vn.fromBufferAttribute(t,r),o=Math.max(o,n.distanceToSquared(vn));this.boundingSphere.radius=Math.sqrt(o),isNaN(this.boundingSphere.radius)&&console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}}toJSON(){}applyMatrix(e){return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."),this.applyMatrix4(e)}}class Wr extends jr{constructor(){super(),this.isLineGeometry=!0,this.type="LineGeometry"}setPositions(e){const t=e.length-3,n=new Float32Array(2*t);for(let o=0;o<t;o+=3)n[2*o]=e[o],n[2*o+1]=e[o+1],n[2*o+2]=e[o+2],n[2*o+3]=e[o+3],n[2*o+4]=e[o+4],n[2*o+5]=e[o+5];return super.setPositions(n),this}setColors(e,t=3){const n=e.length-t,o=new Float32Array(2*n);if(t===3)for(let r=0;r<n;r+=t)o[2*r]=e[r],o[2*r+1]=e[r+1],o[2*r+2]=e[r+2],o[2*r+3]=e[r+3],o[2*r+4]=e[r+4],o[2*r+5]=e[r+5];else for(let r=0;r<n;r+=t)o[2*r]=e[r],o[2*r+1]=e[r+1],o[2*r+2]=e[r+2],o[2*r+3]=e[r+3],o[2*r+4]=e[r+4],o[2*r+5]=e[r+5],o[2*r+6]=e[r+6],o[2*r+7]=e[r+7];return super.setColors(o,t),this}fromLine(e){const t=e.geometry;return this.setPositions(t.attributes.position.array),this}}class co extends l.ShaderMaterial{constructor(e){super({type:"LineMaterial",uniforms:l.UniformsUtils.clone(l.UniformsUtils.merge([l.UniformsLib.common,l.UniformsLib.fog,{worldUnits:{value:1},linewidth:{value:1},resolution:{value:new l.Vector2(1,1)},dashOffset:{value:0},dashScale:{value:1},dashSize:{value:1},gapSize:{value:1}}])),vertexShader:`
				#include <common>
				#include <fog_pars_vertex>
				#include <logdepthbuf_pars_vertex>
				#include <clipping_planes_pars_vertex>

				uniform float linewidth;
				uniform vec2 resolution;

				attribute vec3 instanceStart;
				attribute vec3 instanceEnd;

				#ifdef USE_COLOR
					#ifdef USE_LINE_COLOR_ALPHA
						varying vec4 vLineColor;
						attribute vec4 instanceColorStart;
						attribute vec4 instanceColorEnd;
					#else
						varying vec3 vLineColor;
						attribute vec3 instanceColorStart;
						attribute vec3 instanceColorEnd;
					#endif
				#endif

				#ifdef WORLD_UNITS

					varying vec4 worldPos;
					varying vec3 worldStart;
					varying vec3 worldEnd;

					#ifdef USE_DASH

						varying vec2 vUv;

					#endif

				#else

					varying vec2 vUv;

				#endif

				#ifdef USE_DASH

					uniform float dashScale;
					attribute float instanceDistanceStart;
					attribute float instanceDistanceEnd;
					varying float vLineDistance;

				#endif

				void trimSegment( const in vec4 start, inout vec4 end ) {

					// trim end segment so it terminates between the camera plane and the near plane

					// conservative estimate of the near plane
					float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
					float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
					float nearEstimate = - 0.5 * b / a;

					float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

					end.xyz = mix( start.xyz, end.xyz, alpha );

				}

				void main() {

					#ifdef USE_COLOR

						vLineColor = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

					#endif

					#ifdef USE_DASH

						vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
						vUv = uv;

					#endif

					float aspect = resolution.x / resolution.y;

					// camera space
					vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
					vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

					#ifdef WORLD_UNITS

						worldStart = start.xyz;
						worldEnd = end.xyz;

					#else

						vUv = uv;

					#endif

					// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
					// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
					// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
					// perhaps there is a more elegant solution -- WestLangley

					bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

					if ( perspective ) {

						if ( start.z < 0.0 && end.z >= 0.0 ) {

							trimSegment( start, end );

						} else if ( end.z < 0.0 && start.z >= 0.0 ) {

							trimSegment( end, start );

						}

					}

					// clip space
					vec4 clipStart = projectionMatrix * start;
					vec4 clipEnd = projectionMatrix * end;

					// ndc space
					vec3 ndcStart = clipStart.xyz / clipStart.w;
					vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

					// direction
					vec2 dir = ndcEnd.xy - ndcStart.xy;

					// account for clip-space aspect ratio
					dir.x *= aspect;
					dir = normalize( dir );

					#ifdef WORLD_UNITS

						// get the offset direction as perpendicular to the view vector
						vec3 worldDir = normalize( end.xyz - start.xyz );
						vec3 offset;
						if ( position.y < 0.5 ) {

							offset = normalize( cross( start.xyz, worldDir ) );

						} else {

							offset = normalize( cross( end.xyz, worldDir ) );

						}

						// sign flip
						if ( position.x < 0.0 ) offset *= - 1.0;

						float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

						// don't extend the line if we're rendering dashes because we
						// won't be rendering the endcaps
						#ifndef USE_DASH

							// extend the line bounds to encompass  endcaps
							start.xyz += - worldDir * linewidth * 0.5;
							end.xyz += worldDir * linewidth * 0.5;

							// shift the position of the quad so it hugs the forward edge of the line
							offset.xy -= dir * forwardOffset;
							offset.z += 0.5;

						#endif

						// endcaps
						if ( position.y > 1.0 || position.y < 0.0 ) {

							offset.xy += dir * 2.0 * forwardOffset;

						}

						// adjust for linewidth
						offset *= linewidth * 0.5;

						// set the world position
						worldPos = ( position.y < 0.5 ) ? start : end;
						worldPos.xyz += offset;

						// project the worldpos
						vec4 clip = projectionMatrix * worldPos;

						// shift the depth of the projected points so the line
						// segments overlap neatly
						vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
						clip.z = clipPose.z * clip.w;

					#else

						vec2 offset = vec2( dir.y, - dir.x );
						// undo aspect ratio adjustment
						dir.x /= aspect;
						offset.x /= aspect;

						// sign flip
						if ( position.x < 0.0 ) offset *= - 1.0;

						// endcaps
						if ( position.y < 0.0 ) {

							offset += - dir;

						} else if ( position.y > 1.0 ) {

							offset += dir;

						}

						// adjust for linewidth
						offset *= linewidth;

						// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
						offset /= resolution.y;

						// select end
						vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

						// back to clip space
						offset *= clip.w;

						clip.xy += offset;

					#endif

					gl_Position = clip;

					vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

					#include <logdepthbuf_vertex>
					#include <clipping_planes_vertex>
					#include <fog_vertex>

				}
			`,fragmentShader:`
				uniform vec3 diffuse;
				uniform float opacity;
				uniform float linewidth;

				#ifdef USE_DASH

					uniform float dashOffset;
					uniform float dashSize;
					uniform float gapSize;

				#endif

				varying float vLineDistance;

				#ifdef WORLD_UNITS

					varying vec4 worldPos;
					varying vec3 worldStart;
					varying vec3 worldEnd;

					#ifdef USE_DASH

						varying vec2 vUv;

					#endif

				#else

					varying vec2 vUv;

				#endif

				#include <common>
				#include <fog_pars_fragment>
				#include <logdepthbuf_pars_fragment>
				#include <clipping_planes_pars_fragment>

				#ifdef USE_COLOR
					#ifdef USE_LINE_COLOR_ALPHA
						varying vec4 vLineColor;
					#else
						varying vec3 vLineColor;
					#endif
				#endif

				vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

					float mua;
					float mub;

					vec3 p13 = p1 - p3;
					vec3 p43 = p4 - p3;

					vec3 p21 = p2 - p1;

					float d1343 = dot( p13, p43 );
					float d4321 = dot( p43, p21 );
					float d1321 = dot( p13, p21 );
					float d4343 = dot( p43, p43 );
					float d2121 = dot( p21, p21 );

					float denom = d2121 * d4343 - d4321 * d4321;

					float numer = d1343 * d4321 - d1321 * d4343;

					mua = numer / denom;
					mua = clamp( mua, 0.0, 1.0 );
					mub = ( d1343 + d4321 * ( mua ) ) / d4343;
					mub = clamp( mub, 0.0, 1.0 );

					return vec2( mua, mub );

				}

				void main() {

					#include <clipping_planes_fragment>

					#ifdef USE_DASH

						if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

						if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

					#endif

					float alpha = opacity;

					#ifdef WORLD_UNITS

						// Find the closest points on the view ray and the line segment
						vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
						vec3 lineDir = worldEnd - worldStart;
						vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

						vec3 p1 = worldStart + lineDir * params.x;
						vec3 p2 = rayEnd * params.y;
						vec3 delta = p1 - p2;
						float len = length( delta );
						float norm = len / linewidth;

						#ifndef USE_DASH

							#ifdef USE_ALPHA_TO_COVERAGE

								float dnorm = fwidth( norm );
								alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

							#else

								if ( norm > 0.5 ) {

									discard;

								}

							#endif

						#endif

					#else

						#ifdef USE_ALPHA_TO_COVERAGE

							// artifacts appear on some hardware if a derivative is taken within a conditional
							float a = vUv.x;
							float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
							float len2 = a * a + b * b;
							float dlen = fwidth( len2 );

							if ( abs( vUv.y ) > 1.0 ) {

								alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

							}

						#else

							if ( abs( vUv.y ) > 1.0 ) {

								float a = vUv.x;
								float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
								float len2 = a * a + b * b;

								if ( len2 > 1.0 ) discard;

							}

						#endif

					#endif

					vec4 diffuseColor = vec4( diffuse, alpha );
					#ifdef USE_COLOR
						#ifdef USE_LINE_COLOR_ALPHA
							diffuseColor *= vLineColor;
						#else
							diffuseColor.rgb *= vLineColor;
						#endif
					#endif

					#include <logdepthbuf_fragment>

					gl_FragColor = diffuseColor;

					#include <tonemapping_fragment>
					#include <${parseInt(l.REVISION.replace(/\D+/g,""))>=154?"colorspace_fragment":"encodings_fragment"}>
					#include <fog_fragment>
					#include <premultiplied_alpha_fragment>

				}
			`,clipping:!0}),this.isLineMaterial=!0,this.onBeforeCompile=function(){this.transparent?this.defines.USE_LINE_COLOR_ALPHA="1":delete this.defines.USE_LINE_COLOR_ALPHA},Object.defineProperties(this,{color:{enumerable:!0,get:function(){return this.uniforms.diffuse.value},set:function(t){this.uniforms.diffuse.value=t}},worldUnits:{enumerable:!0,get:function(){return"WORLD_UNITS"in this.defines},set:function(t){t===!0?this.defines.WORLD_UNITS="":delete this.defines.WORLD_UNITS}},linewidth:{enumerable:!0,get:function(){return this.uniforms.linewidth.value},set:function(t){this.uniforms.linewidth.value=t}},dashed:{enumerable:!0,get:function(){return"USE_DASH"in this.defines},set(t){!!t!="USE_DASH"in this.defines&&(this.needsUpdate=!0),t===!0?this.defines.USE_DASH="":delete this.defines.USE_DASH}},dashScale:{enumerable:!0,get:function(){return this.uniforms.dashScale.value},set:function(t){this.uniforms.dashScale.value=t}},dashSize:{enumerable:!0,get:function(){return this.uniforms.dashSize.value},set:function(t){this.uniforms.dashSize.value=t}},dashOffset:{enumerable:!0,get:function(){return this.uniforms.dashOffset.value},set:function(t){this.uniforms.dashOffset.value=t}},gapSize:{enumerable:!0,get:function(){return this.uniforms.gapSize.value},set:function(t){this.uniforms.gapSize.value=t}},opacity:{enumerable:!0,get:function(){return this.uniforms.opacity.value},set:function(t){this.uniforms.opacity.value=t}},resolution:{enumerable:!0,get:function(){return this.uniforms.resolution.value},set:function(t){this.uniforms.resolution.value.copy(t)}},alphaToCoverage:{enumerable:!0,get:function(){return"USE_ALPHA_TO_COVERAGE"in this.defines},set:function(t){!!t!="USE_ALPHA_TO_COVERAGE"in this.defines&&(this.needsUpdate=!0),t===!0?(this.defines.USE_ALPHA_TO_COVERAGE="",this.extensions.derivatives=!0):(delete this.defines.USE_ALPHA_TO_COVERAGE,this.extensions.derivatives=!1)}}}),this.setValues(e)}}const uo=new l.Vector4,Yr=new l.Vector3,Xr=new l.Vector3,Ne=new l.Vector4,Fe=new l.Vector4,et=new l.Vector4,ho=new l.Vector3,fo=new l.Matrix4,ze=new l.Line3,Er=new l.Vector3,xn=new l.Box3,wn=new l.Sphere,tt=new l.Vector4;let nt,Pt;function Zr(i,e,t){return tt.set(0,0,-e,1).applyMatrix4(i.projectionMatrix),tt.multiplyScalar(1/tt.w),tt.x=Pt/t.width,tt.y=Pt/t.height,tt.applyMatrix4(i.projectionMatrixInverse),tt.multiplyScalar(1/tt.w),Math.abs(Math.max(tt.x,tt.y))}function vc(i,e){const t=i.matrixWorld,n=i.geometry,o=n.attributes.instanceStart,r=n.attributes.instanceEnd,s=Math.min(n.instanceCount,o.count);for(let a=0,c=s;a<c;a++){ze.start.fromBufferAttribute(o,a),ze.end.fromBufferAttribute(r,a),ze.applyMatrix4(t);const h=new l.Vector3,p=new l.Vector3;nt.distanceSqToSegment(ze.start,ze.end,p,h),p.distanceTo(h)<Pt*.5&&e.push({point:p,pointOnLine:h,distance:nt.origin.distanceTo(p),object:i,face:null,faceIndex:a,uv:null,[Gn]:null})}}function xc(i,e,t){const n=e.projectionMatrix,r=i.material.resolution,s=i.matrixWorld,a=i.geometry,c=a.attributes.instanceStart,h=a.attributes.instanceEnd,p=Math.min(a.instanceCount,c.count),f=-e.near;nt.at(1,et),et.w=1,et.applyMatrix4(e.matrixWorldInverse),et.applyMatrix4(n),et.multiplyScalar(1/et.w),et.x*=r.x/2,et.y*=r.y/2,et.z=0,ho.copy(et),fo.multiplyMatrices(e.matrixWorldInverse,s);for(let m=0,d=p;m<d;m++){if(Ne.fromBufferAttribute(c,m),Fe.fromBufferAttribute(h,m),Ne.w=1,Fe.w=1,Ne.applyMatrix4(fo),Fe.applyMatrix4(fo),Ne.z>f&&Fe.z>f)continue;if(Ne.z>f){const w=Ne.z-Fe.z,C=(Ne.z-f)/w;Ne.lerp(Fe,C)}else if(Fe.z>f){const w=Fe.z-Ne.z,C=(Fe.z-f)/w;Fe.lerp(Ne,C)}Ne.applyMatrix4(n),Fe.applyMatrix4(n),Ne.multiplyScalar(1/Ne.w),Fe.multiplyScalar(1/Fe.w),Ne.x*=r.x/2,Ne.y*=r.y/2,Fe.x*=r.x/2,Fe.y*=r.y/2,ze.start.copy(Ne),ze.start.z=0,ze.end.copy(Fe),ze.end.z=0;const _=ze.closestPointToPointParameter(ho,!0);ze.at(_,Er);const v=l.MathUtils.lerp(Ne.z,Fe.z,_),g=v>=-1&&v<=1,A=ho.distanceTo(Er)<Pt*.5;if(g&&A){ze.start.fromBufferAttribute(c,m),ze.end.fromBufferAttribute(h,m),ze.start.applyMatrix4(s),ze.end.applyMatrix4(s);const w=new l.Vector3,C=new l.Vector3;nt.distanceSqToSegment(ze.start,ze.end,C,w),t.push({point:C,pointOnLine:w,distance:nt.origin.distanceTo(C),object:i,face:null,faceIndex:m,uv:null,[Gn]:null})}}}class wc extends l.Mesh{constructor(e=new jr,t=new co({color:Math.random()*16777215})){super(e,t),this.isLineSegments2=!0,this.type="LineSegments2"}computeLineDistances(){const e=this.geometry,t=e.attributes.instanceStart,n=e.attributes.instanceEnd,o=new Float32Array(2*t.count);for(let s=0,a=0,c=t.count;s<c;s++,a+=2)Yr.fromBufferAttribute(t,s),Xr.fromBufferAttribute(n,s),o[a]=a===0?0:o[a-1],o[a+1]=o[a]+Yr.distanceTo(Xr);const r=new l.InstancedInterleavedBuffer(o,2,1);return e.setAttribute("instanceDistanceStart",new l.InterleavedBufferAttribute(r,1,0)),e.setAttribute("instanceDistanceEnd",new l.InterleavedBufferAttribute(r,1,1)),this}raycast(e,t){const n=this.material.worldUnits,o=e.camera;o===null&&!n&&console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');const r=e.params.Line2!==void 0&&e.params.Line2.threshold||0;nt=e.ray;const s=this.matrixWorld,a=this.geometry,c=this.material;Pt=c.linewidth+r,a.boundingSphere===null&&a.computeBoundingSphere(),wn.copy(a.boundingSphere).applyMatrix4(s);let h;if(n)h=Pt*.5;else{const f=Math.max(o.near,wn.distanceToPoint(nt.origin));h=Zr(o,f,c.resolution)}if(wn.radius+=h,nt.intersectsSphere(wn)===!1)return;a.boundingBox===null&&a.computeBoundingBox(),xn.copy(a.boundingBox).applyMatrix4(s);let p;if(n)p=Pt*.5;else{const f=Math.max(o.near,xn.distanceToPoint(nt.origin));p=Zr(o,f,c.resolution)}xn.expandByScalar(p),nt.intersectsBox(xn)!==!1&&(n?vc(this,t):xc(this,o,t))}onBeforeRender(e){const t=this.material.uniforms;t&&t.resolution&&(e.getViewport(uo),this.material.uniforms.resolution.value.set(uo.z,uo.w))}}class bc extends wc{constructor(e=new Wr,t=new co({color:Math.random()*16777215})){super(e,t),this.isLine2=!0,this.type="Line2"}}class Mc extends l.Line{constructor(e,t=1,n=16,o=2){const r=new l.BufferGeometry,s=n+o*2,a=new Float32Array((s*3+3)*3);r.setAttribute("position",new l.BufferAttribute(a,3));const c=new l.LineBasicMaterial({color:65280}),h=new l.LineBasicMaterial({color:16776960});super(r,[h,c]),this.type="PositionalAudioHelper",this.audio=e,this.range=t,this.divisionsInnerAngle=n,this.divisionsOuterAngle=o,this.update()}update(){const e=this.audio,t=this.range,n=this.divisionsInnerAngle,o=this.divisionsOuterAngle,r=l.MathUtils.degToRad(e.panner.coneInnerAngle),s=l.MathUtils.degToRad(e.panner.coneOuterAngle),a=r/2,c=s/2;let h=0,p=0,f,m;const d=this.geometry,y=d.attributes.position;d.clearGroups();function _(v,g,A,w){const C=(g-v)/A;for(y.setXYZ(h,0,0,0),p++,f=v;f<g;f+=C)m=h+p,y.setXYZ(m,Math.sin(f)*t,0,Math.cos(f)*t),y.setXYZ(m+1,Math.sin(Math.min(f+C,g))*t,0,Math.cos(Math.min(f+C,g))*t),y.setXYZ(m+2,0,0,0),p+=3;d.addGroup(h,p,w),h+=p,p=0}_(-c,-a,o,0),_(-a,a,n,1),_(a,c,o,0),y.needsUpdate=!0,r===s&&(this.material[0].visible=!1)}dispose(){this.geometry.dispose(),this.material[0].dispose(),this.material[1].dispose()}}function Sc(i){return i}function Ac(i){return i*i*i}function Pc(i){return i<.5?4*i*i*i:1-(-2*i+2)**3/2}function Cc(i){return i*i*i*i}function Tc(i){return i<1/2.75?7.5625*i*i:i<2/2.75?7.5625*(i-=1.5/2.75)*i+.75:i<2.5/2.75?7.5625*(i-=2.25/2.75)*i+.9375:7.5625*(i-=2.625/2.75)*i+.984375}const ut="https://raw.githubusercontent.com/Tresjs/assets/93976c7d63ac83d4a254a41a10b2362bc17e90c9/textures/lensflare/",po=`${ut}circle.png`,bn=`${ut}circleBlur.png`,Ic=`${ut}circleRainbow.png`,Oc=`${ut}line.png`,Kr=`${ut}poly6.png`,qr=`${ut}polyStroke6.png`,Lc=`${ut}rays.png`,Mn=`${ut}ring.png`,Dc=`${ut}starThin6.png`,kc={texture:[Oc,Mn],color:["white"],distance:[0,0],size:[750,1024],length:[0,2]},Bc={texture:[bn],color:["white"],distance:[0,0],size:[180,512],length:[1,1]},Uc={texture:[Lc],color:["white"],distance:[0,0],size:[180,512],length:[1,1]},Nc={texture:[po,Ic,Mn,Dc],color:["white"],distance:[0,0],size:[180,512],length:[2,3]},[Qr,Jr]=[3679071,132442],mo=[kc,Bc,Uc,Nc,{texture:[bn,po,Mn,Kr,qr],color:["dimgray","gray","darkgray",Qr,Jr],distance:[.5,2.5],size:[20,180],length:[5,21]},{texture:[bn,po,Mn,Kr,qr],color:["dimgray","gray","darkgray",Qr,Jr],distance:[-.6,-.1],size:[180,360],length:[0,5]}],Sn={color:"white",distance:0,size:512,texture:bn},Hr=l.MathUtils.clamp;class $r{constructor(e=0,t){ue(this,"_getNext");ue(this,"_getGenerator");this._getGenerator=t??this.getMulberry32,this._getNext=this._getGenerator(e)}seed(e){this._getNext=this._getGenerator(e)}rand(){return this._getNext()}float(e,t){return e+this._getNext()*(t-e)}floatSpread(e){return this.float(-.5*e,.5*e)}int(e,t){return e+Math.floor(this._getNext()*(t-e+1))}choice(e){return e.length?e[Math.floor(this._getNext()*e.length)]:null}defaultChoice(e,t){return e.length?e[Math.floor(this._getNext()*e.length)]:t}sample(e,t,n){const o=e.length;t=Hr(t,0,o-1),n=Hr(n??o-1,0,o-1);const r=this.int(t,n),s=this.shuffle(e.map((c,h)=>h)),a=Math.min(e.length,r);return s.slice(0,a).sort().map(c=>e[c])}shuffle(e){return e.map(t=>({value:t,sort:this._getNext()})).sort((t,n)=>t.sort-n.sort).map(({value:t})=>t)}getMulberry32(e=0){return e>0&&e<1&&(e=Math.floor(e*2**16)),()=>{e+=1831565813;let t=e;return t=Math.imul(t^t>>>15,t|1),t^=t+Math.imul(t^t>>>7,t|61),((t^t>>>14)>>>0)/4294967296}}}const Fc=[Sc,Ac,Pc,Cc,Tc],es=l.MathUtils.lerp,ts=(i=0,e=mo)=>{const n=new $r(i).choice(Fc);return e.map((o,r)=>{const s=new $r(i*(r*7907+1)+(typeof o.seed=="number"?o.seed:0)),a=s.int(o.length[0],o.length[1]);return Array.from({length:a}).fill(0).map(()=>{const c=n(s.rand());return{texture:s.defaultChoice(o.texture,Sn.texture),size:es(o.size[0],o.size[1],n(1-c)),distance:es(o.distance[0],o.distance[1],c),color:s.defaultChoice(o.color,Sn.color)}})}).flat()},ns=(i,e,t=void 0,n=void 0,o=Sn)=>{if(i!==void 0&&i.length>0&&(typeof t=="number"||typeof n<"u")){const a=ts(t??0,n??mo),c=a.length,h=i.length;return c>=h?a.map((p,f)=>Object.assign(p,e,f<h?i[f]:{})):i.map((p,f)=>Object.assign({},o,f<c?a[f]:{},e,p))}if(i!==void 0&&i.length>0){const a=Object.assign({},o,e);return i.map(c=>Object.assign({},a,c))}const r=n===void 0||n.length===0?mo:n;return ts(t??0,r).map(a=>Object.assign({},a,e))};function zc(i){return Vc(i,(e,t)=>t in Sn&&e!==void 0)}function Vc(i,e){const t={};return Object.keys(i).forEach(n=>{e(i[n],n)&&(t[n]=i[n])}),t}const Gc=u.defineComponent({__name:"component",props:{scale:{default:1},elements:{default:void 0},seed:{default:void 0},seedProps:{default:void 0},color:{default:void 0},distance:{default:void 0},size:{default:void 0},texture:{default:void 0}},setup(i,{expose:e}){const t=i,n=u.shallowRef(),o=u.shallowRef([]),r=u.shallowRef(zc(t));e({instance:n});const s=new l.TextureLoader,a=new pr,c=[],h=()=>{var d,y,_;for(;c.length;)c.pop();(d=n.value)==null||d.children.forEach(v=>{"dispose"in v&&v.dispose()}),(y=n.value)==null||y.remove(...n.value.children),(_=n.value)==null||_.dispose()},p=d=>{if(typeof d.texture=="string"){const y=d.texture;d.texture=s.load(y),d.texture.name=y}return d.color=H.normalizeColor(d.color),d},f=()=>{for(let d=o.value.length-1;d<c.length;d++)c[d].size=0;o.value.forEach((d,y)=>{c[y].size=d.size*t.scale})},m=()=>{for(;o.value.length>c.length;){const y={...p(o.value[c.length])};c.push(y),a.addElement(y)}o.value.forEach((d,y)=>{const _=c[y],{texture:v,size:g,distance:A,color:w}=d;if(typeof v=="string"){if(_.texture.name!==v){_.texture.dispose();const C=v;_.texture=s.load(C),_.texture.name=C}}else _.texture!==v&&(_.texture.dispose(),_.texture=v);_.size=g,_.distance=A,_.color=H.normalizeColor(w)}),f()};return u.onUnmounted(()=>{h()}),u.onMounted(()=>{var d;(d=n.value)==null||d.add(a),o.value=ns(t.elements,r.value,t.seed,t.seedProps)}),u.watch(()=>[t.color,t.distance,t.size,t.texture],()=>{r.value={color:t.color,distance:t.distance,size:t.size,texture:t.texture}}),u.watch(()=>[r.value,t.elements,t.seed,t.seedProps],()=>{o.value=ns(t.elements,r.value,t.seed,t.seedProps)}),u.watch(()=>t.scale,()=>{f()}),u.watch(()=>o.value,()=>{m()}),(d,y)=>(u.openBlock(),u.createElementBlock("TresGroup",{ref_key:"lensflareRef",ref:n},null,512))}}),Rc=u.defineComponent({__name:"Levioso",props:{speed:{default:1},rotationFactor:{default:1},floatFactor:{default:1},range:{default:()=>[-.1,.1]}},setup(i,{expose:e}){const t=i,n=u.shallowRef();e({instance:n});{const c=Math.random()*1e4,{onBeforeRender:h}=H.useLoop();let p=c;h(({delta:f,invalidate:m})=>{if(!n.value)return;p+=f*t.speed;const d=p*.25,y=n.value;y.rotation.x=Math.cos(d)*.125*t.rotationFactor,y.rotation.y=Math.sin(d)*.125*t.rotationFactor,y.rotation.z=Math.sin(d)*.05*t.rotationFactor,y.position.y=l.MathUtils.mapLinear(Math.sin(d),-1,1,t.range[0],t.range[1])*t.floatFactor,m()})}return(o,r)=>(u.openBlock(),u.createElementBlock("TresGroup",u.mergeProps(o.$attrs,{ref_key:"groupRef",ref:n}),[u.renderSlot(o.$slots,"default")],16))}}),jc=["render-order"],Wc=u.defineComponent({__name:"component",props:{id:{default:1},colorWrite:{type:Boolean,default:!0},depthWrite:{type:Boolean,default:!1}},setup(i,{expose:e}){const t=i,n=u.shallowRef();function o(){var s,a;const r=Array.isArray((s=n.value)==null?void 0:s.material)?n.value.material[0]:(a=n.value)==null?void 0:a.material;r&&(r.colorWrite=t.colorWrite,r.depthWrite=t.depthWrite,r.stencilWrite=!0,r.stencilRef=t.id,r.stencilFunc=l.AlwaysStencilFunc,r.stencilFail=l.ReplaceStencilOp,r.stencilZFail=l.ReplaceStencilOp,r.stencilZPass=l.ReplaceStencilOp)}return u.watchEffect(o),e({instance:n}),(r,s)=>(u.openBlock(),u.createElementBlock("TresMesh",{ref_key:"meshRef",ref:n,"render-order":-t.id},[u.renderSlot(r.$slots,"default")],8,jc))}}),Yc=u.defineComponent({__name:"MouseParallax",props:{disabled:{type:Boolean,default:!1},factor:{default:2.5},ease:{default:.1},local:{type:Boolean,default:!1}},setup(i){const e=i,{camera:t,renderer:n}=H.useTresContext(),{disabled:o,factor:r,ease:s,local:a}=u.toRefs(e),c={};a.value&&(c.target=n.value.domElement,c.type="client");const{x:h,y:p}=Vi(c),{width:f,height:m}=a.value?Bi(n.value.domElement):qo(),d=u.shallowRef(),y=u.ref(),_=u.ref();u.watch([r,s],()=>{y.value=Array.isArray(r.value)?r.value:[r.value,r.value],_.value=Array.isArray(s.value)?s.value:[s.value,s.value]},{immediate:!0});const v=u.computed(()=>(h.value/f.value-.5)*y.value[0]),g=u.computed(()=>-(p.value/m.value-.5)*y.value[1]),{onBeforeRender:A}=H.useLoop();return A(({delta:w,invalidate:C})=>{o.value||!d.value||Number.isNaN(v.value)||Number.isNaN(g.value)||(d.value.position.x+=(v.value-d.value.position.x)*_.value[0]*w,d.value.position.y+=(g.value-d.value.position.y)*_.value[1]*w,C())}),u.watch(()=>d.value,w=>w==null?void 0:w.add(t.value)),(w,C)=>(u.openBlock(),u.createElementBlock("TresGroup",{ref_key:"cameraGroupRef",ref:d},null,512))}}),Xc=Vn({screenspace:!1,color:new l.Color("black"),opacity:1,thickness:.05,size:new l.Vector2(1,1)},`#include <common>
   #include <morphtarget_pars_vertex>
   #include <skinning_pars_vertex>
   uniform float thickness;
   uniform bool screenspace;
   uniform vec2 size;
   void main() {
     #if defined (USE_SKINNING)
       #include <beginnormal_vertex>
       #include <morphnormal_vertex>
       #include <skinbase_vertex>
       #include <skinnormal_vertex>
       #include <defaultnormal_vertex>
     #endif
     #include <begin_vertex>
     #include <morphtarget_vertex>
     #include <skinning_vertex>
     #include <project_vertex>
     vec4 tNormal = vec4(normal, 0.0);
     vec4 tPosition = vec4(transformed, 1.0);
     #ifdef USE_INSTANCING
       tNormal = instanceMatrix * tNormal;
       tPosition = instanceMatrix * tPosition;
     #endif
     if (screenspace) {
       vec3 newPosition = tPosition.xyz + tNormal.xyz * thickness;
       gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0); 
     } else {
       vec4 clipPosition = projectionMatrix * modelViewMatrix * tPosition;
       vec4 clipNormal = projectionMatrix * modelViewMatrix * tNormal;
       vec2 offset = normalize(clipNormal.xy) * thickness / size * clipPosition.w * 2.0;
       clipPosition.xy += offset;
       gl_Position = clipPosition;
     }
   }`,`uniform vec3 color;
   uniform float opacity;
   void main(){
     gl_FragColor = vec4(color, opacity);
     #include <tonemapping_fragment>
     #include <colorspace_fragment>
   }`),Ec=u.defineComponent({__name:"component",props:{color:{default:"black"},screenspace:{type:Boolean,default:!1},opacity:{default:1},transparent:{type:Boolean,default:!1},thickness:{default:.05},angle:{default:Math.PI},toneMapped:{type:Boolean,default:!0},polygonOffset:{type:Boolean,default:!1},polygonOffsetFactor:{default:0},renderOrder:{default:0}},setup(i,{expose:e}){const t=i,n=u.shallowRef();e({instance:n});const o=new Xc({...t}),r=new l.Vector2(1,1);let s=0,a=null;function c(f){var d;const m=f.parent;if(!(!m||!m.geometry)&&(s!==t.angle||a!==m.geometry)){s=t.angle,a=m.geometry;let y=(d=f.children)==null?void 0:d[0];y&&(t.angle&&y.geometry.dispose(),f.remove(y)),m.skeleton?(y=new l.SkinnedMesh,y.material=o,y.bind(m.skeleton,m.bindMatrix),f.add(y)):m.isInstancedMesh?(y=new l.InstancedMesh(m.geometry,o,m.count),y.instanceMatrix=m.instanceMatrix,f.add(y)):(y=new l.Mesh,y.material=o,f.add(y)),y.geometry=t.angle?$i(m.geometry,t.angle):m.geometry}}function h(){o.side=l.BackSide,o.transparent=t.transparent,o.thickness=t.thickness,o.color=H.normalizeColor(t.color),o.opacity=t.opacity,o.size=r,o.screenspace=t.screenspace,o.toneMapped=t.toneMapped,o.polygonOffset=t.polygonOffset,o.polygonOffsetFactor=t.polygonOffsetFactor}const p=H.useTres().sizes;return u.watch(()=>[p.width.value,p.height.value],([f,m])=>{r.set(f,m)}),u.watch(()=>[t.angle],()=>{n.value&&c(n.value)}),u.watch(()=>[t.transparent,t.thickness,t.color,t.opacity,r,t.screenspace,t.toneMapped,t.polygonOffset,t.polygonOffsetFactor],()=>h(),{immediate:!0}),u.onMounted(()=>c(n.value)),u.onUnmounted(()=>{var m;const f=(m=n.value)==null?void 0:m.children[0];f&&(f.geometry.dispose(),o.dispose(),f.removeFromParent())}),(f,m)=>(u.openBlock(),u.createElementBlock("TresGroup",{ref_key:"groupRef",ref:n},null,512))}}),Zc=["args"],Kc=u.defineComponent({__name:"PositionalAudio",props:{ready:{type:Boolean,default:!1},url:{},distance:{default:2},helper:{type:Boolean,default:!1},loop:{type:Boolean,default:!1},autoplay:{type:Boolean,default:!1},innerAngle:{default:360},outerAngle:{default:360},outerGain:{default:0}},emits:["isPlaying"],async setup(i,{expose:e,emit:t}){let n,o;const r=i,s=t,{ready:a,url:c,distance:h,helper:p,loop:f,autoplay:m,innerAngle:d,outerAngle:y,outerGain:_}=u.toRefs(r),{camera:v}=H.useTresContext(),g=u.shallowRef(null),A=u.shallowRef(null),w=u.shallowRef(null),C=u.shallowReactive(new l.AudioListener),L=()=>{var z,G,E;(z=g==null?void 0:g.value)!=null&&z.isPlaying||((G=g==null?void 0:g.value)==null||G.play(),s("isPlaying",(E=g==null?void 0:g.value)==null?void 0:E.isPlaying))},M=()=>{var z,G;(z=g==null?void 0:g.value)!=null&&z.isPlaying&&(g.value.pause(),s("isPlaying",(G=g==null?void 0:g.value)==null?void 0:G.isPlaying))},P=()=>{var z;g.value&&(g.value.stop(),s("isPlaying",(z=g==null?void 0:g.value)==null?void 0:z.isPlaying))},b=()=>{if(!(g!=null&&g.value))return;P();const z=g.value;z.source&&z.disconnect()},S=()=>{var z,G;!(g!=null&&g.value)||!(A!=null&&A.value)||((z=A==null?void 0:A.value)==null||z.dispose(),(G=g==null?void 0:g.value)==null||G.remove(A==null?void 0:A.value))},x=()=>{var z;if(g.value&&(g.value.setBuffer(w.value),g.value.setRefDistance(h.value),g.value.setLoop(f.value),g.value.setDirectionalCone(d.value,y.value,_.value),(z=A==null?void 0:A.value)==null||z.update(),A!=null&&A.value)){const G=A.value.material[0];!G.visible&&y.value!==d.value&&(G.visible=!0)}},I=()=>{var X,oe;x();const z=(X=g.value)==null?void 0:X.parent,G=new l.Box3().setFromObject(z),E=(G.max.z-G.min.z)*2;A.value=new Mc(g.value,E,32,16),(oe=g==null?void 0:g.value)==null||oe.add(A.value),A.value.update()},D=()=>{var z;(z=v==null?void 0:v.value)==null||z.remove(C),b(),S()};return e({instance:g,play:L,stop:P,pause:M,dispose:D}),w.value=([n,o]=u.withAsyncContext(()=>H.useLoader(l.AudioLoader,c.value)),n=await n,o(),n),u.watch(g,()=>{g!=null&&g.value&&(p.value&&I(),a.value&&m&&L())}),u.watch(p,()=>{p.value?I():S()}),u.watch(a,()=>{a.value&&x(),m.value&&a.value&&L(),!m.value&&a.value&&P()}),u.watch([h,f,w,d,y,_,m],()=>{x()}),u.onMounted(()=>{var z;(z=v==null?void 0:v.value)==null||z.add(C)}),u.onBeforeUnmount(()=>{D()}),(z,G)=>(u.openBlock(),u.createElementBlock("TresPositionalAudio",u.mergeProps({ref_key:"positionalAudioRef",ref:g,args:[u.unref(C)]},z.$attrs),null,16,Zc))}}),qc=["args","material-uniforms-color-value"],Qc=u.defineComponent({__name:"Reflector",props:{color:{default:"#333"},textureWidth:{default:512},textureHeight:{default:512},clipBias:{default:0},multisample:{default:4},shader:{default:Qn.ReflectorShader}},setup(i,{expose:e}){const t=i,{extend:n,invalidate:o}=H.useTresContext(),r=u.shallowRef();n({Reflector:Qn});const{color:s,textureWidth:a,textureHeight:c,clipBias:h,multisample:p,shader:f}=u.toRefs(t);return u.watch(t,()=>o()),e({instance:r}),(m,d)=>(u.openBlock(),u.createElementBlock("TresReflector",{ref_key:"reflectorRef",ref:r,args:[void 0,{textureWidth:u.unref(a),textureHeight:u.unref(c),clipBias:u.unref(h),multisample:u.unref(p),shader:u.unref(f)}],"material-uniforms-color-value":u.unref(s)},[u.renderSlot(m.$slots,"default",{},()=>[d[0]||(d[0]=u.createElementVNode("TresPlaneGeometry",{args:[5,5]},null,-1))])],8,qc))}}),Jc=["position-z"],Hc=u.defineComponent({__name:"ScreenSpace",props:{depth:{default:-1}},setup(i,{expose:e}){const t=u.shallowRef();return H.useLoop().onBeforeRender(({camera:n})=>{t.value&&(t.value.quaternion.copy(n.quaternion),t.value.position.copy(n.position))}),e({instance:t}),(n,o)=>(u.openBlock(),u.createElementBlock("TresGroup",{ref_key:"outerRef",ref:t},[u.createElementVNode("TresGroup",{"position-z":-n.depth},[u.renderSlot(n.$slots,"default")],8,Jc)],512))}}),$c=["args","center"],eu=u.defineComponent({__name:"Text3D",props:{font:{},text:{},size:{default:.5},height:{default:.2},curveSegments:{default:5},bevelEnabled:{type:Boolean,default:!0},bevelThickness:{default:.05},bevelSize:{default:.02},bevelOffset:{default:0},bevelSegments:{default:4},center:{type:Boolean,default:!1},needUpdates:{type:Boolean,default:!1}},async setup(i,{expose:e}){let t,n;const o=i,{center:r,font:s,text:a,needUpdates:c,size:h,height:p,curveSegments:f,bevelEnabled:m,bevelThickness:d,bevelSize:y,bevelOffset:_,bevelSegments:v}=u.toRefs(o),{extend:g,invalidate:A}=H.useTresContext();u.watch(o,()=>A()),g({TextGeometry:Or});const w=new dc,C=u.useSlots(),L=u.computed(()=>{var S;return a!=null&&a.value?a.value:C.default?(S=C.default()[0].children)==null?void 0:S.trim():c.value?"":"TresJS"}),M=u.shallowRef();e({instance:M});const P=([t,n]=u.withAsyncContext(()=>new Promise((S,x)=>{try{typeof s.value=="string"?w.load(s.value,I=>{S(I)}):S(s.value)}catch(I){x(console.error("cientos",I))}})),t=await t,n(),t),b=u.computed(()=>({font:P,size:u.toValue(h),height:u.toValue(p),curveSegments:u.toValue(f),bevelEnabled:u.toValue(m),bevelThickness:u.toValue(d),bevelSize:u.toValue(y),bevelOffset:u.toValue(_),bevelSegments:u.toValue(v)}));return u.watchEffect(()=>{M.value&&c.value&&(M.value.geometry.dispose(),M.value.geometry=new Or(L.value,b.value),r.value&&M.value.geometry.center())}),(S,x)=>u.unref(s)?(u.openBlock(),u.createElementBlock("TresMesh",{key:0,ref_key:"text3DRef",ref:M},[L.value?(u.openBlock(),u.createElementBlock("TresTextGeometry",{key:0,args:[L.value,b.value],center:u.unref(r)},null,8,$c)):u.createCommentVNode("",!0),u.renderSlot(S.$slots,"default")],512)):u.createCommentVNode("",!0)}});function tu(i,e){const t=u.ref(e),n=new l.AnimationMixer(t.value),o=u.shallowReactive({});i.forEach(s=>{const a=n.clipAction(s,t.value);o[s.name]=a});const{onBeforeRender:r}=H.useLoop();return r(({delta:s})=>{n.update(s)}),{actions:o,mixer:n}}function nu(i,e=!1){const t=u.reactive({stencilWrite:!0,stencilRef:u.toValue(i),stencilFunc:u.toValue(e)?l.NotEqualStencilFunc:l.EqualStencilFunc,stencilFail:l.KeepStencilOp,stencilZFail:l.KeepStencilOp,stencilZPass:l.KeepStencilOp});return u.watchEffect(()=>{t.stencilRef=u.toValue(i),t.stencilFunc=u.toValue(e)?l.NotEqualStencilFunc:l.EqualStencilFunc}),t}function os(i){const e=u.ref(null),{height:t,width:n,settings:o,depth:r,autoRender:s=u.ref(!0)}=u.isReactive(i)?u.toRefs(i):u.toRefs(u.reactive(i)),{onBeforeRender:a}=H.useLoop(),{camera:c,renderer:h,scene:p,sizes:f,invalidate:m}=H.useTresContext();return u.watch(()=>[n==null?void 0:n.value,f.width.value,t==null?void 0:t.value,f.height.value],()=>{var d;(d=e.value)==null||d.dispose(),e.value=new l.WebGLRenderTarget((n==null?void 0:n.value)||f.width.value,(t==null?void 0:t.value)||f.height.value,{minFilter:l.LinearFilter,magFilter:l.LinearFilter,type:l.HalfFloatType,...o==null?void 0:o.value}),r!=null&&r.value&&(e.value.depthTexture=new l.DepthTexture((n==null?void 0:n.value)||f.width.value,(t==null?void 0:t.value)||f.height.value,l.FloatType)),m()},{immediate:!0}),a(()=>{s.value&&(h.value.setRenderTarget(e.value),h.value.clear(),h.value.render(p.value,c.value),h.value.setRenderTarget(null))},Number.POSITIVE_INFINITY),u.onBeforeUnmount(()=>{var d;(d=e.value)==null||d.dispose()}),e}const ou=u.defineComponent({__name:"component",props:{width:{},height:{},depth:{type:Boolean,default:!1},settings:{default:void 0},autoRender:{type:Boolean,default:!0}},setup(i,{expose:e}){const n=os(i);return e({instance:n}),()=>{}}}),rs=(i,e=16,t,n,o)=>{const r=new Float32Array(e*16),s=u.ref(new l.InterleavedBuffer(r,16));return(()=>{if(!i)return;const c=new Ea(i);n&&c.setWeightAttribute(n),c.build();const h=new l.Vector3,p=new l.Vector3,f=new l.Color,m=new l.Object3D;i.updateMatrixWorld(!0);for(let d=0;d<e;d++)c.sample(h,p,f),typeof o=="function"?o({dummy:m,sampledMesh:i,position:h,normal:p,color:f},d):m.position.copy(h),m.updateMatrix(),t&&t.setMatrixAt(d,m.matrix),m.matrix.toArray(s.value.array,d*16);t&&(t.instanceMatrix.needsUpdate=!0),s.value.needsUpdate=!0})(),{buffer:s}},ru=u.defineComponent({__name:"component",props:{transform:{type:Function},weight:{},count:{},mesh:{},instanceMesh:{}},setup(i,{expose:e}){const t=i,n=u.ref(),o=u.ref(),r=u.ref(),{invalidate:s}=H.useTresContext();return u.watch(t,()=>s()),u.watchEffect(()=>{var a,c;o.value=t.instanceMesh??((a=n.value)==null?void 0:a.children.find(h=>Object.prototype.hasOwnProperty.call(h,"instanceMatrix"))),r.value=t.mesh??((c=n.value)==null?void 0:c.children.find(h=>h.type==="Mesh")),rs(r.value,t.count,o.value,t.weight,t.transform)}),e({samplerRef:n}),(a,c)=>(u.openBlock(),u.createElementBlock("TresGroup",{ref_key:"samplerRef",ref:n},[u.renderSlot(a.$slots,"default")],512))}}),su=new Ot.Vector3,iu=new Ot.Vector3,au=new Ot.Vector3,lu=(i,e,t)=>{const n=t.width/2,o=t.height/2;e.updateMatrixWorld(!1);const r=i.project(e);return r.x=r.x*n+n,r.y=-(r.y*o)+o,r},cu=(i,e,t,n=1)=>{const o=su.set(i.x/t.width*2-1,-(i.y/t.height)*2+1,n);return o.unproject(e),o},uu=(i,e,t,n)=>{const o=lu(au.copy(i),t,n);let r=0;for(let s=0;s<2;++s){const a=iu.copy(o).setComponent(s,o.getComponent(s)+e),c=cu(a,t,n,a.z);r=Math.max(r,i.distanceTo(c))}return r},hu=u.defineComponent({__name:"ScreenSizer",setup(i,{expose:e}){const t=new l.Vector3,n=u.shallowRef(),o=u.shallowRef(),r=H.useTres().sizes,s=u.computed(()=>({width:r.width.value,height:r.height.value}));return H.useLoop().onBeforeRender(({camera:a})=>{const c=o.value;if(!c)return;const h=uu(c.getWorldPosition(t),1,a,s.value);c.scale.setScalar(h)}),e({instance:n}),(a,c)=>(u.openBlock(),u.createElementBlock("TresObject3D",{ref_key:"outerRef",ref:n},[u.createElementVNode("TresObject3D",{ref_key:"innerRef",ref:o},[u.renderSlot(a.$slots,"default")],512)],512))}}),fu=["color"],du=u.defineComponent({__name:"Edges",props:{color:{default:"#ff0000"},threshold:{default:15}},setup(i,{expose:e}){const t=i,{color:n,threshold:o}=u.toRefs(t),r=u.shallowRef(),s=u.ref(null),a=u.ref(1);return e({instance:r}),u.watch(()=>[r.value,o.value],()=>{if(r.value){const c=r.value.parent;if(c&&"geometry"in c&&c.geometry instanceof l.BufferGeometry){const h=c.geometry;(h!==s.value||o.value!==a.value)&&(s.value=h,a.value=o.value,r.value.geometry=new l.EdgesGeometry(h,o.value))}}}),(c,h)=>(u.openBlock(),u.createElementBlock("TresLineSegments",u.mergeProps({ref_key:"lineSegmentsRef",ref:r},c.$attrs),[u.renderSlot(c.$slots,"default",{},()=>[u.createElementVNode("TresLineBasicMaterial",{color:u.unref(n)},null,8,fu)])],16))}}),An={sunset:"venice/venice_sunset_1k.hdr",studio:"studio/poly_haven_studio_1k.hdr",city:"city/canary_wharf_1k.hdr",umbrellas:"outdoor/outdoor_umbrellas_1k.hdr",night:"outdoor/satara_night_1k.hdr",forest:"outood/mossy_forest_1k.hdr",snow:"outdoor/snowy_forest_path_01_1k.hdr",dawn:"kiara/kiara_1_dawn_1k.hdr",hangar:"indoor/small_hangar_01_1k.hdr",urban:"indoor/abandoned_games_room_02_1k.hdr",modern:"city/modern_buildings_2_1k.hdr",shangai:"city/shanghai_bund_1k.hdr"},pu="https://raw.githubusercontent.com/Tresjs/assets/main/textures/hdr/";function go(i){return i instanceof l.Euler?i:Array.isArray(i)?new l.Euler(i[0],i[1],i[2]):typeof i=="number"?new l.Euler(i,i,i):i instanceof l.Vector3?new l.Euler(i.x,i.y,i.z):typeof i=="object"&&"x"in i&&"y"in i&&"z"in i?new l.Euler(i.x,i.y,i.z):null}function ss(i){i.traverse(e=>{e instanceof l.Mesh&&e.material&&(e.material.needsUpdate=!0)})}async function is(i,e){const{scene:t,invalidate:n}=H.useTresContext(),{preset:o,blur:r,files:s=u.ref([]),path:a=u.ref(""),background:c,backgroundIntensity:h=u.ref(1),environmentIntensity:p=u.ref(1),backgroundRotation:f=u.ref([0,0,0]),environmentRotation:m=u.ref([0,0,0]),syncMaterials:d=u.ref(!1)}=u.toRefs(i);u.watch(i,()=>{n()});const y=u.ref(null),_=u.computed(()=>Array.isArray(s.value)),v=u.computed(()=>_.value?l.CubeTextureLoader:Gr);return u.watch([s,a],async([g,A])=>{if(g&&g.length>0&&!(o!=null&&o.value)){try{const w=await H.useLoader(v.value,_.value?[...u.unref(g)]:u.unref(g),C=>{A&&C.setPath(u.unref(A))});y.value=Array.isArray(w)?w[0]:w}catch(w){throw new Error(`Failed to load environment map: ${w}`)}y.value&&(y.value.mapping=_.value?l.CubeReflectionMapping:l.EquirectangularReflectionMapping)}},{immediate:!0}),u.watch(y,g=>{t.value&&g&&(t.value.environment=g)},{immediate:!0}),u.watch([c,y],([g,A])=>{if(t.value){const w=e!=null&&e.value?e.value.texture:A;w&&(t.value.background=g?w:null)}},{immediate:!0}),u.watch(()=>r==null?void 0:r.value,g=>{t.value&&g&&(t.value.backgroundBlurriness=g)},{immediate:!0}),u.watch(()=>h==null?void 0:h.value,g=>{t.value&&(t.value.backgroundIntensity=g??1)},{immediate:!0}),u.watch(()=>p==null?void 0:p.value,g=>{t.value&&(t.value.environmentIntensity=g??1)},{immediate:!0}),u.watch(()=>f==null?void 0:f.value,g=>{if(t.value){const A=go(g);A&&(t.value.backgroundRotation=A)}},{immediate:!0}),u.watch(()=>m==null?void 0:m.value,g=>{if(t.value&&!(d!=null&&d.value)){const A=go(g);A&&(t.value.environmentRotation=A,ss(t.value))}},{immediate:!0}),u.watch(()=>o==null?void 0:o.value,async g=>{if(g&&g in An){const A=pu,w=An[g];try{const C=await H.useLoader(Gr,w,L=>{A&&L.setPath(A)});y.value=Array.isArray(C)?C[0]:C}catch(C){throw new Error(`Failed to load environment map: ${C}`)}y.value&&(y.value.mapping=l.EquirectangularReflectionMapping),n()}else if(g&&!(g in An))throw new Error(`Preset must be one of: ${Object.keys(An).join(", ")}`)},{immediate:!0}),u.watch([d,f],([g,A])=>{if(g&&t.value){const w=go(A);w&&(t.value.environmentRotation=w,ss(t.value))}},{immediate:!0}),y}/*!
 * camera-controls
 * https://github.com/yomotsu/camera-controls
 * (c) 2017 @yomotsu
 * Released under the MIT License.
 */const Oe={LEFT:1,RIGHT:2,MIDDLE:4},$=Object.freeze({NONE:0,ROTATE:1,TRUCK:2,OFFSET:4,DOLLY:8,ZOOM:16,TOUCH_ROTATE:32,TOUCH_TRUCK:64,TOUCH_OFFSET:128,TOUCH_DOLLY:256,TOUCH_ZOOM:512,TOUCH_DOLLY_TRUCK:1024,TOUCH_DOLLY_OFFSET:2048,TOUCH_DOLLY_ROTATE:4096,TOUCH_ZOOM_TRUCK:8192,TOUCH_ZOOM_OFFSET:16384,TOUCH_ZOOM_ROTATE:32768}),Ft={NONE:0,IN:1,OUT:-1};function Ct(i){return i.isPerspectiveCamera}function vt(i){return i.isOrthographicCamera}const zt=Math.PI*2,as=Math.PI/2,ls=1e-5,Ht=Math.PI/180;function $e(i,e,t){return Math.max(e,Math.min(t,i))}function Te(i,e=ls){return Math.abs(i)<e}function Se(i,e,t=ls){return Te(i-e,t)}function cs(i,e){return Math.round(i/e)*e}function $t(i){return isFinite(i)?i:i<0?-Number.MAX_VALUE:Number.MAX_VALUE}function en(i){return Math.abs(i)<Number.MAX_VALUE?i:i*(1/0)}function Pn(i,e,t,n,o=1/0,r){n=Math.max(1e-4,n);const s=2/n,a=s*r,c=1/(1+a+.48*a*a+.235*a*a*a);let h=i-e;const p=e,f=o*n;h=$e(h,-f,f),e=i-h;const m=(t.value+s*h)*r;t.value=(t.value-s*m)*c;let d=e+(h+m)*c;return p-i>0==d>p&&(d=p,t.value=(d-p)/r),d}function us(i,e,t,n,o=1/0,r,s){n=Math.max(1e-4,n);const a=2/n,c=a*r,h=1/(1+c+.48*c*c+.235*c*c*c);let p=e.x,f=e.y,m=e.z,d=i.x-p,y=i.y-f,_=i.z-m;const v=p,g=f,A=m,w=o*n,C=w*w,L=d*d+y*y+_*_;if(L>C){const E=Math.sqrt(L);d=d/E*w,y=y/E*w,_=_/E*w}p=i.x-d,f=i.y-y,m=i.z-_;const M=(t.x+a*d)*r,P=(t.y+a*y)*r,b=(t.z+a*_)*r;t.x=(t.x-a*M)*h,t.y=(t.y-a*P)*h,t.z=(t.z-a*b)*h,s.x=p+(d+M)*h,s.y=f+(y+P)*h,s.z=m+(_+b)*h;const S=v-i.x,x=g-i.y,I=A-i.z,D=s.x-v,z=s.y-g,G=s.z-A;return S*D+x*z+I*G>0&&(s.x=v,s.y=g,s.z=A,t.x=(s.x-v)/r,t.y=(s.y-g)/r,t.z=(s.z-A)/r),s}function yo(i,e){e.set(0,0),i.forEach(t=>{e.x+=t.clientX,e.y+=t.clientY}),e.x/=i.length,e.y/=i.length}function _o(i,e){return vt(i)?(console.warn(`${e} is not supported in OrthographicCamera`),!0):!1}class mu{constructor(){this._listeners={}}addEventListener(e,t){const n=this._listeners;n[e]===void 0&&(n[e]=[]),n[e].indexOf(t)===-1&&n[e].push(t)}hasEventListener(e,t){const n=this._listeners;return n[e]!==void 0&&n[e].indexOf(t)!==-1}removeEventListener(e,t){const o=this._listeners[e];if(o!==void 0){const r=o.indexOf(t);r!==-1&&o.splice(r,1)}}removeAllEventListeners(e){if(!e){this._listeners={};return}Array.isArray(this._listeners[e])&&(this._listeners[e].length=0)}dispatchEvent(e){const n=this._listeners[e.type];if(n!==void 0){e.target=this;const o=n.slice(0);for(let r=0,s=o.length;r<s;r++)o[r].call(this,e)}}}var vo;const gu="2.9.0",Cn=1/8,yu=/Mac/.test((vo=globalThis==null?void 0:globalThis.navigator)===null||vo===void 0?void 0:vo.platform);let pe,hs,Tn,xo,je,ye,be,Vt,tn,ot,rt,Tt,fs,ds,Qe,nn,Gt,ps,wo,ms,bo,Mo,In;class Ve extends mu{static install(e){pe=e.THREE,hs=Object.freeze(new pe.Vector3(0,0,0)),Tn=Object.freeze(new pe.Vector3(0,1,0)),xo=Object.freeze(new pe.Vector3(0,0,1)),je=new pe.Vector2,ye=new pe.Vector3,be=new pe.Vector3,Vt=new pe.Vector3,tn=new pe.Vector3,ot=new pe.Vector3,rt=new pe.Vector3,Tt=new pe.Vector3,fs=new pe.Vector3,ds=new pe.Vector3,Qe=new pe.Spherical,nn=new pe.Spherical,Gt=new pe.Box3,ps=new pe.Box3,wo=new pe.Sphere,ms=new pe.Quaternion,bo=new pe.Quaternion,Mo=new pe.Matrix4,In=new pe.Raycaster}static get ACTION(){return $}constructor(e,t){super(),this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.minDistance=Number.EPSILON,this.maxDistance=1/0,this.infinityDolly=!1,this.minZoom=.01,this.maxZoom=1/0,this.smoothTime=.25,this.draggingSmoothTime=.125,this.maxSpeed=1/0,this.azimuthRotateSpeed=1,this.polarRotateSpeed=1,this.dollySpeed=1,this.dollyDragInverted=!1,this.truckSpeed=2,this.dollyToCursor=!1,this.dragToOffset=!1,this.verticalDragToForward=!1,this.boundaryFriction=0,this.restThreshold=.01,this.colliderMeshes=[],this.cancel=()=>{},this._enabled=!0,this._state=$.NONE,this._viewport=null,this._changedDolly=0,this._changedZoom=0,this._hasRested=!0,this._boundaryEnclosesCamera=!1,this._needsUpdate=!0,this._updatedLastTime=!1,this._elementRect=new DOMRect,this._isDragging=!1,this._dragNeedsUpdate=!0,this._activePointers=[],this._lockedPointer=null,this._interactiveArea=new DOMRect(0,0,1,1),this._isUserControllingRotate=!1,this._isUserControllingDolly=!1,this._isUserControllingTruck=!1,this._isUserControllingOffset=!1,this._isUserControllingZoom=!1,this._lastDollyDirection=Ft.NONE,this._thetaVelocity={value:0},this._phiVelocity={value:0},this._radiusVelocity={value:0},this._targetVelocity=new pe.Vector3,this._focalOffsetVelocity=new pe.Vector3,this._zoomVelocity={value:0},this._truckInternal=(g,A,w)=>{let C,L;if(Ct(this._camera)){const M=ye.copy(this._camera.position).sub(this._target),P=this._camera.getEffectiveFOV()*Ht,b=M.length()*Math.tan(P*.5);C=this.truckSpeed*g*b/this._elementRect.height,L=this.truckSpeed*A*b/this._elementRect.height}else if(vt(this._camera)){const M=this._camera;C=g*(M.right-M.left)/M.zoom/this._elementRect.width,L=A*(M.top-M.bottom)/M.zoom/this._elementRect.height}else return;this.verticalDragToForward?(w?this.setFocalOffset(this._focalOffsetEnd.x+C,this._focalOffsetEnd.y,this._focalOffsetEnd.z,!0):this.truck(C,0,!0),this.forward(-L,!0)):w?this.setFocalOffset(this._focalOffsetEnd.x+C,this._focalOffsetEnd.y+L,this._focalOffsetEnd.z,!0):this.truck(C,L,!0)},this._rotateInternal=(g,A)=>{const w=zt*this.azimuthRotateSpeed*g/this._elementRect.height,C=zt*this.polarRotateSpeed*A/this._elementRect.height;this.rotate(w,C,!0)},this._dollyInternal=(g,A,w)=>{const C=Math.pow(.95,-g*this.dollySpeed),L=this._sphericalEnd.radius,M=this._sphericalEnd.radius*C,P=$e(M,this.minDistance,this.maxDistance),b=P-M;this.infinityDolly&&this.dollyToCursor?this._dollyToNoClamp(M,!0):this.infinityDolly&&!this.dollyToCursor?(this.dollyInFixed(b,!0),this._dollyToNoClamp(P,!0)):this._dollyToNoClamp(P,!0),this.dollyToCursor&&(this._changedDolly+=(this.infinityDolly?M:P)-L,this._dollyControlCoord.set(A,w)),this._lastDollyDirection=Math.sign(-g)},this._zoomInternal=(g,A,w)=>{const C=Math.pow(.95,g*this.dollySpeed),L=this._zoom,M=this._zoom*C;this.zoomTo(M,!0),this.dollyToCursor&&(this._changedZoom+=M-L,this._dollyControlCoord.set(A,w))},typeof pe>"u"&&console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."),this._camera=e,this._yAxisUpSpace=new pe.Quaternion().setFromUnitVectors(this._camera.up,Tn),this._yAxisUpSpaceInverse=this._yAxisUpSpace.clone().invert(),this._state=$.NONE,this._target=new pe.Vector3,this._targetEnd=this._target.clone(),this._focalOffset=new pe.Vector3,this._focalOffsetEnd=this._focalOffset.clone(),this._spherical=new pe.Spherical().setFromVector3(ye.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)),this._sphericalEnd=this._spherical.clone(),this._lastDistance=this._spherical.radius,this._zoom=this._camera.zoom,this._zoomEnd=this._zoom,this._lastZoom=this._zoom,this._nearPlaneCorners=[new pe.Vector3,new pe.Vector3,new pe.Vector3,new pe.Vector3],this._updateNearPlaneCorners(),this._boundary=new pe.Box3(new pe.Vector3(-1/0,-1/0,-1/0),new pe.Vector3(1/0,1/0,1/0)),this._cameraUp0=this._camera.up.clone(),this._target0=this._target.clone(),this._position0=this._camera.position.clone(),this._zoom0=this._zoom,this._focalOffset0=this._focalOffset.clone(),this._dollyControlCoord=new pe.Vector2,this.mouseButtons={left:$.ROTATE,middle:$.DOLLY,right:$.TRUCK,wheel:Ct(this._camera)?$.DOLLY:vt(this._camera)?$.ZOOM:$.NONE},this.touches={one:$.TOUCH_ROTATE,two:Ct(this._camera)?$.TOUCH_DOLLY_TRUCK:vt(this._camera)?$.TOUCH_ZOOM_TRUCK:$.NONE,three:$.TOUCH_TRUCK};const n=new pe.Vector2,o=new pe.Vector2,r=new pe.Vector2,s=g=>{if(!this._enabled||!this._domElement)return;if(this._interactiveArea.left!==0||this._interactiveArea.top!==0||this._interactiveArea.width!==1||this._interactiveArea.height!==1){const C=this._domElement.getBoundingClientRect(),L=g.clientX/C.width,M=g.clientY/C.height;if(L<this._interactiveArea.left||L>this._interactiveArea.right||M<this._interactiveArea.top||M>this._interactiveArea.bottom)return}const A=g.pointerType!=="mouse"?null:(g.buttons&Oe.LEFT)===Oe.LEFT?Oe.LEFT:(g.buttons&Oe.MIDDLE)===Oe.MIDDLE?Oe.MIDDLE:(g.buttons&Oe.RIGHT)===Oe.RIGHT?Oe.RIGHT:null;if(A!==null){const C=this._findPointerByMouseButton(A);C&&this._disposePointer(C)}if((g.buttons&Oe.LEFT)===Oe.LEFT&&this._lockedPointer)return;const w={pointerId:g.pointerId,clientX:g.clientX,clientY:g.clientY,deltaX:0,deltaY:0,mouseButton:A};this._activePointers.push(w),this._domElement.ownerDocument.removeEventListener("pointermove",a,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",c),this._domElement.ownerDocument.addEventListener("pointermove",a,{passive:!1}),this._domElement.ownerDocument.addEventListener("pointerup",c),this._isDragging=!0,m(g)},a=g=>{g.cancelable&&g.preventDefault();const A=g.pointerId,w=this._lockedPointer||this._findPointerById(A);if(w){if(w.clientX=g.clientX,w.clientY=g.clientY,w.deltaX=g.movementX,w.deltaY=g.movementY,this._state=0,g.pointerType==="touch")switch(this._activePointers.length){case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three;break}else(!this._isDragging&&this._lockedPointer||this._isDragging&&(g.buttons&Oe.LEFT)===Oe.LEFT)&&(this._state=this._state|this.mouseButtons.left),this._isDragging&&(g.buttons&Oe.MIDDLE)===Oe.MIDDLE&&(this._state=this._state|this.mouseButtons.middle),this._isDragging&&(g.buttons&Oe.RIGHT)===Oe.RIGHT&&(this._state=this._state|this.mouseButtons.right);d()}},c=g=>{const A=this._findPointerById(g.pointerId);if(!(A&&A===this._lockedPointer)){if(A&&this._disposePointer(A),g.pointerType==="touch")switch(this._activePointers.length){case 0:this._state=$.NONE;break;case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three;break}else this._state=$.NONE;y()}};let h=-1;const p=g=>{if(!this._domElement||!this._enabled||this.mouseButtons.wheel===$.NONE)return;if(this._interactiveArea.left!==0||this._interactiveArea.top!==0||this._interactiveArea.width!==1||this._interactiveArea.height!==1){const M=this._domElement.getBoundingClientRect(),P=g.clientX/M.width,b=g.clientY/M.height;if(P<this._interactiveArea.left||P>this._interactiveArea.right||b<this._interactiveArea.top||b>this._interactiveArea.bottom)return}if(g.preventDefault(),this.dollyToCursor||this.mouseButtons.wheel===$.ROTATE||this.mouseButtons.wheel===$.TRUCK){const M=performance.now();h-M<1e3&&this._getClientRect(this._elementRect),h=M}const A=yu?-1:-3,w=g.deltaMode===1?g.deltaY/A:g.deltaY/(A*10),C=this.dollyToCursor?(g.clientX-this._elementRect.x)/this._elementRect.width*2-1:0,L=this.dollyToCursor?(g.clientY-this._elementRect.y)/this._elementRect.height*-2+1:0;switch(this.mouseButtons.wheel){case $.ROTATE:{this._rotateInternal(g.deltaX,g.deltaY),this._isUserControllingRotate=!0;break}case $.TRUCK:{this._truckInternal(g.deltaX,g.deltaY,!1),this._isUserControllingTruck=!0;break}case $.OFFSET:{this._truckInternal(g.deltaX,g.deltaY,!0),this._isUserControllingOffset=!0;break}case $.DOLLY:{this._dollyInternal(-w,C,L),this._isUserControllingDolly=!0;break}case $.ZOOM:{this._zoomInternal(-w,C,L),this._isUserControllingZoom=!0;break}}this.dispatchEvent({type:"control"})},f=g=>{if(!(!this._domElement||!this._enabled)){if(this.mouseButtons.right===Ve.ACTION.NONE){const A=g instanceof PointerEvent?g.pointerId:0,w=this._findPointerById(A);w&&this._disposePointer(w),this._domElement.ownerDocument.removeEventListener("pointermove",a,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",c);return}g.preventDefault()}},m=g=>{if(!this._enabled)return;if(yo(this._activePointers,je),this._getClientRect(this._elementRect),n.copy(je),o.copy(je),this._activePointers.length>=2){const w=je.x-this._activePointers[1].clientX,C=je.y-this._activePointers[1].clientY,L=Math.sqrt(w*w+C*C);r.set(0,L);const M=(this._activePointers[0].clientX+this._activePointers[1].clientX)*.5,P=(this._activePointers[0].clientY+this._activePointers[1].clientY)*.5;o.set(M,P)}if(this._state=0,!g)this._lockedPointer&&(this._state=this._state|this.mouseButtons.left);else if("pointerType"in g&&g.pointerType==="touch")switch(this._activePointers.length){case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three;break}else!this._lockedPointer&&(g.buttons&Oe.LEFT)===Oe.LEFT&&(this._state=this._state|this.mouseButtons.left),(g.buttons&Oe.MIDDLE)===Oe.MIDDLE&&(this._state=this._state|this.mouseButtons.middle),(g.buttons&Oe.RIGHT)===Oe.RIGHT&&(this._state=this._state|this.mouseButtons.right);((this._state&$.ROTATE)===$.ROTATE||(this._state&$.TOUCH_ROTATE)===$.TOUCH_ROTATE||(this._state&$.TOUCH_DOLLY_ROTATE)===$.TOUCH_DOLLY_ROTATE||(this._state&$.TOUCH_ZOOM_ROTATE)===$.TOUCH_ZOOM_ROTATE)&&(this._sphericalEnd.theta=this._spherical.theta,this._sphericalEnd.phi=this._spherical.phi,this._thetaVelocity.value=0,this._phiVelocity.value=0),((this._state&$.TRUCK)===$.TRUCK||(this._state&$.TOUCH_TRUCK)===$.TOUCH_TRUCK||(this._state&$.TOUCH_DOLLY_TRUCK)===$.TOUCH_DOLLY_TRUCK||(this._state&$.TOUCH_ZOOM_TRUCK)===$.TOUCH_ZOOM_TRUCK)&&(this._targetEnd.copy(this._target),this._targetVelocity.set(0,0,0)),((this._state&$.DOLLY)===$.DOLLY||(this._state&$.TOUCH_DOLLY)===$.TOUCH_DOLLY||(this._state&$.TOUCH_DOLLY_TRUCK)===$.TOUCH_DOLLY_TRUCK||(this._state&$.TOUCH_DOLLY_OFFSET)===$.TOUCH_DOLLY_OFFSET||(this._state&$.TOUCH_DOLLY_ROTATE)===$.TOUCH_DOLLY_ROTATE)&&(this._sphericalEnd.radius=this._spherical.radius,this._radiusVelocity.value=0),((this._state&$.ZOOM)===$.ZOOM||(this._state&$.TOUCH_ZOOM)===$.TOUCH_ZOOM||(this._state&$.TOUCH_ZOOM_TRUCK)===$.TOUCH_ZOOM_TRUCK||(this._state&$.TOUCH_ZOOM_OFFSET)===$.TOUCH_ZOOM_OFFSET||(this._state&$.TOUCH_ZOOM_ROTATE)===$.TOUCH_ZOOM_ROTATE)&&(this._zoomEnd=this._zoom,this._zoomVelocity.value=0),((this._state&$.OFFSET)===$.OFFSET||(this._state&$.TOUCH_OFFSET)===$.TOUCH_OFFSET||(this._state&$.TOUCH_DOLLY_OFFSET)===$.TOUCH_DOLLY_OFFSET||(this._state&$.TOUCH_ZOOM_OFFSET)===$.TOUCH_ZOOM_OFFSET)&&(this._focalOffsetEnd.copy(this._focalOffset),this._focalOffsetVelocity.set(0,0,0)),this.dispatchEvent({type:"controlstart"})},d=()=>{if(!this._enabled||!this._dragNeedsUpdate)return;this._dragNeedsUpdate=!1,yo(this._activePointers,je);const A=this._domElement&&this._domElement.ownerDocument.pointerLockElement===this._domElement?this._lockedPointer||this._activePointers[0]:null,w=A?-A.deltaX:o.x-je.x,C=A?-A.deltaY:o.y-je.y;if(o.copy(je),((this._state&$.ROTATE)===$.ROTATE||(this._state&$.TOUCH_ROTATE)===$.TOUCH_ROTATE||(this._state&$.TOUCH_DOLLY_ROTATE)===$.TOUCH_DOLLY_ROTATE||(this._state&$.TOUCH_ZOOM_ROTATE)===$.TOUCH_ZOOM_ROTATE)&&(this._rotateInternal(w,C),this._isUserControllingRotate=!0),(this._state&$.DOLLY)===$.DOLLY||(this._state&$.ZOOM)===$.ZOOM){const L=this.dollyToCursor?(n.x-this._elementRect.x)/this._elementRect.width*2-1:0,M=this.dollyToCursor?(n.y-this._elementRect.y)/this._elementRect.height*-2+1:0,P=this.dollyDragInverted?-1:1;(this._state&$.DOLLY)===$.DOLLY?(this._dollyInternal(P*C*Cn,L,M),this._isUserControllingDolly=!0):(this._zoomInternal(P*C*Cn,L,M),this._isUserControllingZoom=!0)}if((this._state&$.TOUCH_DOLLY)===$.TOUCH_DOLLY||(this._state&$.TOUCH_ZOOM)===$.TOUCH_ZOOM||(this._state&$.TOUCH_DOLLY_TRUCK)===$.TOUCH_DOLLY_TRUCK||(this._state&$.TOUCH_ZOOM_TRUCK)===$.TOUCH_ZOOM_TRUCK||(this._state&$.TOUCH_DOLLY_OFFSET)===$.TOUCH_DOLLY_OFFSET||(this._state&$.TOUCH_ZOOM_OFFSET)===$.TOUCH_ZOOM_OFFSET||(this._state&$.TOUCH_DOLLY_ROTATE)===$.TOUCH_DOLLY_ROTATE||(this._state&$.TOUCH_ZOOM_ROTATE)===$.TOUCH_ZOOM_ROTATE){const L=je.x-this._activePointers[1].clientX,M=je.y-this._activePointers[1].clientY,P=Math.sqrt(L*L+M*M),b=r.y-P;r.set(0,P);const S=this.dollyToCursor?(o.x-this._elementRect.x)/this._elementRect.width*2-1:0,x=this.dollyToCursor?(o.y-this._elementRect.y)/this._elementRect.height*-2+1:0;(this._state&$.TOUCH_DOLLY)===$.TOUCH_DOLLY||(this._state&$.TOUCH_DOLLY_ROTATE)===$.TOUCH_DOLLY_ROTATE||(this._state&$.TOUCH_DOLLY_TRUCK)===$.TOUCH_DOLLY_TRUCK||(this._state&$.TOUCH_DOLLY_OFFSET)===$.TOUCH_DOLLY_OFFSET?(this._dollyInternal(b*Cn,S,x),this._isUserControllingDolly=!0):(this._zoomInternal(b*Cn,S,x),this._isUserControllingZoom=!0)}((this._state&$.TRUCK)===$.TRUCK||(this._state&$.TOUCH_TRUCK)===$.TOUCH_TRUCK||(this._state&$.TOUCH_DOLLY_TRUCK)===$.TOUCH_DOLLY_TRUCK||(this._state&$.TOUCH_ZOOM_TRUCK)===$.TOUCH_ZOOM_TRUCK)&&(this._truckInternal(w,C,!1),this._isUserControllingTruck=!0),((this._state&$.OFFSET)===$.OFFSET||(this._state&$.TOUCH_OFFSET)===$.TOUCH_OFFSET||(this._state&$.TOUCH_DOLLY_OFFSET)===$.TOUCH_DOLLY_OFFSET||(this._state&$.TOUCH_ZOOM_OFFSET)===$.TOUCH_ZOOM_OFFSET)&&(this._truckInternal(w,C,!0),this._isUserControllingOffset=!0),this.dispatchEvent({type:"control"})},y=()=>{yo(this._activePointers,je),o.copy(je),this._dragNeedsUpdate=!1,(this._activePointers.length===0||this._activePointers.length===1&&this._activePointers[0]===this._lockedPointer)&&(this._isDragging=!1),this._activePointers.length===0&&this._domElement&&(this._domElement.ownerDocument.removeEventListener("pointermove",a,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",c),this.dispatchEvent({type:"controlend"}))};this.lockPointer=()=>{!this._enabled||!this._domElement||(this.cancel(),this._lockedPointer={pointerId:-1,clientX:0,clientY:0,deltaX:0,deltaY:0,mouseButton:null},this._activePointers.push(this._lockedPointer),this._domElement.ownerDocument.removeEventListener("pointermove",a,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",c),this._domElement.requestPointerLock(),this._domElement.ownerDocument.addEventListener("pointerlockchange",_),this._domElement.ownerDocument.addEventListener("pointerlockerror",v),this._domElement.ownerDocument.addEventListener("pointermove",a,{passive:!1}),this._domElement.ownerDocument.addEventListener("pointerup",c),m())},this.unlockPointer=()=>{var g,A,w;this._lockedPointer!==null&&(this._disposePointer(this._lockedPointer),this._lockedPointer=null),(g=this._domElement)===null||g===void 0||g.ownerDocument.exitPointerLock(),(A=this._domElement)===null||A===void 0||A.ownerDocument.removeEventListener("pointerlockchange",_),(w=this._domElement)===null||w===void 0||w.ownerDocument.removeEventListener("pointerlockerror",v),this.cancel()};const _=()=>{this._domElement&&this._domElement.ownerDocument.pointerLockElement===this._domElement||this.unlockPointer()},v=()=>{this.unlockPointer()};this._addAllEventListeners=g=>{this._domElement=g,this._domElement.style.touchAction="none",this._domElement.style.userSelect="none",this._domElement.style.webkitUserSelect="none",this._domElement.addEventListener("pointerdown",s),this._domElement.addEventListener("pointercancel",c),this._domElement.addEventListener("wheel",p,{passive:!1}),this._domElement.addEventListener("contextmenu",f)},this._removeAllEventListeners=()=>{this._domElement&&(this._domElement.style.touchAction="",this._domElement.style.userSelect="",this._domElement.style.webkitUserSelect="",this._domElement.removeEventListener("pointerdown",s),this._domElement.removeEventListener("pointercancel",c),this._domElement.removeEventListener("wheel",p,{passive:!1}),this._domElement.removeEventListener("contextmenu",f),this._domElement.ownerDocument.removeEventListener("pointermove",a,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",c),this._domElement.ownerDocument.removeEventListener("pointerlockchange",_),this._domElement.ownerDocument.removeEventListener("pointerlockerror",v))},this.cancel=()=>{this._state!==$.NONE&&(this._state=$.NONE,this._activePointers.length=0,y())},t&&this.connect(t),this.update(0)}get camera(){return this._camera}set camera(e){this._camera=e,this.updateCameraUp(),this._camera.updateProjectionMatrix(),this._updateNearPlaneCorners(),this._needsUpdate=!0}get enabled(){return this._enabled}set enabled(e){this._enabled=e,this._domElement&&(e?(this._domElement.style.touchAction="none",this._domElement.style.userSelect="none",this._domElement.style.webkitUserSelect="none"):(this.cancel(),this._domElement.style.touchAction="",this._domElement.style.userSelect="",this._domElement.style.webkitUserSelect=""))}get active(){return!this._hasRested}get currentAction(){return this._state}get distance(){return this._spherical.radius}set distance(e){this._spherical.radius===e&&this._sphericalEnd.radius===e||(this._spherical.radius=e,this._sphericalEnd.radius=e,this._needsUpdate=!0)}get azimuthAngle(){return this._spherical.theta}set azimuthAngle(e){this._spherical.theta===e&&this._sphericalEnd.theta===e||(this._spherical.theta=e,this._sphericalEnd.theta=e,this._needsUpdate=!0)}get polarAngle(){return this._spherical.phi}set polarAngle(e){this._spherical.phi===e&&this._sphericalEnd.phi===e||(this._spherical.phi=e,this._sphericalEnd.phi=e,this._needsUpdate=!0)}get boundaryEnclosesCamera(){return this._boundaryEnclosesCamera}set boundaryEnclosesCamera(e){this._boundaryEnclosesCamera=e,this._needsUpdate=!0}set interactiveArea(e){this._interactiveArea.width=$e(e.width,0,1),this._interactiveArea.height=$e(e.height,0,1),this._interactiveArea.x=$e(e.x,0,1-this._interactiveArea.width),this._interactiveArea.y=$e(e.y,0,1-this._interactiveArea.height)}addEventListener(e,t){super.addEventListener(e,t)}removeEventListener(e,t){super.removeEventListener(e,t)}rotate(e,t,n=!1){return this.rotateTo(this._sphericalEnd.theta+e,this._sphericalEnd.phi+t,n)}rotateAzimuthTo(e,t=!1){return this.rotateTo(e,this._sphericalEnd.phi,t)}rotatePolarTo(e,t=!1){return this.rotateTo(this._sphericalEnd.theta,e,t)}rotateTo(e,t,n=!1){this._isUserControllingRotate=!1;const o=$e(e,this.minAzimuthAngle,this.maxAzimuthAngle),r=$e(t,this.minPolarAngle,this.maxPolarAngle);this._sphericalEnd.theta=o,this._sphericalEnd.phi=r,this._sphericalEnd.makeSafe(),this._needsUpdate=!0,n||(this._spherical.theta=this._sphericalEnd.theta,this._spherical.phi=this._sphericalEnd.phi);const s=!n||Se(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&Se(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold);return this._createOnRestPromise(s)}dolly(e,t=!1){return this.dollyTo(this._sphericalEnd.radius-e,t)}dollyTo(e,t=!1){return this._isUserControllingDolly=!1,this._lastDollyDirection=Ft.NONE,this._changedDolly=0,this._dollyToNoClamp($e(e,this.minDistance,this.maxDistance),t)}_dollyToNoClamp(e,t=!1){const n=this._sphericalEnd.radius;if(this.colliderMeshes.length>=1){const s=this._collisionTest(),a=Se(s,this._spherical.radius);if(!(n>e)&&a)return Promise.resolve();this._sphericalEnd.radius=Math.min(e,s)}else this._sphericalEnd.radius=e;this._needsUpdate=!0,t||(this._spherical.radius=this._sphericalEnd.radius);const r=!t||Se(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(r)}dollyInFixed(e,t=!1){this._targetEnd.add(this._getCameraDirection(tn).multiplyScalar(e)),t||this._target.copy(this._targetEnd);const n=!t||Se(this._target.x,this._targetEnd.x,this.restThreshold)&&Se(this._target.y,this._targetEnd.y,this.restThreshold)&&Se(this._target.z,this._targetEnd.z,this.restThreshold);return this._createOnRestPromise(n)}zoom(e,t=!1){return this.zoomTo(this._zoomEnd+e,t)}zoomTo(e,t=!1){this._isUserControllingZoom=!1,this._zoomEnd=$e(e,this.minZoom,this.maxZoom),this._needsUpdate=!0,t||(this._zoom=this._zoomEnd);const n=!t||Se(this._zoom,this._zoomEnd,this.restThreshold);return this._changedZoom=0,this._createOnRestPromise(n)}pan(e,t,n=!1){return console.warn("`pan` has been renamed to `truck`"),this.truck(e,t,n)}truck(e,t,n=!1){this._camera.updateMatrix(),ot.setFromMatrixColumn(this._camera.matrix,0),rt.setFromMatrixColumn(this._camera.matrix,1),ot.multiplyScalar(e),rt.multiplyScalar(-t);const o=ye.copy(ot).add(rt),r=be.copy(this._targetEnd).add(o);return this.moveTo(r.x,r.y,r.z,n)}forward(e,t=!1){ye.setFromMatrixColumn(this._camera.matrix,0),ye.crossVectors(this._camera.up,ye),ye.multiplyScalar(e);const n=be.copy(this._targetEnd).add(ye);return this.moveTo(n.x,n.y,n.z,t)}elevate(e,t=!1){return ye.copy(this._camera.up).multiplyScalar(e),this.moveTo(this._targetEnd.x+ye.x,this._targetEnd.y+ye.y,this._targetEnd.z+ye.z,t)}moveTo(e,t,n,o=!1){this._isUserControllingTruck=!1;const r=ye.set(e,t,n).sub(this._targetEnd);this._encloseToBoundary(this._targetEnd,r,this.boundaryFriction),this._needsUpdate=!0,o||this._target.copy(this._targetEnd);const s=!o||Se(this._target.x,this._targetEnd.x,this.restThreshold)&&Se(this._target.y,this._targetEnd.y,this.restThreshold)&&Se(this._target.z,this._targetEnd.z,this.restThreshold);return this._createOnRestPromise(s)}lookInDirectionOf(e,t,n,o=!1){const a=ye.set(e,t,n).sub(this._targetEnd).normalize().multiplyScalar(-this._sphericalEnd.radius).add(this._targetEnd);return this.setPosition(a.x,a.y,a.z,o)}fitToBox(e,t,{cover:n=!1,paddingLeft:o=0,paddingRight:r=0,paddingBottom:s=0,paddingTop:a=0}={}){const c=[],h=e.isBox3?Gt.copy(e):Gt.setFromObject(e);h.isEmpty()&&(console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"),Promise.resolve());const p=cs(this._sphericalEnd.theta,as),f=cs(this._sphericalEnd.phi,as);c.push(this.rotateTo(p,f,t));const m=ye.setFromSpherical(this._sphericalEnd).normalize(),d=ms.setFromUnitVectors(m,xo),y=Se(Math.abs(m.y),1);y&&d.multiply(bo.setFromAxisAngle(Tn,p)),d.multiply(this._yAxisUpSpaceInverse);const _=ps.makeEmpty();be.copy(h.min).applyQuaternion(d),_.expandByPoint(be),be.copy(h.min).setX(h.max.x).applyQuaternion(d),_.expandByPoint(be),be.copy(h.min).setY(h.max.y).applyQuaternion(d),_.expandByPoint(be),be.copy(h.max).setZ(h.min.z).applyQuaternion(d),_.expandByPoint(be),be.copy(h.min).setZ(h.max.z).applyQuaternion(d),_.expandByPoint(be),be.copy(h.max).setY(h.min.y).applyQuaternion(d),_.expandByPoint(be),be.copy(h.max).setX(h.min.x).applyQuaternion(d),_.expandByPoint(be),be.copy(h.max).applyQuaternion(d),_.expandByPoint(be),_.min.x-=o,_.min.y-=s,_.max.x+=r,_.max.y+=a,d.setFromUnitVectors(xo,m),y&&d.premultiply(bo.invert()),d.premultiply(this._yAxisUpSpace);const v=_.getSize(ye),g=_.getCenter(be).applyQuaternion(d);if(Ct(this._camera)){const A=this.getDistanceToFitBox(v.x,v.y,v.z,n);c.push(this.moveTo(g.x,g.y,g.z,t)),c.push(this.dollyTo(A,t)),c.push(this.setFocalOffset(0,0,0,t))}else if(vt(this._camera)){const A=this._camera,w=A.right-A.left,C=A.top-A.bottom,L=n?Math.max(w/v.x,C/v.y):Math.min(w/v.x,C/v.y);c.push(this.moveTo(g.x,g.y,g.z,t)),c.push(this.zoomTo(L,t)),c.push(this.setFocalOffset(0,0,0,t))}return Promise.all(c)}fitToSphere(e,t){const n=[],r="isObject3D"in e?Ve.createBoundingSphere(e,wo):wo.copy(e);if(n.push(this.moveTo(r.center.x,r.center.y,r.center.z,t)),Ct(this._camera)){const s=this.getDistanceToFitSphere(r.radius);n.push(this.dollyTo(s,t))}else if(vt(this._camera)){const s=this._camera.right-this._camera.left,a=this._camera.top-this._camera.bottom,c=2*r.radius,h=Math.min(s/c,a/c);n.push(this.zoomTo(h,t))}return n.push(this.setFocalOffset(0,0,0,t)),Promise.all(n)}setLookAt(e,t,n,o,r,s,a=!1){this._isUserControllingRotate=!1,this._isUserControllingDolly=!1,this._isUserControllingTruck=!1,this._lastDollyDirection=Ft.NONE,this._changedDolly=0;const c=be.set(o,r,s),h=ye.set(e,t,n);this._targetEnd.copy(c),this._sphericalEnd.setFromVector3(h.sub(c).applyQuaternion(this._yAxisUpSpace)),this.normalizeRotations(),this._needsUpdate=!0,a||(this._target.copy(this._targetEnd),this._spherical.copy(this._sphericalEnd));const p=!a||Se(this._target.x,this._targetEnd.x,this.restThreshold)&&Se(this._target.y,this._targetEnd.y,this.restThreshold)&&Se(this._target.z,this._targetEnd.z,this.restThreshold)&&Se(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&Se(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold)&&Se(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(p)}lerpLookAt(e,t,n,o,r,s,a,c,h,p,f,m,d,y=!1){this._isUserControllingRotate=!1,this._isUserControllingDolly=!1,this._isUserControllingTruck=!1,this._lastDollyDirection=Ft.NONE,this._changedDolly=0;const _=ye.set(o,r,s),v=be.set(e,t,n);Qe.setFromVector3(v.sub(_).applyQuaternion(this._yAxisUpSpace));const g=Vt.set(p,f,m),A=be.set(a,c,h);nn.setFromVector3(A.sub(g).applyQuaternion(this._yAxisUpSpace)),this._targetEnd.copy(_.lerp(g,d));const w=nn.theta-Qe.theta,C=nn.phi-Qe.phi,L=nn.radius-Qe.radius;this._sphericalEnd.set(Qe.radius+L*d,Qe.phi+C*d,Qe.theta+w*d),this.normalizeRotations(),this._needsUpdate=!0,y||(this._target.copy(this._targetEnd),this._spherical.copy(this._sphericalEnd));const M=!y||Se(this._target.x,this._targetEnd.x,this.restThreshold)&&Se(this._target.y,this._targetEnd.y,this.restThreshold)&&Se(this._target.z,this._targetEnd.z,this.restThreshold)&&Se(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&Se(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold)&&Se(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(M)}setPosition(e,t,n,o=!1){return this.setLookAt(e,t,n,this._targetEnd.x,this._targetEnd.y,this._targetEnd.z,o)}setTarget(e,t,n,o=!1){const r=this.getPosition(ye),s=this.setLookAt(r.x,r.y,r.z,e,t,n,o);return this._sphericalEnd.phi=$e(this._sphericalEnd.phi,this.minPolarAngle,this.maxPolarAngle),s}setFocalOffset(e,t,n,o=!1){this._isUserControllingOffset=!1,this._focalOffsetEnd.set(e,t,n),this._needsUpdate=!0,o||this._focalOffset.copy(this._focalOffsetEnd);const r=!o||Se(this._focalOffset.x,this._focalOffsetEnd.x,this.restThreshold)&&Se(this._focalOffset.y,this._focalOffsetEnd.y,this.restThreshold)&&Se(this._focalOffset.z,this._focalOffsetEnd.z,this.restThreshold);return this._createOnRestPromise(r)}setOrbitPoint(e,t,n){this._camera.updateMatrixWorld(),ot.setFromMatrixColumn(this._camera.matrixWorldInverse,0),rt.setFromMatrixColumn(this._camera.matrixWorldInverse,1),Tt.setFromMatrixColumn(this._camera.matrixWorldInverse,2);const o=ye.set(e,t,n),r=o.distanceTo(this._camera.position),s=o.sub(this._camera.position);ot.multiplyScalar(s.x),rt.multiplyScalar(s.y),Tt.multiplyScalar(s.z),ye.copy(ot).add(rt).add(Tt),ye.z=ye.z+r,this.dollyTo(r,!1),this.setFocalOffset(-ye.x,ye.y,-ye.z,!1),this.moveTo(e,t,n,!1)}setBoundary(e){if(!e){this._boundary.min.set(-1/0,-1/0,-1/0),this._boundary.max.set(1/0,1/0,1/0),this._needsUpdate=!0;return}this._boundary.copy(e),this._boundary.clampPoint(this._targetEnd,this._targetEnd),this._needsUpdate=!0}setViewport(e,t,n,o){if(e===null){this._viewport=null;return}this._viewport=this._viewport||new pe.Vector4,typeof e=="number"?this._viewport.set(e,t,n,o):this._viewport.copy(e)}getDistanceToFitBox(e,t,n,o=!1){if(_o(this._camera,"getDistanceToFitBox"))return this._spherical.radius;const r=e/t,s=this._camera.getEffectiveFOV()*Ht,a=this._camera.aspect;return((o?r>a:r<a)?t:e/a)*.5/Math.tan(s*.5)+n*.5}getDistanceToFitSphere(e){if(_o(this._camera,"getDistanceToFitSphere"))return this._spherical.radius;const t=this._camera.getEffectiveFOV()*Ht,n=Math.atan(Math.tan(t*.5)*this._camera.aspect)*2,o=1<this._camera.aspect?t:n;return e/Math.sin(o*.5)}getTarget(e,t=!0){return(e&&e.isVector3?e:new pe.Vector3).copy(t?this._targetEnd:this._target)}getPosition(e,t=!0){return(e&&e.isVector3?e:new pe.Vector3).setFromSpherical(t?this._sphericalEnd:this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(t?this._targetEnd:this._target)}getSpherical(e,t=!0){return(e||new pe.Spherical).copy(t?this._sphericalEnd:this._spherical)}getFocalOffset(e,t=!0){return(e&&e.isVector3?e:new pe.Vector3).copy(t?this._focalOffsetEnd:this._focalOffset)}normalizeRotations(){this._sphericalEnd.theta=this._sphericalEnd.theta%zt,this._sphericalEnd.theta<0&&(this._sphericalEnd.theta+=zt),this._spherical.theta+=zt*Math.round((this._sphericalEnd.theta-this._spherical.theta)/zt)}stop(){this._focalOffset.copy(this._focalOffsetEnd),this._target.copy(this._targetEnd),this._spherical.copy(this._sphericalEnd),this._zoom=this._zoomEnd}reset(e=!1){if(!Se(this._camera.up.x,this._cameraUp0.x)||!Se(this._camera.up.y,this._cameraUp0.y)||!Se(this._camera.up.z,this._cameraUp0.z)){this._camera.up.copy(this._cameraUp0);const n=this.getPosition(ye);this.updateCameraUp(),this.setPosition(n.x,n.y,n.z)}const t=[this.setLookAt(this._position0.x,this._position0.y,this._position0.z,this._target0.x,this._target0.y,this._target0.z,e),this.setFocalOffset(this._focalOffset0.x,this._focalOffset0.y,this._focalOffset0.z,e),this.zoomTo(this._zoom0,e)];return Promise.all(t)}saveState(){this._cameraUp0.copy(this._camera.up),this.getTarget(this._target0),this.getPosition(this._position0),this._zoom0=this._zoom,this._focalOffset0.copy(this._focalOffset)}updateCameraUp(){this._yAxisUpSpace.setFromUnitVectors(this._camera.up,Tn),this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert()}applyCameraUp(){const e=ye.subVectors(this._target,this._camera.position).normalize(),t=be.crossVectors(e,this._camera.up);this._camera.up.crossVectors(t,e).normalize(),this._camera.updateMatrixWorld();const n=this.getPosition(ye);this.updateCameraUp(),this.setPosition(n.x,n.y,n.z)}update(e){const t=this._sphericalEnd.theta-this._spherical.theta,n=this._sphericalEnd.phi-this._spherical.phi,o=this._sphericalEnd.radius-this._spherical.radius,r=fs.subVectors(this._targetEnd,this._target),s=ds.subVectors(this._focalOffsetEnd,this._focalOffset),a=this._zoomEnd-this._zoom;if(Te(t))this._thetaVelocity.value=0,this._spherical.theta=this._sphericalEnd.theta;else{const f=this._isUserControllingRotate?this.draggingSmoothTime:this.smoothTime;this._spherical.theta=Pn(this._spherical.theta,this._sphericalEnd.theta,this._thetaVelocity,f,1/0,e),this._needsUpdate=!0}if(Te(n))this._phiVelocity.value=0,this._spherical.phi=this._sphericalEnd.phi;else{const f=this._isUserControllingRotate?this.draggingSmoothTime:this.smoothTime;this._spherical.phi=Pn(this._spherical.phi,this._sphericalEnd.phi,this._phiVelocity,f,1/0,e),this._needsUpdate=!0}if(Te(o))this._radiusVelocity.value=0,this._spherical.radius=this._sphericalEnd.radius;else{const f=this._isUserControllingDolly?this.draggingSmoothTime:this.smoothTime;this._spherical.radius=Pn(this._spherical.radius,this._sphericalEnd.radius,this._radiusVelocity,f,this.maxSpeed,e),this._needsUpdate=!0}if(Te(r.x)&&Te(r.y)&&Te(r.z))this._targetVelocity.set(0,0,0),this._target.copy(this._targetEnd);else{const f=this._isUserControllingTruck?this.draggingSmoothTime:this.smoothTime;us(this._target,this._targetEnd,this._targetVelocity,f,this.maxSpeed,e,this._target),this._needsUpdate=!0}if(Te(s.x)&&Te(s.y)&&Te(s.z))this._focalOffsetVelocity.set(0,0,0),this._focalOffset.copy(this._focalOffsetEnd);else{const f=this._isUserControllingOffset?this.draggingSmoothTime:this.smoothTime;us(this._focalOffset,this._focalOffsetEnd,this._focalOffsetVelocity,f,this.maxSpeed,e,this._focalOffset),this._needsUpdate=!0}if(Te(a))this._zoomVelocity.value=0,this._zoom=this._zoomEnd;else{const f=this._isUserControllingZoom?this.draggingSmoothTime:this.smoothTime;this._zoom=Pn(this._zoom,this._zoomEnd,this._zoomVelocity,f,1/0,e)}if(this.dollyToCursor){if(Ct(this._camera)&&this._changedDolly!==0){const f=this._spherical.radius-this._lastDistance,m=this._camera,d=this._getCameraDirection(tn),y=ye.copy(d).cross(m.up).normalize();y.lengthSq()===0&&(y.x=1);const _=be.crossVectors(y,d),v=this._sphericalEnd.radius*Math.tan(m.getEffectiveFOV()*Ht*.5),A=(this._sphericalEnd.radius-f-this._sphericalEnd.radius)/this._sphericalEnd.radius,w=Vt.copy(this._targetEnd).add(y.multiplyScalar(this._dollyControlCoord.x*v*m.aspect)).add(_.multiplyScalar(this._dollyControlCoord.y*v)),C=ye.copy(this._targetEnd).lerp(w,A),L=this._lastDollyDirection===Ft.IN&&this._spherical.radius<=this.minDistance,M=this._lastDollyDirection===Ft.OUT&&this.maxDistance<=this._spherical.radius;if(this.infinityDolly&&(L||M)){this._sphericalEnd.radius-=f,this._spherical.radius-=f;const b=be.copy(d).multiplyScalar(-f);C.add(b)}this._boundary.clampPoint(C,C);const P=be.subVectors(C,this._targetEnd);this._targetEnd.copy(C),this._target.add(P),this._changedDolly-=f,Te(this._changedDolly)&&(this._changedDolly=0)}else if(vt(this._camera)&&this._changedZoom!==0){const f=this._zoom-this._lastZoom,m=this._camera,d=ye.set(this._dollyControlCoord.x,this._dollyControlCoord.y,(m.near+m.far)/(m.near-m.far)).unproject(m),y=be.set(0,0,-1).applyQuaternion(m.quaternion),_=Vt.copy(d).add(y.multiplyScalar(-d.dot(m.up))),g=-(this._zoom-f-this._zoom)/this._zoom,A=this._getCameraDirection(tn),w=this._targetEnd.dot(A),C=ye.copy(this._targetEnd).lerp(_,g),L=C.dot(A),M=A.multiplyScalar(L-w);C.sub(M),this._boundary.clampPoint(C,C);const P=be.subVectors(C,this._targetEnd);this._targetEnd.copy(C),this._target.add(P),this._changedZoom-=f,Te(this._changedZoom)&&(this._changedZoom=0)}}this._camera.zoom!==this._zoom&&(this._camera.zoom=this._zoom,this._camera.updateProjectionMatrix(),this._updateNearPlaneCorners(),this._needsUpdate=!0),this._dragNeedsUpdate=!0;const c=this._collisionTest();this._spherical.radius=Math.min(this._spherical.radius,c),this._spherical.makeSafe(),this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target),this._camera.lookAt(this._target),(!Te(this._focalOffset.x)||!Te(this._focalOffset.y)||!Te(this._focalOffset.z))&&(this._camera.updateMatrixWorld(),ot.setFromMatrixColumn(this._camera.matrix,0),rt.setFromMatrixColumn(this._camera.matrix,1),Tt.setFromMatrixColumn(this._camera.matrix,2),ot.multiplyScalar(this._focalOffset.x),rt.multiplyScalar(-this._focalOffset.y),Tt.multiplyScalar(this._focalOffset.z),ye.copy(ot).add(rt).add(Tt),this._camera.position.add(ye)),this._boundaryEnclosesCamera&&this._encloseToBoundary(this._camera.position.copy(this._target),ye.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse),1);const p=this._needsUpdate;return p&&!this._updatedLastTime?(this._hasRested=!1,this.dispatchEvent({type:"wake"}),this.dispatchEvent({type:"update"})):p?(this.dispatchEvent({type:"update"}),Te(t,this.restThreshold)&&Te(n,this.restThreshold)&&Te(o,this.restThreshold)&&Te(r.x,this.restThreshold)&&Te(r.y,this.restThreshold)&&Te(r.z,this.restThreshold)&&Te(s.x,this.restThreshold)&&Te(s.y,this.restThreshold)&&Te(s.z,this.restThreshold)&&Te(a,this.restThreshold)&&!this._hasRested&&(this._hasRested=!0,this.dispatchEvent({type:"rest"}))):!p&&this._updatedLastTime&&this.dispatchEvent({type:"sleep"}),this._lastDistance=this._spherical.radius,this._lastZoom=this._zoom,this._updatedLastTime=p,this._needsUpdate=!1,p}toJSON(){return JSON.stringify({enabled:this._enabled,minDistance:this.minDistance,maxDistance:$t(this.maxDistance),minZoom:this.minZoom,maxZoom:$t(this.maxZoom),minPolarAngle:this.minPolarAngle,maxPolarAngle:$t(this.maxPolarAngle),minAzimuthAngle:$t(this.minAzimuthAngle),maxAzimuthAngle:$t(this.maxAzimuthAngle),smoothTime:this.smoothTime,draggingSmoothTime:this.draggingSmoothTime,dollySpeed:this.dollySpeed,truckSpeed:this.truckSpeed,dollyToCursor:this.dollyToCursor,verticalDragToForward:this.verticalDragToForward,target:this._targetEnd.toArray(),position:ye.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),zoom:this._zoomEnd,focalOffset:this._focalOffsetEnd.toArray(),target0:this._target0.toArray(),position0:this._position0.toArray(),zoom0:this._zoom0,focalOffset0:this._focalOffset0.toArray()})}fromJSON(e,t=!1){const n=JSON.parse(e);this.enabled=n.enabled,this.minDistance=n.minDistance,this.maxDistance=en(n.maxDistance),this.minZoom=n.minZoom,this.maxZoom=en(n.maxZoom),this.minPolarAngle=n.minPolarAngle,this.maxPolarAngle=en(n.maxPolarAngle),this.minAzimuthAngle=en(n.minAzimuthAngle),this.maxAzimuthAngle=en(n.maxAzimuthAngle),this.smoothTime=n.smoothTime,this.draggingSmoothTime=n.draggingSmoothTime,this.dollySpeed=n.dollySpeed,this.truckSpeed=n.truckSpeed,this.dollyToCursor=n.dollyToCursor,this.verticalDragToForward=n.verticalDragToForward,this._target0.fromArray(n.target0),this._position0.fromArray(n.position0),this._zoom0=n.zoom0,this._focalOffset0.fromArray(n.focalOffset0),this.moveTo(n.target[0],n.target[1],n.target[2],t),Qe.setFromVector3(ye.fromArray(n.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)),this.rotateTo(Qe.theta,Qe.phi,t),this.dollyTo(Qe.radius,t),this.zoomTo(n.zoom,t),this.setFocalOffset(n.focalOffset[0],n.focalOffset[1],n.focalOffset[2],t),this._needsUpdate=!0}connect(e){if(this._domElement){console.warn("camera-controls is already connected.");return}e.setAttribute("data-camera-controls-version",gu),this._addAllEventListeners(e),this._getClientRect(this._elementRect)}disconnect(){this.cancel(),this._removeAllEventListeners(),this._domElement&&(this._domElement.removeAttribute("data-camera-controls-version"),this._domElement=void 0)}dispose(){this.removeAllEventListeners(),this.disconnect()}_getTargetDirection(e){return e.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse)}_getCameraDirection(e){return this._getTargetDirection(e).negate()}_findPointerById(e){return this._activePointers.find(t=>t.pointerId===e)}_findPointerByMouseButton(e){return this._activePointers.find(t=>t.mouseButton===e)}_disposePointer(e){this._activePointers.splice(this._activePointers.indexOf(e),1)}_encloseToBoundary(e,t,n){const o=t.lengthSq();if(o===0)return e;const r=be.copy(t).add(e),a=this._boundary.clampPoint(r,Vt).sub(r),c=a.lengthSq();if(c===0)return e.add(t);if(c===o)return e;if(n===0)return e.add(t).add(a);{const h=1+n*c/t.dot(a);return e.add(be.copy(t).multiplyScalar(h)).add(a.multiplyScalar(1-n))}}_updateNearPlaneCorners(){if(Ct(this._camera)){const e=this._camera,t=e.near,n=e.getEffectiveFOV()*Ht,o=Math.tan(n*.5)*t,r=o*e.aspect;this._nearPlaneCorners[0].set(-r,-o,0),this._nearPlaneCorners[1].set(r,-o,0),this._nearPlaneCorners[2].set(r,o,0),this._nearPlaneCorners[3].set(-r,o,0)}else if(vt(this._camera)){const e=this._camera,t=1/e.zoom,n=e.left*t,o=e.right*t,r=e.top*t,s=e.bottom*t;this._nearPlaneCorners[0].set(n,r,0),this._nearPlaneCorners[1].set(o,r,0),this._nearPlaneCorners[2].set(o,s,0),this._nearPlaneCorners[3].set(n,s,0)}}_collisionTest(){let e=1/0;if(!(this.colliderMeshes.length>=1)||_o(this._camera,"_collisionTest"))return e;const n=this._getTargetDirection(tn);Mo.lookAt(hs,n,this._camera.up);for(let o=0;o<4;o++){const r=be.copy(this._nearPlaneCorners[o]);r.applyMatrix4(Mo);const s=Vt.addVectors(this._target,r);In.set(s,n),In.far=this._spherical.radius+1;const a=In.intersectObjects(this.colliderMeshes);a.length!==0&&a[0].distance<e&&(e=a[0].distance)}return e}_getClientRect(e){if(!this._domElement)return;const t=this._domElement.getBoundingClientRect();return e.x=t.left,e.y=t.top,this._viewport?(e.x+=this._viewport.x,e.y+=t.height-this._viewport.w-this._viewport.y,e.width=this._viewport.z,e.height=this._viewport.w):(e.width=t.width,e.height=t.height),e}_createOnRestPromise(e){return e?Promise.resolve():(this._hasRested=!1,this.dispatchEvent({type:"transitionstart"}),new Promise(t=>{const n=()=>{this.removeEventListener("rest",n),t()};this.addEventListener("rest",n)}))}_addAllEventListeners(e){}_removeAllEventListeners(){}get dampingFactor(){return console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead."),0}set dampingFactor(e){console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.")}get draggingDampingFactor(){return console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead."),0}set draggingDampingFactor(e){console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.")}static createBoundingSphere(e,t=new pe.Sphere){const n=t,o=n.center;Gt.makeEmpty(),e.traverseVisible(s=>{s.isMesh&&Gt.expandByObject(s)}),Gt.getCenter(o);let r=0;return e.traverseVisible(s=>{if(!s.isMesh)return;const a=s,c=a.geometry.clone();c.applyMatrix4(a.matrixWorld);const p=c.attributes.position;for(let f=0,m=p.count;f<m;f++)ye.fromBufferAttribute(p,f),r=Math.max(r,o.distanceToSquared(ye))}),n.radius=Math.sqrt(r),n}}const gs=i=>!!(i&&i.isPerspectiveCamera),ys=i=>!!(i&&i.isOrthographicCamera),_u=["min-polar-angle","max-polar-angle","min-azimuth-angle","max-azimuth-angle","distance","min-distance","max-distance","infinity-dolly","min-zoom","max-zoom","smooth-time","dragging-smooth-time","max-speed","azimuth-rotate-speed","polar-rotate-speed","dolly-speed","dolly-drag-inverted","truck-speed","dolly-to-cursor","drag-to-offset","vertical-drag-to-forward","boundary-friction","rest-threshold","collider-meshes","args","mouse-buttons","touches"],_s=(i,e)=>({left:Ve.ACTION.ROTATE,middle:Ve.ACTION.DOLLY,right:Ve.ACTION.TRUCK,wheel:gs(i)?Ve.ACTION.DOLLY:ys(i)?Ve.ACTION.ZOOM:Ve.ACTION.NONE,...e}),vs=(i,e)=>({one:Ve.ACTION.TOUCH_ROTATE,two:gs(i)?Ve.ACTION.TOUCH_DOLLY_TRUCK:ys(i)?Ve.ACTION.TOUCH_ZOOM_TRUCK:Ve.ACTION.NONE,three:Ve.ACTION.TOUCH_TRUCK,...e}),vu=u.defineComponent({__name:"CameraControls",props:{makeDefault:{type:Boolean,default:!1},camera:{},domElement:{},minPolarAngle:{default:0},maxPolarAngle:{default:Math.PI},minAzimuthAngle:{default:Number.NEGATIVE_INFINITY},maxAzimuthAngle:{default:Number.POSITIVE_INFINITY},distance:{default:()=>H.useTresContext().camera.value.position.z},minDistance:{default:Number.EPSILON},maxDistance:{default:Number.POSITIVE_INFINITY},infinityDolly:{type:Boolean,default:!1},minZoom:{default:.01},maxZoom:{default:Number.POSITIVE_INFINITY},smoothTime:{default:.25},draggingSmoothTime:{default:.125},maxSpeed:{default:Number.POSITIVE_INFINITY},azimuthRotateSpeed:{default:1},polarRotateSpeed:{default:1},dollySpeed:{default:1},dollyDragInverted:{type:Boolean,default:!1},truckSpeed:{default:2},dollyToCursor:{type:Boolean,default:!1},dragToOffset:{type:Boolean,default:!1},verticalDragToForward:{type:Boolean,default:!1},boundaryFriction:{default:0},restThreshold:{default:.01},colliderMeshes:{default:()=>[]},mouseButtons:{default:()=>_s(H.useTresContext().camera.value)},touches:{default:()=>vs(H.useTresContext().camera.value)}},emits:["change","start","end"],setup(i,{expose:e,emit:t}){const n=i,o=t,{makeDefault:r,minPolarAngle:s,maxPolarAngle:a,minAzimuthAngle:c,maxAzimuthAngle:h,distance:p,minDistance:f,maxDistance:m,infinityDolly:d,minZoom:y,maxZoom:_,smoothTime:v,draggingSmoothTime:g,maxSpeed:A,azimuthRotateSpeed:w,polarRotateSpeed:C,dollySpeed:L,dollyDragInverted:M,truckSpeed:P,dollyToCursor:b,dragToOffset:S,verticalDragToForward:x,boundaryFriction:I,restThreshold:D,colliderMeshes:z}=u.toRefs(n),G={Box3:l.Box3,MathUtils:{clamp:l.MathUtils.clamp},Matrix4:l.Matrix4,Quaternion:l.Quaternion,Raycaster:l.Raycaster,Sphere:l.Sphere,Spherical:l.Spherical,Vector2:l.Vector2,Vector3:l.Vector3,Vector4:l.Vector4};Ve.install({THREE:G});const{camera:E,renderer:X,extend:oe,controls:q,invalidate:ee}=H.useTresContext();u.watch(n,()=>{ee()});const te=u.computed(()=>_s(n.camera||E.value,n.mouseButtons)),ce=u.computed(()=>vs(n.camera||E.value,n.touches)),le=u.shallowRef(null);oe({CameraControls:Ve}),u.watchEffect(()=>{de(),le.value&&r.value?q.value=le.value:q.value=null});function de(){Ce(le.value,"update",()=>{o("change",le.value),ee()}),Ce(le.value,"controlend",()=>o("end",le.value)),Ce(le.value,"controlstart",()=>o("start",le.value))}const{onBeforeRender:k}=H.useLoop();return k(({delta:V,invalidate:U})=>{var B,R;(B=le.value)!=null&&B.enabled&&((R=le.value)==null||R.update(V),U())}),u.onUnmounted(()=>{le.value&&le.value.disconnect()}),e({instance:le}),(V,U)=>(V.camera||u.unref(E))&&(V.domElement||u.unref(X))?(u.openBlock(),u.createElementBlock("TresCameraControls",{key:0,ref_key:"controlsRef",ref:le,"min-polar-angle":u.unref(s),"max-polar-angle":u.unref(a),"min-azimuth-angle":u.unref(c),"max-azimuth-angle":u.unref(h),distance:u.unref(p),"min-distance":u.unref(f),"max-distance":u.unref(m),"infinity-dolly":u.unref(d),"min-zoom":u.unref(y),"max-zoom":u.unref(_),"smooth-time":u.unref(v),"dragging-smooth-time":u.unref(g),"max-speed":u.unref(A),"azimuth-rotate-speed":u.unref(w),"polar-rotate-speed":u.unref(C),"dolly-speed":u.unref(L),"dolly-drag-inverted":u.unref(M),"truck-speed":u.unref(P),"dolly-to-cursor":u.unref(b),"drag-to-offset":u.unref(S),"vertical-drag-to-forward":u.unref(x),"boundary-friction":u.unref(I),"rest-threshold":u.unref(D),"collider-meshes":u.unref(z),args:[V.camera||u.unref(E),V.domElement||u.unref(X).domElement],"mouse-buttons":te.value,touches:ce.value},null,8,_u)):u.createCommentVNode("",!0)}}),xu=u.defineComponent({__name:"KeyboardControls",props:{makeDefault:{type:Boolean,default:!0},camera:{},domElement:{},moveSpeed:{default:.2},selector:{}},emits:["isLock","change"],setup(i,{expose:e,emit:t}){const n=i,o=t,{moveSpeed:r}=u.toRefs(n),{camera:s,controls:a,renderer:c,invalidate:h}=H.useTresContext();u.watch(n,()=>{h()});const p=u.ref(0),f=u.ref(0),{KeyW:m,KeyA:d,KeyS:y,KeyD:_,Up:v,Down:g,Left:A,Right:w}=Fi();u.watchEffect(()=>{d.value||A.value?p.value=-r.value:_.value||w.value?p.value=r.value:p.value=0,m.value||v.value?f.value=r.value:y.value||g.value?f.value=-r.value:f.value=0}),e({instance:a});const C=I=>o("isLock",I),L=I=>o("change",I),M=new l.Vector3,P=new l.Vector3,b=new l.Quaternion,S=(I,D)=>{var E;if(!((E=s.value)!=null&&E.position)&&!M)return;const z=s.value,G=I*.001;z==null||z.translateZ(-D),b.set(P.x*G,P.y*G,P.z*G,1).normalize(),z==null||z.quaternion.multiply(b),(p.value||f.value)&&o("change",a.value)},{onBeforeRender:x}=H.useLoop();return x(({delta:I,invalidate:D})=>{var z;a.value instanceof vr&&((z=a.value)!=null&&z.isLocked)&&(S(I,f.value),a.value.moveRight(p.value),D())}),(I,D)=>(u.openBlock(),u.createBlock(u.unref(xs),{selector:I.selector,"make-default":I.makeDefault,camera:I.camera||u.unref(s),"dom-element":I.domElement||u.unref(c).domElement,onIsLock:C,onChange:L},null,8,["selector","make-default","camera","dom-element"]))}}),wu=["args","auto-rotate","auto-rotate-speed","enable-damping","damping-factor","enable-pan","key-pan-speed","keys","max-azimuth-angle","min-azimuth-angle","max-polar-angle","min-polar-angle","min-distance","max-distance","min-zoom","max-zoom","enable-zoom","zoom-speed","enable-rotate","rotate-speed"],bu=u.defineComponent({__name:"MapControls",props:{makeDefault:{type:Boolean,default:!1},camera:{},domElement:{},target:{},enableDamping:{type:Boolean,default:!0},dampingFactor:{default:.05},autoRotate:{type:Boolean,default:!1},autoRotateSpeed:{default:2},enablePan:{type:Boolean,default:!0},keyPanSpeed:{default:7},keys:{},maxAzimuthAngle:{default:Number.POSITIVE_INFINITY},minAzimuthAngle:{default:Number.NEGATIVE_INFINITY},maxPolarAngle:{default:Math.PI},minPolarAngle:{default:0},minDistance:{default:0},maxDistance:{default:Number.POSITIVE_INFINITY},minZoom:{default:0},maxZoom:{default:Number.POSITIVE_INFINITY},touches:{},enableZoom:{type:Boolean,default:!0},zoomSpeed:{default:1},enableRotate:{type:Boolean,default:!0},rotateSpeed:{default:1}},emits:["change","start","end"],setup(i,{expose:e,emit:t}){const n=i,{autoRotate:o,autoRotateSpeed:r,enableDamping:s,dampingFactor:a,enablePan:c,keyPanSpeed:h,maxAzimuthAngle:p,minAzimuthAngle:f,maxPolarAngle:m,minPolarAngle:d,minDistance:y,maxDistance:_,minZoom:v,maxZoom:g,enableZoom:A,zoomSpeed:w,enableRotate:C,rotateSpeed:L}=u.toRefs(n),{camera:M,renderer:P,extend:b,controls:S,invalidate:x}=H.useTresContext();u.watch(n,()=>{x()});const I=u.shallowRef(null);b({MapControls:il}),u.watch(S,z=>{z&&n.makeDefault?S.value=z:S.value=null});const{onBeforeRender:D}=H.useLoop();return D(({invalidate:z})=>{I.value&&(s.value||o.value)&&(I.value.update(),z())}),u.onUnmounted(()=>{I.value&&I.value.dispose()}),e({instance:I}),(z,G)=>(z.camera||u.unref(M))&&(z.domElement||u.unref(P))?(u.openBlock(),u.createElementBlock("TresMapControls",{key:0,ref_key:"controlsRef",ref:I,args:[z.camera||u.unref(M),z.domElement||u.unref(P).domElement],"auto-rotate":u.unref(o),"auto-rotate-speed":u.unref(r),"enable-damping":u.unref(s),"damping-factor":u.unref(a),"enable-pan":u.unref(c),"key-pan-speed":u.unref(h),keys:z.keys,"max-azimuth-angle":u.unref(p),"min-azimuth-angle":u.unref(f),"max-polar-angle":u.unref(m),"min-polar-angle":u.unref(d),"min-distance":u.unref(y),"max-distance":u.unref(_),"min-zoom":u.unref(v),"max-zoom":u.unref(g),"enable-zoom":u.unref(A),"zoom-speed":u.unref(w),"enable-rotate":u.unref(C),"rotate-speed":u.unref(L)},null,8,wu)):u.createCommentVNode("",!0)}}),Mu=["target","auto-rotate","auto-rotate-speed","enable-damping","damping-factor","enable-pan","key-pan-speed","keys","max-azimuth-angle","min-azimuth-angle","max-polar-angle","min-polar-angle","min-distance","max-distance","min-zoom","max-zoom","touches","enable-zoom","zoom-speed","enable-rotate","rotate-speed","mouse-buttons","args"],Su=u.defineComponent({__name:"OrbitControls",props:{makeDefault:{type:Boolean,default:!1},camera:{},domElement:{},target:{default:()=>[0,0,0]},enableDamping:{type:Boolean,default:!0},dampingFactor:{default:.05},autoRotate:{type:Boolean,default:!1},autoRotateSpeed:{default:2},enablePan:{type:Boolean,default:!0},keyPanSpeed:{default:7},keys:{},maxAzimuthAngle:{default:Number.POSITIVE_INFINITY},minAzimuthAngle:{default:Number.NEGATIVE_INFINITY},maxPolarAngle:{default:Math.PI},minPolarAngle:{default:0},minDistance:{default:0},maxDistance:{default:Number.POSITIVE_INFINITY},minZoom:{default:0},maxZoom:{default:Number.POSITIVE_INFINITY},touches:{default:()=>({ONE:l.TOUCH.ROTATE,TWO:l.TOUCH.DOLLY_PAN})},enableZoom:{type:Boolean,default:!0},zoomSpeed:{default:1},enableRotate:{type:Boolean,default:!0},rotateSpeed:{default:1},mouseButtons:{default:()=>({LEFT:l.MOUSE.ROTATE,MIDDLE:l.MOUSE.DOLLY,RIGHT:l.MOUSE.PAN})}},emits:["change","start","end"],setup(i,{expose:e,emit:t}){const n=i,o=t,{makeDefault:r,autoRotate:s,autoRotateSpeed:a,enableDamping:c,dampingFactor:h,enablePan:p,keyPanSpeed:f,maxAzimuthAngle:m,minAzimuthAngle:d,maxPolarAngle:y,minPolarAngle:_,minDistance:v,maxDistance:g,minZoom:A,maxZoom:w,enableZoom:C,zoomSpeed:L,enableRotate:M,touches:P,rotateSpeed:b,target:S,mouseButtons:x}=u.toRefs(n),{camera:I,renderer:D,extend:z,controls:G,invalidate:E}=H.useTresContext(),X=u.shallowRef(null);z({OrbitControls:br}),u.watch(X,ee=>{oe(),ee&&r.value?G.value=ee:G.value=null});function oe(){Ce(X.value,"change",()=>{o("change",X.value),E()}),Ce(X.value,"start",()=>o("start",X.value)),Ce(X.value,"end",()=>o("end",X.value))}const{onBeforeRender:q}=H.useLoop();return q(({invalidate:ee})=>{X.value&&(c.value||s.value)&&(X.value.update(),s.value&&ee())}),u.onUnmounted(()=>{X.value&&X.value.dispose()}),e({instance:X}),(ee,te)=>(ee.camera||u.unref(I))&&(ee.domElement||u.unref(D))?(u.openBlock(),u.createElementBlock("TresOrbitControls",{key:0,ref_key:"controlsRef",ref:X,target:u.unref(S),"auto-rotate":u.unref(s),"auto-rotate-speed":u.unref(a),"enable-damping":u.unref(c),"damping-factor":u.unref(h),"enable-pan":u.unref(p),"key-pan-speed":u.unref(f),keys:ee.keys,"max-azimuth-angle":u.unref(m),"min-azimuth-angle":u.unref(d),"max-polar-angle":u.unref(y),"min-polar-angle":u.unref(_),"min-distance":u.unref(v),"max-distance":u.unref(g),"min-zoom":u.unref(A),"max-zoom":u.unref(w),touches:u.unref(P),"enable-zoom":u.unref(C),"zoom-speed":u.unref(L),"enable-rotate":u.unref(M),"rotate-speed":u.unref(b),"mouse-buttons":u.unref(x),args:[ee.camera||u.unref(I),ee.domElement||u.unref(D).domElement]},null,8,Mu)):u.createCommentVNode("",!0)}}),Au=["args"],xs=u.defineComponent({__name:"PointerLockControls",props:{makeDefault:{type:Boolean,default:!1},camera:{},domElement:{},selector:{}},emits:["isLock","change"],setup(i,{expose:e,emit:t}){const n=i,o=t,{camera:r,renderer:s,extend:a,controls:c,invalidate:h}=H.useTresContext();u.watch(n,()=>{h()});const p=u.shallowRef(null);let f;a({PointerLockControls:vr});const m=d=>{o("isLock",d)};return u.watch(p,d=>{d&&n.makeDefault?c.value=d:c.value=null,f=document.getElementById(n.selector||"")||s.value.domElement,Ce(f,"click",()=>{p.value&&(p.value.lock(),p.value.addEventListener("lock",()=>m(!0)),p.value.addEventListener("unlock",()=>m(!1)),h())})}),u.onUnmounted(()=>{const d=p.value;d&&(d.removeEventListener("lock",()=>m(!0)),d.removeEventListener("unlock",()=>m(!1)),d.dispose())}),e({instance:c}),(d,y)=>(d.camera||u.unref(r))&&(d.domElement||u.unref(s))?(u.openBlock(),u.createElementBlock("TresPointerLockControls",{key:0,ref_key:"controlsRef",ref:p,args:[d.camera||u.unref(r),d.domElement||u.unref(s).domElement]},null,8,Au)):u.createCommentVNode("",!0)}}),Pu=u.defineComponent({__name:"ScrollControls",props:{pages:{default:4},distance:{default:4},smoothScroll:{default:.1},horizontal:{type:Boolean,default:!1},htmlScroll:{type:Boolean,default:!1}},emits:["update:modelValue"],setup(i,{expose:e,emit:t}){const n=i,o=t,{logWarning:r}=H.useLogger();n.smoothScroll<0&&r("SmoothControl must be greater than zero"),n.pages<0&&r("Pages must be greater than zero");const{camera:s,controls:a,renderer:c,invalidate:h}=H.useTresContext();u.watch(n,()=>{h()});const p=u.shallowRef(),f=document.createElement("div"),{y:m}=Gi(),{x:d,y,isScrolling:_}=Ui(f),{height:v,width:g}=qo();let A=0;const w=u.ref(!1),C=u.ref(0),L=u.ref(0),M=u.ref(0),P=n.horizontal?"x":"y",b=u.watch(s,x=>{if(w.value){b();return}A=n.horizontal?(x==null?void 0:x.position.x)||0:(x==null?void 0:x.position.y)||0,w.value=!0},{immediate:!0});u.watch(_,x=>{a.value&&(a.value.enabled=!x)},{immediate:!0}),u.watch(m,x=>{!_.value&&!n.htmlScroll||(L.value=x/v.value/(M.value/v.value-1),C.value=-1*L.value,o("update:modelValue",L.value))}),u.watch(y,x=>{L.value=x/v.value/(M.value/v.value),C.value=-1*L.value,o("update:modelValue",L.value)}),u.watch(d,x=>{L.value=x/g.value/(M.value/g.value-1),C.value=+L.value,o("update:modelValue",L.value)}),u.watch(c,x=>{var D,z;const I=x==null?void 0:x.domElement;if(n.htmlScroll&&(x!=null&&x.domElement))I!=null&&I.style.width&&(I!=null&&I.style.position)&&(I!=null&&I.style.top)&&(I!=null&&I.style.left)&&(I.style.width="100%",I.style.position="fixed",I.style.zIndex=" -99999",I.style.top="0",I.style.left="0"),M.value=document.body.scrollHeight;else{const G=document.createElement("div"),E=document.createElement("div");f.style[n.horizontal?"overflowX":"overflowY"]="auto",f.style[n.horizontal?"overflowY":"overflowX"]="hidden",f.style.position="absolute",f.style.width="100%",f.style.height=" 100%",f.style.top="0",f.style.left="0",f.classList.add("scrollContainer"),G.style.position="sticky",G.style.top="0px",G.style.left="0px",G.style.width="100%",G.style.height="100%",G.style.overflow="hidden",f.appendChild(G),E.style.height=n.horizontal?"100%":`${v.value*n.pages}px`,E.style.width=n.horizontal?`${g.value*n.pages}px`:"100vw",E.style.pointerEvents="none",I.style.position="fixed",I.style.zIndex="0",I!=null&&I.style.width&&(I.style.width="100%"),f.appendChild(E),x!=null&&x.domElement.parentNode&&(x.domElement.parentNode.style.position="relative"),(z=(D=x==null?void 0:x.domElement)==null?void 0:D.parentNode)==null||z.appendChild(f),M.value=n.horizontal?g.value*n.pages:v.value*n.pages}},{immediate:!0});const{onBeforeRender:S}=H.useLoop();return S(({invalidate:x})=>{var I;if((I=s.value)!=null&&I.position){const D=(C.value*n.distance-s.value.position[P]+A)*n.smoothScroll;s.value.position[P]+=D,p.value.children.length>0&&(p.value.position[P]+=D),x()}}),e({instance:p}),(x,I)=>(u.openBlock(),u.createElementBlock("TresGroup",{ref_key:"wrapperRef",ref:p},[u.renderSlot(x.$slots,"default")],512))}}),Cu=["object","args","mode","enabled","axis","translation-snap","rotation-snap","scale-snap","space","size","show-x","show-y","show-z"],Tu=u.defineComponent({__name:"TransformControls",props:{object:{},camera:{},mode:{default:"translate"},enabled:{type:Boolean,default:!0},axis:{default:"XYZ"},translationSnap:{},rotationSnap:{},scaleSnap:{},space:{default:"world"},size:{default:1},showX:{type:Boolean,default:!0},showY:{type:Boolean,default:!0},showZ:{type:Boolean,default:!0}},emits:["dragging","change","mouseDown","mouseUp","objectChange"],setup(i,{expose:e,emit:t}){const n=i,o=t,{object:r,mode:s,enabled:a,axis:c,translationSnap:h,rotationSnap:p,scaleSnap:f,space:m,size:d,showX:y,showY:_,showZ:v}=u.toRefs(n),g=u.shallowRef(null),{controls:A,camera:w,renderer:C,extend:L,invalidate:M}=H.useTresContext();u.watch([r,s,a,c,h,p,f,m,d,y,_,v],()=>{M()}),L({TransformControls:qa});const P=()=>{M(),o("change")},b=z=>{A.value&&(A.value.enabled=!z.value),M(),o("dragging",z.value)},S=()=>{M(),o("mouseDown")},x=()=>{M(),o("mouseDown")},I=()=>{M(),o("objectChange")};function D(){Ce(g.value,"change",P),Ce(g.value,"dragging-changed",b),Ce(g.value,"mouseDown",S),Ce(g.value,"mouseUp",x),Ce(g.value,"objectChange",I)}return u.watch(g,z=>{z&&D()}),u.onUnmounted(()=>{g.value&&g.value.dispose()}),e({instance:g}),(z,G)=>{var E;return(z.camera||u.unref(w))&&u.unref(C)?(u.openBlock(),u.createElementBlock("TresTransformControls",{ref_key:"controlsRef",ref:g,key:(E=z.camera||u.unref(w))==null?void 0:E.uuid,object:u.unref(r),args:[z.camera||u.unref(w),u.unref(C).domElement],mode:u.unref(s),enabled:u.unref(a),axis:u.unref(c),"translation-snap":u.unref(h),"rotation-snap":u.unref(p),"scale-snap":u.unref(f),space:u.unref(m),size:u.unref(d),"show-x":u.unref(y),"show-y":u.unref(_),"show-z":u.unref(v),visible:!0},null,8,Cu)):u.createCommentVNode("",!0)}}}),Iu=["geometry","render-order"],Ou=u.defineComponent({__name:"component",props:{src:{},skipStrokes:{type:Boolean,default:!1},skipFills:{type:Boolean,default:!1},fillMaterial:{},strokeMaterial:{},fillMeshProps:{},strokeMeshProps:{},depth:{default:"renderOrder"}},setup(i,{expose:e}){const t=i;class n extends Jt{load(w,C,L,M){const P=Array.isArray(w)?w[0]:w;super.load(P,C,L,M)}}const{src:o,skipStrokes:r,skipFills:s,fillMaterial:a,strokeMaterial:c,fillMeshProps:h,strokeMeshProps:p,depth:f}=u.toRefs(t),m=u.shallowRef(),d=u.shallowRef([]),y=u.shallowRef([]);e({instance:m}),u.watchEffect(async()=>_(o.value).then(A=>y.value=A.paths)),u.watch([s,r,a,c,y],g);async function _(A){const w=A.startsWith("<svg")?encodeURI(`data:image/svg+xml;utf8,${A}`):A;return H.useLoader(n,w)}u.onUnmounted(v);function v(){d.value.forEach(A=>A.geometry.dispose())}function g(){var M,P,b;v();const A=[],[w,C]=(()=>{const S={flat:!1,renderOrder:!1,offsetZ:!0},x={flat:0,renderOrder:0,offsetZ:.025},I=f.value;return typeof I=="number"?[!0,I]:[S[I],x[I]]})();let L=0;for(const S of y.value){const x=((M=S.userData)==null?void 0:M.style)??{},I=Object.assign({color:x.fill,opacity:x.fillOpacity,transparent:!0,side:l.DoubleSide,depthWrite:w},t.fillMaterial);if(!s.value&&x.fill!==void 0&&x.fill!=="none")for(const D of Jt.createShapes(S)){const z=new l.ShapeGeometry(D);z.scale(1,-1,1),C&&z.translate(0,0,L++*C),A.push({geometry:z,material:I,isStroke:!1})}if(!r.value&&x.stroke!==void 0&&x.stroke!=="none"){const D=Object.assign({color:(P=S.userData)==null?void 0:P.style.stroke,opacity:(b=S.userData)==null?void 0:b.style.strokeOpacity,transparent:!0,side:l.DoubleSide,depthWrite:w},t.strokeMaterial);for(const z of S.subPaths){const G=z.getPoints().map(X=>new l.Vector2(X.x,-X.y)),E=Jt.pointsToStroke(G,x||"none");C&&E.translate(0,0,L++*C),A.push({geometry:E,material:D,isStroke:!0})}}}d.value=A}return(A,w)=>(u.openBlock(),u.createElementBlock("TresGroup",{ref_key:"svgRef",ref:m},[(u.openBlock(!0),u.createElementBlock(u.Fragment,null,u.renderList(d.value,({geometry:C,material:L,isStroke:M},P)=>(u.openBlock(),u.createElementBlock("TresMesh",u.mergeProps({key:`${P}`,ref_for:!0},M?u.unref(p):u.unref(h),{geometry:C,"render-order":u.unref(f)==="renderOrder"?P:0}),[u.createElementVNode("TresMeshBasicMaterial",u.mergeProps({ref_for:!0},L),null,16)],16,Iu))),128))],512))}});class Lu extends l.Loader{constructor(t){super(t);ue(this,"fbxLoader");this.fbxLoader=new $l(t)}load(t,n,o,r){const s=Array.isArray(t)?t[0]:t;this.fbxLoader.load(s,n,o,r)}async loadAsync(t){const n=Array.isArray(t)?t[0]:t;return this.fbxLoader.loadAsync(n)}}const Du=Lu;async function ws(i){return await H.useLoader(Du,i)}const ku=["object"],Bu=u.defineComponent({__name:"component",props:{path:{},castShadow:{type:Boolean,default:!1},receiveShadow:{type:Boolean,default:!1}},async setup(i,{expose:e}){let t,n;const o=i,r=u.ref();e({instance:r});const s=([t,n]=u.withAsyncContext(()=>ws(o.path)),t=await t,n(),t);return(o.castShadow||o.receiveShadow)&&s.traverse(a=>{a.isMesh&&(a.castShadow=o.castShadow,a.receiveShadow=o.receiveShadow)}),(a,c)=>(u.openBlock(),u.createElementBlock("primitive",u.mergeProps({ref_key:"modelRef",ref:r,object:u.unref(s)},a.$attrs),null,16,ku))}});class Uu extends l.Loader{constructor(t){super(t);ue(this,"gltfLoader");this.gltfLoader=new ll(t)}load(t,n,o,r){const s=Array.isArray(t)?t[0]:t;this.gltfLoader.load(s,n,o,r)}async loadAsync(t){const n=Array.isArray(t)?t[0]:t;return this.gltfLoader.loadAsync(n)}setDRACOLoader(t){return this.gltfLoader.setDRACOLoader(t)}}const Nu=Uu;let xt=null;function Fu(i,e){return t=>{e&&e(t),i.draco&&(xt||(xt=new yc),xt.setDecoderPath(i.decoderPath||"https://www.gstatic.com/draco/versioned/decoders/1.4.3/"),t.setDRACOLoader&&t.setDRACOLoader(xt))}}async function bs(i,e={draco:!1},t){const n=await H.useLoader(Nu,i,Fu(e,t));return xt==null||xt.dispose(),xt=null,n}const zu=["object"],Vu=u.defineComponent({__name:"component",props:{path:{},draco:{type:Boolean,default:!1},decoderPath:{default:"https://www.gstatic.com/draco/versioned/decoders/1.4.1/"},castShadow:{type:Boolean,default:!1},receiveShadow:{type:Boolean,default:!1}},async setup(i,{expose:e}){let t,n;const o=i,r=u.ref();e({instance:r});const{scene:s}=([t,n]=u.withAsyncContext(()=>bs(o.path,{draco:o.draco,decoderPath:o.decoderPath})),t=await t,n(),t);return(o.castShadow||o.receiveShadow)&&s.traverse(a=>{a.isMesh&&(a.castShadow=o.castShadow,a.receiveShadow=o.receiveShadow)}),(a,c)=>(u.openBlock(),u.createElementBlock("primitive",u.mergeProps({ref_key:"modelRef",ref:r,object:u.unref(s)},a.$attrs),null,16,zu))}}),Ms="[TresJS - Cientos â–² â–  â™¥] ";function Gu(i,e){console.error(`${Ms} ${i}`,e||"")}function Ru(i){console.warn(`${Ms} ${i}`)}function ju(i,e){}function Ss(){return{logError:Gu,logWarning:Ru,logMessage:ju}}let So=0;function Wu(){const i=u.ref(!1),e=u.ref(0),t=u.ref([]),{logError:n}=Ss();return new Promise(o=>{l.DefaultLoadingManager.onStart=()=>{i.value=!1},l.DefaultLoadingManager.onLoad=()=>{i.value=!0},l.DefaultLoadingManager.onProgress=(r,s,a)=>{s===a&&(So=a,i.value=!0,t.value.push(r)),e.value=Math.round((s-So)/(a-So)*100||100)},l.DefaultLoadingManager.onError=r=>{n("Error loading assets",new Error(r)),i.value=!0},o({items:t,hasFinishLoading:i,progress:e})})}async function Yu(i,e){const{logError:t}=Ss();if(!i)return t("Error no path provided");const{unsuspend:n,start:o,crossOrigin:r,muted:s,loop:a,...c}={unsuspend:"loadedmetadata",crossOrigin:"Anonymous",muted:!0,loop:!0,start:!0,playsInline:!0,...e};function h(){return new Promise((p,f)=>{const m=Object.assign(document.createElement("video"),{src:typeof i=="string"&&i||void 0,crossOrigin:r,loop:a,muted:s,autoplay:!0,...c}),d=new l.VideoTexture(m);return m.addEventListener(n,()=>p(d)),m.addEventListener("error",()=>f(new Error("Error loading video"))),d})}try{const p=await h();return o&&p.image&&p.image.play(),p}catch{t("Error loading resource")}}function on(i){return i&&i.__esModule&&Object.prototype.hasOwnProperty.call(i,"default")?i.default:i}function On(i){throw new Error('Could not dynamically require "'+i+'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')}var Ao={exports:{}},As;function Xu(){return As||(As=1,function(i,e){(function(t){i.exports=t()})(function(){return function t(n,o,r){function s(h,p){if(!o[h]){if(!n[h]){var f=typeof On=="function"&&On;if(!p&&f)return f(h,!0);if(a)return a(h,!0);throw new Error("Cannot find module '"+h+"'")}p=o[h]={exports:{}},n[h][0].call(p.exports,function(m){var d=n[h][1][m];return s(d||m)},p,p.exports,t,n,o,r)}return o[h].exports}for(var a=typeof On=="function"&&On,c=0;c<r.length;c++)s(r[c]);return s}({1:[function(t,n,o){(function(r,s,a,c,h,p,f,m,d){var y=t("crypto");function _(M,P){P=A(M,P);var b;return(b=P.algorithm!=="passthrough"?y.createHash(P.algorithm):new L).write===void 0&&(b.write=b.update,b.end=b.update),C(P,b).dispatch(M),b.update||b.end(""),b.digest?b.digest(P.encoding==="buffer"?void 0:P.encoding):(M=b.read(),P.encoding!=="buffer"?M.toString(P.encoding):M)}(o=n.exports=_).sha1=function(M){return _(M)},o.keys=function(M){return _(M,{excludeValues:!0,algorithm:"sha1",encoding:"hex"})},o.MD5=function(M){return _(M,{algorithm:"md5",encoding:"hex"})},o.keysMD5=function(M){return _(M,{algorithm:"md5",encoding:"hex",excludeValues:!0})};var v=y.getHashes?y.getHashes().slice():["sha1","md5"],g=(v.push("passthrough"),["buffer","hex","binary","base64"]);function A(M,P){var b={};if(b.algorithm=(P=P||{}).algorithm||"sha1",b.encoding=P.encoding||"hex",b.excludeValues=!!P.excludeValues,b.algorithm=b.algorithm.toLowerCase(),b.encoding=b.encoding.toLowerCase(),b.ignoreUnknown=P.ignoreUnknown===!0,b.respectType=P.respectType!==!1,b.respectFunctionNames=P.respectFunctionNames!==!1,b.respectFunctionProperties=P.respectFunctionProperties!==!1,b.unorderedArrays=P.unorderedArrays===!0,b.unorderedSets=P.unorderedSets!==!1,b.unorderedObjects=P.unorderedObjects!==!1,b.replacer=P.replacer||void 0,b.excludeKeys=P.excludeKeys||void 0,M===void 0)throw new Error("Object argument required.");for(var S=0;S<v.length;++S)v[S].toLowerCase()===b.algorithm.toLowerCase()&&(b.algorithm=v[S]);if(v.indexOf(b.algorithm)===-1)throw new Error('Algorithm "'+b.algorithm+'"  not supported. supported values: '+v.join(", "));if(g.indexOf(b.encoding)===-1&&b.algorithm!=="passthrough")throw new Error('Encoding "'+b.encoding+'"  not supported. supported values: '+g.join(", "));return b}function w(M){if(typeof M=="function")return/^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(M))!=null}function C(M,P,b){b=b||[];function S(x){return P.update?P.update(x,"utf8"):P.write(x,"utf8")}return{dispatch:function(x){return this["_"+((x=M.replacer?M.replacer(x):x)===null?"null":typeof x)](x)},_object:function(x){var I,D=Object.prototype.toString.call(x),z=/\[object (.*)\]/i.exec(D);if(z=(z=z?z[1]:"unknown:["+D+"]").toLowerCase(),0<=(D=b.indexOf(x)))return this.dispatch("[CIRCULAR:"+D+"]");if(b.push(x),a!==void 0&&a.isBuffer&&a.isBuffer(x))return S("buffer:"),S(x);if(z==="object"||z==="function"||z==="asyncfunction")return D=Object.keys(x),M.unorderedObjects&&(D=D.sort()),M.respectType===!1||w(x)||D.splice(0,0,"prototype","__proto__","constructor"),M.excludeKeys&&(D=D.filter(function(G){return!M.excludeKeys(G)})),S("object:"+D.length+":"),I=this,D.forEach(function(G){I.dispatch(G),S(":"),M.excludeValues||I.dispatch(x[G]),S(",")});if(!this["_"+z]){if(M.ignoreUnknown)return S("["+z+"]");throw new Error('Unknown object type "'+z+'"')}this["_"+z](x)},_array:function(x,G){G=G!==void 0?G:M.unorderedArrays!==!1;var D=this;if(S("array:"+x.length+":"),!G||x.length<=1)return x.forEach(function(E){return D.dispatch(E)});var z=[],G=x.map(function(E){var X=new L,oe=b.slice();return C(M,X,oe).dispatch(E),z=z.concat(oe.slice(b.length)),X.read().toString()});return b=b.concat(z),G.sort(),this._array(G,!1)},_date:function(x){return S("date:"+x.toJSON())},_symbol:function(x){return S("symbol:"+x.toString())},_error:function(x){return S("error:"+x.toString())},_boolean:function(x){return S("bool:"+x.toString())},_string:function(x){S("string:"+x.length+":"),S(x.toString())},_function:function(x){S("fn:"),w(x)?this.dispatch("[native]"):this.dispatch(x.toString()),M.respectFunctionNames!==!1&&this.dispatch("function-name:"+String(x.name)),M.respectFunctionProperties&&this._object(x)},_number:function(x){return S("number:"+x.toString())},_xml:function(x){return S("xml:"+x.toString())},_null:function(){return S("Null")},_undefined:function(){return S("Undefined")},_regexp:function(x){return S("regex:"+x.toString())},_uint8array:function(x){return S("uint8array:"),this.dispatch(Array.prototype.slice.call(x))},_uint8clampedarray:function(x){return S("uint8clampedarray:"),this.dispatch(Array.prototype.slice.call(x))},_int8array:function(x){return S("int8array:"),this.dispatch(Array.prototype.slice.call(x))},_uint16array:function(x){return S("uint16array:"),this.dispatch(Array.prototype.slice.call(x))},_int16array:function(x){return S("int16array:"),this.dispatch(Array.prototype.slice.call(x))},_uint32array:function(x){return S("uint32array:"),this.dispatch(Array.prototype.slice.call(x))},_int32array:function(x){return S("int32array:"),this.dispatch(Array.prototype.slice.call(x))},_float32array:function(x){return S("float32array:"),this.dispatch(Array.prototype.slice.call(x))},_float64array:function(x){return S("float64array:"),this.dispatch(Array.prototype.slice.call(x))},_arraybuffer:function(x){return S("arraybuffer:"),this.dispatch(new Uint8Array(x))},_url:function(x){return S("url:"+x.toString())},_map:function(x){return S("map:"),x=Array.from(x),this._array(x,M.unorderedSets!==!1)},_set:function(x){return S("set:"),x=Array.from(x),this._array(x,M.unorderedSets!==!1)},_file:function(x){return S("file:"),this.dispatch([x.name,x.size,x.type,x.lastModfied])},_blob:function(){if(M.ignoreUnknown)return S("[blob]");throw Error(`Hashing Blob objects is currently not supported
(see https://github.com/puleos/object-hash/issues/26)
Use "options.replacer" or "options.ignoreUnknown"
`)},_domwindow:function(){return S("domwindow")},_bigint:function(x){return S("bigint:"+x.toString())},_process:function(){return S("process")},_timer:function(){return S("timer")},_pipe:function(){return S("pipe")},_tcp:function(){return S("tcp")},_udp:function(){return S("udp")},_tty:function(){return S("tty")},_statwatcher:function(){return S("statwatcher")},_securecontext:function(){return S("securecontext")},_connection:function(){return S("connection")},_zlib:function(){return S("zlib")},_context:function(){return S("context")},_nodescript:function(){return S("nodescript")},_httpparser:function(){return S("httpparser")},_dataview:function(){return S("dataview")},_signal:function(){return S("signal")},_fsevent:function(){return S("fsevent")},_tlswrap:function(){return S("tlswrap")}}}function L(){return{buf:"",write:function(M){this.buf+=M},end:function(M){this.buf+=M},read:function(){return this.buf}}}o.writeToStream=function(M,P,b){return b===void 0&&(b=P,P={}),C(P=A(M,P),b).dispatch(M)}}).call(this,t("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},t("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/fake_9a5aa49d.js","/")},{buffer:3,crypto:5,lYpoI2:11}],2:[function(t,n,o){(function(r,s,a,c,h,p,f,m,d){(function(y){var _=typeof Uint8Array<"u"?Uint8Array:Array,v=43,g=47,A=48,w=97,C=65,L=45,M=95;function P(b){return b=b.charCodeAt(0),b===v||b===L?62:b===g||b===M?63:b<A?-1:b<A+10?b-A+26+26:b<C+26?b-C:b<w+26?b-w+26:void 0}y.toByteArray=function(b){var S,x;if(0<b.length%4)throw new Error("Invalid string. Length must be a multiple of 4");var I=b.length,I=b.charAt(I-2)==="="?2:b.charAt(I-1)==="="?1:0,D=new _(3*b.length/4-I),z=0<I?b.length-4:b.length,G=0;function E(X){D[G++]=X}for(S=0;S<z;S+=4,0)E((16711680&(x=P(b.charAt(S))<<18|P(b.charAt(S+1))<<12|P(b.charAt(S+2))<<6|P(b.charAt(S+3))))>>16),E((65280&x)>>8),E(255&x);return I==2?E(255&(x=P(b.charAt(S))<<2|P(b.charAt(S+1))>>4)):I==1&&(E((x=P(b.charAt(S))<<10|P(b.charAt(S+1))<<4|P(b.charAt(S+2))>>2)>>8&255),E(255&x)),D},y.fromByteArray=function(b){var S,x,I,D,z=b.length%3,G="";function E(X){return"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(X)}for(S=0,I=b.length-z;S<I;S+=3)x=(b[S]<<16)+(b[S+1]<<8)+b[S+2],G+=E((D=x)>>18&63)+E(D>>12&63)+E(D>>6&63)+E(63&D);switch(z){case 1:G=(G+=E((x=b[b.length-1])>>2))+E(x<<4&63)+"==";break;case 2:G=(G=(G+=E((x=(b[b.length-2]<<8)+b[b.length-1])>>10))+E(x>>4&63))+E(x<<2&63)+"="}return G}})(o===void 0?this.base64js={}:o)}).call(this,t("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},t("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js","/node_modules/gulp-browserify/node_modules/base64-js/lib")},{buffer:3,lYpoI2:11}],3:[function(t,n,o){(function(r,s,v,c,h,p,f,m,d){var y=t("base64-js"),_=t("ieee754");function v(T,O,N){if(!(this instanceof v))return new v(T,O,N);var K,W,Y,Q,re=typeof T;if(O==="base64"&&re=="string")for(T=(Q=T).trim?Q.trim():Q.replace(/^\s+|\s+$/g,"");T.length%4!=0;)T+="=";if(re=="number")K=q(T);else if(re=="string")K=v.byteLength(T,O);else{if(re!="object")throw new Error("First argument needs to be a number, array or string.");K=q(T.length)}if(v._useTypedArrays?W=v._augment(new Uint8Array(K)):((W=this).length=K,W._isBuffer=!0),v._useTypedArrays&&typeof T.byteLength=="number")W._set(T);else if(ee(Q=T)||v.isBuffer(Q)||Q&&typeof Q=="object"&&typeof Q.length=="number")for(Y=0;Y<K;Y++)v.isBuffer(T)?W[Y]=T.readUInt8(Y):W[Y]=T[Y];else if(re=="string")W.write(T,0,O);else if(re=="number"&&!v._useTypedArrays&&!N)for(Y=0;Y<K;Y++)W[Y]=0;return W}function g(T,O,N,K){return v._charsWritten=de(function(W){for(var Y=[],Q=0;Q<W.length;Q++)Y.push(255&W.charCodeAt(Q));return Y}(O),T,N,K)}function A(T,O,N,K){return v._charsWritten=de(function(W){for(var Y,Q,re=[],se=0;se<W.length;se++)Q=W.charCodeAt(se),Y=Q>>8,Q=Q%256,re.push(Q),re.push(Y);return re}(O),T,N,K)}function w(T,O,N){var K="";N=Math.min(T.length,N);for(var W=O;W<N;W++)K+=String.fromCharCode(T[W]);return K}function C(T,O,N,Y){Y||(R(typeof N=="boolean","missing or invalid endian"),R(O!=null,"missing offset"),R(O+1<T.length,"Trying to read beyond buffer length"));var W,Y=T.length;if(!(Y<=O))return N?(W=T[O],O+1<Y&&(W|=T[O+1]<<8)):(W=T[O]<<8,O+1<Y&&(W|=T[O+1])),W}function L(T,O,N,Y){Y||(R(typeof N=="boolean","missing or invalid endian"),R(O!=null,"missing offset"),R(O+3<T.length,"Trying to read beyond buffer length"));var W,Y=T.length;if(!(Y<=O))return N?(O+2<Y&&(W=T[O+2]<<16),O+1<Y&&(W|=T[O+1]<<8),W|=T[O],O+3<Y&&(W+=T[O+3]<<24>>>0)):(O+1<Y&&(W=T[O+1]<<16),O+2<Y&&(W|=T[O+2]<<8),O+3<Y&&(W|=T[O+3]),W+=T[O]<<24>>>0),W}function M(T,O,N,K){if(K||(R(typeof N=="boolean","missing or invalid endian"),R(O!=null,"missing offset"),R(O+1<T.length,"Trying to read beyond buffer length")),!(T.length<=O))return K=C(T,O,N,!0),32768&K?-1*(65535-K+1):K}function P(T,O,N,K){if(K||(R(typeof N=="boolean","missing or invalid endian"),R(O!=null,"missing offset"),R(O+3<T.length,"Trying to read beyond buffer length")),!(T.length<=O))return K=L(T,O,N,!0),2147483648&K?-1*(4294967295-K+1):K}function b(T,O,N,K){return K||(R(typeof N=="boolean","missing or invalid endian"),R(O+3<T.length,"Trying to read beyond buffer length")),_.read(T,O,N,23,4)}function S(T,O,N,K){return K||(R(typeof N=="boolean","missing or invalid endian"),R(O+7<T.length,"Trying to read beyond buffer length")),_.read(T,O,N,52,8)}function x(T,O,N,K,W){if(W||(R(O!=null,"missing value"),R(typeof K=="boolean","missing or invalid endian"),R(N!=null,"missing offset"),R(N+1<T.length,"trying to write beyond buffer length"),V(O,65535)),W=T.length,!(W<=N))for(var Y=0,Q=Math.min(W-N,2);Y<Q;Y++)T[N+Y]=(O&255<<8*(K?Y:1-Y))>>>8*(K?Y:1-Y)}function I(T,O,N,K,W){if(W||(R(O!=null,"missing value"),R(typeof K=="boolean","missing or invalid endian"),R(N!=null,"missing offset"),R(N+3<T.length,"trying to write beyond buffer length"),V(O,4294967295)),W=T.length,!(W<=N))for(var Y=0,Q=Math.min(W-N,4);Y<Q;Y++)T[N+Y]=O>>>8*(K?Y:3-Y)&255}function D(T,O,N,K,W){W||(R(O!=null,"missing value"),R(typeof K=="boolean","missing or invalid endian"),R(N!=null,"missing offset"),R(N+1<T.length,"Trying to write beyond buffer length"),U(O,32767,-32768)),T.length<=N||x(T,0<=O?O:65535+O+1,N,K,W)}function z(T,O,N,K,W){W||(R(O!=null,"missing value"),R(typeof K=="boolean","missing or invalid endian"),R(N!=null,"missing offset"),R(N+3<T.length,"Trying to write beyond buffer length"),U(O,2147483647,-2147483648)),T.length<=N||I(T,0<=O?O:4294967295+O+1,N,K,W)}function G(T,O,N,K,W){W||(R(O!=null,"missing value"),R(typeof K=="boolean","missing or invalid endian"),R(N!=null,"missing offset"),R(N+3<T.length,"Trying to write beyond buffer length"),B(O,34028234663852886e22,-34028234663852886e22)),T.length<=N||_.write(T,O,N,K,23,4)}function E(T,O,N,K,W){W||(R(O!=null,"missing value"),R(typeof K=="boolean","missing or invalid endian"),R(N!=null,"missing offset"),R(N+7<T.length,"Trying to write beyond buffer length"),B(O,17976931348623157e292,-17976931348623157e292)),T.length<=N||_.write(T,O,N,K,52,8)}o.Buffer=v,o.SlowBuffer=v,o.INSPECT_MAX_BYTES=50,v.poolSize=8192,v._useTypedArrays=function(){try{var T=new ArrayBuffer(0),O=new Uint8Array(T);return O.foo=function(){return 42},O.foo()===42&&typeof O.subarray=="function"}catch{return!1}}(),v.isEncoding=function(T){switch(String(T).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"raw":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},v.isBuffer=function(T){return!(T==null||!T._isBuffer)},v.byteLength=function(T,O){var N;switch(T+="",O||"utf8"){case"hex":N=T.length/2;break;case"utf8":case"utf-8":N=ce(T).length;break;case"ascii":case"binary":case"raw":N=T.length;break;case"base64":N=le(T).length;break;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":N=2*T.length;break;default:throw new Error("Unknown encoding")}return N},v.concat=function(T,O){if(R(ee(T),`Usage: Buffer.concat(list, [totalLength])
list should be an Array.`),T.length===0)return new v(0);if(T.length===1)return T[0];if(typeof O!="number")for(W=O=0;W<T.length;W++)O+=T[W].length;for(var N=new v(O),K=0,W=0;W<T.length;W++){var Y=T[W];Y.copy(N,K),K+=Y.length}return N},v.prototype.write=function(T,O,N,K){isFinite(O)?isFinite(N)||(K=N,N=void 0):(se=K,K=O,O=N,N=se),O=Number(O)||0;var W,Y,Q,re,se=this.length-O;switch((!N||se<(N=Number(N)))&&(N=se),K=String(K||"utf8").toLowerCase()){case"hex":W=function(j,F,ie,he){ie=Number(ie)||0;var _e=j.length-ie;(!he||_e<(he=Number(he)))&&(he=_e),R((_e=F.length)%2==0,"Invalid hex string"),_e/2<he&&(he=_e/2);for(var Le=0;Le<he;Le++){var Pe=parseInt(F.substr(2*Le,2),16);R(!isNaN(Pe),"Invalid hex string"),j[ie+Le]=Pe}return v._charsWritten=2*Le,Le}(this,T,O,N);break;case"utf8":case"utf-8":Y=this,Q=O,re=N,W=v._charsWritten=de(ce(T),Y,Q,re);break;case"ascii":case"binary":W=g(this,T,O,N);break;case"base64":Y=this,Q=O,re=N,W=v._charsWritten=de(le(T),Y,Q,re);break;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":W=A(this,T,O,N);break;default:throw new Error("Unknown encoding")}return W},v.prototype.toString=function(T,O,N){var K,W,Y,Q,re=this;if(T=String(T||"utf8").toLowerCase(),O=Number(O)||0,(N=N!==void 0?Number(N):re.length)===O)return"";switch(T){case"hex":K=function(se,j,F){var ie=se.length;(!j||j<0)&&(j=0),(!F||F<0||ie<F)&&(F=ie);for(var he="",_e=j;_e<F;_e++)he+=te(se[_e]);return he}(re,O,N);break;case"utf8":case"utf-8":K=function(se,j,F){var ie="",he="";F=Math.min(se.length,F);for(var _e=j;_e<F;_e++)se[_e]<=127?(ie+=k(he)+String.fromCharCode(se[_e]),he=""):he+="%"+se[_e].toString(16);return ie+k(he)}(re,O,N);break;case"ascii":case"binary":K=w(re,O,N);break;case"base64":W=re,Q=N,K=(Y=O)===0&&Q===W.length?y.fromByteArray(W):y.fromByteArray(W.slice(Y,Q));break;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":K=function(se,j,F){for(var ie=se.slice(j,F),he="",_e=0;_e<ie.length;_e+=2)he+=String.fromCharCode(ie[_e]+256*ie[_e+1]);return he}(re,O,N);break;default:throw new Error("Unknown encoding")}return K},v.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}},v.prototype.copy=function(T,O,N,K){if(O=O||0,(K=K||K===0?K:this.length)!==(N=N||0)&&T.length!==0&&this.length!==0){R(N<=K,"sourceEnd < sourceStart"),R(0<=O&&O<T.length,"targetStart out of bounds"),R(0<=N&&N<this.length,"sourceStart out of bounds"),R(0<=K&&K<=this.length,"sourceEnd out of bounds"),K>this.length&&(K=this.length);var W=(K=T.length-O<K-N?T.length-O+N:K)-N;if(W<100||!v._useTypedArrays)for(var Y=0;Y<W;Y++)T[Y+O]=this[Y+N];else T._set(this.subarray(N,N+W),O)}},v.prototype.slice=function(T,O){var N=this.length;if(T=oe(T,N,0),O=oe(O,N,N),v._useTypedArrays)return v._augment(this.subarray(T,O));for(var K=O-T,W=new v(K,void 0,!0),Y=0;Y<K;Y++)W[Y]=this[Y+T];return W},v.prototype.get=function(T){return console.log(".get() is deprecated. Access using array indexes instead."),this.readUInt8(T)},v.prototype.set=function(T,O){return console.log(".set() is deprecated. Access using array indexes instead."),this.writeUInt8(T,O)},v.prototype.readUInt8=function(T,O){if(O||(R(T!=null,"missing offset"),R(T<this.length,"Trying to read beyond buffer length")),!(T>=this.length))return this[T]},v.prototype.readUInt16LE=function(T,O){return C(this,T,!0,O)},v.prototype.readUInt16BE=function(T,O){return C(this,T,!1,O)},v.prototype.readUInt32LE=function(T,O){return L(this,T,!0,O)},v.prototype.readUInt32BE=function(T,O){return L(this,T,!1,O)},v.prototype.readInt8=function(T,O){if(O||(R(T!=null,"missing offset"),R(T<this.length,"Trying to read beyond buffer length")),!(T>=this.length))return 128&this[T]?-1*(255-this[T]+1):this[T]},v.prototype.readInt16LE=function(T,O){return M(this,T,!0,O)},v.prototype.readInt16BE=function(T,O){return M(this,T,!1,O)},v.prototype.readInt32LE=function(T,O){return P(this,T,!0,O)},v.prototype.readInt32BE=function(T,O){return P(this,T,!1,O)},v.prototype.readFloatLE=function(T,O){return b(this,T,!0,O)},v.prototype.readFloatBE=function(T,O){return b(this,T,!1,O)},v.prototype.readDoubleLE=function(T,O){return S(this,T,!0,O)},v.prototype.readDoubleBE=function(T,O){return S(this,T,!1,O)},v.prototype.writeUInt8=function(T,O,N){N||(R(T!=null,"missing value"),R(O!=null,"missing offset"),R(O<this.length,"trying to write beyond buffer length"),V(T,255)),O>=this.length||(this[O]=T)},v.prototype.writeUInt16LE=function(T,O,N){x(this,T,O,!0,N)},v.prototype.writeUInt16BE=function(T,O,N){x(this,T,O,!1,N)},v.prototype.writeUInt32LE=function(T,O,N){I(this,T,O,!0,N)},v.prototype.writeUInt32BE=function(T,O,N){I(this,T,O,!1,N)},v.prototype.writeInt8=function(T,O,N){N||(R(T!=null,"missing value"),R(O!=null,"missing offset"),R(O<this.length,"Trying to write beyond buffer length"),U(T,127,-128)),O>=this.length||(0<=T?this.writeUInt8(T,O,N):this.writeUInt8(255+T+1,O,N))},v.prototype.writeInt16LE=function(T,O,N){D(this,T,O,!0,N)},v.prototype.writeInt16BE=function(T,O,N){D(this,T,O,!1,N)},v.prototype.writeInt32LE=function(T,O,N){z(this,T,O,!0,N)},v.prototype.writeInt32BE=function(T,O,N){z(this,T,O,!1,N)},v.prototype.writeFloatLE=function(T,O,N){G(this,T,O,!0,N)},v.prototype.writeFloatBE=function(T,O,N){G(this,T,O,!1,N)},v.prototype.writeDoubleLE=function(T,O,N){E(this,T,O,!0,N)},v.prototype.writeDoubleBE=function(T,O,N){E(this,T,O,!1,N)},v.prototype.fill=function(T,O,N){if(O=O||0,N=N||this.length,R(typeof(T=typeof(T=T||0)=="string"?T.charCodeAt(0):T)=="number"&&!isNaN(T),"value is not a number"),R(O<=N,"end < start"),N!==O&&this.length!==0){R(0<=O&&O<this.length,"start out of bounds"),R(0<=N&&N<=this.length,"end out of bounds");for(var K=O;K<N;K++)this[K]=T}},v.prototype.inspect=function(){for(var T=[],O=this.length,N=0;N<O;N++)if(T[N]=te(this[N]),N===o.INSPECT_MAX_BYTES){T[N+1]="...";break}return"<Buffer "+T.join(" ")+">"},v.prototype.toArrayBuffer=function(){if(typeof Uint8Array>"u")throw new Error("Buffer.toArrayBuffer not supported in this browser");if(v._useTypedArrays)return new v(this).buffer;for(var T=new Uint8Array(this.length),O=0,N=T.length;O<N;O+=1)T[O]=this[O];return T.buffer};var X=v.prototype;function oe(T,O,N){return typeof T!="number"?N:O<=(T=~~T)?O:0<=T||0<=(T+=O)?T:0}function q(T){return(T=~~Math.ceil(+T))<0?0:T}function ee(T){return(Array.isArray||function(O){return Object.prototype.toString.call(O)==="[object Array]"})(T)}function te(T){return T<16?"0"+T.toString(16):T.toString(16)}function ce(T){for(var O=[],N=0;N<T.length;N++){var K=T.charCodeAt(N);if(K<=127)O.push(T.charCodeAt(N));else for(var W=N,Y=(55296<=K&&K<=57343&&N++,encodeURIComponent(T.slice(W,N+1)).substr(1).split("%")),Q=0;Q<Y.length;Q++)O.push(parseInt(Y[Q],16))}return O}function le(T){return y.toByteArray(T)}function de(T,O,N,K){for(var W=0;W<K&&!(W+N>=O.length||W>=T.length);W++)O[W+N]=T[W];return W}function k(T){try{return decodeURIComponent(T)}catch{return"ï¿½"}}function V(T,O){R(typeof T=="number","cannot write a non-number as a number"),R(0<=T,"specified a negative value for writing an unsigned value"),R(T<=O,"value is larger than maximum value for type"),R(Math.floor(T)===T,"value has a fractional component")}function U(T,O,N){R(typeof T=="number","cannot write a non-number as a number"),R(T<=O,"value larger than maximum allowed value"),R(N<=T,"value smaller than minimum allowed value"),R(Math.floor(T)===T,"value has a fractional component")}function B(T,O,N){R(typeof T=="number","cannot write a non-number as a number"),R(T<=O,"value larger than maximum allowed value"),R(N<=T,"value smaller than minimum allowed value")}function R(T,O){if(!T)throw new Error(O||"Failed assertion")}v._augment=function(T){return T._isBuffer=!0,T._get=T.get,T._set=T.set,T.get=X.get,T.set=X.set,T.write=X.write,T.toString=X.toString,T.toLocaleString=X.toString,T.toJSON=X.toJSON,T.copy=X.copy,T.slice=X.slice,T.readUInt8=X.readUInt8,T.readUInt16LE=X.readUInt16LE,T.readUInt16BE=X.readUInt16BE,T.readUInt32LE=X.readUInt32LE,T.readUInt32BE=X.readUInt32BE,T.readInt8=X.readInt8,T.readInt16LE=X.readInt16LE,T.readInt16BE=X.readInt16BE,T.readInt32LE=X.readInt32LE,T.readInt32BE=X.readInt32BE,T.readFloatLE=X.readFloatLE,T.readFloatBE=X.readFloatBE,T.readDoubleLE=X.readDoubleLE,T.readDoubleBE=X.readDoubleBE,T.writeUInt8=X.writeUInt8,T.writeUInt16LE=X.writeUInt16LE,T.writeUInt16BE=X.writeUInt16BE,T.writeUInt32LE=X.writeUInt32LE,T.writeUInt32BE=X.writeUInt32BE,T.writeInt8=X.writeInt8,T.writeInt16LE=X.writeInt16LE,T.writeInt16BE=X.writeInt16BE,T.writeInt32LE=X.writeInt32LE,T.writeInt32BE=X.writeInt32BE,T.writeFloatLE=X.writeFloatLE,T.writeFloatBE=X.writeFloatBE,T.writeDoubleLE=X.writeDoubleLE,T.writeDoubleBE=X.writeDoubleBE,T.fill=X.fill,T.inspect=X.inspect,T.toArrayBuffer=X.toArrayBuffer,T}}).call(this,t("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},t("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/buffer/index.js","/node_modules/gulp-browserify/node_modules/buffer")},{"base64-js":2,buffer:3,ieee754:10,lYpoI2:11}],4:[function(t,n,o){(function(r,s,y,c,h,p,f,m,d){var y=t("buffer").Buffer,_=4,v=new y(_);v.fill(0),n.exports={hash:function(g,A,w,C){for(var L=A(function(x,I){x.length%_!=0&&(D=x.length+(_-x.length%_),x=y.concat([x,v],D));for(var D,z=[],G=I?x.readInt32BE:x.readInt32LE,E=0;E<x.length;E+=_)z.push(G.call(x,E));return z}(g=y.isBuffer(g)?g:new y(g),C),8*g.length),A=C,M=new y(w),P=A?M.writeInt32BE:M.writeInt32LE,b=0;b<L.length;b++)P.call(M,L[b],4*b,!0);return M}}}).call(this,t("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},t("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js","/node_modules/gulp-browserify/node_modules/crypto-browserify")},{buffer:3,lYpoI2:11}],5:[function(t,n,o){(function(r,s,y,c,h,p,f,m,d){var y=t("buffer").Buffer,_=t("./sha"),v=t("./sha256"),g=t("./rng"),A={sha1:_,sha256:v,md5:t("./md5")},w=64,C=new y(w);function L(x,I){var D=A[x=x||"sha1"],z=[];return D||M("algorithm:",x,"is not yet supported"),{update:function(G){return y.isBuffer(G)||(G=new y(G)),z.push(G),G.length,this},digest:function(G){var E=y.concat(z),E=I?function(X,oe,q){y.isBuffer(oe)||(oe=new y(oe)),y.isBuffer(q)||(q=new y(q)),oe.length>w?oe=X(oe):oe.length<w&&(oe=y.concat([oe,C],w));for(var ee=new y(w),te=new y(w),ce=0;ce<w;ce++)ee[ce]=54^oe[ce],te[ce]=92^oe[ce];return q=X(y.concat([ee,q])),X(y.concat([te,q]))}(D,I,E):D(E);return z=null,G?E.toString(G):E}}}function M(){var x=[].slice.call(arguments).join(" ");throw new Error([x,"we accept pull requests","http://github.com/dominictarr/crypto-browserify"].join(`
`))}C.fill(0),o.createHash=function(x){return L(x)},o.createHmac=L,o.randomBytes=function(x,I){if(!I||!I.call)return new y(g(x));try{I.call(this,void 0,new y(g(x)))}catch(D){I(D)}};var P,b=["createCredentials","createCipher","createCipheriv","createDecipher","createDecipheriv","createSign","createVerify","createDiffieHellman","pbkdf2"],S=function(x){o[x]=function(){M("sorry,",x,"is not implemented yet")}};for(P in b)S(b[P])}).call(this,t("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},t("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js","/node_modules/gulp-browserify/node_modules/crypto-browserify")},{"./md5":6,"./rng":7,"./sha":8,"./sha256":9,buffer:3,lYpoI2:11}],6:[function(t,n,o){(function(r,s,a,c,h,p,f,m,d){var y=t("./helpers");function _(M,P){M[P>>5]|=128<<P%32,M[14+(P+64>>>9<<4)]=P;for(var b=1732584193,S=-271733879,x=-1732584194,I=271733878,D=0;D<M.length;D+=16){var z=b,G=S,E=x,X=I,b=g(b,S,x,I,M[D+0],7,-680876936),I=g(I,b,S,x,M[D+1],12,-389564586),x=g(x,I,b,S,M[D+2],17,606105819),S=g(S,x,I,b,M[D+3],22,-1044525330);b=g(b,S,x,I,M[D+4],7,-176418897),I=g(I,b,S,x,M[D+5],12,1200080426),x=g(x,I,b,S,M[D+6],17,-1473231341),S=g(S,x,I,b,M[D+7],22,-45705983),b=g(b,S,x,I,M[D+8],7,1770035416),I=g(I,b,S,x,M[D+9],12,-1958414417),x=g(x,I,b,S,M[D+10],17,-42063),S=g(S,x,I,b,M[D+11],22,-1990404162),b=g(b,S,x,I,M[D+12],7,1804603682),I=g(I,b,S,x,M[D+13],12,-40341101),x=g(x,I,b,S,M[D+14],17,-1502002290),b=A(b,S=g(S,x,I,b,M[D+15],22,1236535329),x,I,M[D+1],5,-165796510),I=A(I,b,S,x,M[D+6],9,-1069501632),x=A(x,I,b,S,M[D+11],14,643717713),S=A(S,x,I,b,M[D+0],20,-373897302),b=A(b,S,x,I,M[D+5],5,-701558691),I=A(I,b,S,x,M[D+10],9,38016083),x=A(x,I,b,S,M[D+15],14,-660478335),S=A(S,x,I,b,M[D+4],20,-405537848),b=A(b,S,x,I,M[D+9],5,568446438),I=A(I,b,S,x,M[D+14],9,-1019803690),x=A(x,I,b,S,M[D+3],14,-187363961),S=A(S,x,I,b,M[D+8],20,1163531501),b=A(b,S,x,I,M[D+13],5,-1444681467),I=A(I,b,S,x,M[D+2],9,-51403784),x=A(x,I,b,S,M[D+7],14,1735328473),b=w(b,S=A(S,x,I,b,M[D+12],20,-1926607734),x,I,M[D+5],4,-378558),I=w(I,b,S,x,M[D+8],11,-2022574463),x=w(x,I,b,S,M[D+11],16,1839030562),S=w(S,x,I,b,M[D+14],23,-35309556),b=w(b,S,x,I,M[D+1],4,-1530992060),I=w(I,b,S,x,M[D+4],11,1272893353),x=w(x,I,b,S,M[D+7],16,-155497632),S=w(S,x,I,b,M[D+10],23,-1094730640),b=w(b,S,x,I,M[D+13],4,681279174),I=w(I,b,S,x,M[D+0],11,-358537222),x=w(x,I,b,S,M[D+3],16,-722521979),S=w(S,x,I,b,M[D+6],23,76029189),b=w(b,S,x,I,M[D+9],4,-640364487),I=w(I,b,S,x,M[D+12],11,-421815835),x=w(x,I,b,S,M[D+15],16,530742520),b=C(b,S=w(S,x,I,b,M[D+2],23,-995338651),x,I,M[D+0],6,-198630844),I=C(I,b,S,x,M[D+7],10,1126891415),x=C(x,I,b,S,M[D+14],15,-1416354905),S=C(S,x,I,b,M[D+5],21,-57434055),b=C(b,S,x,I,M[D+12],6,1700485571),I=C(I,b,S,x,M[D+3],10,-1894986606),x=C(x,I,b,S,M[D+10],15,-1051523),S=C(S,x,I,b,M[D+1],21,-2054922799),b=C(b,S,x,I,M[D+8],6,1873313359),I=C(I,b,S,x,M[D+15],10,-30611744),x=C(x,I,b,S,M[D+6],15,-1560198380),S=C(S,x,I,b,M[D+13],21,1309151649),b=C(b,S,x,I,M[D+4],6,-145523070),I=C(I,b,S,x,M[D+11],10,-1120210379),x=C(x,I,b,S,M[D+2],15,718787259),S=C(S,x,I,b,M[D+9],21,-343485551),b=L(b,z),S=L(S,G),x=L(x,E),I=L(I,X)}return Array(b,S,x,I)}function v(M,P,b,S,x,I){return L((P=L(L(P,M),L(S,I)))<<x|P>>>32-x,b)}function g(M,P,b,S,x,I,D){return v(P&b|~P&S,M,P,x,I,D)}function A(M,P,b,S,x,I,D){return v(P&S|b&~S,M,P,x,I,D)}function w(M,P,b,S,x,I,D){return v(P^b^S,M,P,x,I,D)}function C(M,P,b,S,x,I,D){return v(b^(P|~S),M,P,x,I,D)}function L(M,P){var b=(65535&M)+(65535&P);return(M>>16)+(P>>16)+(b>>16)<<16|65535&b}n.exports=function(M){return y.hash(M,_,16)}}).call(this,t("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},t("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js","/node_modules/gulp-browserify/node_modules/crypto-browserify")},{"./helpers":4,buffer:3,lYpoI2:11}],7:[function(t,n,o){(function(r,s,a,c,h,p,f,m,d){n.exports=function(y){for(var _,v=new Array(y),g=0;g<y;g++)!(3&g)&&(_=4294967296*Math.random()),v[g]=_>>>((3&g)<<3)&255;return v}}).call(this,t("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},t("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js","/node_modules/gulp-browserify/node_modules/crypto-browserify")},{buffer:3,lYpoI2:11}],8:[function(t,n,o){(function(r,s,a,c,h,p,f,m,d){var y=t("./helpers");function _(A,w){A[w>>5]|=128<<24-w%32,A[15+(w+64>>9<<4)]=w;for(var C,L,M,P=Array(80),b=1732584193,S=-271733879,x=-1732584194,I=271733878,D=-1009589776,z=0;z<A.length;z+=16){for(var G=b,E=S,X=x,oe=I,q=D,ee=0;ee<80;ee++){P[ee]=ee<16?A[z+ee]:g(P[ee-3]^P[ee-8]^P[ee-14]^P[ee-16],1);var te=v(v(g(b,5),(te=S,L=x,M=I,(C=ee)<20?te&L|~te&M:!(C<40)&&C<60?te&L|te&M|L&M:te^L^M)),v(v(D,P[ee]),(C=ee)<20?1518500249:C<40?1859775393:C<60?-1894007588:-899497514)),D=I,I=x,x=g(S,30),S=b,b=te}b=v(b,G),S=v(S,E),x=v(x,X),I=v(I,oe),D=v(D,q)}return Array(b,S,x,I,D)}function v(A,w){var C=(65535&A)+(65535&w);return(A>>16)+(w>>16)+(C>>16)<<16|65535&C}function g(A,w){return A<<w|A>>>32-w}n.exports=function(A){return y.hash(A,_,20,!0)}}).call(this,t("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},t("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js","/node_modules/gulp-browserify/node_modules/crypto-browserify")},{"./helpers":4,buffer:3,lYpoI2:11}],9:[function(t,n,o){(function(r,s,a,c,h,p,f,m,d){function y(w,C){var L=(65535&w)+(65535&C);return(w>>16)+(C>>16)+(L>>16)<<16|65535&L}function _(w,C){var L,M=new Array(1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298),P=new Array(1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225),b=new Array(64);w[C>>5]|=128<<24-C%32,w[15+(C+64>>9<<4)]=C;for(var S,x,I=0;I<w.length;I+=16){for(var D=P[0],z=P[1],G=P[2],E=P[3],X=P[4],oe=P[5],q=P[6],ee=P[7],te=0;te<64;te++)b[te]=te<16?w[te+I]:y(y(y((x=b[te-2],g(x,17)^g(x,19)^A(x,10)),b[te-7]),(x=b[te-15],g(x,7)^g(x,18)^A(x,3))),b[te-16]),L=y(y(y(y(ee,g(x=X,6)^g(x,11)^g(x,25)),X&oe^~X&q),M[te]),b[te]),S=y(g(S=D,2)^g(S,13)^g(S,22),D&z^D&G^z&G),ee=q,q=oe,oe=X,X=y(E,L),E=G,G=z,z=D,D=y(L,S);P[0]=y(D,P[0]),P[1]=y(z,P[1]),P[2]=y(G,P[2]),P[3]=y(E,P[3]),P[4]=y(X,P[4]),P[5]=y(oe,P[5]),P[6]=y(q,P[6]),P[7]=y(ee,P[7])}return P}var v=t("./helpers"),g=function(w,C){return w>>>C|w<<32-C},A=function(w,C){return w>>>C};n.exports=function(w){return v.hash(w,_,32,!0)}}).call(this,t("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},t("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js","/node_modules/gulp-browserify/node_modules/crypto-browserify")},{"./helpers":4,buffer:3,lYpoI2:11}],10:[function(t,n,o){(function(r,s,a,c,h,p,f,m,d){o.read=function(y,_,v,g,I){var w,C,L=8*I-g-1,M=(1<<L)-1,P=M>>1,b=-7,S=v?I-1:0,x=v?-1:1,I=y[_+S];for(S+=x,w=I&(1<<-b)-1,I>>=-b,b+=L;0<b;w=256*w+y[_+S],S+=x,b-=8);for(C=w&(1<<-b)-1,w>>=-b,b+=g;0<b;C=256*C+y[_+S],S+=x,b-=8);if(w===0)w=1-P;else{if(w===M)return C?NaN:1/0*(I?-1:1);C+=Math.pow(2,g),w-=P}return(I?-1:1)*C*Math.pow(2,w-g)},o.write=function(y,_,v,g,A,D){var C,L,M=8*D-A-1,P=(1<<M)-1,b=P>>1,S=A===23?Math.pow(2,-24)-Math.pow(2,-77):0,x=g?0:D-1,I=g?1:-1,D=_<0||_===0&&1/_<0?1:0;for(_=Math.abs(_),isNaN(_)||_===1/0?(L=isNaN(_)?1:0,C=P):(C=Math.floor(Math.log(_)/Math.LN2),_*(g=Math.pow(2,-C))<1&&(C--,g*=2),2<=(_+=1<=C+b?S/g:S*Math.pow(2,1-b))*g&&(C++,g/=2),P<=C+b?(L=0,C=P):1<=C+b?(L=(_*g-1)*Math.pow(2,A),C+=b):(L=_*Math.pow(2,b-1)*Math.pow(2,A),C=0));8<=A;y[v+x]=255&L,x+=I,L/=256,A-=8);for(C=C<<A|L,M+=A;0<M;y[v+x]=255&C,x+=I,C/=256,M-=8);y[v+x-I]|=128*D}}).call(this,t("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},t("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/ieee754/index.js","/node_modules/gulp-browserify/node_modules/ieee754")},{buffer:3,lYpoI2:11}],11:[function(t,n,o){(function(r,s,a,c,h,p,f,m,d){var y,_,v;function g(){}(r=n.exports={}).nextTick=(_=typeof window<"u"&&window.setImmediate,v=typeof window<"u"&&window.postMessage&&window.addEventListener,_?function(A){return window.setImmediate(A)}:v?(y=[],window.addEventListener("message",function(A){var w=A.source;w!==window&&w!==null||A.data!=="process-tick"||(A.stopPropagation(),0<y.length&&y.shift()())},!0),function(A){y.push(A),window.postMessage("process-tick","*")}):function(A){setTimeout(A,0)}),r.title="browser",r.browser=!0,r.env={},r.argv=[],r.on=g,r.addListener=g,r.once=g,r.off=g,r.removeListener=g,r.removeAllListeners=g,r.emit=g,r.binding=function(A){throw new Error("process.binding is not supported")},r.cwd=function(){return"/"},r.chdir=function(A){throw new Error("process.chdir is not supported")}}).call(this,t("lYpoI2"),typeof self<"u"?self:typeof window<"u"?window:{},t("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/gulp-browserify/node_modules/process/browser.js","/node_modules/gulp-browserify/node_modules/process")},{buffer:3,lYpoI2:11}]},{},[1])(1)})}(Ao)),Ao.exports}var Eu=Xu();const Zu=on(Eu);var Po,Ps;function Cs(){return Ps||(Ps=1,Po=["precision","highp","mediump","lowp","attribute","const","uniform","varying","break","continue","do","for","while","if","else","in","out","inout","float","int","uint","void","bool","true","false","discard","return","mat2","mat3","mat4","vec2","vec3","vec4","ivec2","ivec3","ivec4","bvec2","bvec3","bvec4","sampler1D","sampler2D","sampler3D","samplerCube","sampler1DShadow","sampler2DShadow","struct","asm","class","union","enum","typedef","template","this","packed","goto","switch","default","inline","noinline","volatile","public","static","extern","external","interface","long","short","double","half","fixed","unsigned","input","output","hvec2","hvec3","hvec4","dvec2","dvec3","dvec4","fvec2","fvec3","fvec4","sampler2DRect","sampler3DRect","sampler2DRectShadow","sizeof","cast","namespace","using"]),Po}var Co,Ts;function Ku(){return Ts||(Ts=1,Co=["<<=",">>=","++","--","<<",">>","<=",">=","==","!=","&&","||","+=","-=","*=","/=","%=","&=","^^","^=","|=","(",")","[","]",".","!","~","*","/","%","+","-","<",">","&","^","|","?",":","=",",",";","{","}"]),Co}var To,Is;function Os(){return Is||(Is=1,To=["abs","acos","all","any","asin","atan","ceil","clamp","cos","cross","dFdx","dFdy","degrees","distance","dot","equal","exp","exp2","faceforward","floor","fract","gl_BackColor","gl_BackLightModelProduct","gl_BackLightProduct","gl_BackMaterial","gl_BackSecondaryColor","gl_ClipPlane","gl_ClipVertex","gl_Color","gl_DepthRange","gl_DepthRangeParameters","gl_EyePlaneQ","gl_EyePlaneR","gl_EyePlaneS","gl_EyePlaneT","gl_Fog","gl_FogCoord","gl_FogFragCoord","gl_FogParameters","gl_FragColor","gl_FragCoord","gl_FragData","gl_FragDepth","gl_FragDepthEXT","gl_FrontColor","gl_FrontFacing","gl_FrontLightModelProduct","gl_FrontLightProduct","gl_FrontMaterial","gl_FrontSecondaryColor","gl_LightModel","gl_LightModelParameters","gl_LightModelProducts","gl_LightProducts","gl_LightSource","gl_LightSourceParameters","gl_MaterialParameters","gl_MaxClipPlanes","gl_MaxCombinedTextureImageUnits","gl_MaxDrawBuffers","gl_MaxFragmentUniformComponents","gl_MaxLights","gl_MaxTextureCoords","gl_MaxTextureImageUnits","gl_MaxTextureUnits","gl_MaxVaryingFloats","gl_MaxVertexAttribs","gl_MaxVertexTextureImageUnits","gl_MaxVertexUniformComponents","gl_ModelViewMatrix","gl_ModelViewMatrixInverse","gl_ModelViewMatrixInverseTranspose","gl_ModelViewMatrixTranspose","gl_ModelViewProjectionMatrix","gl_ModelViewProjectionMatrixInverse","gl_ModelViewProjectionMatrixInverseTranspose","gl_ModelViewProjectionMatrixTranspose","gl_MultiTexCoord0","gl_MultiTexCoord1","gl_MultiTexCoord2","gl_MultiTexCoord3","gl_MultiTexCoord4","gl_MultiTexCoord5","gl_MultiTexCoord6","gl_MultiTexCoord7","gl_Normal","gl_NormalMatrix","gl_NormalScale","gl_ObjectPlaneQ","gl_ObjectPlaneR","gl_ObjectPlaneS","gl_ObjectPlaneT","gl_Point","gl_PointCoord","gl_PointParameters","gl_PointSize","gl_Position","gl_ProjectionMatrix","gl_ProjectionMatrixInverse","gl_ProjectionMatrixInverseTranspose","gl_ProjectionMatrixTranspose","gl_SecondaryColor","gl_TexCoord","gl_TextureEnvColor","gl_TextureMatrix","gl_TextureMatrixInverse","gl_TextureMatrixInverseTranspose","gl_TextureMatrixTranspose","gl_Vertex","greaterThan","greaterThanEqual","inversesqrt","length","lessThan","lessThanEqual","log","log2","matrixCompMult","max","min","mix","mod","normalize","not","notEqual","pow","radians","reflect","refract","sign","sin","smoothstep","sqrt","step","tan","texture2D","texture2DLod","texture2DProj","texture2DProjLod","textureCube","textureCubeLod","texture2DLodEXT","texture2DProjLodEXT","textureCubeLodEXT","texture2DGradEXT","texture2DProjGradEXT","textureCubeGradEXT"]),To}var Io,Ls;function qu(){if(Ls)return Io;Ls=1;var i=Cs();return Io=i.slice().concat(["layout","centroid","smooth","case","mat2x2","mat2x3","mat2x4","mat3x2","mat3x3","mat3x4","mat4x2","mat4x3","mat4x4","uvec2","uvec3","uvec4","samplerCubeShadow","sampler2DArray","sampler2DArrayShadow","isampler2D","isampler3D","isamplerCube","isampler2DArray","usampler2D","usampler3D","usamplerCube","usampler2DArray","coherent","restrict","readonly","writeonly","resource","atomic_uint","noperspective","patch","sample","subroutine","common","partition","active","filter","image1D","image2D","image3D","imageCube","iimage1D","iimage2D","iimage3D","iimageCube","uimage1D","uimage2D","uimage3D","uimageCube","image1DArray","image2DArray","iimage1DArray","iimage2DArray","uimage1DArray","uimage2DArray","image1DShadow","image2DShadow","image1DArrayShadow","image2DArrayShadow","imageBuffer","iimageBuffer","uimageBuffer","sampler1DArray","sampler1DArrayShadow","isampler1D","isampler1DArray","usampler1D","usampler1DArray","isampler2DRect","usampler2DRect","samplerBuffer","isamplerBuffer","usamplerBuffer","sampler2DMS","isampler2DMS","usampler2DMS","sampler2DMSArray","isampler2DMSArray","usampler2DMSArray"]),Io}var Oo,Ds;function Qu(){if(Ds)return Oo;Ds=1;var i=Os();return i=i.slice().filter(function(e){return!/^(gl\_|texture)/.test(e)}),Oo=i.concat(["gl_VertexID","gl_InstanceID","gl_Position","gl_PointSize","gl_FragCoord","gl_FrontFacing","gl_FragDepth","gl_PointCoord","gl_MaxVertexAttribs","gl_MaxVertexUniformVectors","gl_MaxVertexOutputVectors","gl_MaxFragmentInputVectors","gl_MaxVertexTextureImageUnits","gl_MaxCombinedTextureImageUnits","gl_MaxTextureImageUnits","gl_MaxFragmentUniformVectors","gl_MaxDrawBuffers","gl_MinProgramTexelOffset","gl_MaxProgramTexelOffset","gl_DepthRangeParameters","gl_DepthRange","trunc","round","roundEven","isnan","isinf","floatBitsToInt","floatBitsToUint","intBitsToFloat","uintBitsToFloat","packSnorm2x16","unpackSnorm2x16","packUnorm2x16","unpackUnorm2x16","packHalf2x16","unpackHalf2x16","outerProduct","transpose","determinant","inverse","texture","textureSize","textureProj","textureLod","textureOffset","texelFetch","texelFetchOffset","textureProjOffset","textureLodOffset","textureProjLod","textureProjLodOffset","textureGrad","textureGradOffset","textureProjGrad","textureProjGradOffset"]),Oo}var Lo,ks;function Ju(){if(ks)return Lo;ks=1,Lo=C;var i=Cs(),e=Ku(),t=Os(),n=qu(),o=Qu(),r=999,s=9999,a=0,c=1,h=2,p=3,f=4,m=5,d=6,y=7,_=8,v=9,g=10,A=11,w=["block-comment","line-comment","preprocessor","operator","integer","float","ident","builtin","keyword","whitespace","eof","integer"];function C(L){var M=0,P=0,b=r,S,x,I=[],D=[],z=1,G=0,E=0,X=!1,oe=!1,q="",ee;L=L||{};var te=t,ce=i;L.version==="300 es"&&(te=o,ce=n);for(var le={},de={},M=0;M<te.length;M++)le[te[M]]=!0;for(var M=0;M<ce.length;M++)de[ce[M]]=!0;return function(j){return D=[],j!==null?V(j):U()};function k(j){j.length&&D.push({type:w[b],data:j,position:E,line:z,column:G})}function V(j){M=0,j.toString&&(j=j.toString()),q+=j.replace(/\r\n/g,`
`),ee=q.length;for(var F;S=q[M],M<ee;){switch(F=M,b){case a:M=N();break;case c:M=O();break;case h:M=T();break;case p:M=K();break;case f:M=Q();break;case A:M=Y();break;case m:M=re();break;case s:M=se();break;case v:M=R();break;case r:M=B();break}if(F!==M)switch(q[F]){case`
`:G=0,++z;break;default:++G;break}}return P+=M,q=q.slice(M),D}function U(j){return I.length&&k(I.join("")),b=g,k("(eof)"),D}function B(){return I=I.length?[]:I,x==="/"&&S==="*"?(E=P+M-1,b=a,x=S,M+1):x==="/"&&S==="/"?(E=P+M-1,b=c,x=S,M+1):S==="#"?(b=h,E=P+M,M):/\s/.test(S)?(b=v,E=P+M,M):(X=/\d/.test(S),oe=/[^\w_]/.test(S),E=P+M,b=X?f:oe?p:s,M)}function R(){return/[^\s]/g.test(S)?(k(I.join("")),b=r,M):(I.push(S),x=S,M+1)}function T(){return(S==="\r"||S===`
`)&&x!=="\\"?(k(I.join("")),b=r,M):(I.push(S),x=S,M+1)}function O(){return T()}function N(){return S==="/"&&x==="*"?(I.push(S),k(I.join("")),b=r,M+1):(I.push(S),x=S,M+1)}function K(){if(x==="."&&/\d/.test(S))return b=m,M;if(x==="/"&&S==="*")return b=a,M;if(x==="/"&&S==="/")return b=c,M;if(S==="."&&I.length){for(;W(I););return b=m,M}if(S===";"||S===")"||S==="("){if(I.length)for(;W(I););return k(S),b=r,M+1}var j=I.length===2&&S!=="=";if(/[\w_\d\s]/.test(S)||j){for(;W(I););return b=r,M}return I.push(S),x=S,M+1}function W(j){var F=0,ie,he;do{if(ie=e.indexOf(j.slice(0,j.length+F).join("")),he=e[ie],ie===-1){if(F--+j.length>0)continue;he=j.slice(0,1).join("")}return k(he),E+=he.length,I=I.slice(he.length),I.length}while(!0)}function Y(){return/[^a-fA-F0-9]/.test(S)?(k(I.join("")),b=r,M):(I.push(S),x=S,M+1)}function Q(){return S==="."||/[eE]/.test(S)?(I.push(S),b=m,x=S,M+1):S==="x"&&I.length===1&&I[0]==="0"?(b=A,I.push(S),x=S,M+1):/[^\d]/.test(S)?(k(I.join("")),b=r,M):(I.push(S),x=S,M+1)}function re(){return S==="f"&&(I.push(S),x=S,M+=1),/[eE]/.test(S)||(S==="-"||S==="+")&&/[eE]/.test(x)?(I.push(S),x=S,M+1):/[^\d]/.test(S)?(k(I.join("")),b=r,M):(I.push(S),x=S,M+1)}function se(){if(/[^\d\w_]/.test(S)){var j=I.join("");return de[j]?b=_:le[j]?b=y:b=d,k(I.join("")),b=r,M}return I.push(S),x=S,M+1}}return Lo}var Do,Bs;function Hu(){if(Bs)return Do;Bs=1;var i=Ju();Do=e;function e(t,n){var o=i(n),r=[];return r=r.concat(o(t)),r=r.concat(o(null)),r}return Do}var $u=Hu();const eh=on($u);var ko,Us;function th(){if(Us)return ko;Us=1,ko=i;function i(e){for(var t=[],n=0;n<e.length;n++)e[n].type!=="eof"&&t.push(e[n].data);return t.join("")}return ko}var nh=th();const Ns=on(nh);var Bo,Fs;function oh(){if(Fs)return Bo;Fs=1,Bo=i;function i(n){var o=null,r=null,s=0,a=0,c=0,h=0,p=0,f=[],m,d,y;for(m=0,d;m<n.length;m++)if(y=n[m],y.data==="{"){if(s&&s++||(d=v(m,e(")"),e()),d<0)||(h=d,d=v(d,e("("),e(")")),d<0)||(p=d,d=v(d,t),d<0)||n[d].type!=="ident"||(r=n[d].data,d=v(d,t),d<0))continue;s=1,a=m,o=n[d].data,c=d;var _=v(d,t);switch(n[_]&&n[_].data){case"lowp":case"highp":case"mediump":c=_}}else if(s&&y.data==="}"){if(--s)continue;f.push({name:r,type:o,body:[a+1,m],args:[p,h+1],outer:[c,m+1]})}for(m=0;m<n.length;m++)if(y=n[m],y.data===";"){if(d=v(m,e(")"),e()),d<0||(h=d,d=v(d,e("("),e(")")),d<0)||(p=d,d=v(d,t),d<0)||n[d].type!=="ident"||(r=n[d].data,d=v(d,t),d<0)||n[d].type==="operator"||n[d].data==="return")continue;o=n[d].data,f.push({name:r,type:o,body:!1,args:[p,h+1],outer:[d,m+1]})}return f.sort(function(g,A){return g.outer[0]-A.outer[0]});function v(g,A,w){for(var C=g-1;C>=0;C--){if(A(n[C]))return C;if(w&&w(n[C]))return-1}return-1}}function e(n){return function(o){return o.type==="operator"&&(!n||o.data===n)}}function t(n){return n.type!=="whitespace"}return Bo}var rh=oh();const sh=on(rh);function ih(i,e){if(typeof i!="object"||i===null)return i;var t=i[Symbol.toPrimitive];if(t!==void 0){var n=t.call(i,e);if(typeof n!="object")return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(i)}function zs(i){var e=ih(i,"string");return typeof e=="symbol"?e:String(e)}function Ae(i,e,t){return e=zs(e),e in i?Object.defineProperty(i,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):i[e]=t,i}function Vs(i,e){var t=Object.keys(i);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(i);e&&(n=n.filter(function(o){return Object.getOwnPropertyDescriptor(i,o).enumerable})),t.push.apply(t,n)}return t}function Rt(i){for(var e=1;e<arguments.length;e++){var t=arguments[e]!=null?arguments[e]:{};e%2?Vs(Object(t),!0).forEach(function(n){Ae(i,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(i,Object.getOwnPropertyDescriptors(t)):Vs(Object(t)).forEach(function(n){Object.defineProperty(i,n,Object.getOwnPropertyDescriptor(t,n))})}return i}function ah(i,e){if(i==null)return{};var t={},n=Object.keys(i),o,r;for(r=0;r<n.length;r++)o=n[r],!(e.indexOf(o)>=0)&&(t[o]=i[o]);return t}function lh(i,e){if(i==null)return{};var t=ah(i,e),n,o;if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(i);for(o=0;o<r.length;o++)n=r[o],!(e.indexOf(n)>=0)&&Object.prototype.propertyIsEnumerable.call(i,n)&&(t[n]=i[n])}return t}function ch(i,e){if(!(i instanceof e))throw new TypeError("Cannot call a class as a function")}function uh(i,e){for(var t=0;t<e.length;t++){var n=e[t];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(i,zs(n.key),n)}}function hh(i,e,t){return e&&uh(i.prototype,e),Object.defineProperty(i,"prototype",{writable:!1}),i}function Gs(i){if(i===void 0)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return i}function Uo(i,e){return Uo=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(n,o){return n.__proto__=o,n},Uo(i,e)}function fh(i,e){if(typeof e!="function"&&e!==null)throw new TypeError("Super expression must either be null or a function");i.prototype=Object.create(e&&e.prototype,{constructor:{value:i,writable:!0,configurable:!0}}),Object.defineProperty(i,"prototype",{writable:!1}),e&&Uo(i,e)}function Ln(i){return Ln=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},Ln(i)}function dh(){if(typeof Reflect>"u"||!Reflect.construct||Reflect.construct.sham)return!1;if(typeof Proxy=="function")return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch{return!1}}function ph(i,e){if(e&&(typeof e=="object"||typeof e=="function"))return e;if(e!==void 0)throw new TypeError("Derived constructors may only return object or undefined");return Gs(i)}function mh(i){var e=dh();return function(){var n=Ln(i),o;if(e){var r=Ln(this).constructor;o=Reflect.construct(n,arguments,r)}else o=n.apply(this,arguments);return ph(this,o)}}var me={position:"csm_Position",positionRaw:"csm_PositionRaw",pointSize:"csm_PointSize",fragColor:"csm_FragColor",diffuseColor:"csm_DiffuseColor",normal:"csm_Normal",roughness:"csm_Roughness",metalness:"csm_Metalness",emissive:"csm_Emissive",ao:"csm_AO",bump:"csm_Bump",depthAlpha:"csm_DepthAlpha"},We,jt,gh=(We={},Ae(We,"".concat(me.normal),{"#include <beginnormal_vertex>":`
    vec3 objectNormal = `.concat(me.normal,`;
    #ifdef USE_TANGENT
	    vec3 objectTangent = vec3( tangent.xyz );
    #endif
    `)}),Ae(We,"".concat(me.position),{"#include <begin_vertex>":`
    vec3 transformed = `.concat(me.position,`;
  `)}),Ae(We,"".concat(me.positionRaw),{"#include <begin_vertex>":`
    vec4 csm_internal_positionUnprojected = `.concat(me.positionRaw,`;
    mat4x4 csm_internal_unprojectMatrix = projectionMatrix * modelViewMatrix;
    #ifdef USE_INSTANCING
      csm_internal_unprojectMatrix = csm_internal_unprojectMatrix * instanceMatrix;
    #endif
    csm_internal_positionUnprojected = inverse(csm_internal_unprojectMatrix) * csm_internal_positionUnprojected;
    vec3 transformed = csm_internal_positionUnprojected.xyz;
  `)}),Ae(We,"".concat(me.pointSize),{"gl_PointSize = size;":`
    gl_PointSize = `.concat(me.pointSize,`;
    `)}),Ae(We,"".concat(me.diffuseColor),{"#include <color_fragment>":`
    #include <color_fragment>
    diffuseColor = `.concat(me.diffuseColor,`;
  `)}),Ae(We,"".concat(me.fragColor),{"#include <dithering_fragment>":`
    #include <dithering_fragment>
    gl_FragColor  = `.concat(me.fragColor,`;
  `)}),Ae(We,"".concat(me.emissive),{"vec3 totalEmissiveRadiance = emissive;":`
    vec3 totalEmissiveRadiance = `.concat(me.emissive,`;
    `)}),Ae(We,"".concat(me.roughness),{"#include <roughnessmap_fragment>":`
    #include <roughnessmap_fragment>
    roughnessFactor = `.concat(me.roughness,`;
    `)}),Ae(We,"".concat(me.metalness),{"#include <metalnessmap_fragment>":`
    #include <metalnessmap_fragment>
    metalnessFactor = `.concat(me.metalness,`;
    `)}),Ae(We,"".concat(me.ao),{"#include <aomap_fragment>":`
    #include <aomap_fragment>
    reflectedLight.indirectDiffuse *= 1. - `.concat(me.ao,`;
    `)}),Ae(We,"".concat(me.bump),{"#include <normal_fragment_maps>":`
    #include <normal_fragment_maps>

    vec3 csm_internal_orthogonal = `.concat(me.bump," - (dot(").concat(me.bump,`, normal) * normal);
    vec3 csm_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_internal_orthogonal;
    normal = normalize(normal - csm_internal_projectedbump);
    `)}),Ae(We,"".concat(me.depthAlpha),{"gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );":`
      gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity * `.concat(me.depthAlpha,` );
    `),"gl_FragColor = packDepthToRGBA( fragCoordZ );":`
      gl_FragColor = packDepthToRGBA( fragCoordZ );
      gl_FragColor.a *= `.concat(me.depthAlpha,`;
    `)}),We),yh=(jt={},Ae(jt,"".concat(me.position),{"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );":`
    gl_Position = projectionMatrix * modelViewMatrix * vec4( `.concat(me.position,`, 1.0 );
  `)}),Ae(jt,"".concat(me.positionRaw),{"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );":`
    gl_Position = `.concat(me.position,`;
  `)}),Ae(jt,"".concat(me.diffuseColor),{"gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );":`
    gl_FragColor = `.concat(me.diffuseColor,`;
  `)}),Ae(jt,"".concat(me.fragColor),{"gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );":`
    gl_FragColor = `.concat(me.fragColor,`;
  `)}),jt),_h=`

#ifdef IS_VERTEX
    // csm_Position & csm_PositionRaw
    #ifdef IS_UNKNOWN
        vec3 csm_Position = vec3(0.0);
        vec4 csm_PositionRaw = vec4(0.0);
        vec3 csm_Normal = vec3(0.0);
    #else
        vec3 csm_Position = position;
        vec4 csm_PositionRaw = projectionMatrix * modelViewMatrix * vec4(position, 1.);
        vec3 csm_Normal = normal;
    #endif

    // csm_PointSize
    #ifdef IS_POINTSMATERIAL
        float csm_PointSize = size;
    #endif
#else
    // csm_DiffuseColor & csm_FragColor
    #if defined IS_UNKNOWN || defined IS_SHADERMATERIAL || defined IS_MESHDEPTHMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_SHADOWMATERIAL
        vec4 csm_DiffuseColor = vec4(1.0, 0.0, 1.0, 1.0);
        vec4 csm_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    #else
        #ifdef USE_MAP
            vec4 _csm_sampledDiffuseColor = texture2D(map, vMapUv);

            #ifdef DECODE_VIDEO_TEXTURE
            // inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)
            _csm_sampledDiffuseColor = vec4(mix(pow(_csm_sampledDiffuseColor.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), _csm_sampledDiffuseColor.rgb * 0.0773993808, vec3(lessThanEqual(_csm_sampledDiffuseColor.rgb, vec3(0.04045)))), _csm_sampledDiffuseColor.w);
            #endif

            vec4 csm_DiffuseColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;
            vec4 csm_FragColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;
        #else
            vec4 csm_DiffuseColor = vec4(diffuse, opacity);
            vec4 csm_FragColor = vec4(diffuse, opacity);
        #endif
    #endif

    // csm_Emissive, csm_Roughness, csm_Metalness
    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL
        vec3 csm_Emissive = emissive;
        float csm_Roughness = roughness;
        float csm_Metalness = metalness;
    #endif

    // csm_AO
    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL
        float csm_AO = 0.0;
    #endif

    // csm_Bump
    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL 
        vec3 csm_Bump = vec3(0.0);
    #endif

    float csm_DepthAlpha = 1.0;
#endif
`,vh=`
    varying mat4 csm_internal_vModelViewMatrix;
`,xh=`
    csm_internal_vModelViewMatrix = modelViewMatrix;
`,wh=`
    varying mat4 csm_internal_vModelViewMatrix;
`,bh=`
    
`,Ye,Mh=(Ye={},Ae(Ye,"".concat(me.position),"*"),Ae(Ye,"".concat(me.positionRaw),"*"),Ae(Ye,"".concat(me.normal),"*"),Ae(Ye,"".concat(me.pointSize),["PointsMaterial"]),Ae(Ye,"".concat(me.diffuseColor),"*"),Ae(Ye,"".concat(me.fragColor),"*"),Ae(Ye,"".concat(me.emissive),["MeshStandardMaterial","MeshPhysicalMaterial"]),Ae(Ye,"".concat(me.roughness),["MeshStandardMaterial","MeshPhysicalMaterial"]),Ae(Ye,"".concat(me.metalness),["MeshStandardMaterial","MeshPhysicalMaterial"]),Ae(Ye,"".concat(me.ao),["MeshStandardMaterial","MeshPhysicalMaterial","MeshBasicMaterial","MeshLambertMaterial","MeshPhongMaterial","MeshToonMaterial"]),Ae(Ye,"".concat(me.bump),["MeshLambertMaterial","MeshMatcapMaterial","MeshNormalMaterial","MeshPhongMaterial","MeshPhysicalMaterial","MeshStandardMaterial","MeshToonMaterial","ShadowMaterial"]),Ae(Ye,"".concat(me.depthAlpha),"*"),Ye),Sh=["baseMaterial","fragmentShader","vertexShader","uniforms","patchMap","cacheKey","silent"],Ah=function(e,t,n){return e.split(t).join(n)},Ph=function(e){return e.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")},Ch=function(e,t){return new RegExp("\\b".concat(Ph(t),"\\b")).test(e)};function Th(i){try{new i}catch(e){if(e.message.indexOf("is not a constructor")>=0)return!1}return!0}function Ih(i,e){var t=arguments.length>2&&arguments[2]!==void 0?arguments[2]:!1;Object.assign(i,e);var n=Object.getPrototypeOf(e);Object.entries(Object.getOwnPropertyDescriptors(n)).filter(function(o){var r=typeof o[1].get=="function",s=typeof o[1].set=="function",a=typeof o[1].value=="function",c=o[0]==="constructor";return(r||s||a)&&!c}).forEach(function(o){if(typeof i[o[0]]=="function"){t||console.warn("Function ".concat(o[0]," already exists on CSM, renaming to base_").concat(o[0]));var r="base_".concat(o[0]);i[r]=o[1].value.bind(i);return}Object.defineProperty(i,o[0],o[1])})}function Oh(i){var e=i.toString().trim(),t=e.substring(e.indexOf("{")+1,e.lastIndexOf("}"));return t.trim().length===0}function Rs(i){return i.replace(/\s/g,"")}function Lh(i,e,t){var n=i.lastIndexOf(e);return n===-1?i:i.substring(0,n)+t+i.substring(n+e.length)}var Dh=function(i){fh(t,i);var e=mh(t);function t(n){var o,r=n.baseMaterial,s=n.fragmentShader,a=n.vertexShader,c=n.uniforms,h=n.patchMap,p=n.cacheKey,f=n.silent,m=lh(n,Sh);ch(this,t);var d;if(Th(r)?d=new r(m):(d=r,Object.assign(d,m)),d.type==="RawShaderMaterial")throw new Error("CustomShaderMaterial does not support RawShaderMaterial");o=e.call(this),Ih(Gs(o),d,f),o.__csm={patchMap:h||{},fragmentShader:s||"",vertexShader:a||"",cacheKey:p,baseMaterial:r,instanceID:Ot.MathUtils.generateUUID(),type:d.type,isAlreadyExtended:!Oh(d.onBeforeCompile),cacheHash:"",silent:f},o.uniforms=Rt(Rt({},o.uniforms||{}),c||{});{var y=o.__csm,_=y.fragmentShader,v=y.vertexShader,g=o.uniforms;o.__csm.cacheHash=o.getCacheHash(),o.generateMaterial(_,v,g)}return o}return hh(t,[{key:"update",value:function(){var o=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};this.uniforms=o.uniforms||this.uniforms,Object.assign(this.__csm,o);var r=this.__csm,s=r.fragmentShader,a=r.vertexShader,c=this.uniforms,h=this.getCacheHash();this.__csm.cacheHash=h,this.generateMaterial(s,a,c)}},{key:"clone",value:function(){var o={baseMaterial:this.__csm.baseMaterial,fragmentShader:this.__csm.fragmentShader,vertexShader:this.__csm.vertexShader,uniforms:this.uniforms,silent:this.__csm.silent,patchMap:this.__csm.patchMap,cacheKey:this.__csm.cacheKey},r=new this.constructor(o);return Object.assign(this,r),r}},{key:"getCacheHash",value:function(){var o=this.__csm,r=o.fragmentShader,s=o.vertexShader,a=this.uniforms,c=Object.values(a).reduce(function(p,f){var m=f.value;return p+JSON.stringify(m)},""),h=Rs(r)+Rs(s)+c;return h.trim().length>0?Zu(h):this.customProgramCacheKey()}},{key:"generateMaterial",value:function(o,r,s){var a=this,c=this.parseShader(o),h=this.parseShader(r);this.uniforms=s||{},this.customProgramCacheKey=function(){return a.__csm.cacheHash};var p=function(d){try{if(c){var y=a.patchShader(c,d.fragmentShader,!0);d.fragmentShader=a.getMaterialDefine()+y}if(h){var _=a.patchShader(h,d.vertexShader);d.vertexShader=`#define IS_VERTEX;
`+_,d.vertexShader=a.getMaterialDefine()+d.vertexShader}d.uniforms=Rt(Rt({},d.uniforms),a.uniforms),a.uniforms=d.uniforms}catch(v){console.error(v)}};if(this.__csm.isAlreadyExtended){var f=this.onBeforeCompile;this.onBeforeCompile=function(m,d){f(m,d),p(m)}}else this.onBeforeCompile=p;this.needsUpdate=!0}},{key:"patchShader",value:function(o,r,s){var a=this,c=r,h=Rt(Rt({},this.getPatchMapForMaterial()),this.__csm.patchMap);Object.keys(h).forEach(function(m){Object.keys(h[m]).forEach(function(d){var y=Mh[m],_=a.__csm.type;if(m==="*"||Ch(o.main,m))if(!y||Array.isArray(y)&&y.includes(_)||y==="*")c=Ah(c,d,h[m][d]);else throw new Error("CSM: ".concat(m," is not available in ").concat(_,". Shader cannot compile."))})}),c=c.replace("void main() {",`
        #ifndef CSM_IS_HEAD_DEFAULTS_DEFINED
          `.concat(s?wh:vh,`
          #define CSM_IS_HEAD_DEFAULTS_DEFINED 1
        #endif

        `).concat(o.header,`
        
        void main() {
          #ifndef CSM_IS_DEFAULTS_DEFINED
            `).concat(_h,`
            #define CSM_IS_DEFAULTS_DEFINED 1
          #endif
          
          #ifndef CSM_IS_MAIN_DEFAULTS_DEFINED
            `).concat(s?bh:xh,`
            #define CSM_IS_MAIN_DEFAULTS_DEFINED 1
          #endif

          // CSM_START
      `));var p=this.__csm.isAlreadyExtended,f=c.includes("// CSM_END");return p&&f?c=Lh(c,"// CSM_END",`
          // CSM_END
          `.concat(o.main,`
          // CSM_END
        `)):c=c.replace("// CSM_START",`
        // CSM_START
        `.concat(o.main,`
        // CSM_END
          `)),c=o.defines+c,c}},{key:"parseShader",value:function(o){if(o){var r=o.replace(/\/\*\*(.*?)\*\/|\/\/(.*?)\n/gm,""),s=eh(r),a=sh(s),c=a.map(function(f){return f.name}).indexOf("main"),h=Ns(s.slice(0,c>=0?a[c].outer[0]:void 0)),p=c>=0?this.getShaderFromIndex(s,a[c].body):"";return{defines:"",header:h,main:p}}}},{key:"getMaterialDefine",value:function(){var o=this.__csm.type;return o?"#define IS_".concat(o.toUpperCase(),`;
`):`#define IS_UNKNOWN;
`}},{key:"getPatchMapForMaterial",value:function(){switch(this.__csm.type){case"ShaderMaterial":return yh;default:return gh}}},{key:"getShaderFromIndex",value:function(o,r){return Ns(o.slice(r[0],r[1]))}}]),t}(Ot.Material);const kh=["args"],Bh=u.defineComponent({__name:"index",props:{baseMaterial:{type:Function},vertexShader:{},fragmentShader:{},silent:{type:Boolean},uniforms:{}},setup(i,{expose:e}){const t=i,n=u.shallowRef(null),{extend:o,invalidate:r}=H.useTresContext();return o({CustomShaderMaterial:Dh}),u.watch(t,()=>r()),e({instance:n}),(s,a)=>(u.openBlock(),u.createElementBlock("TresCustomShaderMaterial",{ref_key:"customShaderMaterialClass",ref:n,args:[t]},null,8,kh))}});class js extends l.ShaderMaterial{constructor(t={}){super();ue(this,"clock");this.vertexShader=`
      #define STANDARD
      varying vec3 vViewPosition;
      #ifdef USE_TRANSMISSION
      varying vec3 vWorldPosition;
      #endif
    
      varying vec2 vUv;
      varying vec4 vPos;
      varying vec3 vNormalW;
      varying vec3 vPositionW;

      #include <common>
      #include <uv_pars_vertex>
      #include <envmap_pars_vertex>
      #include <color_pars_vertex>
      #include <fog_pars_vertex>
      #include <morphtarget_pars_vertex>
      #include <skinning_pars_vertex>
      #include <logdepthbuf_pars_vertex>
      #include <clipping_planes_pars_vertex>

      void main() {
        
        #include <uv_vertex>
        #include <color_vertex>
        #include <morphcolor_vertex>
      
        #if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
      
          #include <beginnormal_vertex>
          #include <morphnormal_vertex>
          #include <skinbase_vertex>
          #include <skinnormal_vertex>
          #include <defaultnormal_vertex>
      
        #endif
      
        #include <begin_vertex>
        #include <morphtarget_vertex>
        #include <skinning_vertex>
        #include <project_vertex>
        #include <logdepthbuf_vertex>
        #include <clipping_planes_vertex>
      
        #include <worldpos_vertex>
        #include <envmap_vertex>
        #include <fog_vertex>

        mat4 modelViewProjectionMatrix = projectionMatrix * modelViewMatrix;

        vUv = uv;
        vPos = projectionMatrix * modelViewMatrix * vec4( transformed, 1.0 );
        vPositionW = vec3( vec4( transformed, 1.0 ) * modelMatrix);
        vNormalW = normalize( vec3( vec4( normal, 0.0 ) * modelMatrix ) );
        
        gl_Position = modelViewProjectionMatrix * vec4( transformed, 1.0 );

      }`,this.fragmentShader=` 
      varying vec2 vUv;
      varying vec3 vPositionW;
      varying vec4 vPos;
      varying vec3 vNormalW;
      
      uniform float time;
      uniform float fresnelOpacity;
      uniform float scanlineSize;
      uniform float fresnelAmount;
      uniform float signalSpeed;
      uniform float hologramBrightness;
      uniform float hologramOpacity;
      uniform bool blinkFresnelOnly;
      uniform bool enableBlinking;
      uniform vec3 hologramColor;

      float flicker( float amt, float time ) {return clamp( fract( cos( time ) * 43758.5453123 ), amt, 1.0 );}
      float random(in float a, in float b) { return fract((cos(dot(vec2(a,b) ,vec2(12.9898,78.233))) * 43758.5453)); }

      void main() {
        vec2 vCoords = vPos.xy;
        vCoords /= vPos.w;
        vCoords = vCoords * 0.5 + 0.5;
        vec2 myUV = fract( vCoords );

        // Defines hologram main color
        vec4 hologramColor = vec4(hologramColor, mix(hologramBrightness, vUv.y, 0.5));

        // Add scanlines
        float scanlines = 10.;
        scanlines += 20. * sin(time *signalSpeed * 20.8 - myUV.y * 60. * scanlineSize);
        scanlines *= smoothstep(1.3 * cos(time *signalSpeed + myUV.y * scanlineSize), 0.78, 0.9);
        scanlines *= max(0.25, sin(time *signalSpeed) * 1.0);

        // Scanlines offsets
        float r = random(vUv.x, vUv.y);
        float g = random(vUv.y * 20.2, vUv.y * .2);
        float b = random(vUv.y * .9, vUv.y * .2);

        // Scanline composition
        hologramColor += vec4(r*scanlines, b*scanlines, r, 1.0) / 84.;
        vec4 scanlineMix = mix(vec4(0.0), hologramColor, hologramColor.a);

        // Calculates fresnel
        vec3 viewDirectionW = normalize(cameraPosition - vPositionW);
        float fresnelEffect = dot(viewDirectionW, vNormalW) * (1.6 - fresnelOpacity/2.);
        fresnelEffect = clamp(fresnelAmount - fresnelEffect, 0., fresnelOpacity);

        // Blinkin effect
        //Suggested by Octano - https://x.com/OtanoDesign?s=20
        float blinkValue = enableBlinking ? 0.6 - signalSpeed : 1.0;
        float blink = flicker(blinkValue, time * signalSpeed * .02);

        // Final shader composition
        vec3 finalColor;

        if(blinkFresnelOnly){
          finalColor = scanlineMix.rgb + fresnelEffect * blink;
        }else{
          finalColor = scanlineMix.rgb * blink + fresnelEffect;
        }

        gl_FragColor = vec4( finalColor, hologramOpacity);

      }`,this.uniforms={time:new l.Uniform(0),fresnelOpacity:new l.Uniform(t.fresnelOpacity!==void 0?t.fresnelOpacity:1),fresnelAmount:new l.Uniform(t.fresnelAmount!==void 0?t.fresnelAmount:.45),scanlineSize:new l.Uniform(t.scanlineSize!==void 0?t.scanlineSize:8),hologramBrightness:new l.Uniform(t.hologramBrightness!==void 0?t.hologramBrightness:1),signalSpeed:new l.Uniform(t.signalSpeed!==void 0?t.signalSpeed:1),hologramColor:new l.Uniform(t.hologramColor!==void 0?new l.Color(t.hologramColor):new l.Color("#00d5ff")),enableBlinking:new l.Uniform(t.enableBlinking!==void 0?t.enableBlinking:!0),blinkFresnelOnly:new l.Uniform(t.blinkFresnelOnly!==void 0?t.blinkFresnelOnly:!0),hologramOpacity:new l.Uniform(t.hologramOpacity!==void 0?t.hologramOpacity:1)},this.clock=new l.Clock,this.setValues(t),this.depthTest=t.depthTest!==void 0?t.depthTest:!1,this.blending=t.blendMode!==void 0?t.blendMode:l.AdditiveBlending,this.transparent=!0,this.side=t.side!==void 0?t.side:l.FrontSide}update(){this.uniforms.time.value=this.clock.getElapsedTime()}}const Uh=["uniforms-fresnelAmount-value","uniforms-enableBlinking-value","uniforms-fresnelOpacity-value","uniforms-hologramBrightness-value","uniforms-scanlineSize-value","uniforms-signalSpeed-value","uniforms-hologramColor-value","uniforms-hologramOpacity-value","uniforms-blinkFresnelOnly-value","enableAdditive","side"],Nh=u.defineComponent({__name:"index",props:{fresnelAmount:{default:.45},fresnelOpacity:{default:1},blinkFresnelOnly:{type:Boolean,default:!0},enableBlinking:{type:Boolean,default:!0},enableAdditive:{type:Boolean,default:!0},hologramBrightness:{default:.7},scanlineSize:{default:8},signalSpeed:{default:.45},hologramOpacity:{default:1},hologramColor:{default:"#00d5ff"},side:{default:l.FrontSide}},setup(i,{expose:e}){const t=i,n=u.shallowRef(),{extend:o}=H.useTresContext();o({HolographicMaterial:js}),e({root:n,constructor:js});const{onBeforeRender:r}=H.useLoop();return r(({invalidate:s})=>{var a;(a=n.value)==null||a.update(),s()}),(s,a)=>(u.openBlock(),u.createElementBlock("TresHolographicMaterial",{ref_key:"MeshHolographicMaterialClass",ref:n,"uniforms-fresnelAmount-value":t.fresnelAmount,"uniforms-enableBlinking-value":t.enableBlinking,"uniforms-fresnelOpacity-value":t.fresnelOpacity,"uniforms-hologramBrightness-value":t.hologramBrightness,"uniforms-scanlineSize-value":t.scanlineSize,"uniforms-signalSpeed-value":t.signalSpeed,"uniforms-hologramColor-value":t.hologramColor,"uniforms-hologramOpacity-value":t.hologramOpacity,"uniforms-blinkFresnelOnly-value":t.blinkFresnelOnly,enableAdditive:t.enableAdditive,side:t.side},null,8,Uh))}});class Fh extends l.ShaderMaterial{constructor(){super(),this.vertexShader="void main() { }",this.fragmentShader="void main() { gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0); discard;}"}}const zh=u.defineComponent({__name:"index",setup(i,{expose:e}){const t=u.shallowRef(),{extend:n}=H.useTresContext();return n({MeshDiscardMaterial:Fh}),e({instance:t}),(o,r)=>(u.openBlock(),u.createElementBlock("TresMeshDiscardMaterial",{ref_key:"meshDiscardMaterialRef",ref:t},null,512))}});class Vh extends l.MeshStandardMaterial{constructor(t={}){super();ue(this,"isMeshPhysicalMaterial");ue(this,"clearcoatMap");ue(this,"clearcoatRoughness");ue(this,"clearcoatRoughnessMap");ue(this,"clearcoatNormalScale");ue(this,"clearcoatNormalMap");ue(this,"ior");ue(this,"transmissionMap");ue(this,"thickness");ue(this,"thicknessMap");ue(this,"attenuationDistance");ue(this,"attenuationColor");ue(this,"specularIntensity");ue(this,"specularIntensityMap");ue(this,"specularColor");ue(this,"specularColorMap");ue(this,"_clearcoat");ue(this,"_transmission");this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new l.Vector2(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get(){return l.MathUtils.clamp(2.5*(this.ior-1)/(this.ior+1),0,1)},set(n){this.ior=(1+.4*n)/(1-.4*n)}}),this.roughness=0,this.transmissionMap=null,this.thickness=.5,this.thicknessMap=null,this.attenuationDistance=Number.POSITIVE_INFINITY,this.attenuationColor=new l.Color(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new l.Color(1,1,1),this.specularColorMap=null,this._clearcoat=.5,this._transmission=1,this.setValues(t)}get clearcoat(){return this._clearcoat}set clearcoat(t){this._clearcoat>0!=t>0&&this.version++,this._clearcoat=t}get transmission(){return this._transmission}set transmission(t){this._transmission>0!=t>0&&this.version++,this._transmission=t}copy(t){return super.copy(t),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.ior=t.ior,this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this.thickness=t.thickness,this.thicknessMap=t.thicknessMap,this.attenuationDistance=t.attenuationDistance,this.attenuationColor.copy(t.attenuationColor),this.specularIntensity=t.specularIntensity,this.specularIntensityMap=t.specularIntensityMap,this.specularColor.copy(t.specularColor),this.specularColorMap=t.specularColorMap,this}}const Gh=u.defineComponent({__name:"index",setup(i,{expose:e}){const t=u.shallowRef(),{extend:n}=H.useTresContext();return n({MeshGlassMaterial:Vh}),e({instance:t}),(o,r)=>(u.openBlock(),u.createElementBlock("TresMeshGlassMaterial",{ref_key:"MeshGlassMaterialClass",ref:t},null,512))}}),Rh=Number.parseInt(l.REVISION.replace(/\D+/g,""));class jh extends l.ShaderMaterial{constructor(t=new l.Vector2){super({uniforms:{inputBuffer:new l.Uniform(null),depthBuffer:new l.Uniform(null),resolution:new l.Uniform(new l.Vector2),texelSize:new l.Uniform(new l.Vector2),halfTexelSize:new l.Uniform(new l.Vector2),kernel:new l.Uniform(0),scale:new l.Uniform(1),cameraNear:new l.Uniform(0),cameraFar:new l.Uniform(1),depthEdge0:new l.Uniform(0),depthEdge1:new l.Uniform(1),depthScale:new l.Uniform(0),depthBias:new l.Uniform(.25)},fragmentShader:`#include <common>
        #include <dithering_pars_fragment>      
        uniform sampler2D inputBuffer;
        uniform sampler2D depthBuffer;
        uniform float cameraNear;
        uniform float cameraFar;
        uniform float depthEdge0;
        uniform float depthEdge1;
        uniform float depthScale;
        uniform float depthBias;
        varying vec2 vUv;
        varying vec2 vUv0;
        varying vec2 vUv1;
        varying vec2 vUv2;
        varying vec2 vUv3;

        void main() {
          float depthFactor = 0.0;
          
          #ifdef USE_DEPTH
            vec4 depth = texture2D(depthBuffer, vUv);
            depthFactor = smoothstep(
              1.0 - depthEdge1, 1.0 - depthEdge0,
              1.0 - (depth.r * depth.a) + depthBias
            );
            depthFactor = clamp(depthScale * depthFactor + 0.25, 0.0, 1.0);
          #endif

          gl_FragColor = 0.25 * (
            texture2D(inputBuffer, mix(vUv0, vUv, depthFactor))
            + texture2D(inputBuffer, mix(vUv1, vUv, depthFactor))
            + texture2D(inputBuffer, mix(vUv2, vUv, depthFactor))
            + texture2D(inputBuffer, mix(vUv3, vUv, depthFactor))
          );
          
          #include <dithering_fragment>
          #include <tonemapping_fragment>
          #include <${Rh>=154?"colorspace_fragment":"encodings_fragment"}>
        }`,vertexShader:`uniform vec2 texelSize;
        uniform vec2 halfTexelSize;
        uniform float kernel;
        uniform float scale;
        varying vec2 vUv;
        varying vec2 vUv0;
        varying vec2 vUv1;
        varying vec2 vUv2;
        varying vec2 vUv3;

        void main() {
          vec2 uv = position.xy * 0.5 + 0.5;
          vUv = uv;

          vec2 dUv = (texelSize * vec2(kernel) + halfTexelSize) * scale;
          vUv0 = vec2(uv.x - dUv.x, uv.y + dUv.y);
          vUv1 = vec2(uv.x + dUv.x, uv.y + dUv.y);
          vUv2 = vec2(uv.x + dUv.x, uv.y - dUv.y);
          vUv3 = vec2(uv.x - dUv.x, uv.y - dUv.y);

          gl_Position = vec4(position.xy, 1.0, 1.0);
        }`,blending:l.NoBlending,depthWrite:!1,depthTest:!1});ue(this,"kernel");this.toneMapped=!1,this.setTexelSize(t.x,t.y),this.kernel=new Float32Array([0,1,2,2,3])}setTexelSize(t,n){this.uniforms.texelSize.value.set(t,n),this.uniforms.halfTexelSize.value.set(t,n).multiplyScalar(.5)}setResolution(t){this.uniforms.resolution.value.copy(t)}}class Wh{constructor({resolution:e,width:t=500,height:n=500,depthEdge0:o=0,depthEdge1:r=1,depthScale:s=0,depthBias:a=.25}){ue(this,"renderTargetA");ue(this,"renderTargetB");ue(this,"convolutionMaterial");ue(this,"scene");ue(this,"camera");ue(this,"screen");ue(this,"renderToScreen",!1);this.renderTargetA=new l.WebGLRenderTarget(e,e,{minFilter:l.LinearFilter,magFilter:l.LinearFilter,stencilBuffer:!1,depthBuffer:!1,type:l.HalfFloatType}),this.renderTargetB=this.renderTargetA.clone(),this.convolutionMaterial=new jh,this.convolutionMaterial.setTexelSize(1/t,1/n),this.convolutionMaterial.setResolution(new l.Vector2(t,n)),this.scene=new l.Scene,this.camera=new l.Camera,this.convolutionMaterial.uniforms.depthEdge0.value=o,this.convolutionMaterial.uniforms.depthEdge1.value=r,this.convolutionMaterial.uniforms.depthScale.value=s,this.convolutionMaterial.uniforms.depthBias.value=a,this.convolutionMaterial.defines.USE_DEPTH=s>0;const c=new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),h=new Float32Array([0,0,2,0,0,2]),p=new l.BufferGeometry;p.setAttribute("position",new l.BufferAttribute(c,3)),p.setAttribute("uv",new l.BufferAttribute(h,2)),this.screen=new l.Mesh(p,this.convolutionMaterial),this.screen.frustumCulled=!1,this.scene.add(this.screen)}render(e,t,n){const o=this.scene,r=this.camera,s=this.renderTargetA,a=this.renderTargetB,c=this.convolutionMaterial,h=c.uniforms;h.depthBuffer.value=t.depthTexture;const p=c.kernel;let f=t,m,d,y;for(d=0,y=p.length-1;d<y;++d)m=d&1?a:s,h.kernel.value=p[d],h.inputBuffer.value=f.texture,e.setRenderTarget(m),e.render(o,r),f=m;h.kernel.value=p[d],h.inputBuffer.value=f.texture,e.setRenderTarget(this.renderToScreen?null:n),e.render(o,r)}dispose(){this.screen.material.dispose(),this.screen.geometry.dispose(),this.renderTargetA.dispose(),this.renderTargetB.dispose(),this.convolutionMaterial.dispose()}}class Yh extends l.MeshStandardMaterial{constructor(t={}){super(t);ue(this,"_tDepth",{value:null});ue(this,"_distortionMap",{value:null});ue(this,"_tSharp",{value:null});ue(this,"_tBlur",{value:null});ue(this,"_textureMatrix",{value:null});ue(this,"_mix",{value:.5});ue(this,"_sharpMix",{value:0});ue(this,"_blurMixSmooth",{value:0});ue(this,"_blurMixRough",{value:0});ue(this,"_sharpDepthEdgeMin",{value:.9});ue(this,"_sharpDepthEdgeMax",{value:1});ue(this,"_sharpDepthScale",{value:0});ue(this,"_sharpDepthBias",{value:0});ue(this,"_distortion",{value:1});this.setValues(t)}onBeforeCompile(t){var n;(n=t.defines)!=null&&n.USE_UV||(t.defines.USE_UV="");for(const o of Object.keys(t.defines))t.defines[o.toUpperCase()]=t.defines[o];t.uniforms.tSharp=this._tSharp,t.uniforms.tDepth=this._tDepth,t.uniforms.tBlur=this._tBlur,t.uniforms.distortionMap=this._distortionMap,t.uniforms.textureMatrix=this._textureMatrix,t.uniforms.mixMain=this._mix,t.uniforms.sharpMix=this._sharpMix,t.uniforms.sharpDepthScale=this._sharpDepthScale,t.uniforms.sharpDepthEdgeMin=this._sharpDepthEdgeMin,t.uniforms.sharpDepthEdgeMax=this._sharpDepthEdgeMax,t.uniforms.sharpDepthBias=this._sharpDepthBias,t.uniforms.blurMixSmooth=this._blurMixSmooth,t.uniforms.blurMixRough=this._blurMixRough,t.uniforms.distortion=this._distortion,t.vertexShader=`
        uniform mat4 textureMatrix;
        varying vec4 my_vUv;
      ${t.vertexShader}`,t.vertexShader=t.vertexShader.replace("#include <project_vertex>",`#include <project_vertex>
        my_vUv = textureMatrix * vec4( position, 1.0 );
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );`),t.fragmentShader=`
        uniform sampler2D tSharp;
        uniform sampler2D tBlur;
        uniform sampler2D tDepth;
        uniform sampler2D distortionMap;
        uniform float distortion;
        uniform float cameraNear;
        uniform float cameraFar;
        uniform float mixMain;
        uniform float sharpMix;
        uniform float blurMixSmooth;
        uniform float blurMixRough;
        uniform float sharpDepthScale;
        uniform float sharpDepthBias;
        uniform float sharpDepthEdgeMin;
        uniform float sharpDepthEdgeMax;
        varying vec4 my_vUv;
        ${t.fragmentShader}`,t.fragmentShader=t.fragmentShader.replace("#include <emissivemap_fragment>",`#include <emissivemap_fragment>

      vec4 new_vUv = my_vUv;

      #ifdef USE_DISTORTION
        float distortionFactor = (texture(distortionMap, vUv).r - 0.5) * distortion;
        new_vUv.x += distortionFactor;
        new_vUv.y += distortionFactor;
      #endif

      #ifdef USE_NORMALMAP

        vec4 normalColor = texture(normalMap, vUv * normalScale);
        vec3 my_normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );
        vec3 coord = new_vUv.xyz / new_vUv.w;
        vec2 normal_uv = coord.xy + coord.z * my_normal.xz * 0.05;

        vec4 sharp = texture(tSharp, normal_uv);

        #ifdef USE_BLUR
          vec4 blur = texture(tBlur, normal_uv);
        #endif

        #ifdef USE_DEPTH
          vec4 depth = texture(tDepth, normal_uv);
        #endif

      #else

        vec4 sharp = textureProj(tSharp, new_vUv);

        #ifdef USE_BLUR
          vec4 blur = textureProj(tBlur, new_vUv);
        #endif

        #ifdef USE_DEPTH
          vec4 depth = textureProj(tDepth, new_vUv);
        #endif

      #endif

      #ifdef USE_DEPTH
        float depthFactor = smoothstep(
          1.0 - sharpDepthEdgeMax, 1.0 - sharpDepthEdgeMin,
          1.0 - (depth.r * depth.a) + sharpDepthBias
        );
        depthFactor = clamp(sharpDepthScale * depthFactor, 0.0, 1.0);

        sharp *= depthFactor;
      #endif

      sharp *= (1.0 - roughnessFactor);
      `),t.fragmentShader=t.fragmentShader.replace("#include <opaque_fragment>",`

      #ifdef USE_BLUR
        outgoingLight += mixMain * (
          vec3(sharp) * sharpMix
          + vec3(blur) * (blurMixSmooth * (1.0 - roughnessFactor) + blurMixRough * roughnessFactor)
        );
      #else
        outgoingLight += mixMain * vec3(sharp) * sharpMix;
      #endif

      #include <opaque_fragment>
      `)}get tSharp(){return this._tSharp.value}set tSharp(t){this._tSharp.value=t}get tDepth(){return this._tDepth.value}set tDepth(t){this._tDepth.value=t}get distortionMap(){return this._distortionMap.value}set distortionMap(t){this._distortionMap.value=t}get tBlur(){return this._tBlur.value}set tBlur(t){this._tBlur.value=t}get textureMatrix(){return this._textureMatrix.value}set textureMatrix(t){this._textureMatrix.value=t}get sharpMix(){return this._sharpMix.value}set sharpMix(t){this._sharpMix.value=t}get blurMixSmooth(){return this._blurMixSmooth.value}set blurMixSmooth(t){this._blurMixSmooth.value=t}get blurMixRough(){return this._blurMixRough.value}set blurMixRough(t){this._blurMixRough.value=t}get mix(){return this._mix.value}set mix(t){this._mix.value=t}get sharpDepthScale(){return this._sharpDepthScale.value}set sharpDepthScale(t){this._sharpDepthScale.value=t}get sharpDepthBias(){return this._sharpDepthBias.value}set sharpDepthBias(t){this._sharpDepthBias.value=t}get sharpDepthEdgeMin(){return this._sharpDepthEdgeMin.value}set sharpDepthEdgeMin(t){this._sharpDepthEdgeMin.value=t}get sharpDepthEdgeMax(){return this._sharpDepthEdgeMax.value}set sharpDepthEdgeMax(t){this._sharpDepthEdgeMax.value=t}get distortion(){return this._distortion.value}set distortion(t){this._distortion.value=t}}const Xh=["texture-matrix","t-sharp","t-depth","t-blur","defines-USE_BLUR","defines-USE_DEPTH","defines-USE_DISTORTION"],Eh=u.defineComponent({__name:"index",props:{resolution:{default:256},mix:{default:1},sharpMix:{default:1},sharpDepthScale:{default:1},sharpDepthBias:{default:0},sharpDepthEdgeMin:{default:0},sharpDepthEdgeMax:{default:.2},blurMixSmooth:{default:1},blurMixRough:{default:1},blurDepthScale:{default:1},blurDepthBias:{default:0},blurDepthEdgeMin:{default:0},blurDepthEdgeMax:{default:.2},blurSize:{default:()=>[0,0]},distortionMap:{},distortion:{default:0},reflectorOffset:{default:0},color:{default:()=>new l.Color(3355443)},roughness:{default:1},metalness:{default:0},map:{},lightMap:{},lightMapIntensity:{default:1},aoMap:{},aoMapIntensity:{default:1},emissive:{default:()=>new l.Color(0)},emissiveIntensity:{default:1},emissiveMap:{},bumpMap:{},bumpScale:{default:1},normalMap:{},normalMapType:{default:l.TangentSpaceNormalMap},normalScale:{default:()=>new l.Vector2(1,1)},displacementMap:{},displacementScale:{default:1},displacementBias:{default:0},roughnessMap:{default:null},metalnessMap:{},alphaMap:{},envMap:{},envMapRotation:{default:()=>new l.Euler},envMapIntensity:{default:1},wireframe:{type:Boolean,default:!1},wireframeLinewidth:{default:1},wireframeLinecap:{default:"round"},wireframeLinejoin:{default:"round"},flatShading:{type:Boolean,default:!1},fog:{type:Boolean,default:!0}},setup(i,{expose:e}){const t=i,{extend:n,invalidate:o}=H.useTresContext();n({MeshReflectionMaterial:Yh});const r=u.computed(()=>500-(Array.isArray(t.blurSize)?t.blurSize[0]:t.blurSize)),s=u.computed(()=>500-(Array.isArray(t.blurSize)?t.blurSize[1]:t.blurSize)),a=u.computed(()=>r.value>0||s.value>0),c=u.computed(()=>t.sharpDepthScale>0||t.blurDepthScale>0),h=u.computed(()=>!!t.distortionMap),p=u.computed(()=>!!t.roughnessMap),f=u.shallowRef();let m;const d={reflectorPlane:new l.Plane,normal:new l.Vector3,reflectorWorldPosition:new l.Vector3,cameraWorldPosition:new l.Vector3,rotationMatrix:new l.Matrix4,lookAtPosition:new l.Vector3(0,0,-1),clipPlane:new l.Vector4,view:new l.Vector3,target:new l.Vector3,q:new l.Vector4,virtualCamera:new l.PerspectiveCamera,textureMatrix:new l.Matrix4},y=new l.WebGLRenderTarget(t.resolution,t.resolution,{minFilter:l.LinearFilter,magFilter:l.LinearFilter,type:l.HalfFloatType,depthBuffer:!0,depthTexture:new l.DepthTexture(t.resolution,t.resolution)}),_=new l.WebGLRenderTarget(t.resolution,t.resolution,{minFilter:l.LinearFilter,magFilter:l.LinearFilter,type:l.HalfFloatType});function v(g,A,w,C){o();const L=g.xr.enabled,M=g.shadowMap.autoUpdate;if(d.reflectorWorldPosition.setFromMatrixPosition(C.matrixWorld),d.cameraWorldPosition.setFromMatrixPosition(w.matrixWorld),d.rotationMatrix.extractRotation(C.matrixWorld),d.normal.set(0,0,1),d.normal.applyMatrix4(d.rotationMatrix),d.reflectorWorldPosition.addScaledVector(d.normal,t.reflectorOffset),d.view.subVectors(d.reflectorWorldPosition,d.cameraWorldPosition),d.view.dot(d.normal)>0)return;C.visible=!1,d.view.reflect(d.normal).negate(),d.view.add(d.reflectorWorldPosition),d.rotationMatrix.extractRotation(w.matrixWorld),d.lookAtPosition.set(0,0,-1),d.lookAtPosition.applyMatrix4(d.rotationMatrix),d.lookAtPosition.add(d.cameraWorldPosition),d.target.subVectors(d.reflectorWorldPosition,d.lookAtPosition),d.target.reflect(d.normal).negate(),d.target.add(d.reflectorWorldPosition),d.virtualCamera.position.copy(d.view),d.virtualCamera.up.set(0,1,0),d.virtualCamera.up.applyMatrix4(d.rotationMatrix),d.virtualCamera.up.reflect(d.normal),d.virtualCamera.lookAt(d.target),d.virtualCamera.far=w.far,d.virtualCamera.updateMatrixWorld(),d.virtualCamera.projectionMatrix.copy(w.projectionMatrix),d.textureMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),d.textureMatrix.multiply(d.virtualCamera.projectionMatrix),d.textureMatrix.multiply(d.virtualCamera.matrixWorldInverse),d.textureMatrix.multiply(C.matrixWorld),d.reflectorPlane.setFromNormalAndCoplanarPoint(d.normal,d.reflectorWorldPosition),d.reflectorPlane.applyMatrix4(d.virtualCamera.matrixWorldInverse),d.clipPlane.set(d.reflectorPlane.normal.x,d.reflectorPlane.normal.y,d.reflectorPlane.normal.z,d.reflectorPlane.constant);const P=d.virtualCamera.projectionMatrix;d.q.x=(Math.sign(d.clipPlane.x)+P.elements[8])/P.elements[0],d.q.y=(Math.sign(d.clipPlane.y)+P.elements[9])/P.elements[5],d.q.z=-1,d.q.w=(1+P.elements[10])/P.elements[14],d.clipPlane.multiplyScalar(2/d.clipPlane.dot(d.q)),P.elements[2]=d.clipPlane.x,P.elements[6]=d.clipPlane.y,P.elements[10]=d.clipPlane.z+1,P.elements[14]=d.clipPlane.w,g.shadowMap.autoUpdate=!1,g.setRenderTarget(y),g.autoClear||g.clear(),g.render(A,d.virtualCamera),m.render(g,y,_),g.xr.enabled=L,g.shadowMap.autoUpdate=M,C.visible=!0,g.setRenderTarget(null)}return u.watch(()=>[t.resolution],()=>{y.setSize(t.resolution,t.resolution),_.setSize(t.resolution,t.resolution)}),u.watch(()=>[t.resolution,r.value,s.value,t.blurDepthEdgeMin,t.blurDepthEdgeMax,t.blurDepthScale,t.blurDepthBias],()=>{m==null||m.dispose(),m=new Wh({resolution:t.resolution,width:r.value,height:s.value,depthEdge0:t.blurDepthEdgeMin,depthEdge1:t.blurDepthEdgeMax,depthScale:t.blurDepthScale,depthBias:t.blurDepthBias})},{immediate:!0}),u.watch(()=>[a.value],()=>{H.useLogger().logWarning("MeshReflectionMaterial: Setting blurMixRough or blurMixSmooth to 0, then non-zero triggers a recompile.The TresJS core cannot currently handle recompiled materials.")}),u.watch(c,()=>{H.useLogger().logWarning("MeshReflectionMaterial: Setting depthScale to 0, then non-zero triggers a recompile.The TresJS core cannot currently handle recompiled materials.")}),u.watch(h,()=>{H.useLogger().logWarning("MeshReflectionMaterial: Toggling distortionMap triggers a recompile.The TresJS core cannot currently handle recompiled materials.")}),u.watch(p,()=>{H.useLogger().logWarning("MeshReflectionMaterial: Toggling roughnessMap triggers a recompile.The TresJS core cannot currently handle recompiled materials.")}),u.watch(()=>[t.normalMap],()=>{H.useLogger().logWarning("MeshReflectionMaterial: Toggling normalMap triggers a recompile.The TresJS core cannot currently handle recompiled materials.")}),u.onBeforeUnmount(()=>{y.dispose(),_.dispose(),m.dispose()}),H.useLoop().onBeforeRender(({renderer:g,scene:A,camera:w,invalidate:C})=>{var M,P;const L=(P=(M=f.value)==null?void 0:M.__tres)==null?void 0:P.parent;L&&(v(g,A,w,L),C())}),e({instance:f}),(g,A)=>{var w,C,L;return u.openBlock(),u.createElementBlock("TresMeshReflectionMaterial",u.mergeProps({key:`key${a.value?"0":"1"}${c.value?"0":"1"}${h.value?"0":"1"}${p.value?"0":"1"}`,ref_key:"materialRef",ref:f},t,{"texture-matrix":d.textureMatrix,"t-sharp":(w=u.unref(y))==null?void 0:w.texture,"t-depth":(C=u.unref(y))==null?void 0:C.depthTexture,"t-blur":(L=u.unref(_))==null?void 0:L.texture,"defines-USE_BLUR":a.value?"":void 0,"defines-USE_DEPTH":c.value?"":void 0,"defines-USE_DISTORTION":h.value?"":void 0}),null,16,Xh)}}});class Zh extends l.MeshStandardMaterial{constructor(t={}){super(t);ue(this,"_time");ue(this,"_factor");this.setValues(t),this._time={value:0},this._factor={value:1}}onBeforeCompile(t){t.uniforms||(t.uniforms={}),t.uniforms.time=this._time,t.uniforms.factor=this._factor,t.vertexShader=`
        uniform float time;
        uniform float factor;
        ${t.vertexShader}
      `,t.vertexShader=t.vertexShader.replace("#include <begin_vertex>",`float theta = sin( time + position.y ) / 2.0 * factor;
          float c = cos( theta );
          float s = sin( theta );
          mat3 m = mat3( c, 0, s, 0, 1, 0, -s, 0, c );
          vec3 transformed = vec3( position ) * m;
          vNormal = vNormal * m;`)}get time(){return this._time.value}set time(t){this._time.value=t}get factor(){return this._factor.value}set factor(t){this._factor.value=t}}const Kh=["factor"],qh=u.defineComponent({__name:"index",props:{speed:{default:1},factor:{default:1}},setup(i,{expose:e}){const t=i,n=u.shallowRef(),{extend:o,invalidate:r}=H.useTresContext();o({MeshWobbleMaterial:Zh}),u.watch(t,()=>r());const{onBeforeRender:s}=H.useLoop();return s(({elapsed:a,invalidate:c})=>{n.value&&(n.value.time=a*(t==null?void 0:t.speed),c())}),e({instance:n}),(a,c)=>(u.openBlock(),u.createElementBlock("TresMeshWobbleMaterial",u.mergeProps({ref_key:"materialRef",ref:n,factor:a.factor},a.$attrs),null,16,Kh))}}),Qh=u.defineComponent({name:"BakeShadows",setup(){const{renderer:i}=H.useTresContext();u.watchEffect(()=>{i.value.shadowMap.autoUpdate=!1,i.value.shadowMap.needsUpdate=!0})}});var Jh=`void main() {
  gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
}`,Hh=`#include <common>

void main() {
  vec2 center = vec2(0., 1.);
  float rotation = 0.0;

  
  
  float size = 0.03;

  vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
  vec2 scale;
  scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
  scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

  bool isPerspective = isPerspectiveMatrix( projectionMatrix );
  if ( isPerspective ) scale *= - mvPosition.z;

  vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
  vec2 rotatedPosition;
  rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
  rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
  mvPosition.xy += rotatedPosition;

  gl_Position = projectionMatrix * mvPosition;
}`;const rn=new l.Vector3(0,0,0),No=new l.Vector3(0,0,0),$h=new l.Vector3(0,0,0);function Ws(i,e,t){const n=rn.setFromMatrixPosition(i.matrixWorld);n.project(e);const o=t.width/2,r=t.height/2;return[(Number.isNaN(n.x)?0:n.x)*o+o,-(n.y*r)+r,n.z]}function ef(i,e){const t=rn.setFromMatrixPosition(i.matrixWorld),n=No.setFromMatrixPosition(e.matrixWorld),o=t.sub(n),r=e.getWorldDirection($h);return o.angleTo(r)>Math.PI/2}function tf(i,e,t,n){const o=rn.setFromMatrixPosition(i.matrixWorld),r=o.clone();r.project(e),t.setFromCamera(new l.Vector2(r.x,r.y),e);const s=t.intersectObjects(n,!0);if(s.length>0){const a=s[0].distance;return o.distanceTo(t.ray.origin)<a}return!0}function nf(i,e){if(e instanceof l.OrthographicCamera)return e.zoom;if(e instanceof l.PerspectiveCamera){const t=rn.setFromMatrixPosition(i.matrixWorld),n=No.setFromMatrixPosition(e.matrixWorld),o=e.fov*Math.PI/180,r=t.distanceTo(n);return 1/(2*Math.tan(o/2)*r)}else return 1}function of(i,e,t){if(e instanceof l.PerspectiveCamera||e instanceof l.OrthographicCamera){const n=rn.setFromMatrixPosition(i.matrixWorld),o=No.setFromMatrixPosition(e.matrixWorld),r=n.distanceTo(o),s=(t[1]-t[0])/(e.far-e.near),a=t[1]-s*e.far;return Math.round(s*r+a)}}const Fo=i=>Math.abs(i)<1e-10?0:i;function Ys(i,e,t=""){let n="matrix3d(";for(let o=0;o!==16;o++)n+=Fo(e[o]*i.elements[o])+(o!==15?",":")");return t+n}const rf=(i=>e=>Ys(e,i))([1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1]),sf=(i=>(e,t)=>Ys(e,i(t),"translate(-50%,-50%)"))(i=>[1/i,1/i,1/i,1,-1/i,-1/i,-1/i,-1,1/i,1/i,1/i,1,1,1,1,1]),af=["geometry","material"],lf=u.defineComponent({__name:"HTML",props:{geometry:{default:new l.PlaneGeometry},material:{},as:{default:"div"},transform:{type:Boolean,default:!1},portal:{},wrapperClass:{},eps:{default:1e-4},distanceFactor:{},fullscreen:{type:Boolean},center:{type:Boolean},pointerEvents:{default:"auto"},sprite:{type:Boolean,default:!1},zIndexRange:{default:()=>[16777271,0]},occlude:{type:[Object,null,Array,Boolean,String]}},emits:["onOcclude"],setup(i,{expose:e,emit:t}){const n=i,o=t,r=u.useSlots(),s=u.useAttrs(),a=u.ref(),c=u.ref(),{geometry:h,material:p,as:f,transform:m,portal:d,wrapperClass:y,eps:_,distanceFactor:v,fullscreen:g,center:A,pointerEvents:w,sprite:C,occlude:L,zIndexRange:M}=u.toRefs(n),{renderer:P,scene:b,camera:S,raycaster:x,sizes:I}=H.useTresContext(),D=u.computed(()=>document.createElement(f.value)),z=u.ref([0,0,0]),G=u.ref(0),E=u.ref(),X=u.computed(()=>m.value?{position:"absolute",top:0,left:0,width:`${I.width.value}px`,height:`${I.height.value}px`,transformStyle:"preserve-3d",pointerEvents:"none",zIndex:2}:{position:"absolute",transform:A.value?"translate3d(-50%,-50%,0)":"none",...g.value&&{top:-I.height.value/2,left:-I.width.value/2,width:`${I.width.value}px`,height:`${I.height.value}px`},zIndex:2,...Object.assign({},s.style)}),oe=u.computed(()=>({position:"absolute",pointerEvents:w.value})),q=u.ref(null),ee=u.ref(!1),te=u.computed(()=>(L==null?void 0:L.value)&&(L==null?void 0:L.value)!=="blending"||Array.isArray(L==null?void 0:L.value)&&(L==null?void 0:L.value.length)&&u.isRef(L.value[0]));u.watch(()=>L,({value:V})=>{V==="blending"?(D.value.style.zIndex=`${Math.floor(M.value[0]/2)}`,D.value.style.position="absolute",D.value.style.pointerEvents="none"):(D.value.style.zIndex=null,D.value.style.position=null,D.value.style.pointerEvents=null)}),u.watch(()=>{var V;return[a.value,P.value,I.width.value,I.height.value,(V=r.default)==null?void 0:V.call(r)]},([V,U])=>{var B,R,T,O,N,K;if(V&&U){const W=(d==null?void 0:d.value)||U.domElement;if((B=b.value)==null||B.updateMatrixWorld(),m.value)D.value.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const Y=Ws(V,S.value,{width:I.width.value,height:I.height.value});D.value.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${Y[0]}px,${Y[1]}px,0);transform-origin:0 0;`}W&&!D.value.parentNode&&((R=W.parentNode)==null||R.appendChild(D.value)),m.value?E.value=u.createVNode("div",{id:"outer",style:X.value},[u.createVNode("div",{id:"inner",style:oe.value},[u.createVNode("div",{key:(T=c.value)==null?void 0:T.uuid,id:b==null?void 0:b.value.uuid,class:s.class,style:s.style},(O=r.default)==null?void 0:O.call(r))])]):E.value=u.createVNode("div",{key:(N=c.value)==null?void 0:N.uuid,id:b==null?void 0:b.value.uuid,style:X.value},(K=r.default)==null?void 0:K.call(r)),u.render(E.value,D.value)}}),u.watchEffect(()=>{y!=null&&y.value&&(D.value.className=y.value)});const ce=u.ref(!0),{onBeforeRender:le}=H.useLoop();le(({invalidate:V})=>{var U,B,R,T,O,N,K;if(V(),a.value&&S.value&&P.value){(U=S.value)==null||U.updateMatrixWorld(),a.value.updateWorldMatrix(!0,!1);const W=m.value?z.value:Ws(a.value,S.value,{width:I.width.value||0,height:I.height.value||0});if(m.value||Math.abs(G.value-S.value.zoom)>_.value||Math.abs(z.value[0]-W[0])>_.value||Math.abs(z.value[1]-W[1])>_.value||Math.abs(z.value[2]-W[2])>_.value){const Y=ef(a.value,S.value);let Q=!1;te.value&&(Array.isArray(L==null?void 0:L.value)?Q=L==null?void 0:L.value:(L==null?void 0:L.value)!=="blending"&&(Q=[b.value]));const re=ce.value;if(Q){const F=tf(a.value,S.value,x.value,Q);ce.value=F&&!Y}else ce.value=!Y;re!==ce.value&&(o("onOcclude",!ce.value),D.value.style.display=ce.value?"block":"none");const se=Math.floor(M.value[0]/2),j=L!=null&&L.value?te.value?[M.value[0],se]:[se-1,0]:M.value;if(D.value.style.zIndex=`${of(a.value,S.value,j)}`,m.value){const[F,ie]=[I.width.value/2,I.height.value/2],he=S.value.projectionMatrix.elements[5]*ie,{isOrthographicCamera:_e,top:Le,left:Pe,bottom:Je,right:wt}=S.value,It=rf(S.value.matrixWorldInverse),st=_e?`scale(${he})translate(${Fo(-(wt+Pe)/2)}px,${Fo((Le+Je)/2)}px)`:`translateZ(${he}px)`;let Ee=a.value.matrixWorld;if(C.value&&(Ee=S.value.matrixWorldInverse.clone().transpose().copyPosition(Ee).scale(a.value.scale),Ee.elements[3]=Ee.elements[7]=Ee.elements[11]=0,Ee.elements[15]=1),D.value.style.width=`${I.width.value}px`,D.value.style.height=`${I.height.value}px`,D.value.style.perspective=_e?"":`${he}px`,(B=E.value)!=null&&B.el&&((R=E.value)!=null&&R.children)&&Array.isArray(E.value.children)){E.value.el.style.transform=`${st}${It}translate(${F}px,${ie}px)`;const it=E.value.children[0];it&&it.el&&(it.el.style.transform=sf(Ee,1/(((v==null?void 0:v.value)||10)/400)))}}else{const F=(v==null?void 0:v.value)===void 0?1:nf(a.value,S.value)*(v==null?void 0:v.value);D.value.style.transform=`translate3d(${W[0]}px,${W[1]}px,0) scale(${F})`}}z.value=W,G.value=S.value.zoom}if(!te.value&&c.value&&!ee.value)if(m.value){if((T=E.value)!=null&&T.el&&((O=E.value)!=null&&O.children)){const W=((N=E.value)==null?void 0:N.children)[0];if(W!=null&&W.clientWidth&&(W!=null&&W.clientHeight)){const{isOrthographicCamera:Y}=S.value;if(Y||h)s.scale&&(Array.isArray(s.scale)?s.scale instanceof l.Vector3?c.value.scale.copy(s.scale.clone().divideScalar(1)):c.value.scale.set(1/s.scale[0],1/s.scale[1],1/s.scale[2]):c.value.scale.setScalar(1/s.scale));else{const Q=((v==null?void 0:v.value)||10)/400,re=W.clientWidth*Q,se=W.clientHeight*Q;c.value.scale.set(re,se,1)}ee.value=!0}}}else{const W=D.value.children[0];if(W!=null&&W.clientWidth&&(W!=null&&W.clientHeight)){const Q=W.clientWidth*1,re=W.clientHeight*1;c.value.scale.set(Q,re,1),ee.value=!0}q.value.lookAt((K=S.value)==null?void 0:K.position)}});const de=u.computed(()=>({vertexShader:m.value?void 0:Hh,fragmentShader:Jh})),k=u.computed(()=>{const V=de.value;return p.value||new l.ShaderMaterial({vertexShader:V.vertexShader,fragmentShader:V.fragmentShader,side:l.DoubleSide})});return u.onUnmounted(()=>{k.value&&k.value.dispose(),D.value.remove()}),e({instance:a}),(V,U)=>(u.openBlock(),u.createElementBlock("TresGroup",{ref_key:"groupRef",ref:a},[u.unref(L)&&!te.value?(u.openBlock(),u.createElementBlock("TresMesh",{key:0,ref_key:"meshRef",ref:c,geometry:u.unref(h),material:k.value},null,8,af)):u.createCommentVNode("",!0)],512))}});var Dn={exports:{}},cf=Dn.exports,Xs;function uf(){return Xs||(Xs=1,function(i,e){(function(t,n){i.exports=n()})(cf,function(){var t=function(){function n(d){return s.appendChild(d.dom),d}function o(d){for(var y=0;y<s.children.length;y++)s.children[y].style.display=y===d?"block":"none";r=d}var r=0,s=document.createElement("div");s.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",s.addEventListener("click",function(d){d.preventDefault(),o(++r%s.children.length)},!1);var a=(performance||Date).now(),c=a,h=0,p=n(new t.Panel("FPS","#0ff","#002")),f=n(new t.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var m=n(new t.Panel("MB","#f08","#201"));return o(0),{REVISION:16,dom:s,addPanel:n,showPanel:o,begin:function(){a=(performance||Date).now()},end:function(){h++;var d=(performance||Date).now();if(f.update(d-a,200),d>c+1e3&&(p.update(1e3*h/(d-c),100),c=d,h=0,m)){var y=performance.memory;m.update(y.usedJSHeapSize/1048576,y.jsHeapSizeLimit/1048576)}return d},update:function(){a=this.end()},domElement:s,setMode:o}};return t.Panel=function(n,o,r){var s=1/0,a=0,c=Math.round,h=c(window.devicePixelRatio||1),p=80*h,f=48*h,m=3*h,d=2*h,y=3*h,_=15*h,v=74*h,g=30*h,A=document.createElement("canvas");A.width=p,A.height=f,A.style.cssText="width:80px;height:48px";var w=A.getContext("2d");return w.font="bold "+9*h+"px Helvetica,Arial,sans-serif",w.textBaseline="top",w.fillStyle=r,w.fillRect(0,0,p,f),w.fillStyle=o,w.fillText(n,m,d),w.fillRect(y,_,v,g),w.fillStyle=r,w.globalAlpha=.9,w.fillRect(y,_,v,g),{dom:A,update:function(C,L){s=Math.min(s,C),a=Math.max(a,C),w.fillStyle=r,w.globalAlpha=1,w.fillRect(0,0,p,_),w.fillStyle=o,w.fillText(c(C)+" "+n+" ("+c(s)+"-"+c(a)+")",m,d),w.drawImage(A,y+h,_,v-h,g,y,_,v-h,g),w.fillRect(y+v-h,_,h,g),w.fillStyle=r,w.globalAlpha=.9,w.fillRect(y+v-h,_,h,c((1-C/L)*g))}}},t})}(Dn)),Dn.exports}var hf=uf();const ff=on(hf),df=u.defineComponent({name:"Stats",props:{showPanel:{type:Number,default:0}},setup(i,{expose:e}){const t=new ff;e({instance:t});const n=document.body;t.showPanel(i.showPanel||0),n==null||n.appendChild(t.dom);const{onBeforeRender:o,onAfterRender:r}=H.useLoop();o(()=>t.begin(),Number.NEGATIVE_INFINITY),r(()=>t.end(),Number.POSITIVE_INFINITY),u.onUnmounted(()=>{n==null||n.removeChild(t.dom)})}});class pf{constructor(e,t,n){this.name=e,this.fg=t,this.bg=n,this.gradient=null,this.PR=Math.round(window.devicePixelRatio||1),this.WIDTH=90*this.PR,this.HEIGHT=48*this.PR,this.TEXT_X=3*this.PR,this.TEXT_Y=2*this.PR,this.GRAPH_X=3*this.PR,this.GRAPH_Y=15*this.PR,this.GRAPH_WIDTH=84*this.PR,this.GRAPH_HEIGHT=30*this.PR,this.canvas=document.createElement("canvas"),this.canvas.width=this.WIDTH,this.canvas.height=this.HEIGHT,this.canvas.style.width="90px",this.canvas.style.height="48px",this.canvas.style.position="absolute",this.canvas.style.cssText="width:90px;height:48px",this.context=this.canvas.getContext("2d"),this.initializeCanvas()}createGradient(){if(!this.context)throw new Error("No context");const e=this.context.createLinearGradient(0,this.GRAPH_Y,0,this.GRAPH_Y+this.GRAPH_HEIGHT);let t;const n=this.fg;switch(this.fg.toLowerCase()){case"#0ff":t="#006666";break;case"#0f0":t="#006600";break;case"#ff0":t="#666600";break;case"#e1e1e1":t="#666666";break;default:t=this.bg;break}return e.addColorStop(0,t),e.addColorStop(1,n),e}initializeCanvas(){this.context&&(this.context.font="bold "+9*this.PR+"px Helvetica,Arial,sans-serif",this.context.textBaseline="top",this.gradient=this.createGradient(),this.context.fillStyle=this.bg,this.context.fillRect(0,0,this.WIDTH,this.HEIGHT),this.context.fillStyle=this.fg,this.context.fillText(this.name,this.TEXT_X,this.TEXT_Y),this.context.fillStyle=this.fg,this.context.fillRect(this.GRAPH_X,this.GRAPH_Y,this.GRAPH_WIDTH,this.GRAPH_HEIGHT),this.context.fillStyle=this.bg,this.context.globalAlpha=.9,this.context.fillRect(this.GRAPH_X,this.GRAPH_Y,this.GRAPH_WIDTH,this.GRAPH_HEIGHT))}update(e,t,n,o,r=0){if(!this.context||!this.gradient)return;const s=Math.min(1/0,e),a=Math.max(n,e);o=Math.max(o,t),this.context.globalAlpha=1,this.context.fillStyle=this.bg,this.context.fillRect(0,0,this.WIDTH,this.GRAPH_Y),this.context.fillStyle=this.fg,this.context.fillText(`${e.toFixed(r)} ${this.name} (${s.toFixed(r)}-${parseFloat(a.toFixed(r))})`,this.TEXT_X,this.TEXT_Y),this.context.drawImage(this.canvas,this.GRAPH_X+this.PR,this.GRAPH_Y,this.GRAPH_WIDTH-this.PR,this.GRAPH_HEIGHT,this.GRAPH_X,this.GRAPH_Y,this.GRAPH_WIDTH-this.PR,this.GRAPH_HEIGHT);const c=this.GRAPH_HEIGHT-(1-t/o)*this.GRAPH_HEIGHT;c>0&&(this.context.globalAlpha=1,this.context.fillStyle=this.gradient,this.context.fillRect(this.GRAPH_X+this.GRAPH_WIDTH-this.PR,this.GRAPH_Y+this.GRAPH_HEIGHT-c,this.PR,c))}}const Es=class Wt{constructor({trackGPU:e=!1,logsPerSecond:t=30,samplesLog:n=60,samplesGraph:o=10,precision:r=2,minimal:s=!1,horizontal:a=!0,mode:c=0}={}){this.gl=null,this.ext=null,this.activeQuery=null,this.gpuQueries=[],this.threeRendererPatched=!1,this.frames=0,this.renderCount=0,this.isRunningCPUProfiling=!1,this.totalCpuDuration=0,this.totalGpuDuration=0,this.totalGpuDurationCompute=0,this.totalFps=0,this.gpuPanel=null,this.gpuPanelCompute=null,this.averageFps={logs:[],graph:[]},this.averageCpu={logs:[],graph:[]},this.averageGpu={logs:[],graph:[]},this.averageGpuCompute={logs:[],graph:[]},this.handleClick=h=>{h.preventDefault(),this.showPanel(++this.mode%this.dom.children.length)},this.handleResize=()=>{this.resizePanel(this.fpsPanel,0),this.resizePanel(this.msPanel,1),this.gpuPanel&&this.resizePanel(this.gpuPanel,2),this.gpuPanelCompute&&this.resizePanel(this.gpuPanelCompute,3)},this.mode=c,this.horizontal=a,this.minimal=s,this.trackGPU=e,this.samplesLog=n,this.samplesGraph=o,this.precision=r,this.logsPerSecond=t,this.dom=document.createElement("div"),this.initializeDOM(),this.beginTime=performance.now(),this.prevTime=this.beginTime,this.prevCpuTime=this.beginTime,this.fpsPanel=this.addPanel(new Wt.Panel("FPS","#0ff","#002"),0),this.msPanel=this.addPanel(new Wt.Panel("CPU","#0f0","#020"),1),this.setupEventListeners()}initializeDOM(){this.dom.style.cssText=`
      position: fixed;
      top: 0;
      left: 0;
      opacity: 0.9;
      z-index: 10000;
      ${this.minimal?"cursor: pointer;":""}
    `}setupEventListeners(){this.minimal?(this.dom.addEventListener("click",this.handleClick),this.showPanel(this.mode)):window.addEventListener("resize",this.handleResize)}async init(e){if(!e){console.error('Stats: The "canvas" parameter is undefined.');return}this.handleThreeRenderer(e)||await this.handleWebGPURenderer(e)||this.initializeWebGL(e)}handleThreeRenderer(e){return e.isWebGLRenderer&&!this.threeRendererPatched?(this.patchThreeRenderer(e),this.gl=e.getContext(),this.trackGPU&&this.initializeGPUTracking(),!0):!1}async handleWebGPURenderer(e){return e.isWebGPURenderer?(this.trackGPU&&(e.backend.trackTimestamp=!0,await e.hasFeatureAsync("timestamp-query")&&this.initializeWebGPUPanels()),this.info=e.info,!0):!1}initializeWebGPUPanels(){this.gpuPanel=this.addPanel(new Wt.Panel("GPU","#ff0","#220"),2),this.gpuPanelCompute=this.addPanel(new Wt.Panel("CPT","#e1e1e1","#212121"),3)}initializeWebGL(e){if(e instanceof WebGL2RenderingContext)this.gl=e;else if(e instanceof HTMLCanvasElement||e instanceof OffscreenCanvas){if(this.gl=e.getContext("webgl2"),!this.gl)return console.error("Stats: Unable to obtain WebGL2 context."),!1}else return console.error("Stats: Invalid input type. Expected WebGL2RenderingContext, HTMLCanvasElement, or OffscreenCanvas."),!1;return!0}initializeGPUTracking(){this.gl&&(this.ext=this.gl.getExtension("EXT_disjoint_timer_query_webgl2"),this.ext&&(this.gpuPanel=this.addPanel(new Wt.Panel("GPU","#ff0","#220"),2)))}begin(){this.isRunningCPUProfiling||this.beginProfiling("cpu-started"),!(!this.gl||!this.ext)&&(this.activeQuery&&this.gl.endQuery(this.ext.TIME_ELAPSED_EXT),this.activeQuery=this.gl.createQuery(),this.activeQuery&&this.gl.beginQuery(this.ext.TIME_ELAPSED_EXT,this.activeQuery))}end(){this.renderCount++,this.gl&&this.ext&&this.activeQuery&&(this.gl.endQuery(this.ext.TIME_ELAPSED_EXT),this.gpuQueries.push({query:this.activeQuery}),this.activeQuery=null)}update(){this.info?this.processWebGPUTimestamps():this.processGpuQueries(),this.endProfiling("cpu-started","cpu-finished","cpu-duration"),this.updateAverages(),this.resetCounters()}processWebGPUTimestamps(){this.totalGpuDuration=this.info.render.timestamp,this.totalGpuDurationCompute=this.info.compute.timestamp,this.addToAverage(this.totalGpuDurationCompute,this.averageGpuCompute)}updateAverages(){this.addToAverage(this.totalCpuDuration,this.averageCpu),this.addToAverage(this.totalGpuDuration,this.averageGpu)}resetCounters(){this.renderCount=0,this.totalCpuDuration===0&&this.beginProfiling("cpu-started"),this.totalCpuDuration=0,this.totalFps=0,this.beginTime=this.endInternal()}resizePanel(e,t){e.canvas.style.position="absolute",this.minimal?e.canvas.style.display="none":(e.canvas.style.display="block",this.horizontal?(e.canvas.style.top="0px",e.canvas.style.left=t*e.WIDTH/e.PR+"px"):(e.canvas.style.left="0px",e.canvas.style.top=t*e.HEIGHT/e.PR+"px"))}addPanel(e,t){return e.canvas&&(this.dom.appendChild(e.canvas),this.resizePanel(e,t)),e}showPanel(e){for(let t=0;t<this.dom.children.length;t++){const n=this.dom.children[t];n.style.display=t===e?"block":"none"}this.mode=e}processGpuQueries(){!this.gl||!this.ext||(this.totalGpuDuration=0,this.gpuQueries.forEach((e,t)=>{if(this.gl){const n=this.gl.getQueryParameter(e.query,this.gl.QUERY_RESULT_AVAILABLE),o=this.gl.getParameter(this.ext.GPU_DISJOINT_EXT);if(n&&!o){const s=this.gl.getQueryParameter(e.query,this.gl.QUERY_RESULT)*1e-6;this.totalGpuDuration+=s,this.gl.deleteQuery(e.query),this.gpuQueries.splice(t,1)}}}))}endInternal(){this.frames++;const e=(performance||Date).now(),t=e-this.prevTime;if(e>=this.prevCpuTime+1e3/this.logsPerSecond){const n=Math.round(this.frames*1e3/t);this.addToAverage(n,this.averageFps),this.updatePanel(this.fpsPanel,this.averageFps,0),this.updatePanel(this.msPanel,this.averageCpu,this.precision),this.updatePanel(this.gpuPanel,this.averageGpu,this.precision),this.gpuPanelCompute&&this.updatePanel(this.gpuPanelCompute,this.averageGpuCompute),this.frames=0,this.prevCpuTime=e,this.prevTime=e}return e}addToAverage(e,t){t.logs.push(e),t.logs.length>this.samplesLog&&t.logs.shift(),t.graph.push(e),t.graph.length>this.samplesGraph&&t.graph.shift()}beginProfiling(e){window.performance&&(window.performance.mark(e),this.isRunningCPUProfiling=!0)}endProfiling(e,t,n){if(window.performance&&t&&this.isRunningCPUProfiling){window.performance.mark(t);const o=performance.measure(n,e,t);this.totalCpuDuration+=o.duration,this.isRunningCPUProfiling=!1}}updatePanel(e,t,n=2){if(t.logs.length>0){let o=0,r=.01;for(let c=0;c<t.logs.length;c++)o+=t.logs[c],t.logs[c]>r&&(r=t.logs[c]);let s=0,a=.01;for(let c=0;c<t.graph.length;c++)s+=t.graph[c],t.graph[c]>a&&(a=t.graph[c]);e&&e.update(o/Math.min(t.logs.length,this.samplesLog),s/Math.min(t.graph.length,this.samplesGraph),r,a,n)}}get domElement(){return this.dom}patchThreeRenderer(e){const t=e.render,n=this;e.render=function(o,r){n.begin(),t.call(this,o,r),n.end()},this.threeRendererPatched=!0}};Es.Panel=pf;let mf=Es;const gf=u.defineComponent({name:"StatsGl",props:["logsPerSecond","samplesLog","samplesGraph","precision","horizontal","minimal","mode"],setup(i,{expose:e}){const t=new mf({logsPerSecond:i.logsPerSecond,samplesLog:i.samplesLog,samplesGraph:i.samplesGraph,precision:i.precision,horizontal:i.horizontal,minimal:i.minimal,mode:i.mode});e({instance:t});const n=document.body,o=t.dom||t.container;n==null||n.appendChild(o);const{renderer:r}=H.useTresContext(),{onAfterRender:s}=H.useLoop();t.init(r.value),s(()=>t.update(),Number.POSITIVE_INFINITY),u.onUnmounted(()=>{n==null||n.removeChild(o)})}}),{logError:yf}=H.useLogger();async function _f(i,e){const t=new Wn,n=(e==null?void 0:e.fileName)||"scene";t.parse(i,o=>{if(o instanceof ArrayBuffer)xf(o,`${n}.glb`);else{const r=JSON.stringify(o,null,2);vf(r,`${n}.gltf`)}},o=>{yf("An error happened while exporting the GLTF",o)},e)}function vf(i,e){Zs(new Blob([i],{type:"text/plain"}),e)}function xf(i,e){Zs(new Blob([i],{type:"application/octet-stream"}),e)}function Zs(i,e){const t=document.createElement("a");t.style.display="none",document.body.appendChild(t),t.href=URL.createObjectURL(i),t.download=e,t.click(),t.remove()}const wf=["args"],bf=["color"],Mf=u.defineComponent({__name:"Box",props:{args:{default:()=>[1,1,1]},color:{default:"#ffffff"}},setup(i,{expose:e}){const t=i,{invalidate:n}=H.useTresContext(),{args:o,color:r}=u.toRefs(t);u.watch(o,()=>n());const s=u.shallowRef();return e({instance:s}),(a,c)=>(u.openBlock(),u.createElementBlock("TresMesh",u.mergeProps({ref_key:"boxRef",ref:s},a.$attrs),[u.createElementVNode("TresBoxGeometry",{args:u.unref(o)},null,8,wf),u.renderSlot(a.$slots,"default",{},()=>[u.createElementVNode("TresMeshBasicMaterial",{color:u.unref(r)},null,8,bf)])],16))}}),Sf=["object"],Ks=u.defineComponent({__name:"Line2",props:{points:{},vertexColors:{default:null},color:{default:"white"},lineWidth:{default:1},worldUnits:{type:Boolean,default:!1},alphaToCoverage:{type:Boolean,default:!1},dashed:{type:Boolean,default:!1},dashSize:{default:1},gapSize:{default:1},dashScale:{default:1},dashOffset:{default:0}},setup(i,{expose:e}){const t=i;function n(d,y){if(!d||d.length===0)return Array.from({length:y}).fill(H.normalizeColor(t.color));if(d.length===1)return Array.from({length:y}).fill(H.normalizeColor(d[0]));if(d.length===y)return d.map(H.normalizeColor);const _=y-1,v=d.map(H.normalizeColor);closed&&v.push(v[0].clone());const g=[v[0]],A=_/(v.length-1);for(let w=1;w<_;w++){const C=w%A/A,L=Math.floor(w/A);g.push(v[L].clone().lerp(v[L+1],C))}return g.push(v[v.length-1]),g}const o=new co,r=new Wr,s=new bc(r,o),{sizes:a,invalidate:c}=H.useTresContext(),h=u.computed(()=>Array.isArray(t.vertexColors));function p(d,y){d.color=H.normalizeColor(y.color),d.linewidth=y.lineWidth,d.alphaToCoverage=y.alphaToCoverage,d.worldUnits=y.worldUnits,d.vertexColors=Array.isArray(y.vertexColors),d.dashed=y.dashed,d.dashScale=y.dashScale,d.dashSize=y.dashSize,d.dashOffset=y.dashOffset,d.gapSize=y.gapSize,d.needsUpdate=!0}function f(d,y,_){const v=y.map(A=>A instanceof l.Vector3?[A.x,A.y,A.z]:A instanceof l.Vector2?[A.x,A.y,0]:Array.isArray(A)&&A.length===2?[A[0],A[1],0]:A).flat();d.setPositions(v.flat());const g=n(_,y.length).map(A=>A.toArray()).flat();d.setColors(g),s.computeLineDistances()}p(o,t),f(r,t.points,t.vertexColors),s.computeLineDistances(),u.watch(()=>[t.color,t.lineWidth,t.alphaToCoverage,t.worldUnits,h,t.dashed,t.dashScale,t.dashSize,t.dashOffset],()=>{p(o,t),c()}),u.watch(()=>[t.points,t.vertexColors],()=>{f(r,t.points,t.vertexColors),c()}),u.watch(()=>[a.height,a.width],()=>{o.resolution=new l.Vector2(a.width.value,a.height.value),c()}),u.onUnmounted(()=>{r.dispose(),o.dispose()});const m=u.shallowRef();return e({instance:m}),(d,y)=>(u.openBlock(),u.createElementBlock("primitive",{ref:m.value,object:u.unref(s)},null,8,Sf))}}),Af=u.defineComponent({__name:"CatmullRomCurve3",props:{segments:{default:20},closed:{type:Boolean,default:!1},curveType:{default:"centripetal"},tension:{default:.5},points:{},vertexColors:{},color:{},lineWidth:{},alphaToCoverage:{type:Boolean},dashed:{type:Boolean},dashSize:{},dashScale:{},dashOffset:{},gapSize:{},worldUnits:{type:Boolean}},setup(i,{expose:e}){const t=i;function n(c,h,p,f){const m=c.map(d=>d instanceof l.Vector3?d:new l.Vector3(...d));return new l.CatmullRomCurve3(m,h,p,f)}function o(c,h){return c.getPoints(h)}const r=u.computed(()=>n(t.points,t.closed,t.curveType,t.tension)),s=u.computed(()=>o(r.value,t.segments)),a=u.shallowRef();return e({instance:a}),(c,h)=>(u.openBlock(),u.createBlock(Ks,{ref:a.value,points:s.value,"vertex-colors":t.vertexColors,color:t.color,"line-width":t.lineWidth,"alpha-to-coverage":t.alphaToCoverage,dashed:t.dashed,"dash-size":t.dashSize,"dash-scale":t.dashScale,"dash-offset":t.dashOffset,"gap-size":t.gapSize,"world-units":t.worldUnits},null,8,["points","vertex-colors","color","line-width","alpha-to-coverage","dashed","dash-size","dash-scale","dash-offset","gap-size","world-units"]))}}),Pf=["args"],Cf=["color"],Tf=u.defineComponent({__name:"Circle",props:{args:{default:()=>[1,32,0,Math.PI*2]},color:{default:"#ffffff"}},setup(i,{expose:e}){const t=i,{args:n,color:o}=u.toRefs(t),{invalidate:r}=H.useTresContext();u.watch(n,()=>r());const s=u.shallowRef();return e({instance:s}),(a,c)=>(u.openBlock(),u.createElementBlock("TresMesh",u.mergeProps({ref_key:"circleRef",ref:s},a.$attrs),[u.createElementVNode("TresCircleGeometry",{args:u.unref(n)},null,8,Pf),u.renderSlot(a.$slots,"default",{},()=>[u.createElementVNode("TresMeshBasicMaterial",{color:u.unref(o)},null,8,Cf)])],16))}}),If=["args"],Of=["color"],Lf=u.defineComponent({__name:"Cone",props:{args:{default:()=>[1,1,12,12,!1,0,Math.PI*2]},color:{default:"#ffffff"}},setup(i,{expose:e}){const t=i,{args:n,color:o}=u.toRefs(t),{invalidate:r}=H.useTresContext();u.watch(n,()=>r());const s=u.shallowRef();return e({instance:s}),(a,c)=>(u.openBlock(),u.createElementBlock("TresMesh",u.mergeProps({ref_key:"coneRef",ref:s},a.$attrs),[u.createElementVNode("TresConeGeometry",{args:u.unref(n)},null,8,If),u.renderSlot(a.$slots,"default",{},()=>[u.createElementVNode("TresMeshBasicMaterial",{color:u.unref(o)},null,8,Of)])],16))}}),Df=["args"],kf=["color"],Bf=u.defineComponent({__name:"Cylinder",props:{args:{default:()=>[1,1,1,32,1,!1,0,Math.PI*2]},color:{default:"#ffffff"}},setup(i,{expose:e}){const t=i,{args:n,color:o}=u.toRefs(t),{invalidate:r}=H.useTresContext();u.watch(n,()=>r());const s=u.shallowRef();return e({instance:s}),(a,c)=>(u.openBlock(),u.createElementBlock("TresMesh",u.mergeProps({ref_key:"cylinderRef",ref:s},a.$attrs),[u.createElementVNode("TresCylinderGeometry",{args:u.unref(n)},null,8,Df),u.renderSlot(a.$slots,"default",{},()=>[u.createElementVNode("TresMeshBasicMaterial",{color:u.unref(o)},null,8,kf)])],16))}}),Uf=["args"],Nf=["color"],Ff=u.defineComponent({__name:"Dodecahedron",props:{args:{default:()=>[1,0]},color:{default:"#ffffff"}},setup(i,{expose:e}){const t=i,{args:n,color:o}=u.toRefs(t),r=u.shallowRef(),{invalidate:s}=H.useTresContext();return u.watch(n,()=>s()),e({instance:r}),(a,c)=>(u.openBlock(),u.createElementBlock("TresMesh",u.mergeProps({ref_key:"dodecahedronRef",ref:r},a.$attrs),[u.createElementVNode("TresDodecahedronGeometry",{args:u.unref(n)},null,8,Uf),u.renderSlot(a.$slots,"default",{},()=>[u.createElementVNode("TresMeshBasicMaterial",{color:u.unref(o)},null,8,Nf)])],16))}}),zf=["args"],Vf=["color"],Gf=u.defineComponent({__name:"Icosahedron",props:{args:{default:()=>[1,0]},color:{default:"#ffffff"}},setup(i,{expose:e}){const t=i,{args:n,color:o}=u.toRefs(t),{invalidate:r}=H.useTresContext();u.watch(n,()=>r());const s=u.shallowRef();return e({instance:s}),(a,c)=>(u.openBlock(),u.createElementBlock("TresMesh",u.mergeProps({ref_key:"icosahedronRef",ref:s},a.$attrs),[u.createElementVNode("TresIcosahedronGeometry",{args:u.unref(n)},null,8,zf),u.renderSlot(a.$slots,"default",{},()=>[u.createElementVNode("TresMeshBasicMaterial",{color:u.unref(o)},null,8,Vf)])],16))}}),Rf=["args"],jf=["color"],Wf=u.defineComponent({__name:"Octahedron",props:{args:{default:()=>[1,0]},color:{default:"#ffffff"}},setup(i,{expose:e}){const t=i,{args:n,color:o}=u.toRefs(t),{invalidate:r}=H.useTresContext();u.watch(n,()=>r());const s=u.shallowRef();return e({instance:s}),(a,c)=>(u.openBlock(),u.createElementBlock("TresMesh",u.mergeProps({ref_key:"octahedronRef",ref:s},a.$attrs),[u.createElementVNode("TresOctahedronGeometry",{args:u.unref(n)},null,8,Rf),u.renderSlot(a.$slots,"default",{},()=>[u.createElementVNode("TresMeshBasicMaterial",{color:u.unref(o)},null,8,jf)])],16))}}),Yf=["rotation"],Xf=["args"],Ef=["color"],Zf=u.defineComponent({__name:"Plane",props:{args:{default:()=>[1,1]},color:{default:"#ffffff"}},setup(i,{expose:e}){const t=i,{args:n,color:o}=u.toRefs(t),{invalidate:r}=H.useTresContext();u.watch(n,()=>r());const s=u.shallowRef();return e({instance:s}),(a,c)=>(u.openBlock(),u.createElementBlock("TresMesh",u.mergeProps({ref_key:"planeRef",ref:s,rotation:[-Math.PI/2,0,0]},a.$attrs),[u.createElementVNode("TresPlaneGeometry",{args:u.unref(n)},null,8,Xf),u.renderSlot(a.$slots,"default",{},()=>[u.createElementVNode("TresMeshBasicMaterial",{color:u.unref(o)},null,8,Ef)])],16,Yf))}}),Kf=["args"],qf=["color"],Qf=u.defineComponent({__name:"Ring",props:{args:{default:()=>[.5,1,32]},color:{default:"#ffffff"}},setup(i,{expose:e}){const t=i,{args:n,color:o}=u.toRefs(t),{invalidate:r}=H.useTresContext();u.watch(n,()=>r());const s=u.shallowRef();return e({instance:s}),(a,c)=>(u.openBlock(),u.createElementBlock("TresMesh",u.mergeProps({ref_key:"ringRef",ref:s},a.$attrs),[u.createElementVNode("TresRingGeometry",{args:u.unref(n)},null,8,Kf),u.renderSlot(a.$slots,"default",{},()=>[u.createElementVNode("TresMeshBasicMaterial",{color:u.unref(o)},null,8,qf)])],16))}}),Jf=["args"],Hf=["color"],$f=u.defineComponent({__name:"RoundedBox",props:{args:{default:()=>[1,1,1,2,.1]},color:{default:"#ffffff"}},setup(i,{expose:e}){const t=i,{args:n,color:o}=u.toRefs(t),{invalidate:r,extend:s}=H.useTresContext();s({RoundedBoxGeometry:Wl}),u.watch(n,()=>r());const a=u.shallowRef();return e({instance:a}),(c,h)=>(u.openBlock(),u.createElementBlock("TresMesh",{ref_key:"roundedBoxRef",ref:a},[u.createElementVNode("TresRoundedBoxGeometry",{args:u.unref(n)},null,8,Jf),u.renderSlot(c.$slots,"default",{},()=>[u.createElementVNode("TresMeshBasicMaterial",{color:u.unref(o)},null,8,Hf)])],512))}}),ed=["args"],td=["color"],nd=u.defineComponent({__name:"Sphere",props:{args:{default:()=>[2,32,16]},color:{default:"#ffffff"}},setup(i,{expose:e}){const t=i,{args:n,color:o}=u.toRefs(t),{invalidate:r}=H.useTresContext();u.watch(n,()=>r());const s=u.shallowRef();return e({instance:s}),(a,c)=>(u.openBlock(),u.createElementBlock("TresMesh",u.mergeProps({ref_key:"sphereRef",ref:s},a.$attrs),[u.createElementVNode("TresSphereGeometry",{args:u.unref(n)},null,8,ed),u.renderSlot(a.$slots,"default",{},()=>[u.createElementVNode("TresMeshBasicMaterial",{color:u.unref(o)},null,8,td)])],16))}}),od=["geometry"],rd=["color"],sd=u.defineComponent({__name:"Superformula",props:{widthSegments:{default:32},heightSegments:{default:32},numArmsA:{default:4},expA:{default:()=>[40,1.3,.9]},numArmsB:{default:4},expB:{default:()=>[40,1.3,.9]},color:{default:"white"}},setup(i,{expose:e}){const t=i,{invalidate:n}=H.useTresContext(),{cos:o,sin:r,abs:s}=Math,a=u.shallowRef(),c=u.shallowRef(t.color);function h(d,y){const _=new l.BufferGeometry,v=d*y,g=new Float32Array(Array.from({length:3*v}).fill(0)),A=new Float32Array(Array.from({length:3*v}).fill(0)),w=[];for(let C=0;C<y-1;C++){for(let S=0;S<d-1;S++){const x=C*d+S,I=x+1,D=x+d,z=I+d;w.push(x,D,I),w.push(D,z,I)}const L=C*d+d-1,M=C*d,P=L+d,b=M+d;w.push(L,P,M),w.push(P,b,M)}return _.setIndex(w),_.setAttribute("position",new l.BufferAttribute(g,3)),_.setAttribute("normal",new l.BufferAttribute(A,3)),_}function p(d,y,_,v,g){return(s(o(y*d*.25))**v+s(r(y*d*.25))**g)**(-1/_)}function f(d,y,_,v,g,A,w,C,L,M,P){const b=2*Math.PI/M,S=-Math.PI,x=Math.PI/(P-1),I=-.5*Math.PI,D=d.getAttribute("position");let z=0,G=0,E=I;for(let X=0;X<P;X++){G=S;for(let oe=0;oe<M;oe++){const q=p(G,y,_,v,g),ee=p(E,A,w,C,L);D.setXYZ(z,q*o(G)*ee*o(E),ee*r(E),q*r(G)*ee*o(E)),z++,G+=b}E+=x}D.needsUpdate=!0,d.computeVertexNormals()}u.watch(()=>t.color,()=>c.value=t.color),u.watch(()=>[t.widthSegments,t.heightSegments],()=>{a.value&&a.value.dispose(),a.value=h(t.widthSegments,t.heightSegments),n()},{immediate:!0}),u.watch(()=>[t.numArmsA,t.expA[0],t.expA[1],t.expA[2],t.numArmsB,t.expB[0],t.expB[1],t.expB[2]],()=>{f(a.value,t.numArmsA,t.expA[0],t.expA[1],t.expA[2],t.numArmsB,t.expB[0],t.expB[1],t.expB[2],t.widthSegments,t.heightSegments),n()},{immediate:!0}),u.onUnmounted(()=>{a.value&&a.value.dispose()});const m=u.shallowRef();return e({instance:m}),(d,y)=>(u.openBlock(),u.createElementBlock("TresMesh",u.mergeProps({ref_key:"superformulaRef",ref:m},d.$attrs,{geometry:a.value}),[u.renderSlot(d.$slots,"default",{},()=>[u.createElementVNode("TresMeshBasicMaterial",{color:c.value},null,8,rd)])],16,od))}}),id=["rotation"],ad=["args"],ld=["color"],cd=u.defineComponent({__name:"Tetrahedron",props:{args:{default:()=>[1,0]},color:{default:"#ffffff"}},setup(i,{expose:e}){const t=i,{args:n,color:o}=u.toRefs(t),r=u.shallowRef();return e({instance:r}),(s,a)=>(u.openBlock(),u.createElementBlock("TresMesh",u.mergeProps({ref_key:"tetrahedronRef",ref:r,rotation:[-Math.PI/2,0,0]},s.$attrs),[u.createElementVNode("TresTetrahedronGeometry",{args:u.unref(n)},null,8,ad),u.renderSlot(s.$slots,"default",{},()=>[u.createElementVNode("TresMeshBasicMaterial",{color:u.unref(o)},null,8,ld)])],16,id))}}),ud=["args"],hd=["color"],fd=u.defineComponent({__name:"Torus",props:{args:{default:()=>[1,1,16,80]},color:{default:"#ffffff"}},setup(i,{expose:e}){const t=i,{args:n,color:o}=u.toRefs(t),{invalidate:r}=H.useTresContext();u.watch(n,()=>r());const s=u.shallowRef();return e({instance:s}),(a,c)=>(u.openBlock(),u.createElementBlock("TresMesh",u.mergeProps({ref_key:"torusRef",ref:s},a.$attrs),[u.createElementVNode("TresTorusGeometry",{args:u.unref(n)},null,8,ud),u.renderSlot(a.$slots,"default",{},()=>[u.createElementVNode("TresMeshBasicMaterial",{color:u.unref(o)},null,8,hd)])],16))}}),dd=["args"],pd=["color"],md=u.defineComponent({__name:"TorusKnot",props:{args:{default:()=>[1,.4,64,8]},color:{default:"#ffffff"}},setup(i,{expose:e}){const t=i,{args:n,color:o}=u.toRefs(t),{invalidate:r}=H.useTresContext();u.watch(n,()=>r());const s=u.shallowRef();return e({instance:s}),(a,c)=>(u.openBlock(),u.createElementBlock("TresMesh",u.mergeProps({ref_key:"torusKnotRef",ref:s},a.$attrs),[u.createElementVNode("TresTorusKnotGeometry",{args:u.unref(n)},null,8,dd),u.renderSlot(a.$slots,"default",{},()=>[u.createElementVNode("TresMeshBasicMaterial",{color:u.unref(o)},null,8,pd)])],16))}}),gd=["args"],yd=["color"],_d=u.defineComponent({__name:"Tube",props:{args:{default:()=>[new l.QuadraticBezierCurve3(new l.Vector3(-1,0,0),new l.Vector3(0,1,0),new l.Vector3(1,0,0)),20,.2,8,!1]},color:{default:"#ffffff"}},setup(i,{expose:e}){const t=i,{args:n,color:o}=u.toRefs(t),{invalidate:r}=H.useTresContext();u.watch(n,()=>r());const s=u.shallowRef();return e({instance:s}),(a,c)=>(u.openBlock(),u.createElementBlock("TresMesh",u.mergeProps({ref_key:"tubeRef",ref:s},a.$attrs),[u.createElementVNode("TresTubeGeometry",{args:u.unref(n)},null,8,gd),u.renderSlot(a.$slots,"default",{},()=>[u.createElementVNode("TresMeshBasicMaterial",{color:u.unref(o)},null,8,yd)])],16))}}),vd=u.defineComponent({__name:"Align",props:{top:{type:Boolean},right:{type:Boolean},bottom:{type:Boolean},left:{type:Boolean},front:{type:Boolean},back:{type:Boolean},disable:{type:Boolean},disableX:{type:Boolean},disableY:{type:Boolean},disableZ:{type:Boolean},precise:{type:Boolean,default:!0},onAlign:{},cacheKey:{default:void 0}},setup(i,{expose:e}){const t=i,n=u.shallowRef(),o=u.shallowRef(),r=u.shallowRef(),s=new l.Box3,a=new l.Vector3,c=new l.Sphere;function h(){if(!o.value||!r.value||!n.value)return;o.value.matrixWorld.identity(),s.setFromObject(r.value,t.precise);const d=s.max.x-s.min.x,y=s.max.y-s.min.y,_=s.max.z-s.min.z;s.getCenter(a),s.getBoundingSphere(c);const v=t.top?y/2:t.bottom?-y/2:0,g=t.left?-d/2:t.right?d/2:0,A=t.front?_/2:t.back?-_/2:0;o.value.position.set(t.disable||t.disableX?0:-a.x+g,t.disable||t.disableY?0:-a.y+v,t.disable||t.disableZ?0:-a.z+A),typeof t.onAlign<"u"&&t.onAlign({parent:n.value.parent,container:n.value,width:d,height:y,depth:_,boundingBox:s,boundingSphere:c,center:a,verticalAlignment:v,horizontalAlignment:g,depthAlignment:A})}let p=null,f=null;const m=H.useLoop();return u.watchEffect(()=>{p==null||p(),p=null;const d=u.toValue(t.cacheKey);d===f&&f!==null&&f!==void 0||(f=d,t.cacheKey===null||t.cacheKey===void 0?p=m.onBeforeRender(()=>{h()}).off:h())}),e({instance:n,update:h}),(d,y)=>(u.openBlock(),u.createElementBlock("TresGroup",{ref_key:"ref",ref:n},[u.createElementVNode("TresGroup",{ref_key:"outer",ref:o},[u.createElementVNode("TresGroup",{ref_key:"inner",ref:r},[u.renderSlot(d.$slots,"default")],512)],512)],512))}}),xd=["receive-shadow","rotation"],wd=["args"],bd=u.defineComponent({__name:"Backdrop",props:{floor:{default:.25},segments:{default:20},receiveShadow:{type:Boolean,default:!1}},setup(i,{expose:e}){const t=i,n=h=>h===0?0:2**(10*h-10),{floor:o,segments:r,receiveShadow:s}=u.toRefs(t),a=u.ref(null);u.watch([r,o,a],([h,p,f])=>{if(!f||h===null)return;let m=0;const d=h/h/2,y=f.attributes.position;for(let _=0;_<h+1;_++)for(let v=0;v<h+1;v++)y.setXYZ(m++,_/h-d+(_===0?-p:0),v/h-d,n(_/h));y.needsUpdate=!0,f.computeVertexNormals()});const c=u.shallowRef();return e({instance:c}),(h,p)=>(u.openBlock(),u.createElementBlock("TresGroup",u.mergeProps({ref_key:"backdropRef",ref:c},h.$attrs),[u.createElementVNode("TresMesh",{"receive-shadow":u.unref(s),rotation:[-Math.PI/2,0,Math.PI/2]},[u.createElementVNode("TresPlaneGeometry",{ref_key:"planeRef",ref:a,args:[1,1,u.unref(r),u.unref(r)]},null,8,wd),u.renderSlot(h.$slots,"default",{},()=>[p[0]||(p[0]=u.createElementVNode("TresMeshStandardMaterial",{color:8421504,side:2},null,-1))])],8,xd)],16))}}),Md=["object"],Sd=u.defineComponent({__name:"ContactShadows",props:{opacity:{default:1},blur:{default:1},color:{default:"#000000"},tint:{default:void 0},scale:{default:10},width:{default:1},height:{default:1},far:{default:10},smooth:{type:Boolean,default:!0},resolution:{default:512},frames:{default:Number.POSITIVE_INFINITY},depthWrite:{type:Boolean,default:!1}},setup(i,{expose:e}){const t=i;function n(d,y,_){_.blurPlane.visible=!0,_.blurPlane.material=_.horizontalBlurMaterial,_.horizontalBlurMaterial.uniforms.tDiffuse.value=_.renderTarget.texture,_.horizontalBlurMaterial.uniforms.h.value=d/256,y.setRenderTarget(_.renderTargetBlur),y.render(_.blurPlane,_.shadowCamera),_.blurPlane.material=_.verticalBlurMaterial,_.verticalBlurMaterial.uniforms.tDiffuse.value=_.renderTargetBlur.texture,_.verticalBlurMaterial.uniforms.v.value=d/256,y.setRenderTarget(_.renderTarget),y.render(_.blurPlane,_.shadowCamera),_.blurPlane.visible=!1}function o(d,y,_,v){const{renderTarget:g,shadowCamera:A,depthMaterial:w}=v,C=y.background;y.background=null,y.overrideMaterial=w;const L=_.getClearAlpha();_.setClearAlpha(0),_.setRenderTarget(g),_.render(y,A),y.overrideMaterial=null,n(d.blur,_,v),d.smooth&&n(d.blur*.4,_,v),_.setRenderTarget(null),_.setClearAlpha(L),y.background=C}function r(d){const y=new l.Group,_=new l.WebGLRenderTarget(d.resolution,d.resolution);_.texture.generateMipmaps=!1;const v=new l.WebGLRenderTarget(d.resolution,d.resolution);v.texture.generateMipmaps=!1;const g=new l.PlaneGeometry(d.width,d.height).rotateX(Math.PI/2),A=new l.MeshBasicMaterial({map:_.texture,opacity:d.opacity,transparent:!0,depthWrite:d.depthWrite,color:new l.Color(d.color??"black")}),w=new l.Mesh(g,A);y.add(w),w.scale.y=-1;const C=new l.Mesh(g);C.visible=!1,y.add(C);const L=new l.OrthographicCamera(-d.width/2,d.width/2,d.height/2,-d.height/2,0,.3);L.rotation.x=Math.PI/2,y.add(L);const M=new l.MeshDepthMaterial,P=new l.ShaderMaterial(Yl);P.depthTest=!1;const b=new l.ShaderMaterial(Xl);return b.depthTest=!1,{renderTarget:_,renderTargetBlur:v,shadowCamera:L,depthMaterial:M,horizontalBlurMaterial:P,verticalBlurMaterial:b,shadowGroup:y,plane:w,blurPlane:C}}function s(d,y){const _=y.shadowCamera;_.left=-d.width/2,_.right=d.width/2,_.top=d.height/2,_.bottom=-d.height/2,_.far=d.far;const v=d.width*(Array.isArray(d.scale)?d.scale[0]:d.scale||1),g=d.height*(Array.isArray(d.scale)?d.scale[1]:d.scale||1);y.shadowGroup.scale.set(v,d.far,g)}function a(d,y){y.renderTarget.dispose(),y.renderTargetBlur.dispose(),y.renderTarget=new l.WebGLRenderTarget(d,d),y.renderTarget.texture.generateMipmaps=!1,y.renderTargetBlur=new l.WebGLRenderTarget(d,d),y.renderTargetBlur.texture.generateMipmaps=!1,y.plane.material.map=y.renderTarget.texture}function c(d,y){y.plane.material.color=new l.Color(d.color??"black"),y.depthMaterial.dispose(),y.depthMaterial=new l.MeshDepthMaterial,y.depthMaterial.onBeforeCompile=function(_){const v=d.tint?new l.Color(d.tint):new l.Color("white"),{r:g,g:A,b:w}=v,C=_.fragmentShader.replace("gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );",`gl_FragColor = vec4( ${g}, ${A}, ${w}, ( 1.0 - fragCoordZ ) * opacity);`);_.fragmentShader=C}}const{onBeforeRender:h}=H.useLoop(),p=r(t);let f=0;const m=()=>f=f>=t.frames?t.frames-1:f;return h(({renderer:d,scene:y,invalidate:_})=>{f<t.frames&&(f++,o(t,y,d,p),_())}),u.watch(()=>[t.opacity,t.depthWrite,t.blur,t.smooth],()=>{p.plane.material.opacity=t.opacity??1,p.plane.material.depthWrite=t.depthWrite??!1,m()},{immediate:!0}),u.watch(()=>[t.color,t.tint],()=>{c(t,p),m()},{immediate:!0}),u.watch(()=>[t.resolution],()=>{a(t.resolution,p),m()}),u.watch(()=>[t.width,t.height,t.scale,t.far],()=>{s(t,p),m()},{immediate:!0}),u.onUnmounted(()=>{for(const d of Object.values(p))d&&"dispose"in d&&typeof d.dispose=="function"&&d.dispose()}),e({instance:p.shadowGroup}),(d,y)=>(u.openBlock(),u.createElementBlock("primitive",{object:u.unref(p).shadowGroup},null,8,Md))}}),Ad=u.defineComponent({__name:"Fit",props:{into:{default:()=>new l.Box3(new l.Vector3(-.5,-.5,-.5),new l.Vector3(.5,.5,.5))},precise:{type:Boolean,default:!1}},setup(i,{expose:e}){const t=i,{invalidate:n}=H.useTresContext(),o=u.shallowRef(new l.Group),r=u.shallowRef(new l.Group);function s(h,p){if(o.value.position.set(0,0,0),o.value.updateMatrixWorld(),r.value.scale.set(1,1,1),r.value.updateMatrixWorld(),!r.value.children.length||h===null)return;const{box3:f,use:m}=a(h,p),d=new l.Box3;r.value.children.forEach(A=>d.expandByObject(A,p));const y=d.getSize(new l.Vector3),_=f.getSize(new l.Vector3),v=Math.min(_.x/y.x,_.y/y.y,_.z/y.z);r.value.scale.setScalar(v===Number.POSITIVE_INFINITY?1:v),r.value.updateMatrixWorld();const g=o.value.worldToLocal(d.getCenter(new l.Vector3));if(m.position){const A=o.value.worldToLocal(f.getCenter(new l.Vector3));o.value.position.copy(A.sub(g.multiplyScalar(v)))}else o.value.position.copy(g.sub(g.multiplyScalar(v)));n()}function a(h,p){return typeof h=="number"?h=new l.Vector3(h,h,h):Array.isArray(h)&&(h=new l.Vector3(...h)),h&&"isVector3"in h&&h.isVector3?{box3:new l.Box3(new l.Vector3(0,0,0),h),use:{position:!1}}:h&&"isBox3"in h&&h.isBox3?{box3:h,use:{position:!0}}:h&&"isObject3D"in h&&h.isObject3D?{box3:new l.Box3().setFromObject(h,p??!1),use:{position:!0}}:{box3:new l.Box3(new l.Vector3(-.5,-.5,-.5),new l.Vector3(.5,.5,.5)),use:{position:!0}}}u.watch(()=>[t.into,t.precise],()=>s(t.into,t.precise)),u.onMounted(()=>{s(t.into,t.precise),u.nextTick().then(()=>{s(t.into,t.precise)})});const c=u.shallowRef();return e({instance:c,fit:(h=new l.Box3(new l.Vector3(-.5,-.5,-.5),new l.Vector3(.5,.5,.5)),p=!1)=>{s(h,p)},update:()=>s(t.into,t.precise)}),(h,p)=>(u.openBlock(),u.createElementBlock("TresGroup",{ref_key:"outer",ref:c},[u.createElementVNode("TresGroup",{ref_key:"middle",ref:o},[u.createElementVNode("TresGroup",{ref_key:"inner",ref:r},[u.renderSlot(h.$slots,"default")],512)],512)],512))}}),Pd=["side","cell-size","section-size","cell-color","section-color","cell-thickness","section-thickness","fade-distance","fade-strength","fade-from","infinite-grid","follow-camera"],Cd=["args"],Td=u.defineComponent({__name:"Grid",props:{cellSize:{default:.5},cellThickness:{default:.5},cellColor:{default:"#000000"},sectionSize:{default:1},sectionThickness:{default:1},sectionColor:{default:"#0000ff"},followCamera:{type:Boolean,default:!1},infiniteGrid:{type:Boolean,default:!1},fadeDistance:{default:100},fadeStrength:{default:1},fadeFrom:{default:1},side:{default:l.BackSide},args:{}},setup(i){const e=i,t=Vn({cellSize:.5,sectionSize:1,fadeDistance:100,fadeStrength:1,fadeFrom:1,cellThickness:.5,sectionThickness:1,cellColor:new l.Color,sectionColor:new l.Color,infiniteGrid:!1,followCamera:!1,worldCamProjPosition:new l.Vector3,worldPlanePosition:new l.Vector3},`
    varying vec3 localPosition;
    varying vec4 worldPosition;

    uniform vec3 worldCamProjPosition;
    uniform vec3 worldPlanePosition;
    uniform float fadeDistance;
    uniform bool infiniteGrid;
    uniform bool followCamera;

    void main() {
      localPosition = position.xzy;
      if (infiniteGrid) localPosition *= 1.0 + fadeDistance;
      
      worldPosition = modelMatrix * vec4(localPosition, 1.0);
      if (followCamera) {
        worldPosition.xyz += (worldCamProjPosition - worldPlanePosition);
        localPosition = (inverse(modelMatrix) * worldPosition).xyz;
      }

      gl_Position = projectionMatrix * viewMatrix * worldPosition;
    }
  `,`
    varying vec3 localPosition;
    varying vec4 worldPosition;

    uniform vec3 worldCamProjPosition;
    uniform float cellSize;
    uniform float sectionSize;
    uniform vec3 cellColor;
    uniform vec3 sectionColor;
    uniform float fadeDistance;
    uniform float fadeStrength;
    uniform float fadeFrom;
    uniform float cellThickness;
    uniform float sectionThickness;

    float getGrid(float size, float thickness) {
      vec2 r = localPosition.xz / size;
      vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);
      float line = min(grid.x, grid.y) + 1.0 - thickness;
      return 1.0 - min(line, 1.0);
    }

    void main() {
      float g1 = getGrid(cellSize, cellThickness);
      float g2 = getGrid(sectionSize, sectionThickness);

      vec3 from = worldCamProjPosition*vec3(fadeFrom);
      float dist = distance(from, worldPosition.xyz);
      float d = 1.0 - min(dist / fadeDistance, 1.0);
      vec3 color = mix(cellColor, sectionColor, min(1.0, sectionThickness * g2));

      gl_FragColor = vec4(color, (g1 + g2) * pow(d, fadeStrength));
      gl_FragColor.a = mix(0.75 * gl_FragColor.a, gl_FragColor.a, g2);
      if (gl_FragColor.a <= 0.0) discard;

      #include <tonemapping_fragment>
      #include <colorspace_fragment>
    }
  `);H.extend({GridMaterial:t});const n=u.shallowRef(new l.Mesh),o=new l.Plane,r=new l.Vector3(0,1,0),s=new l.Vector3(0,0,0);return H.useLoop().onBeforeRender(a=>{o.setFromNormalAndCoplanarPoint(r,s).applyMatrix4(n.value.matrixWorld);const c=n.value.material,h=c.uniforms.worldCamProjPosition,p=c.uniforms.worldPlanePosition;o.projectPoint(a.camera.position,h.value),p.value.set(0,0,0).applyMatrix4(n.value.matrixWorld)}),(a,c)=>(u.openBlock(),u.createElementBlock("TresMesh",{ref_key:"ref",ref:n,"frustum-culled":!1},[u.createElementVNode("TresGridMaterial",{transparent:!0,"extensions-derivatives":!0,side:e.side,"cell-size":e.cellSize,"section-size":e.sectionSize,"cell-color":e.cellColor,"section-color":e.sectionColor,"cell-thickness":e.cellThickness,"section-thickness":e.sectionThickness,"fade-distance":e.fadeDistance,"fade-strength":e.fadeStrength,"fade-from":e.fadeFrom,"infinite-grid":e.infiniteGrid,"follow-camera":e.followCamera},null,8,Pd),u.createElementVNode("TresPlaneGeometry",{args:e.args},null,8,Cd)],512))}}),Id=["rotation-x","args"],Od=u.defineComponent({__name:"Ocean",props:{textureWidth:{default:512},textureHeight:{default:512},waterNormals:{default:"https://raw.githubusercontent.com/Tresjs/assets/main/textures/water-normals/Water_1_M_Normal.jpg"},sunDirection:{default:()=>new l.Vector3},sunColor:{default:16777215},waterColor:{default:7695},distortionScale:{default:3.7},size:{default:1},clipBias:{default:0},alpha:{default:1},side:{default:l.FrontSide}},async setup(i,{expose:e}){let t,n;const o=i,{textureWidth:r,textureHeight:s,waterNormals:a,sunDirection:c,sunColor:h,waterColor:p,distortionScale:f,size:m,clipBias:d,alpha:y,side:_}=u.toRefs(o),{extend:v,scene:g}=H.useTresContext();v({Water:Wa});const A=u.shallowRef(),w=u.shallowRef(),C=g.value.fog!==void 0;e({instance:A}),g.value.traverse(P=>{Object.prototype.hasOwnProperty.call(P,"isSky")&&(w.value=P)}),u.onMounted(async()=>{if(await u.nextTick(),w.value){const P=w.value.material.uniforms.sunPosition.value;A.value.material.uniforms.sunDirection.value.copy(P)}});const{normalMap:L}=([t,n]=u.withAsyncContext(()=>H.useTexture({normalMap:a.value})),t=await t,n(),t);L.wrapS=L.wrapT=l.RepeatWrapping;const{onBeforeRender:M}=H.useLoop();return M(({delta:P,invalidate:b})=>{A.value.material.uniforms.time.value+=P,b()}),(P,b)=>(u.openBlock(),u.createElementBlock("TresWater",{ref_key:"waterRef",ref:A,"rotation-x":-Math.PI/2,args:[void 0,{textureWidth:u.unref(r),textureHeight:u.unref(s),waterNormals:u.unref(L),sunDirection:u.unref(c),sunColor:u.unref(h),waterColor:u.unref(p),distortionScale:u.unref(f),fog:C,size:u.unref(m),clipBias:u.unref(d),alpha:u.unref(y),side:u.unref(_)}]},[u.renderSlot(P.$slots,"default",{},()=>[b[0]||(b[0]=u.createElementVNode("TresPlaneGeometry",{args:[1e4,1e4]},null,-1))])],8,Id))}}),Ld=["size","color","alpha-map","map","opacity","alpha-test","depth-write","transparent","size-attenuation"],Dd=["position","velocity"],kd=u.defineComponent({__name:"Precipitation",props:{size:{default:.1},area:{default:()=>[10,10,20]},color:{default:16777215},map:{},alphaMap:{},alphaTest:{default:.01},opacity:{default:.8},count:{default:5e3},speed:{default:.1},randomness:{default:.5},depthWrite:{type:Boolean,default:!1},transparent:{type:Boolean,default:!0},sizeAttenuation:{type:Boolean,default:!0}},setup(i,{expose:e}){const t=i,{size:n,area:o,color:r,alphaMap:s,map:a,opacity:c,alphaTest:h,depthWrite:p,transparent:f,sizeAttenuation:m,count:d,speed:y,randomness:_}=u.toRefs(t),v=u.shallowRef();let g=[],A=[];const w=()=>{g=new Float32Array(d.value*3);for(let S=0;S<d.value;S++){const x=S*3;g[x]=(Math.random()-.5)*o.value[0],g[x+1]=(Math.random()-.5)*o.value[1],g[x+2]=(Math.random()-.5)*o.value[2]}},C=()=>{A=new Float32Array(d.value*2);for(let S=0;S<d.value*2;S+=2)A[S]=(Math.random()-.5)/5*y.value*_.value,A[S+1]=Math.random()/5*y.value};C(),w(),u.watchEffect(()=>{C(),w()});const L=u.shallowRef(null),M=u.shallowRef(null);u.watchEffect(async()=>{u.watchEffect(async()=>{if(typeof s.value=="string"){const S=await H.useTexture({alphaMap:s.value});L.value=S.alphaMap}else L.value=s.value??null;if(typeof a.value=="string"){const S=await H.useTexture({map:a.value});M.value=S.map}else M.value=a.value??null})});const{onBeforeRender:P}=H.useLoop();P(({invalidate:S})=>{var x,I;if((x=v.value)!=null&&x.attributes.position.array&&((I=v.value)!=null&&I.attributes.position.count)){const D=v.value.attributes.position.array;for(let z=0;z<v.value.attributes.position.count;z++){const G=A[z*2],E=A[z*2+1];D[z*3]+=G,D[z*3+1]-=E,(D[z*3]<=-o.value[0]/2||D[z*3]>=o.value[0]/2)&&(D[z*3]=D[z*3]*-1),(D[z*3+1]<=-o.value[1]/2||D[z*3+1]>=o.value[1]/2)&&(D[z*3+1]=D[z*3+1]*-1)}v.value.attributes.position.needsUpdate=!0,S()}});const b=u.shallowRef();return e({instance:b}),(S,x)=>(u.openBlock(),u.createElementBlock("TresPoints",{ref_key:"pointsRef",ref:b},[u.createElementVNode("TresPointsMaterial",{size:u.unref(n),color:u.unref(r),"alpha-map":L.value,map:M.value,opacity:u.unref(c),"alpha-test":u.unref(h),"depth-write":u.unref(p),transparent:u.unref(f),"size-attenuation":u.unref(m)},null,8,Ld),u.createElementVNode("TresBufferGeometry",{ref_key:"geometryRef",ref:v,position:[u.unref(g),3],velocity:[u.unref(A)]},null,8,Dd)],512))}}),Bd=["object","material-uniforms-turbidity-value","material-uniforms-rayleigh-value","material-uniforms-mieCoefficient-value","material-uniforms-mieDirectionalG-value","material-uniforms-sunPosition-value","scale"],Ud=u.defineComponent({__name:"Sky",props:{turbidity:{default:3.4},rayleigh:{default:3},mieCoefficient:{default:.005},mieDirectionalG:{default:.7},elevation:{default:.6},azimuth:{default:180},distance:{default:45e4}},setup(i,{expose:e}){const t=i,{invalidate:n}=H.useTresContext();u.watch(t,()=>n());const o=u.shallowRef(),r=new Hn,s=u.computed(()=>a(t.azimuth,t.elevation));function a(c,h){const p=l.MathUtils.degToRad(90-h),f=l.MathUtils.degToRad(c);return new l.Vector3().setFromSphericalCoords(1,p,f)}return e({instance:o,sunPosition:s.value}),(c,h)=>(u.openBlock(),u.createElementBlock("primitive",{ref_key:"skyRef",ref:o,object:u.unref(r),"material-uniforms-turbidity-value":t.turbidity,"material-uniforms-rayleigh-value":t.rayleigh,"material-uniforms-mieCoefficient-value":t.mieCoefficient,"material-uniforms-mieDirectionalG-value":t.mieDirectionalG,"material-uniforms-sunPosition-value":s.value,scale:t.distance},null,8,Bd))}}),Nd=["position"],Fd=["position"],zd=["scale"],Vd=["map","depth-test","color-space","color","opacity"],Gd=u.defineComponent({__name:"Smoke",props:{color:{default:"#ffffff"},opacity:{default:.5},speed:{default:.4},width:{default:10},depth:{default:1.5},segments:{default:20},texture:{default:"https://raw.githubusercontent.com/Tresjs/assets/main/textures/clouds/defaultCloud.png"},depthTest:{type:Boolean,default:!0}},async setup(i,{expose:e}){let t,n;const o=i,{width:r,depth:s,segments:a,texture:c,color:h,depthTest:p,opacity:f,speed:m}=u.toRefs(o),d=u.shallowRef(),y=u.shallowRef();e({instance:d});const _=[a].map((M,P)=>({x:r.value/2-Math.random()*r.value,y:r.value/2-Math.random()*r.value,scale:.4+Math.sin((P+1)/a.value*Math.PI)*((.2+Math.random())*10),density:Math.max(.2,Math.random()),rotation:Math.max(.002,.005*Math.random())*m.value})),v=(M,P)=>M/6*P*f.value,{map:g}=([t,n]=u.withAsyncContext(()=>H.useTexture({map:c.value})),t=await t,n(),t),{renderer:A,camera:w}=H.useTresContext(),C=u.computed(()=>{var M;return(M=A.value)==null?void 0:M.outputColorSpace}),{onBeforeRender:L}=H.useLoop();return L(({invalidate:M})=>{var P,b;d.value&&w.value&&y.value&&((P=y.value)==null||P.children.forEach((S,x)=>{S.rotation.z+=_[x].rotation}),d.value.lookAt((b=w.value)==null?void 0:b.position),M())}),(M,P)=>(u.openBlock(),u.createElementBlock("TresGroup",u.mergeProps({ref_key:"smokeRef",ref:d},M.$attrs),[u.createElementVNode("TresGroup",{ref_key:"groupRef",ref:y,position:[0,0,u.unref(a)/2*u.unref(s)]},[(u.openBlock(!0),u.createElementBlock(u.Fragment,null,u.renderList(u.unref(_),({scale:b,x:S,y:x,density:I},D)=>(u.openBlock(),u.createElementBlock("TresMesh",{key:`${D}`,position:[S,x,-D*u.unref(s)]},[u.createElementVNode("TresPlaneGeometry",{scale:[b,b,b],rotation:[0,0,0]},null,8,zd),u.createElementVNode("TresMeshStandardMaterial",{map:u.unref(g),"depth-test":u.unref(p),"color-space":C.value,color:u.unref(h),"depth-write":!1,transparent:"",opacity:v(b,I)},null,8,Vd)],8,Fd))),128))],8,Nd)],16))}}),Rd=`
return PCSS( shadowMap, shadowCoord );
`,jd=u.defineComponent({__name:"SoftShadows",props:{size:{default:25},samples:{default:10},focus:{default:0}},setup(i){const e=i,t=({focus:h=0,size:p=25,samples:f=10}={})=>`
#define PENUMBRA_FILTER_SIZE float(${p})
#define RGB_NOISE_FUNCTION(uv) (randRGB(uv))
vec3 randRGB(vec2 uv) {
  return vec3(
    fract(sin(dot(uv, vec2(12.75613, 38.12123))) * 13234.76575),
    fract(sin(dot(uv, vec2(19.45531, 58.46547))) * 43678.23431),
    fract(sin(dot(uv, vec2(23.67817, 78.23121))) * 93567.23423)
  );
}

vec3 lowPassRandRGB(vec2 uv) {
  // 3x3 convolution (average)
  // can be implemented as separable with an extra buffer for a total of 6 samples instead of 9
  vec3 result = vec3(0);
  result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, -1.0));
  result += RGB_NOISE_FUNCTION(uv + vec2(-1.0,  0.0));
  result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, +1.0));
  result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, -1.0));
  result += RGB_NOISE_FUNCTION(uv + vec2( 0.0,  0.0));
  result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, +1.0));
  result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, -1.0));
  result += RGB_NOISE_FUNCTION(uv + vec2(+1.0,  0.0));
  result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, +1.0));
  result *= 0.111111111; // 1.0 / 9.0
  return result;
}
vec3 highPassRandRGB(vec2 uv) {
  // by subtracting the low-pass signal from the original signal, we're being left with the high-pass signal
  // hp(x) = x - lp(x)
  return RGB_NOISE_FUNCTION(uv) - lowPassRandRGB(uv) + 0.5;
}


vec2 vogelDiskSample(int sampleIndex, int sampleCount, float angle) {
  const float goldenAngle = 2.399963f; // radians
  float r = sqrt(float(sampleIndex) + 0.5f) / sqrt(float(sampleCount));
  float theta = float(sampleIndex) * goldenAngle + angle;
  float sine = sin(theta);
  float cosine = cos(theta);
  return vec2(cosine, sine) * r;
}
float penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation
  return (zReceiver - zBlocker) / zBlocker;
}
float findBlocker(sampler2D shadowMap, vec2 uv, float compare, float angle) {
  float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);
  float blockerDepthSum = float(${h});
  float blockers = 0.0;

  int j = 0;
  vec2 offset = vec2(0.);
  float depth = 0.;

  #pragma unroll_loop_start
  for(int i = 0; i < ${f}; i ++) {
    offset = (vogelDiskSample(j, ${f}, angle) * texelSize) * 2.0 * PENUMBRA_FILTER_SIZE;
    depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset));
    if (depth < compare) {
      blockerDepthSum += depth;
      blockers++;
    }
    j++;
  }
  #pragma unroll_loop_end

  if (blockers > 0.0) {
    return blockerDepthSum / blockers;
  }
  return -1.0;
}

        
float vogelFilter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius, float angle) {
  float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);
  float shadow = 0.0f;
  int j = 0;
  vec2 vogelSample = vec2(0.0);
  vec2 offset = vec2(0.0);
  #pragma unroll_loop_start
  for (int i = 0; i < ${f}; i++) {
    vogelSample = vogelDiskSample(j, ${f}, angle) * texelSize;
    offset = vogelSample * (1.0 + filterRadius * float(${p}));
    shadow += step( zReceiver, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );
    j++;
  }
  #pragma unroll_loop_end
  return shadow * 1.0 / ${f}.0;
}

float PCSS (sampler2D shadowMap, vec4 coords) {
  vec2 uv = coords.xy;
  float zReceiver = coords.z; // Assumed to be eye-space z in this code
  float angle = highPassRandRGB(gl_FragCoord.xy).r * PI2;
  float avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver, angle);
  if (avgBlockerDepth == -1.0) {
    return 1.0;
  }
  float penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);
  return vogelFilter(shadowMap, uv, zReceiver, 1.25 * penumbraRatio, angle);
}`,n=l.ShaderChunk.shadowmap_pars_fragment,{renderer:o,scene:r,camera:s}=H.useTres();function a(h,p){let f=n;f=f.replace("#ifdef USE_SHADOWMAP",`#ifdef USE_SHADOWMAP
    ${t(p)}`),f=f.replace("#if defined( SHADOWMAP_TYPE_PCF )",`${Rd} 
    #if defined( SHADOWMAP_TYPE_PCF )`),l.ShaderChunk.shadowmap_pars_fragment=f,h.shadowMap.enabled=!0}function c(h,p,f){p.traverse(m=>{var d,y;"material"in m&&m.material&&(h.properties.remove(m.material),typeof m.material=="object"&&"dispose"in m.material&&typeof m.material.dispose=="function"&&((y=(d=m.material).dispose)==null||y.call(d)))}),h.info.programs&&(h.info.programs.length=0),h.compile(p,f)}return u.onUnmounted(()=>{s.value&&(l.ShaderChunk.shadowmap_pars_fragment=n,c(o.value,r.value,s.value))}),u.watch(e,()=>{s.value&&(a(o.value,e),c(o.value,r.value,s.value))},{immediate:!0}),(h,p)=>(u.openBlock(),u.createElementBlock("TresGroup"))}});function Wd(i){return Vo(i,{normalizeValue:e=>H.normalizeColor(e),getDefaultValue:()=>new l.Color(0,0,0),isSingleValue:e=>!Array.isArray(e),isMultipleValues:e=>Array.isArray(e)&&(e.length===0||!Array.isArray(e[0])),isMultipleValuesWithStops:e=>Array.isArray(e)&&e.length>0&&Array.isArray(e[0]),isEmpty:e=>Array.isArray(e)&&e.length===0})}function zo(i){return"isVector3"in i||Array.isArray(i)&&i.length>0&&i.every(e=>typeof e=="number")}function Yd(i){return Vo(i,{normalizeValue:e=>H.normalizeVectorFlexibleParam(e),getDefaultValue:()=>[0,0,0],isSingleValue:e=>zo(e),isMultipleValues:e=>Array.isArray(e)&&e.length>0&&zo(e[0]),isMultipleValuesWithStops:e=>Array.isArray(e)&&e.length>0&&Array.isArray(e[0])&&e[0].length===2&&zo(e[0][1]),isEmpty:e=>Array.isArray(e)&&e.length===0})}function Xd(i){return Vo(i,{normalizeValue:e=>e,getDefaultValue:()=>1,isSingleValue:e=>!Array.isArray(e)&&typeof e<"u",isMultipleValues:e=>Array.isArray(e)&&(e.length===0||!Array.isArray(e[0])),isMultipleValuesWithStops:e=>Array.isArray(e)&&e.length>0&&Array.isArray(e[0]),isEmpty:e=>Array.isArray(e)&&e.length===0})}function Vo(i,e){const{normalizeValue:t,getDefaultValue:n,isEmpty:o}=e,r=c=>e.isSingleValue(c),s=c=>e.isMultipleValues(c),a=c=>e.isMultipleValuesWithStops(c);if(o(i))return[[0,n()]];if(r(i))return[[0,t(i)]];if(s(i)){const c=i.length>1?1/(i.length-1):1;return i.map((h,p)=>[c*p,t(h)])}else if(a(i))return i.map(([c,h],p)=>[c,t(h)]);return[[0,n()]]}class Ed{constructor(e,t){ue(this,"entries");ue(this,"resolution");this.entries=e,this.resolution=t}useTexture(){return new qd(this.entries,this.resolution).use()}}class Go{constructor(e,t,n,o,r,s){ue(this,"data");ue(this,"ref");ue(this,"name");ue(this,"valueMin");ue(this,"valueMax");ue(this,"suffix");ue(this,"renderToCanvasGradient");this.data=u.isRef(e)?e.value:e,this.ref=u.isRef(e)?e:null,this.name=t,this.valueMin=n,this.valueMax=o,this.suffix=r,this.renderToCanvasGradient=s}}class Zd extends Go{constructor(e,t="color",n=0,o=1,r="rgba",s=Qd){super(e,t,n,o,r,s)}}class qs extends Go{constructor(e,t="scalar",n=0,o=1,r="x",s=Jd){super(e,t,n,o,r,s)}}class Kd extends Go{constructor(e,t="scalar3",n=0,o=1,r="xyz",s=Hd){super(e,t,n,o,r,s)}}class qd{constructor(e,t){ue(this,"entries");ue(this,"size");ue(this,"dirty",u.shallowRef(0));ue(this,"context");this.entries=e,this.size=Math.max(t,e.length);const n=document.createElement("canvas");n.height=this.size,n.width=this.size,this.context=n.getContext("2d")}use(){const e=this.build(),t=u.shallowRef(e);for(const n of this.entries)n.ref&&u.watch(n.ref,()=>{var o;n.data=(o=n.ref)==null?void 0:o.value,u.triggerRef(this.dirty)});return Oi(this.dirty,()=>{this.build(e),t.value=e},{throttle:1e3/60}),{texture:t,dispose:()=>e.dispose(),yFor:this.entries.reduce((n,o,r)=>(n[o.name]=(r+.5)/this.size,n),{})}}build(e){this.entries.forEach((n,o)=>{const r=this.context.createLinearGradient(0,o,this.size,o);n.renderToCanvasGradient(r,n),this.context.fillStyle=r,this.context.fillRect(0,o,this.size,1)}),e&&(e.source.data=this.context.getImageData(0,0,this.size,this.size));const t=e??new l.DataTexture(this.context.getImageData(0,0,this.size,this.size).data,this.size,this.size,l.RGBAFormat,l.UnsignedByteType,l.UVMapping,l.ClampToEdgeWrapping,l.ClampToEdgeWrapping);return t.needsUpdate=!0,t}}function Qs(i,e,t,n,o){return l.MathUtils.mapLinear(l.MathUtils.clamp(i,e,t),e,t,n,o)}function Qd(i,e){return Wd(e.data).forEach(([t,n])=>i.addColorStop(t,`rgb(${n.r*255}, ${n.g*255}, ${n.b*255})`))}function Jd(i,e){return Xd(e.data).forEach(([t,n])=>{i.addColorStop(t,`rgb(${Qs(n,e.valueMin,e.valueMax,0,255)}, 0, 0)`)})}function Hd(i,e){return Yd(e.data).forEach(([t,n])=>i.addColorStop(t,`rgb(${n.map(o=>Qs(o,e.valueMin,e.valueMax,0,255))})`))}class $d{constructor(e=256){ue(this,"entries");ue(this,"resolution");this.resolution=e,this.entries=[]}withResolution(e){return this.resolution=e,this}get add(){return new tp(e=>this.onAdd(e))}build(){return new Ed(this.entries,this.resolution)}onAdd(e){return this.entries.push(e),new ep(e,this)}}class ep{constructor(e,t){ue(this,"entry");ue(this,"parent");this.entry=e,this.parent=t}id(e){return this.entry.name=e,this}range(e,t){return this.entry.valueMin=e,this.entry.valueMax=t,this}suffix(e){return this.entry.suffix=e,this}canvasGradientRenderer(e){return this.entry.renderToCanvasGradient=e,this}get add(){return this.parent.add}build(){return this.parent.build()}}class tp{constructor(e){ue(this,"onAdd");this.onAdd=e}GradientTresColor(e){return this.onAdd(new Zd(e))}Gradient01(e){return this.onAdd(new qs(e,"zeroOne",0,1))}GradientScalar(e,t,n){return this.onAdd(new qs(e,"scalar",t,n))}GradientXyz(e,t,n){return this.onAdd(new Kd(e,"position",t,n))}}let Ro=null;function np(){return Ro===null&&(Ro=new l.DataTexture(new Uint8Array([0,0,0,0]),1,1)),Ro}const op=["object"],rp=u.defineComponent({__name:"component",props:{map:{default:"https://raw.githubusercontent.com/Tresjs/assets/e41a93c56ec7cb5ac2d241f309e23582a5fe1fc6/textures/sparkles/particle.png"},geometry:{default:void 0},directionalLight:{default:void 0},lifetimeSec:{default:.4},cooldownSec:{default:2},normalThreshold:{default:.7},noiseScale:{default:3},scaleNoise:{default:1},offsetNoise:{default:.1},lifetimeNoise:{default:0},size:{default:1},alpha:{default:1},offset:{default:1},surfaceDistance:{default:1},sequenceColor:{default:()=>[[.7,"#82dbc5"],[.8,"#fbb03b"]]},sequenceAlpha:{default:()=>[[0,0],[.1,1],[.5,1],[.9,0]]},sequenceOffset:{default:()=>[0,0,0]},sequenceNoise:{default:()=>[.1,.1,.1]},sequenceSize:{default:()=>[0,1]},sequenceSurfaceDistance:{default:()=>[.05,.08,.1]},mixColor:{default:.5},mixAlpha:{default:1},mixOffset:{default:1},mixSize:{default:0},mixSurfaceDistance:{default:1},mixNoise:{default:1},blending:{default:l.AdditiveBlending},transparent:{type:Boolean,default:!0},depthWrite:{type:Boolean,default:!1}},setup(i,{expose:e}){const t=i,n=Number.parseInt(l.REVISION.replace(/\D+/g,"")),o=u.toRefs(t),r=typeof t.map=="string"?np():t.map,{texture:s,yFor:a}=new $d(256).add.GradientTresColor(o.sequenceColor).id("sequenceColor").add.Gradient01(o.sequenceAlpha).id("sequenceAlpha").add.Gradient01(o.sequenceSurfaceDistance).id("sequenceSurfaceDistance").add.Gradient01(o.sequenceSize).id("sequenceSize").add.GradientXyz(o.sequenceOffset,-1,1).id("sequenceOffset").add.GradientXyz(o.sequenceNoise,0,1).id("sequenceNoise").build().useTexture(),c={blending:t.blending,transparent:t.transparent,depthWrite:t.depthWrite,uniforms:{uMap:new l.Uniform(r),uPixelRatio:new l.Uniform(1),uNormal:new l.Uniform(l.Object3D.DEFAULT_UP),uNormalThreshold:new l.Uniform(t.normalThreshold),uTime:new l.Uniform(0),uCooldownRatio:new l.Uniform(1),uSize:new l.Uniform(t.size),uAlpha:new l.Uniform(t.alpha),uOffset:new l.Uniform(t.offset),uSurfaceDistance:new l.Uniform(t.surfaceDistance),uNoiseScale:new l.Uniform(t.noiseScale),uScaleNoise:new l.Uniform(t.scaleNoise),uOffsetNoise:new l.Uniform(t.offsetNoise),uLifetimeNoise:new l.Uniform(t.lifetimeNoise),uMixColor:new l.Uniform(t.mixColor),uMixAlpha:new l.Uniform(t.mixAlpha),uMixOffset:new l.Uniform(t.mixOffset),uMixSize:new l.Uniform(t.mixSize),uMixSurfaceDistance:new l.Uniform(t.mixSurfaceDistance),uMixNoise:new l.Uniform(t.mixNoise),uInfoTexture:new l.Uniform(s.value)},vertexShader:`
    uniform float uPixelRatio;
    uniform vec3 uNormal;
    uniform float uNormalThreshold;
    uniform float uTime;
    uniform float uCooldownRatio;
    uniform float uSize;
    uniform float uAlpha;
    uniform float uOffset;
    uniform float uSurfaceDistance;
    uniform float uNoiseScale;
    uniform float uScaleNoise;
    uniform float uOffsetNoise;
    uniform float uLifetimeNoise;
    uniform float uMixColor;
    uniform float uMixAlpha;
    uniform float uMixOffset;
    uniform float uMixSize;
    uniform float uMixSurfaceDistance;
    uniform float uMixNoise;
    uniform sampler2D uInfoTexture;

    varying vec4 vColor;

    void main() {
      float dotNormal = dot(normal, uNormal) * 0.5 + 0.5;
      float normalP = smoothstep(uNormalThreshold, 1., dotNormal);
      float lifetimeNoise = uLifetimeNoise * mix(normalP, 1.0, uMixNoise);

      float t = uTime + position.x * 1. * uNoiseScale + position.y * 10. * uNoiseScale + 
      position.z * 7.3 * uNoiseScale + sin(lifetimeNoise * (position.x + 13. * position.y)) * lifetimeNoise;

      float lifetimeP = max(-0.0001, mix(-uCooldownRatio, 1. + cos(t) * lifetimeNoise, fract(t)));
      float surfaceDistance = texture2D(uInfoTexture, vec2(
        mix(normalP, lifetimeP, uMixSurfaceDistance),
        ${a.sequenceSurfaceDistance})).x * uSurfaceDistance;

      vec4 modelPosition = modelMatrix * (vec4(position, 1.0) + vec4(normal * surfaceDistance, 0.0));
      vec3 noise = texture2D(uInfoTexture, vec2(
        mix(normalP, lifetimeP, uMixNoise),
        ${a.sequenceNoise})).xyz;
      vec3 offset = uOffset * (texture2D(uInfoTexture, vec2(
        mix(normalP, lifetimeP, uMixOffset),
        ${a.sequenceOffset})).xyz * 2.0 - vec3(1.0, 1.0, 1.0));
      modelPosition.x += cos(t * uNoiseScale * 10.0) * 0.2 * uOffsetNoise * noise.x + offset.x;
      modelPosition.y += sin(t * uNoiseScale * 10.0) * 0.2 * uOffsetNoise * noise.y + offset.y;
      modelPosition.z += cos(t * uNoiseScale * 10.0) * 0.2 * uOffsetNoise * noise.z + offset.z;

      vec4 viewPosition = viewMatrix * modelPosition;
      vec4 projectionPostion = projectionMatrix * viewPosition;
      gl_Position = projectionPostion;

      gl_PointSize = 2.
      * texture2D(uInfoTexture, vec2(mix(normalP, lifetimeP, uMixSize), ${a.sequenceSize})).x
      * mix(1., abs(sin(t * uNoiseScale + position.x * 13.9 + position.y * 73.1)), uScaleNoise)
      * uSize * (100.0 / -viewPosition.z) * uPixelRatio;

      if (gl_PointSize < 0.6 || lifetimeP < 0.0) { gl_Position = vec4(2, 2, 2, 1); }

      vColor = texture2D(uInfoTexture, vec2(mix(normalP, lifetimeP, uMixColor), ${a.sequenceColor}))
      * texture2D(uInfoTexture, vec2(mix(normalP, lifetimeP, uMixAlpha), ${a.sequenceAlpha})).x * uAlpha;
    }`,fragmentShader:`
    varying vec4 vColor;

    uniform sampler2D uMap;
    uniform sampler2D uInfoTexture;

    void main() {
      gl_FragColor = vColor * texture2D(uMap, gl_PointCoord);
      #include <tonemapping_fragment>
      #include <${n>=154?"colorspace_fragment":"encodings_fragment"}>
    }`},h=new l.ShaderMaterial(c),p=new l.Points(void 0,h),f=h.uniforms,m={immediate:!0};[[f.uPixelRatio,H.useTresContext().sizes.aspectRatio],[f.uSize,o.size],[f.uNormalThreshold,o.normalThreshold],[f.uAlpha,o.alpha],[f.uOffset,o.offset],[f.uOffsetNoise,o.offsetNoise],[f.uMixColor,o.mixColor],[f.uMixAlpha,o.mixAlpha],[f.uMixOffset,o.mixOffset],[f.uMixSize,o.mixSize],[f.uMixSurfaceDistance,o.mixSurfaceDistance],[f.uMixNoise,o.mixNoise],[f.uInfoTexture,s]].forEach(([w,C])=>u.watch(C,()=>{w.value=C.value},m)),u.watch([o.noiseScale,o.lifetimeSec],()=>{f.uNoiseScale.value=o.noiseScale.value*o.lifetimeSec.value},m),u.watch([o.lifetimeSec,o.cooldownSec],()=>{f.uCooldownRatio.value=o.cooldownSec.value/o.lifetimeSec.value},m),u.watch(o.map,()=>{typeof o.map.value=="string"?H.useTexture([o.map.value]).then(w=>h.uniforms.uMap.value=w):h.uniforms.uMap.value=o.map.value});const y=new l.Quaternion,_=new l.Vector3;H.useLoop().onBeforeRender(({elapsed:w,invalidate:C})=>{p.getWorldQuaternion(y),_.copy(t.directionalLight?t.directionalLight.position:l.Object3D.DEFAULT_UP).normalize(),_.applyQuaternion(y.invert()),h.uniforms.uNormal.value=_,h.uniforms.uTime.value=w/(t.cooldownSec+t.lifetimeSec),C()});function v(w){return w&&"isObject3D"in w}function g(w){return w&&"isBufferGeometry"in w}u.onMounted(()=>{t.geometry?g(t.geometry)?p.geometry.copy(t.geometry):v(t.geometry)&&"geometry"in t.geometry&&g(t.geometry.geometry)&&p.geometry.copy(t.geometry.geometry):v(p.parent)&&"geometry"in p.parent&&g(p.parent.geometry)?p.geometry.copy(p.parent.geometry):p.geometry=new l.IcosahedronGeometry(1,16),typeof t.map=="string"&&H.useTexture([t.map]).then(w=>h.uniforms.uMap.value=w)}),u.onUnmounted(()=>{var w;(w=h.uniforms.uMap.value)==null||w.dispose(),s.value.dispose(),h.dispose()});const A=u.shallowRef();return e({instance:p}),(w,C)=>(u.openBlock(),u.createElementBlock("primitive",{ref_key:"sparkleRef",ref:A,object:u.unref(p)},null,8,op))}}),sp=["position","a-scale"],ip=["size","size-attenuation","transparent","alpha-test","alpha-map"],ap=u.defineComponent({__name:"Stars",props:{size:{default:.1},sizeAttenuation:{type:Boolean,default:!0},transparent:{type:Boolean,default:!0},alphaTest:{default:.01},count:{default:5e3},depth:{default:50},radius:{default:100},alphaMap:{default:null}},setup(i,{expose:e}){const t=i,n=u.ref(),o=u.ref(),{radius:r,depth:s,count:a,size:c,sizeAttenuation:h,transparent:p,alphaMap:f,alphaTest:m}=u.toRefs(t),{invalidate:d}=H.useTresContext();u.watch(t,()=>{d()});const y=()=>{let v=r.value+s.value;const g=u.computed(()=>s.value/a.value),A=[],w=Array.from({length:a.value},()=>(.5+.5*Math.random())*4),C=L=>new l.Vector3().setFromSpherical(new l.Spherical(L,Math.acos(1-Math.random()*2),Math.random()*2*Math.PI)).toArray();for(let L=0;L<a.value;L++)v-=g.value*Math.random(),A.push(...C(v));n.value=new Float32Array(A),o.value=new Float32Array(w)};u.watchEffect(()=>{y()});const _=u.shallowRef();return e({instance:_}),(v,g)=>(u.openBlock(),u.createElementBlock("TresPoints",{ref_key:"starsRef",ref:_},[u.createElementVNode("TresBufferGeometry",{position:[n.value,3],"a-scale":[o.value,1]},null,8,sp),u.createElementVNode("TresPointsMaterial",{size:u.unref(c),"size-attenuation":u.unref(h),transparent:u.unref(p),"alpha-test":u.unref(m),"alpha-map":u.unref(f)},null,8,ip)],512))}});class Js extends l.Object3D{constructor(){super();ue(this,"virtualScene",null);this.virtualScene=new l.Scene}add(...t){return this.virtualScene.add(...t),this}dispose(){this.virtualScene.traverse(t=>{t instanceof l.Mesh&&(t.geometry.dispose(),t.material.dispose(),t.material.map&&t.material.map.dispose(),this.virtualScene.remove(t))}),this.virtualScene=null}}const lp=u.defineComponent({__name:"component",props:{background:{type:[Boolean,String],default:!1},blur:{default:0},files:{default:()=>[]},path:{default:""},preset:{default:void 0},resolution:{default:256},near:{default:1},far:{default:1e3},frames:{default:Number.POSITIVE_INFINITY},backgroundIntensity:{default:1},backgroundRotation:{},environmentIntensity:{default:1},environmentRotation:{},syncMaterials:{type:Boolean}},async setup(i,{expose:e}){let t,n;const o=i,r=u.ref(null);e({texture:r});const{extend:s,renderer:a,scene:c}=H.useTresContext();s({EnvironmentScene:Js});let h=null;const p=u.ref(null);let f=null;const m=u.ref(null),d=([t,n]=u.withAsyncContext(()=>is(o,p)),t=await t,n(),t),{onBeforeRender:y}=H.useLoop();let _=1;y(()=>{if(f&&m.value&&p.value&&(o.frames===Number.POSITIVE_INFINITY||_<o.frames)){const g=a.value.autoClear;a.value.autoClear=!0;const A=u.toRaw(m.value).virtualScene;f.update(a.value,A),a.value.autoClear=g,_++}},-1),u.watch([d,m],([g,A])=>{if(g&&(A!=null&&A.virtualScene)){const w=u.toRaw(A).virtualScene;let C=w.children.find(L=>L instanceof l.Mesh&&L.userData.isEnvironment);C||(C=new l.Mesh(new l.BoxGeometry(1,1,1),new l.MeshBasicMaterial({side:l.BackSide})),C.userData.isEnvironment=!0,w.add(C)),w.background=g,w.backgroundBlurriness=o.blur}},{immediate:!0});const v=g=>{g&&(h!=null&&h.length)?(c.value.environment=g.texture,o.background&&(c.value.background=g.texture)):d.value&&(c.value.environment=d.value,o.background&&(c.value.background=d.value))};return u.watch(d,()=>{p.value&&v(p.value)},{immediate:!0,deep:!0}),u.watch(()=>u.useSlots().default,g=>{var A;if(g&&(h=g(),Array.isArray(h)&&h.length>0)){s({EnvironmentScene:Js}),p.value=new l.WebGLCubeRenderTarget(o.resolution),p.value.texture.type=l.HalfFloatType,f=new l.CubeCamera(o.near,o.far,p.value),v(p.value);return}(A=p.value)==null||A.dispose(),p.value=null,v()},{immediate:!0,deep:!0}),r.value=d.value,u.onUnmounted(()=>{var g,A;(g=m.value)==null||g.dispose(),(A=p.value)==null||A.dispose()}),(g,A)=>p.value?(u.openBlock(),u.createElementBlock("TresEnvironmentScene",{key:0,ref_key:"environmentScene",ref:m},[u.renderSlot(g.$slots,"default")],512)):u.createCommentVNode("",!0)}}),cp={key:0,args:[0,1,64]},up={key:1,args:[.5,1,64]},hp={key:2},fp=["tone-mapped","map","side","color"],dp=u.defineComponent({__name:"index",props:{args:{default:null},form:{default:"rect"},toneMapped:{type:Boolean,default:!1},map:{default:null},intensity:{default:1},color:{default:new l.Color(16777215)}},setup(i,{expose:e}){const t=i,n=u.ref(),o=u.ref();return u.watchEffect(()=>{n.value&&(n.value.color.copy(new l.Color(t.color)),n.value.color.multiplyScalar(t.intensity),n.value.needsUpdate=!0)}),e({mesh:o}),(r,s)=>(u.openBlock(),u.createElementBlock("TresMesh",{ref_key:"mesh",ref:o},[r.form==="circle"?(u.openBlock(),u.createElementBlock("TresRingGeometry",cp)):r.form==="ring"?(u.openBlock(),u.createElementBlock("TresRingGeometry",up)):r.form==="rect"?(u.openBlock(),u.createElementBlock("TresPlaneGeometry",hp)):(u.openBlock(),u.createBlock(t.form,{key:3,args:r.args},null,8,["args"])),u.createElementVNode("TresMeshBasicMaterial",{ref_key:"material",ref:n,"tone-mapped":r.toneMapped,map:r.map,side:u.unref(l.DoubleSide),color:r.color},null,8,fp)],512))}});function pp(i,e){const t={};for(const n of e)Object.prototype.hasOwnProperty.call(i,n)&&(t[n]=i[n]);return t}function mp(i,e){const t=`set${e[0].toUpperCase()}${e.slice(1)}`;return i[t]!==void 0}function gp(i){var t,n;let e=i.value;return i.value&&((n=(t=i.value)==null?void 0:t.value)!=null&&n.isMesh)&&(e=i.value.value.position),Array.isArray(i.value)&&(e=new l.Vector3(...e)),e}ne.Align=vd,ne.AnimatedSprite=xi,ne.Backdrop=bd,ne.BakeShadows=Qh,ne.BaseCameraControls=Ve,ne.Billboard=Yi,ne.Box=Mf,ne.CameraControls=vu,ne.CatmullRomCurve3=Af,ne.Circle=Tf,ne.Cone=Lf,ne.ContactShadows=Sd,ne.CubeCamera=Wi,ne.CustomShaderMaterial=Bh,ne.Cylinder=Bf,ne.Dodecahedron=Ff,ne.Edges=du,ne.Environment=lp,ne.FBXModel=Bu,ne.Fbo=ou,ne.Fit=Ad,ne.GLTFModel=Vu,ne.GlobalAudio=Xi,ne.GradientTexture=Zi,ne.Grid=Td,ne.HolographicMaterial=Nh,ne.Html=lf,ne.Icosahedron=Gf,ne.Image=Hi,ne.KeyboardControls=xu,ne.Lensflare=Gc,ne.Levioso=Rc,ne.Lightformer=dp,ne.Line2=Ks,ne.MapControls=bu,ne.Mask=Wc,ne.MeshDiscardMaterial=zh,ne.MeshGlassMaterial=Gh,ne.MeshReflectionMaterial=Eh,ne.MeshWobbleMaterial=qh,ne.MouseParallax=Yc,ne.Ocean=Od,ne.Octahedron=Wf,ne.OrbitControls=Su,ne.Outline=Ec,ne.Plane=Zf,ne.PointerLockControls=xs,ne.PositionalAudio=Kc,ne.Precipitation=kd,ne.Reflector=Qc,ne.Ring=Qf,ne.RoundedBox=$f,ne.SVG=Ou,ne.Sampler=ru,ne.ScreenSizer=hu,ne.ScreenSpace=Hc,ne.ScrollControls=Pu,ne.Sky=Ud,ne.Smoke=Gd,ne.SoftShadows=jd,ne.Sparkles=rp,ne.Sphere=nd,ne.Stars=ap,ne.Stats=df,ne.StatsGl=gf,ne.Superformula=sd,ne.Tetrahedron=cd,ne.Text3D=eu,ne.Torus=fd,ne.TorusKnot=md,ne.TransformControls=Tu,ne.Tube=_d,ne.extractBindingPosition=gp,ne.hasSetter=mp,ne.pick=pp,ne.useAnimations=tu,ne.useEnvironment=is,ne.useFBO=os,ne.useFBX=ws,ne.useGLTF=bs,ne.useGLTFExporter=_f,ne.useMask=nu,ne.useProgress=Wu,ne.useSurfaceSampler=rs,ne.useVideoTexture=Yu,Object.defineProperty(ne,Symbol.toStringTag,{value:"Module"})});
